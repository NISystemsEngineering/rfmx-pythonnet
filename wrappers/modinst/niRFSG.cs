//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Measurement Studio for NI-RFSG 15.0.
//     
//     Documentation is available at Start»All Programs»National Instruments»NI-RFSG»Documentation>>NI RF Signal Generators Help.
//      
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace NationalInstruments.ModularInstruments.Interop
{
    //niRFSG class. Open a niRFSG session by calling one of the constructor methods.
    //Use the niRFSGConstants class and the niRFSGProperties enum when possible to ensure valid input.
    /// <summary>
    /// 
    /// </summary>
    public class niRFSG : object, System.IDisposable
    {

        private System.Runtime.InteropServices.HandleRef _handle;

        private bool _disposed = true;

        // NIRFSG_MAX_ERROR_MESSAGE_SIZE is 1024
        private const int maxErrorMessageSize = 1024;
        /// <summary>
        /// 
        /// </summary>
        public System.Runtime.InteropServices.HandleRef Handle
        {
            get
            {
                return _handle;
            }
        }

        /// <summary>
        /// 
        /// niRFSG_init
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_init&#160;(ViRsrc&#160;resourceName, ViBoolean&#160;idQuery, ViBoolean&#160;resetDevice, ViSession*&#160;vi);
        /// Purpose
        /// Opens a session to the device you specify for the resourceName parameter and returns a ViSession handle that you use to identify the NI-RFSG device in all subsequent NI-RFSG function calls.
        /// 
        /// 
        /// Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Resource_Name">
        /// 
        /// resourceName
        /// ViRsrc
        /// Specifies the resource name of the device to initialize.
        /// 
        /// 
        /// 
        /// For NI-DAQmx devices, the syntax is the device name specified in MAX. Typical default names for NI-DAQmx devices in MAX are Dev2 or PXISlot2. You can rename an NI-DAQmx device by right-clicking on the name in MAX.
        /// 
        /// You can also specify the name of an IVI logical name configured with the IVI Configuration utility. For additional information, refer to the IVI topic of the Measurement &amp; Automation Explorer Help. 
        /// 
        /// 
        /// Caution&#160;&#160;NI-DAQmx device names are not case-sensitive. However, all IVI names, such as logical names, are case-sensitive. If you use an IVI logical name, make sure the name is identical to the name shown in the IVI Configuration Utility.
        /// 
        /// 
        /// </param>
        /// <param name="ID_Query">
        /// 
        /// idQuery
        /// ViBoolean
        /// Specifies whether you want NI-RFSG to perform an ID query.
        /// 
        /// 
        /// 
        /// Defined Values:
        /// 
        /// 
        /// VI_TRUE (1) Perform ID query.VI_FALSE (0)Do not perform ID query.
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Reset">
        /// 
        /// reset
        /// ViBoolean
        /// Specifies whether you want to reset the NI-RFSG device during the initialization procedure.
        /// 
        /// 
        /// Defined Values:
        /// VI_TRUE (1)Reset device.VI_FALSE (0)Do not reset device.
        /// 
        /// 
        /// </param>
        public niRFSG(string Resource_Name, bool ID_Query, bool Reset)
        {
            System.IntPtr instrumentHandle;
            int pInvokeResult = PInvoke.init(Resource_Name, System.Convert.ToUInt16(ID_Query), System.Convert.ToUInt16(Reset), out instrumentHandle);
            this._handle = new System.Runtime.InteropServices.HandleRef(this, instrumentHandle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            this._disposed = false;
        }

        /// <summary>
        /// 
        /// niRFSG_InitWithOptions
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_InitWithOptions&#160;(ViRsrc&#160;resourceName, ViBoolean&#160;idQuery, ViBoolean&#160;resetDevice, ViConstString&#160;optionString, ViSession*&#160;vi);
        /// 
        /// Purpose
        /// 
        /// Opens a session to the device you specify using the resourceName parameter and 
        /// returns a ViSession handle that you use to identify the NI-RFSG device in all subsequent NI-RFSG function calls.  This function also configures the device through the optionString parameter.
        /// 
        /// 
        /// Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Resource_Name">
        /// 
        /// resourceName
        /// ViRsrc
        /// Specifies the resource name of the device to initialize.
        /// 
        /// 
        /// 
        /// For NI-DAQmx devices, the syntax is the device name specified in MAX. Typical default names for NI-DAQmx devices in MAX are Dev2 or PXISlot2. You can rename an NI-DAQmx device by right-clicking on the name in MAX.
        /// 
        /// You can also specify the name of an IVI logical name configured with the IVI Configuration utility. For additional information, refer to the IVI topic of the Measurement &amp; Automation Explorer Help. 
        /// 
        /// 
        /// Caution&#160;&#160;NI-DAQmx device names are not case-sensitive. However, all IVI names, such as logical names, are case-sensitive. If you use an IVI logical name, make sure the name is identical to the name shown in the IVI Configuration Utility.
        /// 
        /// 
        /// </param>
        /// <param name="ID_Query">
        /// 
        /// idQuery
        /// ViBoolean
        /// Specifies whether you want NI-RFSG to perform an ID query.
        /// 
        /// 
        /// 
        /// Defined Values:
        /// 
        /// 
        /// VI_TRUE (1) Perform ID query.VI_FALSE (0)Do not perform ID query.
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Reset">
        /// 
        /// reset
        /// ViBoolean
        /// Specifies whether you want to reset the NI-RFSG device during the initialization procedure.
        /// 
        /// 
        /// Defined Values:
        /// VI_TRUE (1)Reset device.VI_FALSE (0)Do not reset device.
        /// 
        /// 
        /// </param>
        /// <param name="Option_String">
        /// 
        /// 
        /// optionString
        /// ViConstString
        /// Specifies the initial value of certain attributes for the session.  The following table lists the attributes and the name you pass in this parameter to identify the attribute.
        /// 
        /// 
        /// 
        /// Name              Attribute Name  
        /// RangeCheckNIRFSG_ATTR_RANGE_CHECK
        /// 
        /// QueryInstrStatus  NIRFSG_ATTR_QUERY_INSTRUMENT_STATUS   
        /// 
        /// CacheNIRFSG_ATTR_CACHE
        ///    
        /// 
        /// 
        /// RecordCoercionsNIRFSG_ATTR_RECORD_COERCIONS
        /// 
        /// 
        /// 
        /// DriverSetupNIRFSG_ATTR_DRIVER_SETUP
        /// 
        /// SimulateNIRFSG_ATTR_SIMULATE
        /// 
        /// 
        /// 
        /// 
        /// The format of this string consists of the following relations:
        ///  &quot;AttributeName=Value&quot; 
        /// 
        /// where
        ///  AttributeName is the name of the attribute and Value is the value to which the attribute is set.  To set multiple attributes, separate their assignments with a comma, as shown in the following option string:  
        /// 
        /// &quot;RangeCheck=1,QueryInstrStatus=0,Cache=1,DriverSetup=AWG:pxi1slot4&quot;
        /// 
        /// 
        /// 
        /// 
        /// The DriverSetup string is required in order to simulate a specific device.
        /// 
        /// </param>
        public niRFSG(string Resource_Name, bool ID_Query, bool Reset, string Option_String)
        {
            System.IntPtr instrumentHandle;
            int pInvokeResult = PInvoke.InitWithOptions(Resource_Name, System.Convert.ToUInt16(ID_Query), System.Convert.ToUInt16(Reset), Option_String, out instrumentHandle);
            this._handle = new System.Runtime.InteropServices.HandleRef(this, instrumentHandle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            this._disposed = false;
        }

        /// <summary>
        /// 
        /// 
        /// niRFSG_ConfigureRF
        /// 
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureRF&#160;(ViSession&#160;vi, ViReal64&#160;frequency, ViReal64&#160;powerLevel);
        /// 
        /// Purpose
        /// 
        /// Configures the frequency and power level of the RF output signal. The NI 5670/5671/5672 device must be in the Configuration state before calling this function.  The NI 5650/5651/5652/5673/5673E device can be in the Configuration or Generation state when you call this function.
        /// 
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5670/5671, NI PXIe-5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Frequency">
        /// 
        /// frequency
        /// ViReal64
        /// Specifies the frequency of the generated RF signal. For arbitrary waveform generation, this parameter specifies the center frequency of the signal.
        /// 
        /// 
        /// Units: Hz
        /// 
        /// </param>
        /// <param name="Power_Level">
        /// 
        /// 
        /// powerLevel
        /// ViReal64
        /// Specifies either the average power level or peak power level of the generated RF signal, depending on the NIRFSG_ATTR_POWER_LEVEL_TYPE attribute .
        /// 
        /// 
        /// 
        /// Units: dBm
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureRF(double Frequency, double Power_Level)
        {
            int pInvokeResult = PInvoke.ConfigureRF(this._handle, Frequency, Power_Level);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureGenerationMode
        /// 
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureGenerationMode&#160;(ViSession&#160;vi, ViInt32&#160;generationMode);
        /// Purpose
        /// Configures the NI-RFSG device to generate a continuous tone (CW) sine tone, apply I/Q (vector) modulation to the RF output signal, or generate arbitrary waveforms according to scripts. The NI-RFSG device must be in the Configuration state before you call this function.
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5670/5671, NI PXIe-5653/5672/5673/5673E 
        /// 
        /// </summary>
        /// <param name="Generation_Mode">
        /// 
        /// generationMode
        /// ViInt32
        /// Specifies the mode used by NI-RFSG to generate an RF output signal.
        /// 
        /// 
        /// Defined Values:
        /// NIRFSG_VAL_CWNI-RFSG generates a signal in CW mode.
        /// NIRFSG_VAL_ARB_WAVEFORMNI-RFSG generates a signal in arb waveform mode.
        /// NIRFSG_VAL_SCRIPTNI-RFSG generates a signal in script mode.
        /// 
        /// Default Value: NIRFSG_VAL_CW
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureGenerationMode(int Generation_Mode)
        {
            int pInvokeResult = PInvoke.ConfigureGenerationMode(this._handle, Generation_Mode);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_AllocateArbWaveform
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_AllocateArbWaveform&#160;(ViSession&#160;vi,&#160;ViConstString&#160;name,&#160;ViInt32&#160;size_in_samples);
        /// Purpose
        /// Allocates onboard memory space for the arbitrary waveform. Use this function to specify the total size of a waveform before writing the data.  You only need to use this function if you are calling the niRFSG_WriteArbWaveform function multiple times to write a large waveform in smaller blocks. The NI-RFSG device must be in the Configuration state before you call this function.
        /// 
        /// 
        /// Supported Devices: NI PXI-5670/5671, NI PXIe-5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Name">
        /// 
        /// name
        /// ViConstString
        /// Specifies the name used to identify the waveform. This string is case-insensitive and alphanumeric, and it does not use reserved words.
        /// 
        /// </param>
        /// <param name="Size_In_Samples">
        /// 
        /// size_in_samples
        /// ViInt32
        /// Specifies the number of samples to reserve in the onboard memory for the specified waveform.  Each I/Q pair is considered one sample.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int AllocateArbWaveform(string Name, int Size_In_Samples)
        {
            int pInvokeResult = PInvoke.AllocateArbWaveform(this._handle, Name, Size_In_Samples);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_WriteArbWaveform
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_WriteArbWaveform&#160;(ViSession&#160;vi, ViConstString&#160;waveformName, ViInt32&#160;numberOfSamples, ViReal64[]&#160;iData, ViReal64[]&#160;qData, ViBoolean&#160;moreDataPending);
        /// Purpose
        /// Writes an arbitrary waveform to the NI-RFSG device. This function configures the I and Q vectors of a complex baseband signal. If the waveform to be written is already allocated using the niRFSG_AllocateArbWaveform function, the moreDataPending parameter is ignored. The NI 5670/5671 must be in the Configuration state before you call this function. When streaming is enabled, this function can be called when the NI PXIe-5672/5673/5673E is in the Generation state.
        /// 
        /// 
        /// Note&#160;&#160;On the NI PXIe-5672/5673/5673E, the moreDataPending parameter is always
        /// ignored. To write data in blocks on these devices, you must allocate the waveform before writing it.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Name">
        /// 
        /// name
        /// ViConstString
        /// Specifies the name used to identify the waveform. This string is case-insensitive and alphanumeric, and it does not use reserved words.
        /// 
        /// </param>
        /// <param name="Number_Of_Samples">
        /// 
        /// numberOfSamples
        /// ViInt32
        /// Specifies the number of samples in both the iData and qData arrays. The iData and qData arrays must have the same length. If the NIRFSG_ATTR_ARB_WAVEFORM_QUANTUM attribute value is q, then the number of samples should be a multiple of q. The specified number of samples cannot be 0.
        /// 
        /// </param>
        /// <param name="IData">
        /// 
        /// iData
        /// ViReal64[]
        /// Specifies the in-phase (I) component of the complex baseband signal.
        /// 
        /// </param>
        /// <param name="QData">
        /// 
        /// qData
        /// ViReal64[]
        /// Specifies the quadrature (Q) component of the complex baseband signal.
        /// 
        /// </param>
        /// <param name="More_Data_Pending">
        /// 
        /// moreDataPending
        /// ViBoolean
        /// Specifies whether or not the data block contains the end of the waveform.  Set this parameter to VI_TRUE to allow data to be appended later to the waveform. Splitting the waveform into multiple data blocks can reduce the memory requirements of the write operation. Append data to a previously written waveform by using the same waveform in the name parameter. Set moreDataPending to VI_FALSE to indicate that this data block contains the end of the waveform. If the waveform is already allocated, this parameter is ignored.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int WriteArbWaveform(string Name, int Number_Of_Samples, double[] IData, double[] QData, bool More_Data_Pending)
        {
            int pInvokeResult = PInvoke.WriteArbWaveform(this._handle, Name, Number_Of_Samples, IData, QData, System.Convert.ToUInt16(More_Data_Pending));
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_WriteArbWaveformComplexF64
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_WriteArbWaveformComplexF64&#160;(ViSession&#160;vi, ViConstString&#160;waveformName, ViInt32&#160;numberOfSamples, NIComplexNumber&#160;wfmData[], ViBoolean&#160;moreDataPending);
        /// Purpose
        /// Writes an arbitrary waveform to the NI-RFSG device starting at the position of the last data written in onboard memory. This function accepts the complex baseband data in the form of complex doubles. If the waveform to be written is already allocated using the niRFSG_AllocateArbWaveform function, the moreDataPending parameter is ignored.  
        /// The NI 5670/5671 must be in the Configuration state before you call this function. When streaming is enabled, this function can be called when the NI PXIe-5672/5673/5673E is in the Generation state.
        /// 
        /// 
        /// 
        /// Note&#160;&#160;On the NI PXIe-5672/5673/5673E, the moreDataPending parameter is always
        /// ignored. To write data in blocks on these devices, you must allocate the waveform before writing it.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Name">
        /// 
        /// name
        /// ViConstString
        /// Specifies the name used to identify the waveform. This string is case-insensitive and alphanumeric, and it does not use reserved words.
        /// 
        /// </param>
        /// <param name="Number_Of_Samples">
        /// 
        /// numberOfSamples
        /// ViInt32
        /// Specifies the number of samples in both of the data arrays.
        /// 
        /// </param>
        /// <param name="Data">
        /// 
        /// 
        /// data
        /// NIComplexNumber[]
        /// Specifies the array of data to load into the waveform. The array must have at least as many elements as the value in the size_in_samples parameter in the niRFSG_AllocateArbWaveform function.
        ///  
        /// </param>
        /// <param name="More_Data_Pending">
        /// 
        /// moreDataPending
        /// ViBoolean
        /// Specifies whether or not the data block contains the end of the waveform.  Set this parameter to VI_TRUE to allow data to be appended later to the waveform. Splitting the waveform into multiple data blocks can reduce the memory requirements of the write operation. Append data to a previously written waveform by using the same waveform in the name parameter. Set moreDataPending to VI_FALSE to indicate that this data block contains the end of the waveform. If the waveform is already allocated, this parameter is ignored.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int WriteArbWaveformComplexF64(string Name, int Number_Of_Samples, niComplexNumber[] Data, bool More_Data_Pending)
        {
            int pInvokeResult = PInvoke.WriteArbWaveformComplexF64(this._handle, Name, Number_Of_Samples, Data, System.Convert.ToUInt16(More_Data_Pending));
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="Name"></param>
        /// <param name="Number_Of_Samples"></param>
        /// <param name="Data"></param>
        /// <param name="More_Data_Pending"></param>
        /// <returns></returns>
        public int WriteArbWaveformComplexF32(string Name, int Number_Of_Samples, niComplexNumberF32[] Data, bool More_Data_Pending)
        {
            int pInvokeResult = PInvoke.WriteArbWaveformComplexF32(this._handle, Name, Number_Of_Samples, Data, System.Convert.ToUInt16(More_Data_Pending));
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="Name"></param>
        /// <param name="Number_Of_Samples"></param>
        /// <param name="iData"></param>
        /// <param name="qData"></param>
        /// <param name="More_Data_Pending"></param>
        /// <returns></returns>
        public int WriteArbWaveformF32(string Name, int Number_Of_Samples, float[] iData, float[] qData, bool More_Data_Pending)
        {
            int pInvokeResult = PInvoke.WriteArbWaveformF32(this._handle, Name, Number_Of_Samples, iData, qData, System.Convert.ToUInt16(More_Data_Pending));
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_WriteArbWaveformComplexI16
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_WriteArbWaveformComplexI16&#160;(ViSession&#160;vi, ViConstString&#160;waveformName, ViInt32&#160;numberOfSamples,  NIComplexI16&#160;wfmData[]);
        /// Purpose
        /// Writes an arbitrary waveform to the NI-RFSG device starting at the position of the last data written in onboard memory. This function accepts the interleaved I/Q data of a complex baseband signal. If the waveform to be written is already allocated using the niRFSG_AllocateArbWaveform function, the More_Data_Pending parameter is ignored. The NI 5670/5671 must be in the Configuration state before you call this function. When streaming is enabled, this function can be called when the NI PXIe-5672/5673/5673E is in the Generation state.
        /// 
        /// Note&#160;&#160;This function only supports NIRFSG_VAL_PEAK_POWER mode as specified in the NIRFSG_ATTR_POWER_LEVEL_TYPE attribute.  If a waveform is downloaded using this function, NIRFSG_ATTR_POWER_LEVEL_TYPE cannot be changed to NIRFSG_VAL_AVERAGE_POWER mode without causing error in the output.
        /// 
        /// Supported Devices&#58; NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Name">
        /// 
        /// name
        /// ViConstString
        /// Specifies the name used to identify the waveform. This string is case-insensitive and alphanumeric, and it does not use reserved words.
        /// 
        /// </param>
        /// <param name="Number_Of_Samples">
        /// 
        /// numberOfSamples
        /// ViInt32
        /// Specifies the number of samples in the data array.
        /// 
        /// </param>
        /// <param name="Data">
        /// 
        /// 
        /// data
        /// niComplexI16[]
        /// Specifies the array of data to load into the waveform. The array must have at least as many elements as the value in the size_in_samples parameter in the niRFSG_AllocateArbWaveform function.
        ///  
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int WriteArbWaveformComplexI16(string Name, int Number_Of_Samples, niComplexI16[] Data)
        {
            int pInvokeResult = PInvoke.WriteArbWaveformComplexI16(this._handle, Name, Number_Of_Samples, Data);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_WriteArbWaveformComplexI16
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_WriteArbWaveformComplexI16&#160;(ViSession&#160;vi, ViConstString&#160;waveformName, ViInt32&#160;numberOfSamples,  NIComplexI16&#160;wfmData[]);
        /// Purpose
        /// Writes an arbitrary waveform to the NI-RFSG device starting at the position of the last data written in onboard memory. This function accepts the interleaved I/Q data of a complex baseband signal. If the waveform to be written is already allocated using the niRFSG_AllocateArbWaveform function, the More_Data_Pending parameter is ignored. The NI 5670/5671 must be in the Configuration state before you call this function. When streaming is enabled, this function can be called when the NI PXIe-5672/5673/5673E is in the Generation state.
        /// 
        /// Note&#160;&#160;This function only supports NIRFSG_VAL_PEAK_POWER mode as specified in the NIRFSG_ATTR_POWER_LEVEL_TYPE attribute.  If a waveform is downloaded using this function, NIRFSG_ATTR_POWER_LEVEL_TYPE cannot be changed to NIRFSG_VAL_AVERAGE_POWER mode without causing error in the output.
        /// 
        /// Supported Devices&#58; NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Name">
        /// 
        /// name
        /// ViConstString
        /// Specifies the name used to identify the waveform. This string is case-insensitive and alphanumeric, and it does not use reserved words.
        /// 
        /// </param>
        /// <param name="Number_Of_Samples">
        /// 
        /// numberOfSamples
        /// ViInt32
        /// Specifies the number of samples in the data array.
        /// 
        /// </param>
        /// <param name="Data">
        /// 
        /// 
        /// data
        /// RfsgNIComplexI16[]
        /// Specifies the array of data to load into the waveform. The array must have at least as many elements as the value in the size_in_samples parameter in the niRFSG_AllocateArbWaveform function.
        ///  
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        [Obsolete]
        public int WriteArbWaveformComplexI16(string Name, int Number_Of_Samples, RfsgNIComplexI16[] Data)
        {
            int pInvokeResult = PInvoke.WriteArbWaveformComplexI16(this._handle, Name, Number_Of_Samples, Data);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_SelectArbWaveform
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_SelectArbWaveform&#160;(ViSession&#160;vi, ViConstString&#160;name);
        /// Purpose
        /// Specifies the waveform that is generated upon a call to the niRFSG_Initiate function when the generationMode parameter of the niRFSG_ConfigureGenerationMode function is set to NIRFSG_VAL_ARB_WAVEFORM. You must specify a waveform using the name parameter if you have written multiple waveforms. The NI-RFSG device must be in the Configuration  state before you call this function. 
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Name">
        /// 
        /// name
        /// ViConstString
        /// Specifies the name of the stored waveform to generate. This is a case-insensitive alphanumeric string that does not use reserved words. NI-RFSG sets the NIRFSG_ATTR_ARB_SELECTED_WAVEFORM attribute to this value.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int SelectArbWaveform(string Name)
        {
            int pInvokeResult = PInvoke.SelectArbWaveform(this._handle, Name);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ClearArbWaveform
        /// 
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ClearArbWaveform&#160;(ViSession&#160;vi, ViConstString&#160;name);
        /// Purpose
        /// Deletes a specified waveform from the pool of  currently defined waveforms. The NI-RFSG device must be in the Configuration state before you call this function.
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// </summary>
        /// <param name="Name">
        /// 
        /// name
        /// ViConstString
        /// Name of the stored waveform to delete.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ClearArbWaveform(string Name)
        {
            int pInvokeResult = PInvoke.ClearArbWaveform(this._handle, Name);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ClearAllArbWaveforms
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ClearAllArbWaveforms&#160;(ViSession&#160;vi);
        /// Purpose
        /// Deletes all currently defined waveforms and scripts. The NI-RFSG device must be in the Configuration  state before you call this function.
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ClearAllArbWaveforms()
        {
            int pInvokeResult = PInvoke.ClearAllArbWaveforms(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureSignalBandwidth
        /// 
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureSignalBandwidth&#160;(ViSession&#160;vi, ViReal64&#160;signalBandwidth);
        /// Purpose
        /// Configures the signal bandwidth of the arbitrary waveform. The NI-RFSG device must be in the Configuration state before you call this function. 
        /// 
        /// NI-RFSG defines signal bandwidth as twice the maximum baseband signal deviation from 0 Hz. Usually, the baseband signal center frequency is 0 Hz. In such cases, the signal bandwidth is simply the baseband signal minimum frequency subtracted from its maximum frequency, or fmax minus fmin. NI-RFSG uses this value to optimally configure the center frequency of the upconverter to help minimize phase noise. The generated signal is not filtered to achieve the set bandwidth. However, specifying a bandwidth smaller than the actual bandwidth of the signal could potentially result in spectral distortion.
        /// 
        /// 
        /// Note&#160;&#160;Based on your signal bandwidth, NI-RFSG decides whether to configure the upconverter center frequency on the NI 5670/5671/5672 in increments of 1 MHz or 5 MHz. Failure to configure signal bandwidth may result in
        /// the signal being placed outside the upconverter passband.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Signal_Bandwidth">
        /// 
        /// signalBandwidth
        /// ViReal64
        /// Specifies the signal bandwidth used by NI-RFSG to generate an RF output signal. NI-RFSG sets the NIRFSG_ATTR_SIGNAL_BANDWIDTH  attribute to this value. 
        /// 
        /// Valid Values:
        /// 0 Hz to 20 MHz
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureSignalBandwidth(double Signal_Bandwidth)
        {
            int pInvokeResult = PInvoke.ConfigureSignalBandwidth(this._handle, Signal_Bandwidth);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureDigitalModulationUserDefinedWaveform
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureDigitalModulationUserDefinedWaveform&#160;(ViSession&#160;vi,&#160;ViInt32&#160;numberOfSamples,&#160;ViInt8[]&#160;userDefinedWaveform);
        /// Purpose
        /// Specifies the message signal used for digital modulation when NIRFSG_ATTR_DIGITAL_MODULATION_WAVEFORM_TYPE is set to NIRFSG_VAL_USER_DEFINED.Supported Devices: NI PXI/PXIe-5650/5651/5652
        /// 
        /// 
        /// </summary>
        /// <param name="Number_Of_Samples">
        /// 
        /// numberOfSamples
        /// ViInt32
        /// Specifies the number of samples in the message signal.
        /// 
        /// </param>
        /// <param name="User_Defined_Waveform">
        /// 
        /// userDefinedWaveform
        /// ViInt8[]
        /// Specifies the user-defined message signal used for digital modulation.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureDigitalModulationUserDefinedWaveform(int Number_Of_Samples, sbyte[] User_Defined_Waveform)
        {
            int pInvokeResult = PInvoke.ConfigureDigitalModulationUserDefinedWaveform(this._handle, Number_Of_Samples, User_Defined_Waveform);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigurePowerLevelType
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigurePowerLevelType&#160;(ViSession&#160;vi, ViInt32&#160;power_level_type);
        /// Purpose
        /// Specifies the way the driver interprets the NIRFSG_ATTR_POWER_LEVEL attribute. In average power mode, NI-RFSG automatically scales waveform data to use the maximum dynamic range.  In peak power mode, waveforms are scaled according to the NIRFSG_ATTR_SOFTWARE_SCALING_FACTOR attribute.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Power_Level_Type">
        /// 
        /// power_level_type
        /// ViInt32
        /// Specifies the way the driver interprets the value of the NIRFSG_ATTR_POWER_LEVEL attribute. NI-RFSG sets the NIRFSG_ATTR_POWER_LEVEL_TYPE attribute to this value.
        /// 
        ///  
        ///                                                             Average Power (default)
        ///                     Indicates the desired power averaged in time. The driver maximizes the dynamic range by scaling the I/Q waveform so that its peak magnitude is equal to one. If your write more than one waveform, NI-RFSG scales each waveform without preserving the power level ratio between the waveforms.
        ///                 
        ///                                                             Peak Power
        ///                     
        ///                     Indicates the maximum power level of the RF signal averaged over one period of the RF carrier frequency (the peak envelope power). This setting requires that the magnitude of the I/Q waveform must always be less than or equal to one. When using peak power, the power level of the RF signal matches the specified power level at moments when the magnitude of the I/Q waveform equals one. If you write more than one waveform, the relative scaling between waveforms is preserved. In peak power mode, waveforms are scaled according to the NIRFSG_ATTR_ARB_WAVEFORM_SOFTWARE_SCALING_FACTOR attribute.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigurePowerLevelType(int Power_Level_Type)
        {
            int pInvokeResult = PInvoke.ConfigurePowerLevelType(this._handle, Power_Level_Type);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_CreateConfigurationList
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_CreateConfigurationList&#160;(ViSession&#160;vi, ViConstString&#160;listName, ViInt32&#160;numberOfAttributes, const ViAttr&#160;configurationListAttributes[], ViBoolean&#160;setAsActiveList);
        /// Purpose
        /// Creates an empty configuration list.  After a configuration list is created, the list is enabled using the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST attribute.  Call the niRFSG_CreateConfigurationListStep function to add steps to the configuration list.
        /// 
        /// Supported Devices&#58; NI PXIe-5650/5651/5652/5673E
        /// 
        /// </summary>
        /// <param name="List_Name">
        /// 
        /// listName
        /// ViConstString
        /// Specifies the name of the configuration list.  This string may not contain spaces.
        /// 
        /// </param>
        /// <param name="Number_Of_Attributes">
        /// 
        /// numberOfAttributes
        /// const ViInt32
        /// Specifies size of the <strong class="Monospace">configurationListAttributes</strong> parameter. 
        /// 
        /// </param>
        /// <param name="Configuration_List_Attributes">
        /// 
        /// configurationListAttributes[]
        /// const ViAttr
        /// Specifies the attributes that the user intends to change between configuration list steps.  Calling the niRFSG_CreateConfigurationList function allocates space for each of the configuration list attributes.  When you use an NI-RFSG Set attribute function to set one of the attributes in the configuration list, that attribute is set for one of the configuration list steps.  Use the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST attribute to specify which configuration list step to configure.
        /// 
        /// 
        /// 
        /// 
        /// The following attributes are valid values for this parameter's array elements:
        /// 
        /// NIRFSG_ATTR_FREQUENCY
        /// 
        /// NIRFSG_ATTR_POWER_LEVEL
        /// 
        /// NIRFSG_ATTR_PHASE_OFFSET
        /// 
        /// NIRFSG_ATTR_TIMER_EVENT_INTERVAL
        /// 
        /// NIRFSG_ATTR_FREQUENCY_SETTLING
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Set_As_Active_List">
        /// 
        /// setAsActiveList
        /// ViBoolean
        /// Sets this list as the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST attribute when this parameter is enabled.   NI recommends that you set this parameter to VI_TRUE when creating the list.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int CreateConfigurationList(string List_Name, int Number_Of_Attributes, niRFSGProperties[] Configuration_List_Attributes, bool Set_As_Active_List)
        {
            int pInvokeResult = PInvoke.CreateConfigurationList(this._handle, List_Name, Number_Of_Attributes, Configuration_List_Attributes, System.Convert.ToUInt16(Set_As_Active_List));
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_CreateConfigurationListStep
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_CreateConfigurationListStep&#160;(ViSession&#160;vi, ViBoolean&#160;setAsActiveStep);
        /// Purpose
        /// Creates a new configuration list step in the configuration list specified by the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST attribute.  When you create a configuration list step, a new instance of each attribute specified by the configuration list attributes is created.  Configuration list attributes are specified when a configuration list is created.  The new instance of an attribute can be accessed with any Set attribute function using the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST and NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST_STEP attributes.
        /// 
        /// Supported Devices&#58; NI PXIe-5650/5651/5652/5673E
        /// 
        /// </summary>
        /// <param name="Set_As_Active_Step">
        /// 
        /// setAsActiveStep
        /// ViBoolean
        /// Sets this step as the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST_STEP attribute list specified by the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST attribute.  NI recommends that you set this parameter to VI_TRUE when creating the list steps.
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int CreateConfigurationListStep(bool Set_As_Active_Step)
        {
            int pInvokeResult = PInvoke.CreateConfigurationListStep(this._handle, System.Convert.ToUInt16(Set_As_Active_Step));
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_DeleteConfigurationList
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_DeleteConfigurationList&#160;(ViSession&#160;vi, ViConstString&#160;listName);
        /// Purpose
        /// Deletes a previously created configuration list and all the configuration list steps in the configuration list.  When a configuration list step is deleted, all the instances of the attributes associated with the configuration list step are also removed.
        /// 
        /// Supported Devices&#58; NI PXIe-5650/5651/5652/5673E
        /// 
        /// </summary>
        /// <param name="List_Name">
        /// 
        /// listName
        /// ViConstString
        /// Specifies the name of the configuration list.  This string may not contain spaces.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int DeleteConfigurationList(string List_Name)
        {
            int pInvokeResult = PInvoke.DeleteConfigurationList(this._handle, List_Name);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureSoftwareStartTrigger
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureSoftwareStartTrigger&#160;(ViSession&#160;vi);
        /// Purpose
        /// Configures the Start trigger for software triggering. Refer to the niRFSG_SendSoftwareEdgeTrigger function for more information about using a software trigger.  The NI-RFSG device must be in the Configuration state before calling this function.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureSoftwareStartTrigger()
        {
            int pInvokeResult = PInvoke.ConfigureSoftwareStartTrigger(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureDigitalEdgeStartTrigger
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureDigitalEdgeStartTrigger&#160;(ViSession&#160;vi, ViConstString&#160;source, ViInt32&#160;edge);
        /// Purpose
        /// Configures the Start trigger for digital edge triggering.  The NI-RFSG device must be in the Configuration state before calling this function.
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Source">
        /// 
        /// source
        /// ViConstString
        /// Specifies the source terminal for the digital edge trigger. NI-RFSG sets NIRFSG_ATTR_DIGITAL_EDGE_START_TRIGGER_SOURCE to this value. 
        /// Defined Values:
        /// 
        /// ""Empty string.
        /// NIRFSG_VAL_PFI0_STRPFI 0 on the front panel SMB connector.
        /// NIRFSG_VAL_PFI1_STRPFI 1 on the front panel SMB connector.
        /// NIRFSG_VAL_PFI2_STRPFI 2 on the front panel DDC connector.
        /// NIRFSG_VAL_PFI3_STRPFI 3 on the front panel DDC connector.
        /// NIRFSG_VAL_PXI_TRIG0_STRPXI trigger line 0.
        /// NIRFSG_VAL_PXI_TRIG1_STRPXI trigger line 1.
        /// NIRFSG_VAL_PXI_TRIG2_STRPXI trigger line 2.
        /// NIRFSG_VAL_PXI_TRIG3_STRPXI tigger line 3.
        /// NIRFSG_VAL_PXI_TRIG4_STRPXI trigger line 4.
        /// NIRFSG_VAL_PXI_TRIG5_STRPXI trigger line 5.
        /// NIRFSG_VAL_PXI_TRIG6_STRPXI trigger line 6.
        /// NIRFSG_VAL_PXI_TRIG7_STRPXI trigger line 7.
        /// NIRFSG_VAL_PXI_STAR_STRPXI Star trigger line.
        /// 
        /// Default Value: &quot;&quot; (empty string)
        /// 
        /// 
        /// </param>
        /// <param name="Edge">
        /// 
        /// edge
        /// ViInt32
        /// Specifies the active edge for the Start trigger.  NI-RFSG sets NIRFSG_ATTR_DIGITAL_EDGE_START_TRIGGER_EDGE to this value.
        /// Defined Values:NIRFSG_VAL_RISING_EDGERising edge trigger transition from low to high.NIRFSG_VAL_FALLING_EDGEFalling edge trigger.
        /// 
        /// 
        /// Default Value: NIRFSG_VAL_RISING_EDGE
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureDigitalEdgeStartTrigger(string Source, int Edge)
        {
            int pInvokeResult = PInvoke.ConfigureDigitalEdgeStartTrigger(this._handle, Source, Edge);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureP2PEndpointFullnessStartTrigger
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureP2PEndpointFullnessStartTrigger&#160;(ViSession&#160;vi, ViInt64&#160;p2pEndpointFullnessLevel);
        /// Purpose
        /// Configures the Start trigger to detect peer-to-peer endpoint fullness. Generation begins when the number of samples in the peer-to-peer endpoint reaches the threshold specified by the level parameter.  The NI-RFSG device must be in the Configuration state before calling this function.
        /// 
        /// Note&#160;&#160;Due to an additional internal FIFO in the RF signal generator, the writer peer actually writes 2,304 bytes more than the quantity of data specified by this function to satisfy the trigger level.
        /// 
        /// 
        /// Supported Devices&#58; NI PXIe-5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="P2P_Endpoint_Fullness_Level">
        /// 
        /// p2pEndpointFullnessLevel
        /// ViInt64
        /// Specifies the quantity of data in the FIFO endpoint that asserts the trigger.  Units are samples per channel. 
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureP2PEndpointFullnessStartTrigger(long P2P_Endpoint_Fullness_Level)
        {
            int pInvokeResult = PInvoke.ConfigureP2PEndpointFullnessStartTrigger(this._handle, P2P_Endpoint_Fullness_Level);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_DisableStartTrigger
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_DisableStartTrigger&#160;(ViSession&#160;vi);
        /// Purpose
        /// Configures the device to not wait for a Start trigger after the niRFSG_Initiate function is called. Calling the niRFSG_DisableStartTrigger function is only necessary if the Start trigger has been previously configured and now needs to be disabled.  The NI-RFSG device must be in the Configuration state before calling this function.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int DisableStartTrigger()
        {
            int pInvokeResult = PInvoke.DisableStartTrigger(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureSoftwareScriptTrigger
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureSoftwareScriptTrigger&#160;(ViSession&#160;vi, ViConstString&#160;triggerIdentifier);
        /// Purpose
        /// Configures the Script trigger for software triggering. Refer to the niRFSG_SendSoftwareEdgeTrigger function for more information about using the software Script trigger. The NI-RFSG device must be in the Configuration state before calling this function.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Trigger_Identifier">
        /// 
        /// triggerIdentifier
        /// ViConstString
        /// Specifies the Script trigger to configure.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureSoftwareScriptTrigger(string Trigger_Identifier)
        {
            int pInvokeResult = PInvoke.ConfigureSoftwareScriptTrigger(this._handle, Trigger_Identifier);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureDigitalEdgeScriptTrigger
        /// Specific Function
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureDigitalEdgeScriptTrigger&#160;(ViSession&#160;vi, ViConstString&#160;triggerIdentifier, ViConstString&#160;source, ViInt32&#160;edge);
        /// Purpose
        /// Configures the specified Script trigger for digital edge triggering. The NI-RFSG device must be in the Configuration state before calling this function.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Trigger_Identifier">
        /// 
        /// triggerIdentifier
        /// ViConstString
        /// Specifies the Script trigger to configure.
        /// 
        /// </param>
        /// <param name="Source">
        /// 
        /// source
        /// ViConstString
        /// Specifies the source terminal for the digital edge Script trigger. NI-RFSG sets NIRFSG_ATTR_DIGITAL_EDGE_SCRIPT_TRIGGER_SOURCE to this value.
        /// Defined Values:
        /// 
        /// ""Empty string.
        /// NIRFSG_VAL_PFI0_STRPFI 0 on the front panel SMB connector.
        /// NIRFSG_VAL_PFI1_STRPFI 1 on the front panel SMB connector.
        /// NIRFSG_VAL_PFI2_STRPFI 2 on the front panel DDC connector.
        /// NIRFSG_VAL_PFI3_STRPFI 3 on the front panel DDC connector.
        /// NIRFSG_VAL_PXI_TRIG0_STRPXI trigger line 0.
        /// NIRFSG_VAL_PXI_TRIG1_STRPXI trigger line 1.
        /// NIRFSG_VAL_PXI_TRIG2_STRPXI trigger line 2.
        /// NIRFSG_VAL_PXI_TRIG3_STRPXI tigger line 3.
        /// NIRFSG_VAL_PXI_TRIG4_STRPXI trigger line 4.
        /// NIRFSG_VAL_PXI_TRIG5_STRPXI trigger line 5.
        /// NIRFSG_VAL_PXI_TRIG6_STRPXI trigger line 6.
        /// NIRFSG_VAL_PXI_TRIG7_STRPXI trigger line 7.
        /// NIRFSG_VAL_PXI_STAR_STRPXI Star trigger line.
        /// 
        /// Default Value: &quot;&quot; (empty string)
        /// 
        /// </param>
        /// <param name="Edge">
        /// 
        /// edge
        /// ViInt32
        /// Specifies the active edge for the digital edge Script trigger. NI-RFSG sets NIRFSG_ATTR_DIGITAL_EDGE_SCRIPT_TRIGGER_EDGE to this value.
        /// Defined Values:NIRFSG_VAL_RISING_EDGERising edge trigger transition from low to high.NIRFSG_VAL_FALLING_EDGEFalling edge trigger.
        /// 
        /// Default Value: NIRFSG_VAL_RISING_EDGE
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureDigitalEdgeScriptTrigger(string Trigger_Identifier, string Source, int Edge)
        {
            int pInvokeResult = PInvoke.ConfigureDigitalEdgeScriptTrigger(this._handle, Trigger_Identifier, Source, Edge);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureDigitalLevelScriptTrigger
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureDigitalLevelScriptTrigger&#160;(ViSession vi, ViConstString Trigger_Identifier, ViConstString Source, ViInt32 Level);
        /// 
        /// Purpose
        /// Configures a specified Script trigger for digital level triggering.  The NI-RFSG device must be in the Configuration state before calling this function.
        /// 
        /// Supported Devices: NI PXI-5670/5671, NI PXIe-5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Trigger_Identifier">
        /// 
        /// triggerIdentifier
        /// ViConstString
        /// Specifies the Script trigger to configure.
        /// 
        /// </param>
        /// <param name="Source">
        /// 
        /// source
        /// ViConstString
        /// Specifies the trigger source terminal for the digital level script trigger. NI-RFSG sets NIRFSG_ATTR_DIGITAL_LEVEL_SCRIPT_TRIGGER_SOURCE to this value. 
        /// Defined Values:
        /// 
        /// ""Empty string.
        /// 
        /// NIRFSG_VAL_PFI0_STRPFI 0 on the front panel SMB connector.
        /// NIRFSG_VAL_PFI1_STRPFI 1 on the front panel SMB connector.
        /// NIRFSG_VAL_PFI2_STRPFI 2 on the front panel DDC connector.
        /// NIRFSG_VAL_PFI3_STRPFI 3 on the front panel DDC connector.
        /// NIRFSG_VAL_PXI_TRIG0_STRPXI trigger line 0.
        /// NIRFSG_VAL_PXI_TRIG1_STRPXI trigger line 1.
        /// NIRFSG_VAL_PXI_TRIG2_STRPXI trigger line 2.
        /// NIRFSG_VAL_PXI_TRIG3_STRPXI tigger line 3.
        /// NIRFSG_VAL_PXI_TRIG4_STRPXI trigger line 4.
        /// NIRFSG_VAL_PXI_TRIG5_STRPXI trigger line 5.
        /// NIRFSG_VAL_PXI_TRIG6_STRPXI trigger line 6.
        /// NIRFSG_VAL_PXI_TRIG7_STRPXI trigger line 7.
        /// NIRFSG_VAL_RTSI0_STRRTSI trigger line 0.
        /// NIRFSG_VAL_RTSI1_STRRTSI trigger line 1.
        /// NIRFSG_VAL_RTSI2_STRRTSI trigger line 2.
        /// NIRFSG_VAL_RTSI3_STRRTSI trigger line 3.
        /// NIRFSG_VAL_RTSI4_STRRTSI trigger line 4.
        /// NIRFSG_VAL_RTSI5_STRRTSI trigger line 5.
        /// NIRFSG_VAL_RTSI6_STRRTSI trigger line 6.
        ///  NIRFSG_VAL_PXI_STAR_STRPXI STAR Line.
        /// Default Value: "" (empty string)
        /// 
        /// </param>
        /// <param name="Level">
        /// 
        /// Level
        /// ViInt32
        /// Specifies the active level for the digital level script trigger. NI-RFSG sets NIRFSG_ATTR_DIGITAL_LEVEL_SCRIPT_TRIGGER_ACTIVE_LEVEL to this value.
        /// Defined Values:NIRFSG_VAL_ACTIVE_HIGHNIRFSG_VAL_ACTIVE_LOW
        /// Default Value: NIRFSG_VAL_ACTIVE_HIGH
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureDigitalLevelScriptTrigger(string Trigger_Identifier, string Source, int Level)
        {
            int pInvokeResult = PInvoke.ConfigureDigitalLevelScriptTrigger(this._handle, Trigger_Identifier, Source, Level);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_DisableScriptTrigger
        /// Specific Function
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_DisableScriptTrigger&#160;(ViSession&#160;vi, ViConstString&#160;triggerIdentifier);
        /// Purpose
        /// Configures the device to not wait for the specified Script trigger after the niRFSG_Initiate function is called. Calling the niRFSG_DisableScriptTrigger function is only necessary if the Script trigger has been previously configured and now must be disabled. The NI-RFSG device must be in the Configuration state before you call this function.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Trigger_Identifier">
        /// 
        /// triggerIdentifier
        /// ViConstString
        /// Specifies the Script trigger to configure.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int DisableScriptTrigger(string Trigger_Identifier)
        {
            int pInvokeResult = PInvoke.DisableScriptTrigger(this._handle, Trigger_Identifier);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_SendSoftwareEdgeTrigger
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_SendSoftwareEdgeTrigger&#160;(ViSession&#160;vi, ViInt32&#160;trigger, ViConstString&#160;triggerIdentifier);
        /// Purpose
        /// Forces a particular trigger to occur. The specified trigger is generated regardless of whether the trigger has been configured as a software trigger.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Trigger">
        /// 
        /// trigger
        /// ViInt32
        /// Specifies the trigger to assert.
        /// Defined Values:NIRFSG_VAL_START_TRIGGERTransitions the device from an Idle state to a Generation state where the device can respond to sample clocks.NIRFSG_VAL_SCRIPT_TRIGGERAllows you to create sophisticated generation operations that are determined by the generation script.
        /// 
        /// Default Value: NIRFSG_VAL_START_TRIGGER
        /// 
        /// 
        /// </param>
        /// <param name="Trigger_Identifier">
        /// 
        /// triggerIdentifier
        /// ViConstString
        /// Specifies the Script trigger to configure.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int SendSoftwareEdgeTrigger(int Trigger, string Trigger_Identifier)
        {
            int pInvokeResult = PInvoke.SendSoftwareEdgeTrigger(this._handle, Trigger, Trigger_Identifier);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureDigitalEdgeConfigurationListStepTrigger
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureDigitalEdgeConfigurationListStepTrigger&#160;(ViSession&#160;vi, ViConstString&#160;source, ViInt32&#160;edge);
        /// Purpose
        /// Configures the Configuration List Step trigger for digital edge triggering. The NI-RFSG device must be in the Configuration state before you call this function.
        /// 
        /// Supported Devices&#58; NI PXIe-5650/5651/5652/5653/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Source">
        /// 
        /// source
        /// ViConstString
        /// Specifies the trigger source terminal for the digital edge Configuration List Step trigger. NI-RFSG sets the NIRFSG_ATTR_DIGITAL_EDGE_CONFIGURATION_LIST_STEP_TRIGGER_SOURCE  attribute to this value. Refer to this attribute for possible values.
        /// 
        /// 
        /// </param>
        /// <param name="Edge">
        /// 
        /// edge
        /// ViInt32
        /// Specifies the active edge for the digital edge Configuration List Step trigger.  NI-RFSG sets NIRFSG_ATTR_DIGITAL_EDGE_CONFIGURATION_LIST_STEP_TRIGGER_EDGE to this value.
        /// Defined Values:NIRFSG_VAL_RISING_EDGERising edge trigger transition from low to high.NIRFSG_VAL_FALLING_EDGEFalling edge trigger.
        /// 
        /// 
        /// Default Value: NIRFSG_VAL_RISING_EDGE
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureDigitalEdgeConfigurationListStepTrigger(string Source, int Edge)
        {
            int pInvokeResult = PInvoke.ConfigureDigitalEdgeConfigurationListStepTrigger(this._handle, Source, Edge);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_DisableConfigurationListStepTrigger
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_DisableConfigurationListStepTrigger&#160;(ViSession&#160;vi, ViConstString&#160;source, ViInt32&#160;edge);
        /// Purpose
        /// Configures the device to not receive triggers for the configuration list after the niRFSG_Initiate function is called.  The configuration list does not advance steps if this trigger is disabled.  Calling the niRFSG_DisableConfigurationListStepTrigger  function is necessary if the trigger has been previously configuration and then needs to be disabled. The NI-RFSG device must be in the Configuration state before you call this VI.
        /// 
        /// Supported Devices&#58; NI PXIe-5650/5651/5652/5653/5673E
        /// 
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int DisableConfigurationListStepTrigger()
        {
            int pInvokeResult = PInvoke.DisableConfigurationListStepTrigger(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_GetTerminalName
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_GetTerminalName&#160;(ViSession&#160;vi, ViInt32&#160;signal, ViConstString&#160;signalIdentifier, ViInt32&#160;bufferSize, ViChar&#160;terminalName);
        /// Purpose
        /// Returns the fully-qualified name of the signal being queried. The fully-qualified name is helpful to automatically route signals in a multisegment chassis.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Signal">
        /// 
        /// signal
        /// ViInt32
        /// Specifies the signal being queried.
        /// 
        /// 
        /// Defined Values:
        /// 
        /// NIRFSG_VAL_START_TRIGGERQueries the Start trigger.NIRFSG_VAL_SCRIPT_TRIGGERQueries a Script trigger.
        /// NIRFSG_VAL_MARKER_EVENTQueries a Marker event.
        /// NIRFSG_VAL_STARTED_EVENTQueries the Started event.
        /// NIRFSG_VAL_DONE_EVENTQueries the Done event.
        /// NIRFSG_VAL_CONFIGURATION_LIST_STEP_TRIGGERQueries the Configuration List Step trigger.
        /// 
        /// 
        /// </param>
        /// <param name="Signal_Identifier">
        /// 
        /// signalIdentifier
        /// ViConstString
        /// Specifies which instance of the selected signal to query.  This parameter is necessary when the signal parameter is set to NIRFSG_VAL_SCRIPT_TRIGGER or NIRFSG_VAL_MARKER_EVENT. Otherwise, set the signalIdentifier parameter to "" (empty string).
        /// 
        /// 
        /// 
        /// 
        /// Defined Values:
        /// 
        /// NIRFSG_VAL_SCRIPT_TRIGGER0Specifies Script trigger 0.
        /// NIRFSG_VAL_SCRIPT_TRIGGER1Specifies Script trigger 1.
        ///   NIRFSG_VAL_SCRIPT_TRIGGER2Specifies Script trigger 2.
        ///   NIRFSG_VAL_SCRIPT_TRIGGER3Specifies Script trigger 3.
        /// NIRFSG_VAL_MARKER_EVENT0 Specifies Marker 0.
        ///  NIRFSG_VAL_MARKER_EVENT1Specifies Marker 1.
        ///   NIRFSG_VAL_MARKER_EVENT2 Specifies Marker 2.
        ///    NIRFSG_VAL_MARKER_EVENT3Specifies Marker 3.
        /// "" (empty string)Does not specify a signal identifier. 
        ///    
        /// 
        /// </param>
        /// <param name="Buffer_Size">
        /// 
        /// bufferSize
        /// ViInt32
        /// Pass the number of bytes in the ViChar buffer you specify for the attributeValue parameter.  
        /// 
        /// If you pass 0, you can pass VI_NULL for the attributeValue parameter.
        /// </param>
        /// <param name="Terminal_Name">
        /// 
        /// terminalName[]
        /// ViChar
        /// Returns the string to use as the source for other devices.
        ///    
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the status code, call the niRFSG_error_message function.  To obtain additional information about the error condition, call the niRFSG_GetError function.  To clear the error information from the driver, call the niRFSG_ClearError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int GetTerminalName(int Signal, string Signal_Identifier, int Buffer_Size, System.Text.StringBuilder Terminal_Name)
        {
            int pInvokeResult = PInvoke.GetTerminalName(this._handle, Signal, Signal_Identifier, Buffer_Size, Terminal_Name);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureRefClock
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureRefClock&#160;(ViSession&#160;vi, ViConstString&#160;clockSource, ViReal64&#160;refClockRate);
        /// Purpose
        /// Configures the NI-RFSG device Reference clock.  The Reference clock ensures that the NI-RFSG devices are operating from a common timebase.  The NI-RFSG device must be in the Configuration state before calling this function.
        /// 
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Ref_Clock_Source">
        /// 
        /// refClockSource
        /// ViConstString
        /// Specifies the source of Reference clock signal. 
        /// 
        /// 
        ///  
        /// 
        /// NIRFSG_VAL_ONBOARD_CLOCK_STR (default)Uses the onboard Reference clock as the clock source.
        /// NIRFSG_VAL_REF_IN_STR             Uses the clock signal present at the front panel REF IN connector as the clock source.     
        /// NIRFSG_VAL_PXI_CLK_STRUses the PXI_CLK signal, which is present on the PXI backplane, as the clock source.  
        /// NIRFSG_VAL_CLK_IN_STR  Uses the clock signal present at the front panel CLK IN connector as the clock source.
        /// 
        /// </param>
        /// <param name="Ref_Clock_Rate">
        /// 
        /// refClockRate
        /// ViReal64
        /// Specifies the Reference clock rate, expressed in Hz. NI-RFSG sets NIRFSG_ATTR_REF_CLOCK_RATE to this value.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureRefClock(string Ref_Clock_Source, double Ref_Clock_Rate)
        {
            int pInvokeResult = PInvoke.ConfigureRefClock(this._handle, Ref_Clock_Source, Ref_Clock_Rate);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigurePXIChassisClk10
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigurePXIChassisClk10&#160;(ViSession&#160;vi, ViConstString&#160;pxiClk10Source);
        /// Purpose
        /// Specifies the signal to drive the 10&#160;MHz Reference clock on the PXI backplane. 
        /// This option can only be configured when the NI 5610 is in Slot 2 of the PXI chassis.
        /// The NI-RFSG device must be in the Configuration state before you call this function.
        /// 
        /// Supported Devices&#58; NI PXI-5610/5670/5671
        /// 
        /// 
        /// </summary>
        /// <param name="PXI_Clk_10_Source">
        /// 
        /// pxiClk10Source
        /// ViConstString
        /// Specifies the source of the Reference clock signal.
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigurePXIChassisClk10(string PXI_Clk_10_Source)
        {
            int pInvokeResult = PInvoke.ConfigurePXIChassisClk10(this._handle, PXI_Clk_10_Source);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ExportSignal
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ExportSignal&#160;(ViSession&#160;vi, ViInt32&#160;signal, ViConstString&#160;signalIdentifier, ViConstString&#160;outputTerminal);
        /// Purpose
        /// Routes signals (triggers, clocks, and events) to a specified output terminal. The NI-RFSG device must be in the Configuration state before you call this function.
        /// 
        /// You can clear a previously routed signal by exporting the signal to "" (empty string). 
        /// Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5670/5671, NI PXIe-5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Signal">
        /// 
        /// signal
        /// ViInt32
        /// Specifies the signal to route.Onboard Reference clock output terminal is not configurable on the&#160;NI 5670/5671/5672 device.Triggers and Marker events are not available on the NI 5650/5651/5652 device.
        /// 
        /// 
        /// Defined Values:
        /// <tr>
        /// NIRFSG_VAL_START_TRIGGERExports a Start trigger.NIRFSG_VAL_SCRIPT_TRIGGERExports a Script trigger.
        /// NIRFSG_VAL_MARKER_EVENTExports a Marker event.
        /// NIRFSG_VAL_DONE_EVENTExports a Done event.NIRFSG_VAL_REF_CLOCKRoutes the onboard 10 MHz synchronization clock (PXI chassis only).
        /// NIRFSG_VAL_STARTED_EVENTExports a Started event.</tr>
        /// 
        /// </param>
        /// <param name="Signal_Identifier">
        /// 
        /// signalIdentifier
        /// ViConstString
        /// Specifies which instance of the selected signal to export.This parameter is useful when the signal parameter is set to NIRFSG_VAL_SCRIPT_TRIGGER or NIRFSG_VAL_MARKER_EVENT. Otherwise, set the signalIdentifier parameter to "" (empty string).
        /// 
        /// 
        /// 
        /// 
        /// Defined Values:
        /// 
        /// NIRFSG_VAL_SCRIPT_TRIGGER0Specifies Script trigger 0.
        /// NIRFSG_VAL_SCRIPT_TRIGGER1Specifies Script trigger 1.
        ///   NIRFSG_VAL_SCRIPT_TRIGGER2Specifies Script trigger 2.
        ///   NIRFSG_VAL_SCRIPT_TRIGGER3Specifies Script trigger 3.
        /// NIRFSG_VAL_MARKER_EVENT0 Specifies Marker 0.
        ///  NIRFSG_VAL_MARKER_EVENT1Specifies Marker 1.
        ///   NIRFSG_VAL_MARKER_EVENT2 Specifies Marker 2.
        ///    NIRFSG_VAL_MARKER_EVENT3Specifies Marker 3.
        /// "" (empty string)None (no signal to export) 
        ///    
        /// 
        /// </param>
        /// <param name="Output_Terminal">
        /// 
        /// outputTerminal
        /// ViConstString
        /// Specifies the terminal where the signal is exported.  You can choose not to export any signal.
        /// 
        /// 
        /// 
        /// 
        /// 
        /// 
        /// Defined Values:
        /// 
        /// NIRFSG_VAL_DO_NOT_EXPORT_STRDoes not export a signal.
        /// NIRFSG_VAL_REF_OUT_STRExports a signal to the REF OUT connector.
        ///   NIRFSG_VAL_REF_OUT2_STRExports a signal to the REF OUT2 connector, if applicable.
        ///   NIRFSG_VAL_CLK_OUT_STRExports a signal to the CLK OUT connector.
        /// NIRFSG_VAL_PFI0_STR Exports a signal to the PFI 0 terminal.
        ///  NIRFSG_VAL_PFI1_STRExports a signal to the PFI 1 terminal.
        ///   NIRFSG_VAL_PFI4_STR Exports a signal to the PFI 4 terminal.
        ///    NIRFSG_VAL_PFI5_STRExports a signal to the PFI 5 terminal.
        ///   NIRFSG_VAL_PXI_TRIG0_STRExports a signal to the PXI trigger line 0 terminal.
        ///   NIRFSG_VAL_PXI_TRIG1_STRExports a signal to the PXI trigger line 1 terminal.
        ///   NIRFSG_VAL_PXI_TRIG2_STRExports a signal to the PXI trigger line 2 terminal.
        ///   NIRFSG_VAL_PXI_TRIG3_STRExports a signal to the PXI trigger line 3 terminal.
        ///   NIRFSG_VAL_PXI_TRIG4_STRExports a signal to the PXI trigger line 4 terminal.
        /// 
        ///   NNIRFSG_VAL_PXI_TRIG5_STRExports a signal to the PXI trigger line 5 terminal.
        /// 
        ///   NIRFSG_VAL_PXI_TRIG6_STRExports a signal to the PXI trigger line 6 terminal.
        ///   NIRFSG_VAL_PXI_STAR_STRExports a signal to the PXI star trigger line terminal.
        ///    
        /// 
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ExportSignal(int Signal, string Signal_Identifier, string Output_Terminal)
        {
            int pInvokeResult = PInvoke.ExportSignal(this._handle, Signal, Signal_Identifier, Output_Terminal);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_GetStreamEndpointHandle
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_GetStreamEndpointHandle&#160;(ViSession&#160;vi, ViConstString&#160;streamEndpoint, ViUInt32*&#160;readerHandle);
        /// Purpose
        /// Returns a reader endpoint handle that can be used with NI-P2P to configure a peer-to-peer stream with an RF signal generator endpoint.
        /// 
        /// 
        /// Supported Devices: NI PXIe-5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Stream_Endpoint">
        /// 
        /// streamEndpoint
        /// ViConstString
        /// Specifies the stream endpoint FIFO to configure. Refer to the Peer-to-Peer Data Streaming topic in the NI RF Signal Generators Help for more information.
        /// 
        /// </param>
        /// <param name="Reader_Handle">
        /// 
        /// readerHandle
        /// ViUInt32*
        /// Returns the reader endpoint handle that is used with NI-P2P to create a stream with the NI-RFSG device as an endpoint.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int GetStreamEndpointHandle(string Stream_Endpoint, out uint Reader_Handle)
        {
            int pInvokeResult = PInvoke.GetStreamEndpointHandle(this._handle, Stream_Endpoint, out Reader_Handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// niRFSG_WriteP2PEndpointI16
        /// 
        /// ViStatus niRFSG_WriteP2PEndpointI16&#160;(ViSession&#160;vi, ViConstString&#160;streamEndpoint, ViInt32&#160;numberOfSamples, ViInt16&#160;endpointData[])
        /// 
        /// Purpose
        /// 
        /// Writes an array of 16-bit integer data to the peer-to-peer endpoint. Use this function to write initial data from the host to the endpoint before starting generation to avoid an underflow when you start the generation.
        /// 
        /// Supported Devices: NI PXIe-5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Stream_Endpoint">
        /// 
        /// streamEndpoint
        /// ViConstString
        /// Specifies the stream endpoint FIFO to configure. Refer to the Peer-to-Peer Data Streaming topic in the NI RF Signal Generators Help for more information.
        /// 
        /// </param>
        /// <param name="Number_Of_Samples">
        /// 
        /// 
        /// numberOfSamples
        /// ViInt32
        /// Specifies the number of samples to write into the endpoint FIFO.
        ///  
        /// </param>
        /// <param name="Endpoint_Data">
        /// 
        /// 
        /// endpointData
        /// ViInt16 []
        /// Specifies the array of data to write into the endpoint FIFO. The binary data is left-justified.
        ///  
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int WriteP2PEndpointI16(string Stream_Endpoint, int Number_Of_Samples, short[] Endpoint_Data)
        {
            int pInvokeResult = PInvoke.WriteP2PEndpointI16(this._handle, Stream_Endpoint, Number_Of_Samples, Endpoint_Data);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_WriteScript
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_WriteScript&#160;(ViSession&#160;vi, ViConstString&#160;script);
        /// 
        /// Purpose
        /// Writes a script to the device to control waveform generation in Script mode. First, configure your device for Script mode by calling the niRFSG_ConfigureGenerationMode function. The NI-RFSG device must be in the Configuration state before calling the niRFSG_WriteScript function. Refer to Scripting Instructions in the NI RF Signal Generators Help for information about using scripts
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// </summary>
        /// <param name="Script">
        /// 
        /// 
        /// script
        /// ViConstString
        /// Specifies a string containing a syntactically correct script. NI-RFSG supports multiple scripts that may be selected by name with the NIRFSG_ATTR_SELECTED_SCRIPT attribute. Refer to Scripting Instructions for more information about using scripts. 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int WriteScript(string Script)
        {
            int pInvokeResult = PInvoke.WriteScript(this._handle, Script);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureOutputEnabled
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureOutputEnabled&#160;(ViSession&#160;vi, ViBoolean&#160;output_enabled);
        /// Purpose
        /// Enables or disables signal output.  You can call this function in any software state, and it does not change the current software state.  Setting output_enabled to VI_FALSE while in the Generation state attenuates the generated signal so that no signal is output.
        /// 
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Output_Enabled">
        /// 
        /// output_enabled
        /// ViBoolean
        /// Specifies whether you want to enable or disable the output.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureOutputEnabled(bool Output_Enabled)
        {
            int pInvokeResult = PInvoke.ConfigureOutputEnabled(this._handle, System.Convert.ToUInt16(Output_Enabled));
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ConfigureIQEnabled [OBSOLETE]
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ConfigureIQEnabled&#160;(ViSession&#160;vi, ViBoolean&#160;enabled);
        /// Purpose
        /// Configures the NI-RFSG device to apply I/Q (vector) modulation to the RF output signal. I/Q modulation must be enabled in order to generate any arbitrary (non-sine) waveform; if I/Q modulation is disabled, a sine tone is always generated, regardless if an arbitrary waveform is written. The NI-RFSG device must be in the Configuration state before calling this function.
        /// 
        /// 
        /// 
        /// Note&#160;&#160;This function is obsolete.  Use the  NIRFSG_ATTR_GENERATION_MODE attribute to enable I/Q modulation instead.
        /// 
        /// Upon device initialization, or calling the niRFSG_reset function or the niRFSG_ResetDevice function, I/Q modulation is disabled.
        /// 
        /// 
        /// </summary>
        /// <param name="IQ_Enabled">
        /// 
        /// enabled
        /// ViBoolean
        /// NI-RFSG sets the NIRFSG_ATTR_IQ_ENABLED attribute to this value.
        /// 
        /// 
        /// 
        /// Defined Values:
        /// 
        /// 
        /// VI_TRUEEnables IQ (vector) modulation (arbitrary waveform generation)VI_FALSEDisables IQ (vector) modulation (sine wave generation)
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ConfigureIQEnabled(bool IQ_Enabled)
        {
            int pInvokeResult = PInvoke.ConfigureIQEnabled(this._handle, System.Convert.ToUInt16(IQ_Enabled));
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// 
        /// niRFSG_ResetAttribute
        /// 
        /// ViStatus niRFSG_ResetAttribute         (ViSession vi, ViConstString channelName, ViAttr attributeId);
        /// 
        /// Purpose
        /// 
        /// Resets the attribute to its default value.
        /// 
        /// Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the channel to which the attribute applies if this attribute is channel-based. If the attribute is not channel-based, set this parameter to &quot;&quot; (empty string) or VI_NULL.
        /// 
        /// Default Value:  &quot;&quot; (empty string)
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Attribute_ID">
        /// 
        /// attributeID
        /// ViAttr
        /// Pass the ID of an attribute.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ResetAttribute(string Channel_Name, int Attribute_ID)
        {
            int pInvokeResult = PInvoke.ResetAttribute(this._handle, Channel_Name, Attribute_ID);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_Initiate
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_Initiate&#160;(ViSession&#160;vi);
        /// Purpose
        /// Initiates signal generation, causing the NI-RFSG device to leave the Configuration state and enter the Generation state.  If the settings have not been committed to the device before you call this function, they are committed with this function. The operation returns when the RF output signal settles. To return to the Configuration state, call the niRFSG_Abort function. On the NI 5653, this function tunes the device and waits for the required settling time.
        /// 
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int Initiate()
        {
            int pInvokeResult = PInvoke.Initiate(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_CheckGenerationStatus
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_CheckGenerationStatus&#160;(ViSession&#160;vi, ViBoolean*&#160;isDone);
        /// Purpose
        /// Checks the status of the generation.  Call this function to check for any errors that might occur during the signal generation or to check whether the device has finished generating.
        /// 
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Is_Done">
        /// 
        /// isDone
        /// ViBoolean*
        /// Returns information about the completion of signal generation.
        /// 
        /// 
        /// Defined Values:
        /// 
        /// VI_TRUESignal generation is complete. VI_FALSE Signal generation is occurring.
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int CheckGenerationStatus(out bool Is_Done)
        {
            ushort Is_DoneAsUShort;
            int pInvokeResult = PInvoke.CheckGenerationStatus(this._handle, out Is_DoneAsUShort);
            Is_Done = System.Convert.ToBoolean(Is_DoneAsUShort);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_Abort
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_Abort&#160;(ViSession&#160;vi);
        /// Purpose
        /// Stops signal generation.
        /// 
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int Abort()
        {
            int pInvokeResult = PInvoke.Abort(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_Commit
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_Commit&#160;(ViSession&#160;vi);
        /// Purpose
        /// Programs the device with the correct settings.  Calling this function moves the NI-RFSG device from the Configuration state to the Committed state. 
        /// After calling this function, changing any attribute reverts the NI-RFSG device to the Configuration state.
        /// 
        /// <p class="Body">Supported devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E</p>
        /// 
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int Commit()
        {
            int pInvokeResult = PInvoke.Commit(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_PerformThermalCorrection
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_PerformThermalCorrection&#160;(ViSession&#160;vi);
        /// Purpose
        /// Corrects for any signal drift due to environmental temperature variation when generating the same signal for extended periods of time without a parameter change.   Under normal circumstances of short-term signal generation, NI-RFSG performs thermal correction automatically by ensuring stable power levels, and you do not need to call this function.
        /// 
        /// Use this function when generating the same signal for an extended period of time in a temperature-fluctuating environment.
        /// The NI-RFSG device must be in the Generation state before calling this function.
        /// 
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E 
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int PerformThermalCorrection()
        {
            int pInvokeResult = PInvoke.PerformThermalCorrection(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_WaitUntilSettled
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_WaitUntilSettled&#160;(ViSession&#160;vi, ViInt32&#160;maxTimeMilliseconds);
        /// Purpose
        /// Waits until the RF output signal has settled. This function is useful for devices that support changes while in the Generation state. Call this function after making a dynamic change to wait for the output to settle. 
        /// 
        /// 
        /// 
        /// You can also call this function after calling the niRFSG_Commit function to wait for changes to settle. The niRFSG_WaitUntilSettled function is not needed after calling the niRFSG_Initiate function because the niRFSG_Initiate function does not return until the output is settled. 
        /// 
        /// Supported Devices&#58;  NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Max_Time_Milliseconds">
        /// 
        /// maxTimeMilliseconds
        /// ViInt32
        /// Defines the maximum time the function waits for the output to settle. If the maximum time is exceeded, this function returns an error. The units are expressed in milliseconds.
        /// 
        /// Default Value: 10000
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int WaitUntilSettled(int Max_Time_Milliseconds)
        {
            int pInvokeResult = PInvoke.WaitUntilSettled(this._handle, Max_Time_Milliseconds);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_reset
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_reset&#160;(ViSession&#160;vi);
        /// Purpose
        /// Resets all attributes to their default values and moves the NI-RFSG device to the Configuration state.  This function aborts the generation, clears all routes, and resets session attributes to the initial values.  During a reset, routes of signals between this and other devices are released, regardless of which device created the route.
        /// 
        /// Generally, calling this function instead of the niRFSG_ResetDevice function is acceptable.  The niRFSG_reset function executes faster than the niRFSG_ResetDevice function.
        /// 
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int reset()
        {
            int pInvokeResult = PInvoke.reset(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ResetDevice
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ResetDevice&#160;(ViSession&#160;vi);
        /// 
        /// Purpose
        /// 
        /// Performs a hard reset on the device which consists of the following actions:
        /// Signal generation is stopped.
        /// All routes are released.
        /// External bidirectional terminals are tristated.
        /// FPGAs are reset.
        /// Hardware is configured to its default state.
        /// All session attributes are reset to their default states.
        ///  
        /// During a device reset, routes of signals between this and other devices are released, regardless of which device created the route.
        /// 
        /// NI 5610/5670/5671/5672&#8212; After calling this function, the device requires 25 seconds before returning to full functionality.  NI-RFSG enforces this condition by adding a wait, if needed, the next time you try to access the device. 
        ///  
        /// 
        /// Note&#160;&#160;You must call the niRFSG_ResetDevice function if the NI-RFSG device has shut down because of a high-temperature condition.
        /// 
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ResetDevice()
        {
            int pInvokeResult = PInvoke.ResetDevice(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_ResetWithDefaults
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_ResetWithDefaults&#160;(ViSession vi);
        /// 
        /// Purpose
        /// Performs a software reset of the device, returning it to the default state and applying any initial default settings from the IVI Configuration Store.
        /// <p class="body">Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E</p>
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ResetWithDefaults()
        {
            int pInvokeResult = PInvoke.ResetWithDefaults(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_GetChannelName
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_GetChannelName&#160;(ViSession vi, ViInt32 Index, ViInt32 BufferSize, ViChar Channel_Name[]);
        /// 
        /// Purpose
        /// Returns the channel string that is in the channel table at an index you specify.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Index">
        /// 
        /// Index
        /// ViInt32
        /// Specifies a one-based index into the channel table.
        /// 
        /// </param>
        /// <param name="BufferSize">
        /// 
        /// BufferSize
        /// ViInt32
        /// Specifies the size of the buffer for the channel string
        /// 
        /// </param>
        /// <param name="Channel_Name">
        /// 
        /// Channel_Name
        /// ViChar[]
        /// Returns a channel string from the channel table at the index you specify in the Index parameter.
        /// Do not modify the contents of the channel string.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int GetChannelName(int Index, int BufferSize, System.Text.StringBuilder Channel_Name)
        {
            int pInvokeResult = PInvoke.GetChannelName(this._handle, Index, BufferSize, Channel_Name);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_Disable
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_Disable&#160;(ViSession vi);
        /// 
        /// Purpose
        /// Places the instrument in a quiescent state where it has minimal or no impact on the system to which it is connected.
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5672/5673/5673E
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int Disable()
        {
            int pInvokeResult = PInvoke.Disable(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_self_test
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_self_test&#160;(ViSession&#160;vi, ViInt16*&#160;selfTestResult, ViChar[]&#160;selfTestMessage);
        /// Purpose
        /// Performs a self-test on the NI-RFSG device and returns the test results.  This function performs a simple series of tests to ensure that the NI-RFSG device is powered up and responding.  
        /// 
        /// 
        /// 
        /// This function does not affect external I/O connections or connections between devices.  Complete functional testing and calibration are not performed by this function. The NI-RFSG device must be in the Configuration state before you call this function.
        /// 
        /// Supported Devices&#58; NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// 
        /// </summary>
        /// <param name="Self_Test_Result">
        /// 
        /// selfTestResult
        /// ViInt16*
        /// This parameter contains the value returned from the NI-RFSG device self test.
        /// 
        /// 
        /// 
        /// Self-Test Code Description
        /// 0Self test passed
        /// 1Self test failed
        ///    
        ///    
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Self_Test_Message">
        /// 
        /// selfTestMessage
        /// ViChar[]
        /// Returns the self-test response string from the NI-RFSG device. For an explanation of the string contents, refer to the status parameter of this function.
        /// 
        /// You must pass a ViChar array with at least 256 bytes.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int self_test(out short Self_Test_Result, System.Text.StringBuilder Self_Test_Message)
        {
            int pInvokeResult = PInvoke.self_test(this._handle, out Self_Test_Result, Self_Test_Message);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }
        // Change casing : SelfTest ==>Not Required
        /// <summary>
        /// 
        /// niRFSG_error_query
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_error_query&#160;(ViSession&#160;vi, ViInt32&#160;*Error_Code, ViChar&#160;Error_Message[]);
        /// Purpose
        /// Reads an error code and an error message from the instrument error queue.
        /// Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// </summary>
        /// <param name="Error_Code">
        /// 
        /// Error_Code
        /// ViInt32*
        /// Returns the error code read from the instrument error queue.
        /// 
        /// </param>
        /// <param name="Error_Message">
        /// 
        /// Error_Message
        /// ViChar[]
        /// Returns the error message string read from the instrument error message queue.
        /// You must pass a ViChar array with at least 256 bytes.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int error_query(out int Error_Code, System.Text.StringBuilder Error_Message)
        {
            int pInvokeResult = PInvoke.error_query(this._handle, out Error_Code, Error_Message);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }
        // Change casing : ErrorQuery ==>Not Required
        /// <summary>
        /// 
        /// niRFSG_revision_query
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_revision_query&#160;(ViSession&#160;vi, ViChar[]&#160;instrumentDriverRevision, ViChar[]&#160;firmwareRevision);
        /// Purpose
        /// Returns the revision numbers of the NI-RFSG driver and the instrument firmware.
        /// 
        /// Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Instrument_Driver_Revision">
        /// 
        /// instrumentDriverRevision
        /// ViChar[]
        /// Returns the value of the NIRFSG_ATTR_SPECIFIC_DRIVER_REVISION attribute in the form of a string.
        /// 
        /// You must pass a ViChar array with at least 256 bytes.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Firmware_Revision">
        /// 
        /// firmwareRevision
        /// ViChar[]
        /// Returns the value of the NIRFSG_ATTR_INSTRUMENT_FIRMWARE_REVISION attribute in the form of a string.
        /// 
        /// You must pass a ViChar array with at least 256 bytes.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int revision_query(System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision)
        {
            int pInvokeResult = PInvoke.revision_query(this._handle, Instrument_Driver_Revision, Firmware_Revision);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }
        // Change casing : RevisionQuery ==>Not Required
        /// <summary>
        /// 
        /// niRFSG_QueryArbWaveformCapabilities
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_QueryArbWaveformCapabilities&#160;(ViSession&#160;vi, ViInt32*&#160;maxNumberWaveforms, ViInt32*&#160;waveformQuantum, ViInt32*&#160;minWaveformSize, ViInt32*&#160;maxWaveformSize);
        /// Purpose
        /// Queries and returns the waveform capabilities of the NI-RFSG device.  These capabilities are related to the current device configuration. The NI-RFSG device must be in the Configuration  or the Generation state before calling this function.
        /// 
        /// Supported Devices&#58; NI PXI-5670/5671, NI PXIe-5672/5673/5673E 
        /// 
        /// 
        /// </summary>
        /// <param name="Max_Number_Waveforms">
        /// 
        /// maxNumberWaveforms
        /// ViInt32*
        /// Returns the value of the NIRFSG_ATTR_ARB_MAX_NUMBER_WAVEFORMS attribute. This value is the maximum number of waveforms you can write.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Waveform_Quantum">
        /// 
        /// waveformQuantum
        /// ViInt32*
        /// Returns the value of the NIRFSG_ATTR_ARB_WAVEFORM_QUANTUM attribute. If the waveform quantum is q, then the size of the waveform that you write should be a multiple of q. The units are expressed in samples.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Min_Waveform_Size">
        /// 
        /// minWaveformSize
        /// ViInt32*
        /// Returns the value of the NIRFSG_ATTR_ARB_WAVEFORM_SIZE_MIN attribute. The number of samples of the waveform that you write must be greater than or equal to this value.
        /// 
        /// 
        /// 
        /// </param>
        /// <param name="Max_Waveform_Size">
        /// 
        /// maxWaveformSize
        /// ViInt32*
        /// Returns the value of the NIRFSG_ATTR_ARB_WAVEFORM_SIZE_MAX attribute. The number of samples of the waveform that you write must be less than or equal to this value.
        /// 
        /// 
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int QueryArbWaveformCapabilities(out int Max_Number_Waveforms, out int Waveform_Quantum, out int Min_Waveform_Size, out int Max_Waveform_Size)
        {
            int pInvokeResult = PInvoke.QueryArbWaveformCapabilities(this._handle, out Max_Number_Waveforms, out Waveform_Quantum, out Min_Waveform_Size, out Max_Waveform_Size);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_SelfCal
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_SelfCal&#160;(ViSession&#160;vi);
        /// Purpose
        /// Performs an internal self-calibration on the device. If the calibration is successful, new calibration data and constants are stored in the onboard nonvolatile memory of the module.
        /// 
        /// Supported Devices&#58; NI PXI-5610/5670/5671, NI PXIe-5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int SelfCal()
        {
            int pInvokeResult = PInvoke.SelfCal(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Self-calibrates all configurations within the specified frequency and peak power level limits.
        /// If there is an open session for NI-RFSA for your device, it may remain open but cannot be used while this function runs.
        /// It is recommended that no external signals are present on the RF In port while the calibration is taking place.
        /// For best results, NI recommends that you perform a self-calibration without omitting any steps. However, if certain aspects of performance are less important for your application, you can omit that step for faster execution.
        /// Supported Devices&#58; NI 5644R/5645R/5646R
        /// 
        /// </summary>
        ///<param name = "stepsToOmit">
        /// Specifies which calibration steps to skip during the self-calibration process. The default value is an empty array, which indicates that no calibration steps are omitted.
        /// Defined Values:
        /// NIRFSG_VAL_SELF_CAL_OMIT_NONENo calibration steps are omitted.
        /// NIRFSG_VAL_SELF_CAL_LO_SELF_CALOmits the LO Self Cal step. If you omit this step, the power level of the LO is not adjusted.
        /// NIRFSG_VAL_SELF_CAL_POWER_LEVEL_ACCURACYOmits the Power Level Accuracy step. If you omit this step, the power level accuracy of the device is not adjusted.
        /// NIRFSG_VAL_SELF_CAL_RESIDUAL_LO_POWEROmits the Residual LO Power step. If you omit this step, the Residual LO Power performance is not adjusted.
        /// NIRFSG_VAL_SELF_CAL_IMAGE_SUPPRESSIONOmits the Image Suppression step. If you omit this step, the Residual Sideband Image performance is not adjusted.
        /// Default Value: NIRFSG_VAL_SELF_CAL_OMIT_NONE
        /// 
        ///</param>
        ///<param name = "minFrequency">
        /// Specifies the minimum frequency to calibrate.
        /// 
        ///</param>
        ///<param name = "maxFrequency">
        /// Specifies the maximum frequency to calibrate.
        /// 
        ///</param>
        ///<param name = "minPowerLevel">
        /// Specifies the minimum power level to calibrate.
        /// 
        ///</param>
        ///<param name = "maxPowerLevel">
        /// Specifies the maximum power level to calibrate.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSG_SelfCalibrateRange
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_SelfCalibrateRange&#160;(ViSession&#160;vi,&#160;ViInt64&#160;stepsToOmit,&#160;ViReal64&#160;minFrequency,&#160;ViReal64&#160;maxFrequency,&#160;ViReal64&#160;minPowerLevel,&#160;ViReal64&#160;maxPowerLevel);
        /// Purpose
        /// Self-calibrates all configurations within the specified frequency and peak power level limits.
        /// If there is an open session for NI-RFSA for your device, it may remain open but cannot be used while this function runs.
        /// It is recommended that no external signals are present on the RF In port while the calibration is taking place.
        /// For best results, NI recommends that you perform a self-calibration without omitting any steps. However, if certain aspects of performance are less important for your application, you can omit that step for faster execution.
        /// Supported Devices&#58; NI 5644R/5645R/5646R
        /// 
        ///</returns>
        public int SelfCalibrateRange(long stepsToOmit, double minFrequency, double maxFrequency, double minPowerLevel, double maxPowerLevel)
        {
            int pInvokeResult = PInvoke.SelfCalibrateRange(this._handle, stepsToOmit, minFrequency, maxFrequency, minPowerLevel, maxPowerLevel);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// niRFSG_GetExternalCalibrationLastDateAndTime
        /// 
        /// ViStatus niRFSG_GetExternalCalibrationLastDateAndTime&#160;(ViSession&#160;vi, ViInt32*&#160;year, ViInt32*&#160;month, ViInt32*&#160;day, ViInt32*&#160;hour, ViInt32*&#160;minute, ViInt32*&#160;second);
        /// 
        /// Purpose
        /// 
        /// Returns the date and time of the last successful external calibration. The time returned is 24-hour local time. For example, if the device was calibrated at 2:30 PM, this function returns 14 for the hours parameter and 30 for the minutes parameter. 
        /// 
        /// Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Module">
        /// 
        /// </param>
        /// <param name="Year">
        /// 
        /// 
        /// year
        /// ViInt32*
        /// Specifies the year of the last successful calibration.
        ///  
        /// </param>
        /// <param name="Month">
        /// 
        /// 
        /// month
        /// ViInt32*
        /// Specifies the month of the last successful calibration.
        ///  
        /// </param>
        /// <param name="Day">
        /// 
        /// 
        /// day
        /// ViInt32*
        /// Specifies the day of the last successful calibration.
        ///  
        /// </param>
        /// <param name="Hour">
        /// 
        /// 
        /// hour
        /// ViInt32*
        /// Specifies the hour of the last successful calibration.
        ///  
        /// </param>
        /// <param name="Minute">
        /// 
        /// 
        /// minute
        /// ViInt32*
        /// Specifies the minute of the last successful calibration.
        ///  
        /// </param>
        /// <param name="Second">
        /// 
        /// 
        /// second
        /// ViInt32*
        /// Specifies the second of the last successful calibration.
        ///  
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int GetSelfCalibrationDateAndTime(int Module, out int Year, out int Month, out int Day, out int Hour, out int Minute, out int Second)
        {
            int pInvokeResult = PInvoke.GetSelfCalibrationDateAndTime(this._handle, Module, out Year, out Month, out Day, out Hour, out Minute, out Second);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// niRFSG_GetExternalCalibrationLastDateAndTime
        /// 
        /// ViStatus niRFSG_GetExternalCalibrationLastDateAndTime&#160;(ViSession&#160;vi, ViInt32*&#160;year, ViInt32*&#160;month, ViInt32*&#160;day, ViInt32*&#160;hour, ViInt32*&#160;minute, ViInt32*&#160;second);
        /// 
        /// Purpose
        /// 
        /// Returns the date and time of the last successful external calibration. The time returned is 24-hour (military) local time; for example, if the device was calibrated at 2:30 PM, this function returns 14 for the hours parameter and 30 for the minutes parameter. 
        /// 
        /// Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// 
        /// </summary>
        /// <param name="Year">
        /// 
        /// 
        /// year
        /// ViInt32*
        /// Specifies the year of the last successful calibration.
        ///  
        /// </param>
        /// <param name="Month">
        /// 
        /// 
        /// month
        /// ViInt32*
        /// Specifies the month of the last successful calibration.
        ///  
        /// </param>
        /// <param name="Day">
        /// 
        /// 
        /// day
        /// ViInt32*
        /// Specifies the day of the last successful calibration.
        ///  
        /// </param>
        /// <param name="Hour">
        /// 
        /// 
        /// hour
        /// ViInt32*
        /// Specifies the hour of the last successful calibration.
        ///  
        /// </param>
        /// <param name="Minute">
        /// 
        /// 
        /// minute
        /// ViInt32*
        /// Specifies the minute of the last successful calibration.
        ///  
        /// </param>
        /// <param name="Second">
        /// 
        /// 
        /// second
        /// ViInt32*
        /// Specifies the second of the last successful calibration.
        ///  
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int GetExternalCalibrationLastDateAndTime(out int Year, out int Month, out int Day, out int Hour, out int Minute, out int Second)
        {
            int pInvokeResult = PInvoke.GetExternalCalibrationLastDateAndTime(this._handle, out Year, out Month, out Day, out Hour, out Minute, out Second);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// 
        /// 
        /// niRFSG_ChangeExternalCalibrationPassword
        /// 
        /// ViStatus niRFSG_ChangeExternalCalibrationPassword&#160;(ViSession&#160;vi, ViConstString&#160;Password, ViConstString&#160;newPassword);
        /// 
        /// Purpose
        /// 
        /// Changes the external calibration password of the device.
        /// 
        /// Supported Devices: NI PXIe-5611/5653/5673/5673E
        /// 
        /// 
        /// 
        /// </summary>
        /// <param name="Old_Password">
        /// 
        /// 
        /// Password
        /// ViConstString
        /// Specifies the old (current) external calibration password.  This password is case sensitive.
        ///  
        /// </param>
        /// <param name="New_Password">
        /// 
        /// 
        /// newPassword
        /// ViConstString
        /// Specifies the new (desired) external calibration password.
        ///  
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation.  The status code  either indicates success or describes an error or warning condition.  Examine the status code from each call to an instrument driver function to determine if an error occurred.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// ValueMeaning
        /// 0Success
        /// Positive ValuesWarnings
        /// Negative ValuesErrors
        /// 
        /// </returns>
        public int ChangeExternalCalibrationPassword(string Old_Password, string New_Password)
        {
            int pInvokeResult = PInvoke.ChangeExternalCalibrationPassword(this._handle, Old_Password, New_Password);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Aborts any signal generation in progress and destroys the instrument driver session.
        /// Note&#160;&#160;After calling this function, you cannot use NI-RFSG again until you call the niRFSG_init function or the  niRFSG_InitWithOptions function.
        /// Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        /// </summary>
        ///
        ///<returns>
        /// 
        ///niRFSG_close
        /// C Function Prototype
        /// ViStatus&#160;niRFSG_close&#160;(ViSession&#160;vi);
        /// Purpose
        /// Aborts any signal generation in progress and destroys the instrument driver session.
        /// Note&#160;&#160;After calling this function, you cannot use NI-RFSG again until you call the niRFSG_init function or the  niRFSG_InitWithOptions function.
        /// Supported Devices: NI PXI/PXIe-5650/5651/5652, NI PXI-5610/5670/5671, NI PXIe-5611/5653/5672/5673/5673E
        /// 
        ///</returns>
        public int close()
        {
            return PInvoke.TestForError(this._handle, this.Dispose(true));
        }
        /// <summary>
        /// 
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            System.GC.SuppressFinalize(this);
        }

        private int Dispose(bool disposing)
        {
            int pInvokeResult = 0;
            if ((this._disposed == false))
            {
                // Returns any error RFSG returns, but does not throw exception
                pInvokeResult = PInvoke.close(this._handle);
                this._handle = new System.Runtime.InteropServices.HandleRef(null, System.IntPtr.Zero);
            }
            this._disposed = true;
            return pInvokeResult;
        }


        /// <summary>
        ///Specifies the name of the list to be active.  When you get or set    an attribute and it is in the configuration list configuration,    the attribute is set to or read from the active list step of the    active configuration list.   If the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST attribute is set    to &quot;&quot; (empty string), no list is active. 
        /// 
        /// </summary>
        public int SetActiveConfigurationList(string channel, string value)
        {
            return SetString(niRFSGProperties.ActiveConfigurationList, channel, value);
        }

        /// <summary>
        ///Specifies the name of the list to be active.  When you get or set    an attribute and it is in the configuration list configuration,    the attribute is set to or read from the active list step of the    active configuration list.   If the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST attribute is set    to &quot;&quot; (empty string), no list is active. 
        /// 
        /// </summary>
        public int GetActiveConfigurationList(string channel, out string value)
        {
            return GetString(niRFSGProperties.ActiveConfigurationList, channel, out value);
        }

        /// <summary>
        ///Specifies the step in the configuration list for RF list mode    that you want to make active for configuration or initiation. 
        /// 
        /// </summary>
        public int SetActiveConfigurationListStep(string channel, int value)
        {
            return SetInt32(niRFSGProperties.ActiveConfigurationListStep, channel, value);
        }

        /// <summary>
        ///Specifies the step in the configuration list for RF list mode    that you want to make active for configuration or initiation. 
        /// 
        /// </summary>
        public int GetActiveConfigurationListStep(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ActiveConfigurationListStep, channel, out value);
        }

        /// <summary>
        ///Allows you to set the frequency and power values beyond the limits of the   NI-RFSG device specifications.  This allows a wider frequency and power   range, but accuracy cannot be guaranteed, and results may vary by unit. To   set this attribute, the NI-RFSG device must be in the Configuration state.   
        /// 
        /// </summary>
        public int SetAllowOutOfSpecificationUserSettings(string channel, int value)
        {
            return SetInt32(niRFSGProperties.AllowOutOfSpecificationUserSettings, channel, value);
        }

        /// <summary>
        ///Allows you to set the frequency and power values beyond the limits of the   NI-RFSG device specifications.  This allows a wider frequency and power   range, but accuracy cannot be guaranteed, and results may vary by unit. To   set this attribute, the NI-RFSG device must be in the Configuration state.   
        /// 
        /// </summary>
        public int GetAllowOutOfSpecificationUserSettings(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.AllowOutOfSpecificationUserSettings, channel, out value);
        }

        /// <summary>
        ///Specifies the frequency deviation to use in frequency modulation. 
        /// 
        /// </summary>
        public int SetAnalogModulationFmDeviation(string channel, double value)
        {
            return SetDouble(niRFSGProperties.AnalogModulationFmDeviation, channel, value);
        }

        /// <summary>
        ///>Specifies the frequency deviation to use in frequency modulation. 
        /// 
        /// </summary>
        public int GetAnalogModulationFmDeviation(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.AnalogModulationFmDeviation, channel, out value);
        }

        /// <summary>
        ///Specifies the deviation to use in phase modulation. 
        /// 
        /// </summary>
        public int SetAnalogModulationPmDeviation(string channel, double value)
        {
            return SetDouble(niRFSGProperties.AnalogModulationPmDeviation, channel, value);
        }

        /// <summary>
        ///Specifies the deviation to use in phase modulation. 
        /// 
        /// </summary>
        public int GetAnalogModulationPmDeviation(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.AnalogModulationPmDeviation, channel, out value);
        }

        /// <summary>
        ///Specifies the analog modulation format to use. 
        /// 
        /// </summary>
        public int SetAnalogModulationType(string channel, int value)
        {
            return SetInt32(niRFSGProperties.AnalogModulationType, channel, value);
        }
        /// <summary>
        ///Specifies the analog modulation format to use. 
        /// 
        /// </summary>
        public int GetAnalogModulationType(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.AnalogModulationType, channel, out value);
        }

        /// <summary>
        ///Specifies the frequency of the waveform to use as the message signal in   analog modulation. Units: hertz (Hz) 
        /// 
        /// </summary>
        public int SetAnalogModulationWaveformFrequency(string channel, double value)
        {
            return SetDouble(niRFSGProperties.AnalogModulationWaveformFrequency, channel, value);
        }

        /// <summary>
        ///Specifies the frequency of the waveform to use as the message signal in   analog modulation. Units: hertz (Hz) 
        /// 
        /// </summary>
        public int GetAnalogModulationWaveformFrequency(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.AnalogModulationWaveformFrequency, channel, out value);
        }

        /// <summary>
        ///Specifies the type of waveform to use as the message signal for analog   modulation. 
        /// 
        /// </summary>
        public int SetAnalogModulationWaveformType(string channel, int value)
        {
            return SetInt32(niRFSGProperties.AnalogModulationWaveformType, channel, value);
        }

        /// <summary>
        ///Specifies the type of waveform to use as the message signal for analog   modulation. 
        /// 
        /// </summary>
        public int GetAnalogModulationWaveformType(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.AnalogModulationWaveformType, channel, out value);
        }

        /// <summary>
        ///Indicates the carrier frequency generated by the arbitrary waveform   generator (AWG) module. The specified carrier frequency is related  
        /// 
        /// </summary>
        public int SetArbCarrierFrequency(string channel, double value)
        {
            return SetDouble(niRFSGProperties.ArbCarrierFrequency, channel, value);
        }

        /// <summary>
        ///Indicates the carrier frequency generated by the arbitrary waveform   generator (AWG) module. The specified carrier frequency is related  
        /// 
        /// </summary>
        public int GetArbCarrierFrequency(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.ArbCarrierFrequency, channel, out value);
        }

        /// <summary>
        ///Alpha value to use when calculating the pulse-shaping filter coefficients.   This attribute is only used when the NIRFSG_ATTR_ARB_FILTER_TYPE   attribute is set to NIRFSG_VAL_ARB_RAISED_COSINE and with signal   generators that support onboard signal processing (OSP).   NI-RFSG returns an error if you use this attribute with a device   that does not support OSP. 
        /// 
        /// </summary>
        public int SetArbFilterRaisedCosineAlpha(string channel, double value)
        {
            return SetDouble(niRFSGProperties.ArbFilterRaisedCosineAlpha, channel, value);
        }

        /// <summary>
        ///Alpha value to use when calculating the pulse-shaping filter coefficients.   This attribute is only used when the NIRFSG_ATTR_ARB_FILTER_TYPE   attribute is set to NIRFSG_VAL_ARB_RAISED_COSINE and with signal   generators that support onboard signal processing (OSP).   NI-RFSG returns an error if you use this attribute with a device   that does not support OSP. 
        /// 
        /// </summary>
        public int GetArbFilterRaisedCosineAlpha(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.ArbFilterRaisedCosineAlpha, channel, out value);
        }

        /// <summary>
        ///Alpha value to use when calculating the pulse-shaping FIR filter coefficients.   This attribute can only used when the NIRFSG_ATTR_ARB_FILTER_TYPE   attribute is set to NIRFSG_VAL_ARB_ROOT_RAISED_COSINE and with signal   generators that support onboard signal processing (OSP).   NI-RFSG returns an error if you use this property with a device   that does not support OSP. 
        /// 
        /// </summary>
        public int SetArbFilterRootRaisedCosineAlpha(string channel, double value)
        {
            return SetDouble(niRFSGProperties.ArbFilterRootRaisedCosineAlpha, channel, value);
        }

        /// <summary>
        ///Alpha value to use when calculating the pulse-shaping FIR filter coefficients.   This attribute can only used when the NIRFSG_ATTR_ARB_FILTER_TYPE   attribute is set to NIRFSG_VAL_ARB_ROOT_RAISED_COSINE and with signal   generators that support onboard signal processing (OSP).   NI-RFSG returns an error if you use this property with a device   that does not support OSP. 
        /// 
        /// </summary>
        public int GetArbFilterRootRaisedCosineAlpha(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.ArbFilterRootRaisedCosineAlpha, channel, out value);
        }

        /// <summary>
        ///Pulse-shaping filter type for the FIR filter. This attribute can be used   only with signal generators that support onboard signal processing (OSP).   NI-RFSG returns an error if you use this attribute with a device that   does not support OSP. 
        /// 
        /// </summary>
        public int SetArbFilterType(string channel, int value)
        {
            return SetInt32(niRFSGProperties.ArbFilterType, channel, value);
        }

        /// <summary>
        ///Pulse-shaping filter type for the FIR filter. This attribute can be used   only with signal generators that support onboard signal processing (OSP).   NI-RFSG returns an error if you use this attribute with a device that   does not support OSP. 
        /// 
        /// </summary>
        public int GetArbFilterType(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ArbFilterType, channel, out value);
        }

        /// <summary>
        ///Returns the maximum number of waveforms the device can hold in memory. 
        /// 
        /// </summary>
        public int GetArbMaxNumberWaveforms(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ArbMaxNumberWaveforms, channel, out value);
        }

        /// <summary>
        ///Specifies the Sample clock mode on the NI 5421/5441/5442/5450 AWG module.   To set this attribute, the device must be in the Configuration state. 
        ///   NOTE: Using the high resolution clock may result in increased phase noise. /n 
        /// 
        /// </summary>
        public int SetArbOnboardSampleClockMode(string channel, int value)
        {
            return SetInt32(niRFSGProperties.ArbOnboardSampleClockMode, channel, value);
        }

        /// <summary>
        ///Specifies the Sample clock mode on the NI 5421/5441/5442/5450 AWG module.   To set this attribute, the device must be in the Configuration state. 
        ///   NOTE: Using the high resolution clock may result in increased phase noise. /n 
        /// 
        /// </summary>
        public int GetArbOnboardSampleClockMode(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ArbOnboardSampleClockMode, channel, out value);
        }

        /// <summary>
        ///Specifies the oscillator phase digital-to-analog converter (DAC) value    on the arbitrary waveform generator (AWG).  Use this attribute to reduce    the trigger jitter when synchronizing multiple devices with NI-TClk.    This attribute can also help maintain synchronization repeatability    by writing a previous measurement's phase DAC value to the current session.    This attribute is applicable only when using the    NIRFSG_ATTR_ARB_SAMPLE_CLOCK_SOURCE attribute set to NIRFSG_VAL_CLK_IN_STR. /n   
        /// 
        /// </summary>
        public int SetArbOscillatorPhaseDacValue(string channel, int value)
        {
            return SetInt32(niRFSGProperties.ArbOscillatorPhaseDacValue, channel, value);
        }

        /// <summary>
        ///Specifies the oscillator phase digital-to-analog converter (DAC) value    on the arbitrary waveform generator (AWG).  Use this attribute to reduce    the trigger jitter when synchronizing multiple devices with NI-TClk.    This attribute can also help maintain synchronization repeatability    by writing a previous measurement's phase DAC value to the current session.    This attribute is applicable only when using the    NIRFSG_ATTR_ARB_SAMPLE_CLOCK_SOURCE attribute set to NIRFSG_VAL_CLK_IN_STR. /n   
        /// 
        /// </summary>
        public int GetArbOscillatorPhaseDacValue(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ArbOscillatorPhaseDacValue, channel, out value);
        }

        /// <summary>
        ///Indicates the average output power from the NI 5421/5441/5442/5450   AWG module. If an arbitrary waveform is being generated, this   attribute specifies either the average power or the peak power of the   signal, depending on the NIRFSG_ATTR_POWER_LEVEL_TYPE   attribute setting. 
        ///    Units: dBm 
        /// 
        /// </summary>
        public int GetArbPower(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.ArbPower, channel, out value);
        }

        /// <summary>
        ///Specifies the AWG prefilter gain. The prefilter gain is   applied to the waveform data before any other signal processing.   Reduce this value to prevent overflow in the AWG interpolation filters.   Other gains on the NI-RFSG device are automatically adjusted to   compensate for nonunity AWG prefilter gain. The NI PXI-5671 and   the NI PXIe-5672 must be in the Configuration state to use this attribute.   However, the NI PXIe-5673/5673E can be in either the Configuration   or the Generation state to use this attribute. 
        ///   On the NI PXI-5671, this attribute applies only when the   NIRFSG_ATTR_IQ_RATE attribute is set to a value   less than or equal to 8.33 MS/s. 
        ///   Units: dB 
        /// 
        /// </summary>
        public int SetArbPreFilterGain(string channel, double value)
        {
            return SetDouble(niRFSGProperties.ArbPreFilterGain, channel, value);
        }

        /// <summary>
        ///Specifies the AWG prefilter gain. The prefilter gain is   applied to the waveform data before any other signal processing.   Reduce this value to prevent overflow in the AWG interpolation filters.   Other gains on the NI-RFSG device are automatically adjusted to   compensate for nonunity AWG prefilter gain. The NI PXI-5671 and   the NI PXIe-5672 must be in the Configuration state to use this attribute.   However, the NI PXIe-5673/5673E can be in either the Configuration   or the Generation state to use this attribute. 
        ///   On the NI PXI-5671, this attribute applies only when the   NIRFSG_ATTR_IQ_RATE attribute is set to a value   less than or equal to 8.33 MS/s. 
        ///   Units: dB 
        /// 
        /// </summary>
        public int GetArbPreFilterGain(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.ArbPreFilterGain, channel, out value);
        }

        /// <summary>
        ///Returns the rate of the Sample clock on the AWG module. 
        ///   Units: hertz (Hz) 
        /// 
        /// </summary>
        public int GetArbSampleClockRate(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.ArbSampleClockRate, channel, out value);
        }

        /// <summary>
        ///Specifies the Sample clock source for the NI 5421/5441/5442/5450/5451   AWG module. To set this attribute, the NI-RFSG device must   be in the Configuration state.
        /// 
        /// </summary>
        public int SetArbSampleClockSource(string channel, string value)
        {
            return SetString(niRFSGProperties.ArbSampleClockSource, channel, value);
        }

        /// <summary>
        ///Specifies the Sample clock source for the NI 5421/5441/5442/5450/5451   AWG module. To set this attribute, the NI-RFSG device must   be in the Configuration state.
        /// 
        /// </summary>
        public int GetArbSampleClockSource(string channel, out string value)
        {
            return GetString(niRFSGProperties.ArbSampleClockSource, channel, out value);
        }

        /// <summary>
        ///Indicates the AWG module temperature in degrees Celsius. 
        ///   Units: degrees Celsius (°C) 
        /// 
        /// </summary>
        public int GetArbTemperature(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.ArbTemperature, channel, out value);
        }

        /// <summary>
        ///Returns the waveform quantum for the device. The number of samples   in a waveform must be an integer multiple of the waveform quantum.   The other restrictions on the length of the waveform are the minimum and    maximum arbitrary waveform sizes. On the NI 5671/5672, the value of this   attribute depends on the I/Q rate. Set the NIRFSG_ATTR_IQ_RATE attribute   before reading this attribute. 
        /// 
        /// </summary>
        public int GetArbWaveformQuantum(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ArbWaveformQuantum, channel, out value);
        }

        /// <summary>
        ///Returns the repeat count of a waveform when you set the NIRFSG_ATTR_GENERATION_MODE attribute to NIRFSG_VAL_ARB_WAVEFORM and the repeat count is finite.
        ///   To set this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetArbWaveformRepeatCount(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ArbWaveformRepeatCount, channel, out value);
        }

        /// <summary>
        ///Returns the repetition mode of a waveform when you set the NIRFSG_ATTR_GENERATION_MODE attribute to NIRFSG_VAL_ARB_WAVEFORM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetAttrArbWaveformRepeatCountIsFinite(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.ArbWaveformRepeatCountIsFinite, channel, out value);
        }

        /// <summary>
        ///Returns the size of the largest waveform that is allowed. To read   this attribute, the NI-RFSG device must be in the Configuration state.
        ///   For the NI 5671/5672, the value of this attribute depends on the I/Q rate.   Set the I/Q rate before reading this attribute.  For the NI 5673/5673E,   the maximum waveform size is reduced to account for the amount of device   memory currently used. 
        ///   Note: Not all onboard memory can be used for waveform storage. A portion   of onboard memory stores scripts that specify how the waveforms are   generated.  These scripts typically require less than 1 KB of onboard   memory. 
        /// 
        /// </summary>
        public int GetArbWaveformSizeMax(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ArbWaveformSizeMax, channel, out value);
        }

        /// <summary>
        ///Returns the size of the smallest waveform that is allowed. For the   NI 5671/5672, the value of this attribute depends on the I/Q rate.   Set the NIRFSG_ATTR_IQ_RATE attribute before reading this attribute.
        ///   Units: Samples 
        /// 
        /// </summary>
        public int GetArbWaveformSizeMin(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ArbWaveformSizeMin, channel, out value);
        }

        /// <summary>
        ///Specifies how much to scale the data before writing it with the   niRFSG_WriteArbWaveform function. The resulting waveform must be   smaller than 1.0 in complex magnitude. This attribute is supported only   if the NIRFSG_ATTR_POWER_LEVEL_TYPE attribute is set to   NIRFSG_VAL_PEAK_POWER. 
        /// 
        /// </summary>
        public int SetArbWaveformSoftwareScalingFactor(string channel, double value)
        {
            return SetDouble(niRFSGProperties.ArbWaveformSoftwareScalingFactor, channel, value);
        }

        /// <summary>
        ///Specifies how much to scale the data before writing it with the   niRFSG_WriteArbWaveform function. The resulting waveform must be   smaller than 1.0 in complex magnitude. This attribute is supported only   if the NIRFSG_ATTR_POWER_LEVEL_TYPE attribute is set to   NIRFSG_VAL_PEAK_POWER. 
        /// 
        /// </summary>
        public int GetArbWaveformSoftwareScalingFactor(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.ArbWaveformSoftwareScalingFactor, channel, out value);
        }

        /// <summary>
        ///Specifies the repeat count of a waveform when you set the NIRFSG_ATTR_GENERATION_MODE attribute to NIRFSG_VAL_ARB_WAVEFORM and the repeat count is finite.
        ///   To set this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetArbWaveformRepeatCount(string channel, int value)
        {
            return SetInt32(niRFSGProperties.ArbWaveformRepeatCount, channel, value);
        }

        /// <summary>
        ///Specifies the repetition mode of a waveform when you set the NIRFSG_ATTR_GENERATION_MODE attribute to NIRFSG_VAL_ARB_WAVEFORM.
        ///   To set this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetArbWaveformRepeatCountIsFinite(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.ArbWaveformRepeatCountIsFinite, channel, value);
        }

        /// <summary>
        ///Specifies whether attenuator hold is enabled. While this attribute is   set to VI_TRUE, changing the power level causes NI-RFSG to scale the   digital data sent to the AWG instead of adjusting the attenuators.   Changing power levels in this manner allows the device to increase or   decrease the power level in more accurate increments, but it may affect   signal-to-noise ratios (noise density).
        ///   Setting this attribute to VI_TRUE limits the power levels that can be   attained. With attenuator hold enabled, the power level must satisfy the   following conditions:
        ///   - Power level &lt;= the maximum power level set with the   NIRFSG_ATTR_ATTENUATOR_HOLD_MAX_POWER attribute 
        ///   - Power level &gt;= (the maximum power level set with  the   NIRFSG_ATTR_ATTENUATOR_HOLD_MAX_POWER attribute -70 dB)
        ///   - Power level &gt;= -145 dBm
        ///   To set this attribute, the NI-RFSG device must be in the Configuration   state.
        /// 
        /// </summary>
        public int SetAttenuatorHoldEnabled(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.AttenuatorHoldEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether attenuator hold is enabled. While this attribute is   set to VI_TRUE, changing the power level causes NI-RFSG to scale the   digital data sent to the AWG instead of adjusting the attenuators.   Changing power levels in this manner allows the device to increase or   decrease the power level in more accurate increments, but it may affect   signal-to-noise ratios (noise density).
        ///   Setting this attribute to VI_TRUE limits the power levels that can be   attained. With attenuator hold enabled, the power level must satisfy the   following conditions:
        ///   - Power level &lt;= the maximum power level set with the   NIRFSG_ATTR_ATTENUATOR_HOLD_MAX_POWER attribute 
        ///   - Power level &gt;= (the maximum power level set with  the   NIRFSG_ATTR_ATTENUATOR_HOLD_MAX_POWER attribute -70 dB)
        ///   - Power level &gt;= -145 dBm
        ///   To set this attribute, the NI-RFSG device must be in the Configuration   state.
        /// 
        /// </summary>
        public int GetAttenuatorHoldEnabled(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.AttenuatorHoldEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies the maximum power level of the RF output signal whenthe   NIRFSG_ATTR_ATTENUATOR_HOLD_ENABLED attribute is set to VI_TRUE.
        ///   To set this attribute, the NI-RFSG device must be in the Configuration   state.
        ///   Units: dBm 
        /// 
        /// </summary>
        public int SetAttenuatorHoldMaxPower(string channel, double value)
        {
            return SetDouble(niRFSGProperties.AttenuatorHoldMaxPower, channel, value);
        }

        /// <summary>
        ///Specifies the maximum power level of the RF output signal whenthe   NIRFSG_ATTR_ATTENUATOR_HOLD_ENABLED attribute is set to VI_TRUE.
        ///   To set this attribute, the NI-RFSG device must be in the Configuration   state.
        ///   Units: dBm 
        /// 
        /// </summary>
        public int GetAttenuatorHoldMaxPower(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.AttenuatorHoldMaxPower, channel, out value);
        }

        /// <summary>
        ///Enables or disables automatic thermal correction. When enabled, settings   changes cause NI-RFSG to check whether the device temperature has changed   and adjustd the settings as needed.When disabled, you must explicitly call   the niRFSG_PerformThermalCorrection function to adjust the device for   temperature changes. 
        /// 
        /// </summary>
        public int GetAutomaticThermalCorrection(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.AutomaticThermalCorrection, channel, out value);
        }

        /// <summary>
        ///Specifies whether to cache the value of attributes. When caching is   enabled, NI-RFSG tracks the current NI-RFSG device settings and avoids   sending redundant commands to the device. 
        ///   NI-RFSG can always cache or never cache particular attributes, regardless   of the setting of this attribute.
        /// 
        /// </summary>
        public int SetCache(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.Cache, channel, value);
        }

        /// <summary>
        ///Specifies whether to cache the value of attributes. When caching is   enabled, NI-RFSG tracks the current NI-RFSG device settings and avoids   sending redundant commands to the device. 
        ///   NI-RFSG can always cache or never cache particular attributes, regardless   of the setting of this attribute.
        /// 
        /// </summary>
        public int GetCache(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.Cache, channel, out value);
        }

        ///<summary>
        ///
        /// </summary>
        public int GetCompensateForFilterGroupDelay(string channel, out Boolean value)
        {
            return GetBoolean(niRFSGProperties.CompensateForFilterGroupDelay, channel, out value);
        }
        ///<summary>
        ///
        /// </summary>
        public int SetCompensateForFilterGroupDelay(string channel, Boolean value)
        {
            return SetBoolean(niRFSGProperties.CompensateForFilterGroupDelay, channel, value);
        }

        /// <summary>
        ///Specifies the Configuration List step that is currently programmed to the hardware.    This attribute can be read only when a Configuration List is running. 
        /// 
        /// </summary>
        public int GetConfigurationListStepInProgress(string channel, out long value)
        {
            return GetLong(niRFSGProperties.ConfigurationListStepInProgress, channel, out value);
        }

        /// <summary>
        ///Returns the fully-qualified signal name as a string. 
        /// 
        /// </summary>
        public int GetConfigurationListStepTriggerTerminalName(string channel, out string value)
        {
            return GetString(niRFSGProperties.ConfigurationListStepTriggerTerminalName, channel, out value);
        }

        /// <summary>
        ///Specifies the type of trigger to use as the Configuration List Step Trigger.    To set this attribute, the NI-RFSG device must be in the    Configuration state. 
        /// 
        /// </summary>
        public int SetConfigurationListStepTriggerType(string channel, int value)
        {
            return SetInt32(niRFSGProperties.ConfigurationListStepTriggerType, channel, value);
        }

        /// <summary>
        ///Specifies the type of trigger to use as the Configuration List Step Trigger.    To set this attribute, the NI-RFSG device must be in the    Configuration state. 
        /// 
        /// </summary>
        public int GetConfigurationListStepTriggerType(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ConfigurationListStepTriggerType, channel, out value);
        }

        /// <summary>
        ///Indicates the number of samples download to onboard memory at one time. This   attribute is useful when the total data to be transferred to onboard   memory is large. 
        ///   Units: Samples 
        /// 
        /// </summary>
        public int SetDataTransferBlockSize(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DataTransferBlockSize, channel, value);
        }

        /// <summary>
        ///Indicates the number of samples download to onboard memory at one time. This   attribute is useful when the total data to be transferred to onboard   memory is large. 
        ///   Units: Samples 
        /// 
        /// </summary>
        public int GetDataTransferBlockSize(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DataTransferBlockSize, channel, out value);
        }

        /// <summary>
        ///Specifies the maximum amount of bus bandwidth to use for data transfers. 
        /// 
        /// </summary>
        public int SetDataTransferMaximumBandwidth(string channel, double value)
        {
            return SetDouble(niRFSGProperties.DataTransferMaximumBandwidth, channel, value);
        }

        /// <summary>
        ///Specifies the maximum amount of bus bandwidth to use for data transfers. 
        /// 
        /// </summary>
        public int GetDataTransferMaximumBandwidth(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.DataTransferMaximumBandwidth, channel, out value);
        }

        /// <summary>
        ///Specifies the maximum number of concurrent PCI Express read requests the RF signal   
        /// 
        /// </summary>
        public int SetDataTransferMaximumInFlightReads(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DataTransferMaximumInFlightReads, channel, value);
        }

        /// <summary>
        ///Specifies the maximum number of concurrent PCI Express read requests the RF signal   
        /// 
        /// </summary>
        public int GetDataTransferMaximumInFlightReads(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DataTransferMaximumInFlightReads, channel, out value);
        }

        /// <summary>
        ///Specifies the preferred size of the data field in a PCI Express read request packet. 
        /// 
        /// </summary>
        public int SetDataTransferPreferredPacketSize(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DataTransferPreferredPacketSize, channel, value);
        }

        /// <summary>
        ///Specifies the preferred size of the data field in a PCI Express read request packet. 
        /// 
        /// </summary>
        public int GetDataTransferPreferredPacketSize(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DataTransferPreferredPacketSize, channel, out value);
        }

        /// <summary>
        ///Returns the device temperature. If the NI-RFSG session is controlling   multiple devices, this attribute returns the temperature of the primary   NI RF device.  The NI-RFSG session is opened using the primary RF device name. 
        ///   Serial signals between the sensor and the system control unit could   modulate the signal being generated, thus causing phase spurs. After the device   thoroughly warms up, its temperature varies only slightly (less than 1 degree Celsius)   and slowly, and it is not necessary to constantly poll this temperature sensor.   Refer to the thermal management topic appropriate to your device in the   NI RF Signal Generators Help for more information about device temperature. 
        ///   Units: desgrees Celsius (°C) 
        /// 
        /// </summary>
        public int GetDeviceTemperature(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.DeviceTemperature, channel, out value);
        }

        /// <summary>
        ///Specifies the active edge for the Configuration List Step    trigger.  This attribute is valid only when the    NIRFSG_ATTR_CONFIGURATION_LIST_STEP_TRIGGER_TYPE attribute    is set to NIRFSG_VAL_DIGITAL_EDGE. To set this property, the NI-RFSG    device must be in the Configuration state. 
        /// 
        /// </summary>
        public int SetDigitalEdgeConfigurationListStepTriggerEdge(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DigitalEdgeConfigurationListStepTriggerEdge, channel, value);
        }

        /// <summary>
        ///Specifies the active edge for the Configuration List Step    trigger.  This attribute is valid only when the    NIRFSG_ATTR_CONFIGURATION_LIST_STEP_TRIGGER_TYPE attribute    is set to NIRFSG_VAL_DIGITAL_EDGE. To set this property, the NI-RFSG    device must be in the Configuration state. 
        /// 
        /// </summary>
        public int GetDigitalEdgeConfigurationListStepTriggerEdge(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DigitalEdgeConfigurationListStepTriggerEdge, channel, out value);
        }

        /// <summary>
        ///Specifies the source terminal for the Configuration List Step trigger.   This attribute is valid only when the   NIRFSG_ATTR_CONFIGURATION_LIST_STEP_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_EDGE. 
        /// 
        /// </summary>
        public int SetDigitalEdgeConfigurationListStepTriggerSource(string channel, string value)
        {
            return SetString(niRFSGProperties.DigitalEdgeConfigurationListStepTriggerSource, channel, value);
        }

        /// <summary>
        ///Specifies the source terminal for the Configuration List Step trigger.   This attribute is valid only when the   NIRFSG_ATTR_CONFIGURATION_LIST_STEP_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_EDGE. 
        /// 
        /// </summary>
        public int GetDigitalEdgeConfigurationListStepTriggerSource(string channel, out string value)
        {
            return GetString(niRFSGProperties.DigitalEdgeConfigurationListStepTriggerSource, channel, out value);
        }

        /// <summary>
        ///Specifies the active edge for the script trigger. This attribute is used   when NIRFSG_ATTR_SCRIPT_TRIGGER_TYPE is set to NIRFSG_VAL_DIGITAL_EDGE. To   set the NIRFSG_ATTR_DIGITAL_EDGE_SCRIPT_TRIGGER_EDGE attribute,   the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetDigitalEdgeScriptTriggerEdge(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DigitalEdgeScriptTriggerEdge, channel, value);
        }

        /// <summary>
        ///Specifies the active edge for the script trigger. This attribute is used   when NIRFSG_ATTR_SCRIPT_TRIGGER_TYPE is set to NIRFSG_VAL_DIGITAL_EDGE. To   set the NIRFSG_ATTR_DIGITAL_EDGE_SCRIPT_TRIGGER_EDGE attribute,   the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int GetDigitalEdgeScriptTriggerEdge(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DigitalEdgeScriptTriggerEdge, channel, out value);
        }

        /// <summary>
        ///Specifies the source terminal for the Script trigger. This attribute is   used when the NIRFSG_ATTR_SCRIPT_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_EDGE. This attribute is not case-sensitive. To set this   attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetDigitalEdgeScriptTriggerSource(string channel, string value)
        {
            return SetString(niRFSGProperties.DigitalEdgeScriptTriggerSource, channel, value);
        }

        /// <summary>
        ///Specifies the source terminal for the Script trigger. This attribute is   used when the NIRFSG_ATTR_SCRIPT_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_EDGE. This attribute is not case-sensitive. To set this   attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int GetDigitalEdgeScriptTriggerSource(string channel, out string value)
        {
            return GetString(niRFSGProperties.DigitalEdgeScriptTriggerSource, channel, out value);
        }

        /// <summary>
        ///Specifies the active edge for the start trigger. This attribute is used   when the NIRFSG_ATTR_START_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_EDGE. To set the NIRFSG_ATTR_DIGITAL_EDGE_START_TRIGGER_EDGE   attribute, the NI-RFSG device must be in the Configuration state. 
        /// 
        /// </summary>
        public int SetDigitalEdgeStartTriggerEdge(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DigitalEdgeStartTriggerEdge, channel, value);
        }

        /// <summary>
        ///Specifies the active edge for the start trigger. This attribute is used   when the NIRFSG_ATTR_START_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_EDGE. To set the NIRFSG_ATTR_DIGITAL_EDGE_START_TRIGGER_EDGE   attribute, the NI-RFSG device must be in the Configuration state. 
        /// 
        /// </summary>
        public int GetDigitalEdgeStartTriggerEdge(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DigitalEdgeStartTriggerEdge, channel, out value);
        }

        /// <summary>
        ///Specifies the source terminal for the start trigger. This attribute is   used when the NIRFSG_ATTR_START_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_EDGE. This attribute is not case-sensitive. To set the   NIRFSG_ATTR_DIGITAL_EDGE_START_TRIGGER_SOURCE attribute, the NI-RFSG device   must be in the Configuration state.
        /// 
        /// </summary>
        public int SetDigitalEdgeStartTriggerSource(string channel, string value)
        {
            return SetString(niRFSGProperties.DigitalEdgeStartTriggerSource, channel, value);
        }

        /// <summary>
        ///Specifies the source terminal for the start trigger. This attribute is   used when the NIRFSG_ATTR_START_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_EDGE. This attribute is not case-sensitive. To set the   NIRFSG_ATTR_DIGITAL_EDGE_START_TRIGGER_SOURCE attribute, the NI-RFSG device   must be in the Configuration state.
        /// 
        /// </summary>
        public int GetDigitalEdgeStartTriggerSource(string channel, out string value)
        {
            return GetString(niRFSGProperties.DigitalEdgeStartTriggerSource, channel, out value);
        }

        /// <summary>
        ///When this attribute is enabled, NI-RFSG equalizes the waveform   data to correct for variations in the response of the NI-RFSG device.   Enabling digital equalization improves   the modulation error rates (MER) and error vector magnitude (EVM) for   signals with large bandwidths (> 500 kHz). On the NI 5670/5671, this   equalization is performed in the software so that tuning time is   increased. On the NI 5672, this is performed in the hardware so that it   has no performance penalties.
        ///   This attribute only applies when the NIRFSG_ATTR_GENERATION_MODE attribute   is set to NIRFSG_VAL_ARB_WAVEFORM or NIRFSG_VAL_SCRIPT. To set this   attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetDigitalEqualizationEnabled(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DigitalEqualizationEnabled, channel, value);
        }

        /// <summary>
        ///When this attribute is enabled, NI-RFSG equalizes the waveform   data to correct for variations in the response of the NI-RFSG device.   Enabling digital equalization improves   the modulation error rates (MER) and error vector magnitude (EVM) for   signals with large bandwidths (> 500 kHz). On the NI 5670/5671, this   equalization is performed in the software so that tuning time is   increased. On the NI 5672, this is performed in the hardware so that it   has no performance penalties.
        ///   This attribute only applies when the NIRFSG_ATTR_GENERATION_MODE attribute   is set to NIRFSG_VAL_ARB_WAVEFORM or NIRFSG_VAL_SCRIPT. To set this   attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int GetDigitalEqualizationEnabled(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DigitalEqualizationEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies the active level for the Script trigger. This attribute is used   when the NIRFSG_ATTR_SCRIPT_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_LEVEL. 
        /// 
        /// </summary>
        public int SetDigitalLevelScriptTriggerActiveLevel(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DigitalLevelScriptTriggerActiveLevel, channel, value);
        }

        /// <summary>
        ///Specifies the active level for the Script trigger. This attribute is used   when the NIRFSG_ATTR_SCRIPT_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_LEVEL. 
        /// 
        /// </summary>
        public int GetDigitalLevelScriptTriggerActiveLevel(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DigitalLevelScriptTriggerActiveLevel, channel, out value);
        }

        /// <summary>
        ///Specifies the source terminal for the Script trigger. This attribute is   used when the NIRFSG_ATTR_SCRIPT_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_LEVEL. This attribute is not case-sensitive. To set   the NIRFSG_ATTR_DIGITAL_LEVEL_SCRIPT_TRIGGER_SOURCE attribute,   the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetDigitalLevelScriptTriggerSource(string channel, string value)
        {
            return SetString(niRFSGProperties.DigitalLevelScriptTriggerSource, channel, value);
        }

        /// <summary>
        ///Specifies the source terminal for the Script trigger. This attribute is   used when the NIRFSG_ATTR_SCRIPT_TRIGGER_TYPE attribute is set to   NIRFSG_VAL_DIGITAL_LEVEL. This attribute is not case-sensitive. To set   the NIRFSG_ATTR_DIGITAL_LEVEL_SCRIPT_TRIGGER_SOURCE attribute,   the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int GetDigitalLevelScriptTriggerSource(string channel, out string value)
        {
            return GetString(niRFSGProperties.DigitalLevelScriptTriggerSource, channel, out value);
        }

        /// <summary>
        ///Specifies the deviation to use in FSK modulation. 
        /// 
        /// </summary>
        public int SetDigitalModulationFskDeviation(string channel, double value)
        {
            return SetDouble(niRFSGProperties.DigitalModulationFskDeviation, channel, value);
        }

        /// <summary>
        ///Specifies the deviation to use in FSK modulation. 
        /// 
        /// </summary>
        public int GetDigitalModulationFskDeviation(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.DigitalModulationFskDeviation, channel, out value);
        }

        /// <summary>
        ///Specifies the order of the pseudorandom bit sequence (PRBS)   sequence internally generated by hardware   and used as the message signal in digital modulation. 
        /// 
        /// </summary>
        public int SetDigitalModulationPrbsOrder(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DigitalModulationPrbsOrder, channel, value);
        }

        /// <summary>
        ///Specifies the order of the pseudorandom bit sequence (PRBS)   sequence internally generated by hardware   and used as the message signal in digital modulation. 
        /// 
        /// </summary>
        public int GetDigitalModulationPrbsOrder(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DigitalModulationPrbsOrder, channel, out value);
        }

        /// <summary>
        ///Specifies the seed of the internally generated   pseudorandom bit sequence (PRBS) sequence.
        /// 
        /// </summary>
        public int SetDigitalModulationPrbsSeed(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DigitalModulationPrbsSeed, channel, value);
        }

        /// <summary>
        ///Specifies the seed of the internally generated   pseudorandom bit sequence (PRBS) sequence.
        /// 
        /// </summary>
        public int GetDigitalModulationPrbsSeed(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DigitalModulationPrbsSeed, channel, out value);
        }

        /// <summary>
        ///Specifies the symbol rate of the bit stream for FSK modulation.
        /// 
        /// </summary>
        public int SetDigitalModulationSymbolRate(string channel, double value)
        {
            return SetDouble(niRFSGProperties.DigitalModulationSymbolRate, channel, value);
        }

        /// <summary>
        ///Specifies the symbol rate of the bit stream for FSK modulation.
        /// 
        /// </summary>
        public int GetDigitalModulationSymbolRate(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.DigitalModulationSymbolRate, channel, out value);
        }

        /// <summary>
        ///Specifies the digital modulation format to use.
        /// 
        /// </summary>
        public int SetDigitalModulationType(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DigitalModulationType, channel, value);
        }

        /// <summary>
        ///Specifies the digital modulation format to use.
        /// 
        /// </summary>
        public int GetDigitalModulationType(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DigitalModulationType, channel, out value);
        }

        /// <summary>
        ///Specifies the type of waveform to use as the message signal in digital   modulation.
        /// 
        /// </summary>
        public int SetDigitalModulationWaveformType(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DigitalModulationWaveformType, channel, value);
        }

        /// <summary>
        ///Specifies the type of waveform to use as the message signal in digital   modulation.
        /// 
        /// </summary>
        public int GetDigitalModulationWaveformType(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DigitalModulationWaveformType, channel, out value);
        }

        /// <summary>
        ///Enables or disables digital pattern on the NI 5421/5441 AWG module. This   attribute must be set to VI_TRUE to enable signal routing to and from the   Digital Data &amp; Control connector. To set this attribute, the NI-RFSG   device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetDigitalPattern(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.DigitalPattern, channel, value);
        }

        /// <summary>
        ///Enables or disables digital pattern on the NI 5421/5441 AWG module. This   attribute must be set to VI_TRUE to enable signal routing to and from the   Digital Data &amp; Control connector. To set this attribute, the NI-RFSG   device must be in the Configuration state.
        /// 
        /// </summary>
        public int GetDigitalPattern(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.DigitalPattern, channel, out value);
        }

        /// <summary>
        ///Enables the device for Direct DMA writes.  When enabled, the   niRFSG_WriteArbWaveform function writes data residing on the direct DMA   device (specified in the data address in the   NIRFSG_ATTR_DIRECT_DMA_WINDOW_ADDRESS attribute) to the NI-RFSG device   onboard memory.
        /// 
        /// </summary>
        public int SetDirectDmaEnabled(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.DirectDmaEnabled, channel, value);
        }

        /// <summary>
        ///Enables the device for Direct DMA writes.  When enabled, the   niRFSG_WriteArbWaveform function writes data residing on the direct DMA   device (specified in the data address in the   NIRFSG_ATTR_DIRECT_DMA_WINDOW_ADDRESS attribute) to the NI-RFSG device   onboard memory.
        /// 
        /// </summary>
        public int GetDirectDmaEnabled(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.DirectDmaEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies the window address (beginning of window) of the waveform data   source. This window address is specified by your Direct DMA-compatible   data source.
        /// 
        /// </summary>
        public int SetDirectDmaWindowAddress(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DirectDmaWindowAddress, channel, value);
        }

        /// <summary>
        ///Specifies the window address (beginning of window) of the waveform data   source. This window address is specified by your Direct DMA-compatible   data source.
        /// 
        /// </summary>
        public int GetDirectDmaWindowAddress(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DirectDmaWindowAddress, channel, out value);
        }

        /// <summary>
        ///Specifies the size of the memory window provided by your direct   DMA-compatible data source. 
        ///   Units: bytes 
        /// 
        /// </summary>
        public int SetDirectDmaWindowSize(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DirectDmaWindowSize, channel, value);
        }

        /// <summary>
        ///Specifies the size of the memory window provided by your direct   DMA-compatible data source. 
        ///   Units: bytes 
        /// 
        /// </summary>
        public int GetDirectDmaWindowSize(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DirectDmaWindowSize, channel, out value);
        }

        /// <summary>
        ///Specifies whether the niRFSG_WriteArbWaveform function writes waveforms   immediately to the device or copies the waveform to host memory for   download later. NI-RFSG reads and validates this attribute when an   arbitrary waveform is first allocated.
        ///   NI 5670: Direct download is always disabled. 
        ///   NI 5671: To increase performance when using large waveforms,   enable direct download.  To maximize reconfigurability, disable direct   
        /// 
        /// </summary>
        public int SetDirectDownload(string channel, int value)
        {
            return SetInt32(niRFSGProperties.DirectDownload, channel, value);
        }

        /// <summary>
        ///Specifies whether the niRFSG_WriteArbWaveform function writes waveforms   immediately to the device or copies the waveform to host memory for   download later. NI-RFSG reads and validates this attribute when an   arbitrary waveform is first allocated.
        ///   NI 5670: Direct download is always disabled. 
        ///   NI 5671: To increase performance when using large waveforms,   enable direct download.  To maximize reconfigurability, disable direct   
        /// 
        /// </summary>
        public int GetDirectDownload(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.DirectDownload, channel, out value);
        }

        /// <summary>
        ///Returns the name of the fully-qualified signal name as a string. 
        /// 
        /// </summary>
        public int GetDoneEventTerminalName(string channel, out string value)
        {
            return GetString(niRFSGProperties.DoneEventTerminalName, channel, out value);
        }

        /// <summary>
        ///The driver setup string is used to set the initial values for attributes   that are specific to NI-RFSG.
        ///    The format of the driver setup string is in the following format:
        ///        Tag: Value
        ///   where
        ///   Tag is the name of the driver setup string attribute
        ///    Value is the value set to the attribute.
        ///    To set multiple attributes, separate their assignments with a semicolon.
        ///   The following describes the driver setup string tags:
        ///   AWG--Specifies the resource name of the Arbitrary Waveform Generator to   use for this session. If this driver setup tag is not specified, the   resource name for the upconverter associated in MAX is used.
        ///   Example:  DriverSetup=AWG:pxi1slot4 
        ///    or 
        ///   DriverSetup=AWGModule:pxi1slot4 
        ///    Refer to the niRFSG_InitWithOptions function for additional information   about the optionsString parameter. Refer to the NI RF Signal Generators   Getting Started Guide, located at Start» All Programs»National   Instruments»NI-RFSG» Documentation, for information about MAX setup.
        /// 
        /// </summary>
        public int GetDriverSetup(string channel, out string value)
        {
            return GetString(niRFSGProperties.DriverSetup, channel, out value);
        }

        /// <summary>
        ///Specifies the delay, in seconds, applied to the Started event, Done event, and all Marker events with respect to the analog    output of the RF signal generator. To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    By default, markers and events are delayed to align with the waveform data generated from the device.    This attribute adds an additional delay to markers and events. Use this attribute to adjust the time delay between    events and the corresponding data. 
        ///    Units: Seconds 
        /// 
        /// </summary>
        public int SetEventsDelay(string channel, double value)
        {
            return SetDouble(niRFSGProperties.EventsDelay, channel, value);
        }
        /// <summary>
        ///Specifies the delay, in seconds, applied to the Started event, Done event, and all Marker events with respect to the analog    output of the RF signal generator. To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    By default, markers and events are delayed to align with the waveform data generated from the device.    This attribute adds an additional delay to markers and events. Use this attribute to adjust the time delay between    events and the corresponding data. 
        ///    Units: Seconds 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetEventsDelay(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.EventsDelay, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the Configuration List Step   trigger.  To set this attribute, the NI-RFSG device must be in the Configuration state. 
        /// 
        /// </summary>
        public int SetExportedConfigurationListStepTriggerOutputTerminal(string channel, string value)
        {
            return SetString(niRFSGProperties.ExportedConfigurationListStepTriggerOutputTerminal, channel, value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the Configuration List Step   trigger.  To set this attribute, the NI-RFSG device must be in the Configuration state. 
        /// 
        /// </summary>
        public int GetExportedConfigurationListStepTriggerOutputTerminal(string channel, out string value)
        {
            return GetString(niRFSGProperties.ExportedConfigurationListStepTriggerOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the Done event. To set   this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetExportedDoneEventOutputTerminal(string channel, string value)
        {
            return SetString(niRFSGProperties.ExportedDoneEventOutputTerminal, channel, value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the Done event. To set   this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int GetExportedDoneEventOutputTerminal(string channel, out string value)
        {
            return GetString(niRFSGProperties.ExportedDoneEventOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the marker event. To set   this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetExportedMarkerEventOutputTerminal(string channel, string value)
        {
            return SetString(niRFSGProperties.ExportedMarkerEventOutputTerminal, channel, value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the marker event. To set   this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int GetExportedMarkerEventOutputTerminal(string channel, out string value)
        {
            return GetString(niRFSGProperties.ExportedMarkerEventOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the reference clock on   the NI 5650/5651/5652/5673 RF signal generators. To set this attribute,   the NI-RFSG device must be in the Configuration state. 
        /// 
        /// </summary>
        public int SetExportedRefClockOutputTerminal(string channel, string value)
        {
            return SetString(niRFSGProperties.ExportedRefClockOutputTerminal, channel, value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the reference clock on   the NI 5650/5651/5652/5673 RF signal generators. To set this attribute,   the NI-RFSG device must be in the Configuration state. 
        /// 
        /// </summary>
        public int GetExportedRefClockOutputTerminal(string channel, out string value)
        {
            return GetString(niRFSGProperties.ExportedRefClockOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the script trigger. To   set this attribute, the NI-RFSG device must be in the Configuration state.   For trigger delay information, refer to the triggering section in the NI   RF Signal Generators Help. 
        /// 
        /// </summary>
        public int SetExportedScriptTriggerOutputTerminal(string channel, string value)
        {
            return SetString(niRFSGProperties.ExportedScriptTriggerOutputTerminal, channel, value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the script trigger. To   set this attribute, the NI-RFSG device must be in the Configuration state.   For trigger delay information, refer to the triggering section in the NI   RF Signal Generators Help. 
        /// 
        /// </summary>
        public int GetExportedScriptTriggerOutputTerminal(string channel, out string value)
        {
            return GetString(niRFSGProperties.ExportedScriptTriggerOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the started event. To set   this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetExportedStartedEventOutputTerminal(string channel, string value)
        {
            return SetString(niRFSGProperties.ExportedStartedEventOutputTerminal, channel, value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the started event. To set   this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int GetExportedStartedEventOutputTerminal(string channel, out string value)
        {
            return GetString(niRFSGProperties.ExportedStartedEventOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the Start trigger.   To set this attribute, the NI-RFSG device must be in the Configuration   state.
        /// 
        /// </summary>
        public int SetExportedStartTriggerOutputTerminal(string channel, string value)
        {
            return SetString(niRFSGProperties.ExportedStartTriggerOutputTerminal, channel, value);
        }

        /// <summary>
        ///Specifies the destination terminal for exporting the Start trigger.   To set this attribute, the NI-RFSG device must be in the Configuration   state.
        /// 
        /// </summary>
        public int GetExportedStartTriggerOutputTerminal(string channel, out string value)
        {
            return GetString(niRFSGProperties.ExportedStartTriggerOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Returns the recommended interval between each external calibration of the device. 
        ///   Units: months 
        /// 
        /// </summary>
        public int GetExternalCalibrationRecommendedInterval(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ExternalCalibrationRecommendedInterval, channel, out value);
        }

        /// <summary>
        ///Indicates in degrees Celsius the temperature of the device at the time of   the last external calibration. 
        /// 
        /// </summary>
        public int GetExternalCalibrationTemperature(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.ExternalCalibrationTemperature, channel, out value);
        }

        /// <summary>
        ///Specifies a string that contains arbitrary, user-defined information that   is stored with external calibration. 
        /// 
        /// </summary>
        public int GetExternalCalibrationUserDefinedInfo(string channel, out string value)
        {
            return GetString(niRFSGProperties.ExternalCalibrationUserDefinedInfo, channel, out value);
        }

        /// <summary>
        ///Returns the maximum string length for the   NIRFSG_ATTR_EXTERNAL_CALIBRATION_USER_DEFINED_INFO attribute. 
        /// 
        /// </summary>
        public int GetExternalCalibrationUserDefinedInfoMaxSize(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ExternalCalibrationUserDefinedInfoMaxSize, channel, out value);
        }

        /// <summary>
        ///Specifies the external amplification or attenuation, if any, between   the RF signal generator and the device under test.   
        ///   Positive values for this property represent amplification, and   negative values for this property represent attenuation.  
        ///   Note:  Setting this property adjusts the device output   power to compensate for any amplification or attenuation between   the RF signal generator and the device under test.  
        /// 
        /// </summary>
        public int SetExternalGain(string channel, double value)
        {
            return SetDouble(niRFSGProperties.ExternalGain, channel, value);
        }

        /// <summary>
        ///Specifies the external amplification or attenuation, if any, between   the RF signal generator and the device under test.   
        ///   Positive values for this property represent amplification, and   negative values for this property represent attenuation.  
        ///   Note:  Setting this property adjusts the device output   power to compensate for any amplification or attenuation between   the RF signal generator and the device under test.  
        /// 
        /// </summary>
        public int GetExternalGain(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.ExternalGain, channel, out value);
        }

        /// <summary>
        ///Returns a string containing the path to the location of the current NI-RFSG instrument    driver FPGA extensions bitfile, a .lvbitx file, that is programmed on the device.    You can specify the bitfile location using the Driver Setup string in the optionString parameter    of the niRFSG_InitWithOptions function. 
        ///    NI-RFSG instrument driver FPGA extensions enable you to use pre-compiled FPGA bitfiles to    customize the behavior of the vector signal transceiver FPGA while maintaining the functionality    of the NI-RFSG instrument driver. 
        ///    Refer to the NI-RFSA and NI-RFSG Instrument Driver FPGA Extensions topic in the NI RF Signal    Generators Help for more information about using NI-RFSG instrument driver FPGA extensions for    NI vector signal analyzers. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetFpgaBitfilePath(string channel, out string value)
        {
            return GetString(niRFSGProperties.FpgaBitfilePath, channel, out value);
        }

        /// <summary>
        ///Specifies the frequency of the generated RF signal. For arbitrary waveform   generation, this attribute specifies the center frequency of the signal. 
        ///   Units: hertz (Hz) 
        /// 
        /// </summary>
        public int SetFrequency(string channel, double value)
        {
            return SetDouble(niRFSGProperties.Frequency, channel, value);
        }

        /// <summary>
        ///Specifies the frequency of the generated RF signal. For arbitrary waveform   generation, this attribute specifies the center frequency of the signal. 
        ///   Units: hertz (Hz) 
        /// 
        /// </summary>
        public int GetFrequency(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.Frequency, channel, out value);
        }

        /// <summary>
        ///Configures the frequency settling time.  Interpretation of this value   depends on the NIRFSG_ATTR_FREQUENCY_SETTLING_UNITS attribute. 
        /// 
        /// </summary>
        public int SetFrequencySettling(string channel, double value)
        {
            return SetDouble(niRFSGProperties.FrequencySettling, channel, value);
        }

        /// <summary>
        ///Configures the frequency settling time.  Interpretation of this value   depends on the NIRFSG_ATTR_FREQUENCY_SETTLING_UNITS attribute. 
        /// 
        /// </summary>
        public int GetFrequencySettling(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.FrequencySettling, channel, out value);
        }

        /// <summary>
        ///Specifies the interpretation of the value passed to the   NIRFSG_ATTR_FREQUENCY_SETTLING attribute. 
        /// 
        /// </summary>
        public int SetFrequencySettlingUnits(string channel, int value)
        {
            return SetInt32(niRFSGProperties.FrequencySettlingUnits, channel, value);
        }

        /// <summary>
        ///Specifies the interpretation of the value passed to the   NIRFSG_ATTR_FREQUENCY_SETTLING attribute. 
        /// 
        /// </summary>
        public int GetFrequencySettlingUnits(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.FrequencySettlingUnits, channel, out value);
        }

        /// <summary>
        ///Specifies the maximum frequency error allowed during the software   upconversion process. NI-RFSG may introduce a frequency error up to the   specified amount in order to optimize computational speed and onboard   memory usage while upconverting phase-continuous signals. 
        ///   If the NIRFSG_ATTR_PHASE_CONTINUITY_ENABLED attribute is set to   NIRFSG_VAL_DISABLE, the NIRFSG_ATTR_FREQUENCY_TOLERANCE attribute is   ignored, and the driver does not introduce a frequency error. On devices   that do not use software upconversion, this property is ignored. The   NI 5670 always uses software upconversion, and the NI 5671 uses software   upconversion for I/Q rates greater than 8.33 MS/s. 
        ///   To set the   NIRFSG_ATTR_FREQUENCY_TOLERANCE attribute, the NI-RFSG device must be in   the Configuration state.
        ///   Units: hertz (Hz) 
        /// 
        /// </summary>
        public int SetFrequencyTolerance(string channel, double value)
        {
            return SetDouble(niRFSGProperties.FrequencyTolerance, channel, value);
        }

        /// <summary>
        ///Specifies the maximum frequency error allowed during the software   upconversion process. NI-RFSG may introduce a frequency error up to the   specified amount in order to optimize computational speed and onboard   memory usage while upconverting phase-continuous signals. 
        ///   If the NIRFSG_ATTR_PHASE_CONTINUITY_ENABLED attribute is set to   NIRFSG_VAL_DISABLE, the NIRFSG_ATTR_FREQUENCY_TOLERANCE attribute is   ignored, and the driver does not introduce a frequency error. On devices   that do not use software upconversion, this property is ignored. The   NI 5670 always uses software upconversion, and the NI 5671 uses software   upconversion for I/Q rates greater than 8.33 MS/s. 
        ///   To set the   NIRFSG_ATTR_FREQUENCY_TOLERANCE attribute, the NI-RFSG device must be in   the Configuration state.
        ///   Units: hertz (Hz) 
        /// 
        /// </summary>
        public int GetFrequencyTolerance(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.FrequencyTolerance, channel, out value);
        }

        /// <summary>
        ///Specifies whether to generate a continuous wave (CW) signal, the arb   waveform specified by the NIRFSG_ATTR_SELECTED_WAVEFORM attribute, or the   script specified by the NIRFSG_ATTR_SELECTED_SCRIPT attribute, upon   calling the niRFSG_Initiate function. 
        /// 
        /// </summary>
        public int SetGenerationMode(string channel, int value)
        {
            return SetInt32(niRFSGProperties.GenerationMode, channel, value);
        }

        /// <summary>
        ///Specifies whether to generate a continuous wave (CW) signal, the arb   waveform specified by the NIRFSG_ATTR_SELECTED_WAVEFORM attribute, or the   script specified by the NIRFSG_ATTR_SELECTED_SCRIPT attribute, upon   calling the niRFSG_Initiate function. 
        /// 
        /// </summary>
        public int GetGenerationMode(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.GenerationMode, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains a comma-separated list of class-extension   groups that NI-RFSG implements.
        /// 
        /// </summary>
        public int GetGroupCapabilities(string channel, out string value)
        {
            return GetString(niRFSGProperties.GroupCapabilities, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains the firmware revision information for the   NI-RFSG device you are currently using.
        /// 
        /// </summary>
        public int GetInstrumentFirmwareRevision(string channel, out string value)
        {
            return GetString(niRFSGProperties.InstrumentFirmwareRevision, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains the name of the manufacturer for the   NI-RFSG device you are currently using.
        /// 
        /// </summary>
        public int GetInstrumentManufacturer(string channel, out string value)
        {
            return GetString(niRFSGProperties.InstrumentManufacturer, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains the model number or name of the NI-RFSG   device that you are currently using. For drivers that support more than   one device, this attribute returns a comma-separated list of   supported devices.
        /// 
        /// </summary>
        public int GetInstrumentModel(string channel, out string value)
        {
            return GetString(niRFSGProperties.InstrumentModel, channel, out value);
        }

        /// <summary>
        ///Specifies whether to perform interchangeability checking and retrieve   interchangeability warnings.
        ///   NOTE: This attribute is currently not supported. 
        /// 
        /// </summary>
        public int SetInterchangeCheck(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.InterchangeCheck, channel, value);
        }

        /// <summary>
        ///Specifies whether to perform interchangeability checking and retrieve   interchangeability warnings.
        ///   NOTE: This attribute is currently not supported. 
        /// 
        /// </summary>
        public int GetInterchangeCheck(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.InterchangeCheck, channel, out value);
        }

        /// <summary>
        ///Specifies the delay, in seconds, to apply to the I/Q waveform. To set this attribute,    the NI-RFSG device must be in the Configuration state. 
        ///    Units: Seconds 
        /// 
        /// </summary>
        public int SetInterpolationDelay(string channel, double value)
        {
            return SetDouble(niRFSGProperties.InterpolationDelay, channel, value);
        }

        /// <summary>
        ///Specifies the delay, in seconds, to apply to the I/Q waveform. To set this attribute,    the NI-RFSG device must be in the Configuration state. 
        ///    Units: Seconds 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetInterpolationDelay(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.InterpolationDelay, channel, out value);
        }

        /// <summary>
        ///Specifies the gain imbalance of the I/Q modulator (I versus Q). 
        ///   Units: dB 
        /// 
        /// </summary>
        public int SetIqGainImbalance(string channel, double value)
        {
            return SetDouble(niRFSGProperties.IqGainImbalance, channel, value);
        }

        /// <summary>
        ///Specifies the gain imbalance of the I/Q modulator (I versus Q). 
        ///   Units: dB 
        /// 
        /// </summary>
        public int GetIqGainImbalance(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqGainImbalance, channel, out value);
        }

        /// <summary>
        ///Enables/disables I/Q impairment.  The NIRFSG_ATTR_IQ_I_OFFSET,   NIRFSG_ATTR_IQ_Q_OFFSET, NIRFSG_ATTR_IQ_GAIN_IMBALANCE, and   NIRFSG_ATTR_IQ_SKEW attributes are ignored when the   NIRFSG_ATTR_IQ_IMPAIRMENT_ENABLED attribute is disabled. 
        /// 
        /// </summary>
        public int SetIqImpairmentEnabled(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.IqImpairmentEnabled, channel, value);
        }

        /// <summary>
        ///Enables/disables I/Q impairment.  The NIRFSG_ATTR_IQ_I_OFFSET,   NIRFSG_ATTR_IQ_Q_OFFSET, NIRFSG_ATTR_IQ_GAIN_IMBALANCE, and   NIRFSG_ATTR_IQ_SKEW attributes are ignored when the   NIRFSG_ATTR_IQ_IMPAIRMENT_ENABLED attribute is disabled. 
        /// 
        /// </summary>
        public int GetIqImpairmentEnabled(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.IqImpairmentEnabled, channel, out value);
        }

        /// <summary>
        ///When using a National Instruments AWG, this attribute specifies the   I-signal DC offset.  Actual AWG signal offset is equal to the I/Q   modulator offset correction plus the value specified by this attribute.    Units are either percent or volts, depending on the    NIRFSG_ATTR_OFFSET_UNITS attribute.
        ///   When using an external AWG, this attribute is read-only 
        ///   and indicates the I/Q modulator I-offset.  Units are volts, as indicated   by the NIRFSG_ATTR_OFFSET_UNITS attribute. 
        /// 
        /// </summary>
        public int SetIqIOffset(string channel, double value)
        {
            return SetDouble(niRFSGProperties.IqIOffset, channel, value);
        }

        /// <summary>
        ///When using a National Instruments AWG, this attribute specifies the   I-signal DC offset.  Actual AWG signal offset is equal to the I/Q   modulator offset correction plus the value specified by this attribute.    Units are either percent or volts, depending on the    NIRFSG_ATTR_OFFSET_UNITS attribute.
        ///   When using an external AWG, this attribute is read-only 
        ///   and indicates the I/Q modulator I-offset.  Units are volts, as indicated   by the NIRFSG_ATTR_OFFSET_UNITS attribute. 
        /// 
        /// </summary>
        public int GetIqIOffset(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqIOffset, channel, out value);
        }

        /// <summary>
        ///Specifies the units of the NIRFSG_ATTR_IQ_I_OFFSET attribute and the   NIRFSG_ATTR_IQ_Q_OFFSET attribute.  Offset units are either percent or   volts.
        /// 
        /// </summary>
        public int SetIqOffsetUnits(string channel, int value)
        {
            return SetInt32(niRFSGProperties.IqOffsetUnits, channel, value);
        }

        /// <summary>
        ///Specifies the units of the NIRFSG_ATTR_IQ_I_OFFSET attribute and the   NIRFSG_ATTR_IQ_Q_OFFSET attribute.  Offset units are either percent or   volts.
        /// 
        /// </summary>
        public int GetIqOffsetUnits(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.IqOffsetUnits, channel, out value);
        }

        /// <summary>
        ///When using a National Instruments AWG, this attribute 
        ///   specifies the Q-signal DC offset.  Actual AWGsignal offset is equal to the   I/Q modulator offset correction plus the value specified by this   attribute.  Units are either percent or volts, depending on the   NIRFSG_ATTR_OFFSET_UNITS attribute.
        ///   When using an external AWG, 
        ///   this attribute is read-only, and indicates the IQ modulator Q offset.   Units are volts, as indicated by the NIRFSG_ATTR_OFFSET_UNITS attribute. 
        /// 
        /// </summary>
        public int SetIqQOffset(string channel, double value)
        {
            return SetDouble(niRFSGProperties.IqQOffset, channel, value);
        }

        /// <summary>
        ///When using a National Instruments AWG, this attribute 
        ///   specifies the Q-signal DC offset.  Actual AWGsignal offset is equal to the   I/Q modulator offset correction plus the value specified by this   attribute.  Units are either percent or volts, depending on the   NIRFSG_ATTR_OFFSET_UNITS attribute.
        ///   When using an external AWG, 
        ///   this attribute is read-only, and indicates the IQ modulator Q offset.   Units are volts, as indicated by the NIRFSG_ATTR_OFFSET_UNITS attribute. 
        /// 
        /// </summary>
        public int GetIqQOffset(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqQOffset, channel, out value);
        }

        /// <summary>
        ///Specifies the frequency of the I/Q OUT port signal. The onboard signal processing (OSP)    applies the specified frequency shift to the I/Q data before the data is sent to the    digital-to-analog converter (DAC). To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Units: Hertz (Hz) 
        /// 
        /// </summary>
        public int SetIqOutPortCarrierFrequency(string channel, double value)
        {
            return SetDouble(niRFSGProperties.IqOutPortCarrierFrequency, channel, value);
        }
        /// <summary>
        ///Specifies the frequency of the I/Q OUT port signal. The onboard signal processing (OSP)    applies the specified frequency shift to the I/Q data before the data is sent to the    digital-to-analog converter (DAC). To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Units: Hertz (Hz) 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetIqOutPortCarrierFrequency(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqOutPortCarrierFrequency, channel, out value);
        }

        /// <summary>
        ///Specifies the common-mode offset applied to the signals generated at each differential output terminal.    This attribute applies only when you set the NIRFSG_ATTR_IQ_OUT_PORT_TERMINAL_CONFIGURATION attribute to NIRFSG_VAL_DIFFERENTIAL.    Common-mode offset shifts both positive and negative terminals in the same direction. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Units: Volts 
        /// 
        /// </summary>
        public int SetIqOutPortCommonModeOffset(string channel, double value)
        {
            return SetDouble(niRFSGProperties.IqOutPortCommonModeOffset, channel, value);
        }
        /// <summary>
        ///Specifies the common-mode offset applied to the signals generated at each differential output terminal.    This attribute applies only when you set the NIRFSG_ATTR_IQ_OUT_PORT_TERMINAL_CONFIGURATION attribute to NIRFSG_VAL_DIFFERENTIAL.    Common-mode offset shifts both positive and negative terminals in the same direction. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Units: Volts 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetIqOutPortCommonModeOffset(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqOutPortCommonModeOffset, channel, out value);
        }

        /// <summary>
        ///Specifies the amplitude of the generated signal in volts, peak-to-peak (Vpp). For example,    if you set this attribute to 1.0, the output signal ranges from -0.5 volts to 0.5 volts. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the specifications document for your device for allowable output levels. 
        ///    Units: Volts, peak-to-peak 
        /// 
        /// </summary>
        public int SetIqOutPortLevel(string channel, double value)
        {
            return SetDouble(niRFSGProperties.IqOutPortLevel, channel, value);
        }
        /// <summary>
        ///Specifies the amplitude of the generated signal in volts, peak-to-peak (Vpp). For example,    if you set this attribute to 1.0, the output signal ranges from -0.5 volts to 0.5 volts. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the specifications document for your device for allowable output levels. 
        ///    Units: Volts, peak-to-peak 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetIqOutPortLevel(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqOutPortLevel, channel, out value);
        }

        /// <summary>
        ///Specifies the load impedance connected to the I/Q OUT port. To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Units: Ohms 
        /// 
        /// </summary>
        public int SetIqOutPortLoadImpedance(string channel, double value)
        {
            return SetDouble(niRFSGProperties.IqOutPortLoadImpedance, channel, value);
        }
        /// <summary>
        ///Specifies the load impedance connected to the I/Q OUT port. To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Units: Ohms 
        /// 
        /// </summary>
        public int GetIqOutPortLoadImpedance(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqOutPortLoadImpedance, channel, out value);
        }

        /// <summary>
        ///Specifies the value, in volts, that the signal generator adds to the arbitrary waveform data.    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Units: Volts 
        /// 
        /// </summary>
        public int SetIqOutPortOffset(string channel, double value)
        {
            return SetDouble(niRFSGProperties.IqOutPortOffset, channel, value);
        }
        /// <summary>
        ///Specifies the value, in volts, that the signal generator adds to the arbitrary waveform data.    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Units: Volts 
        /// 
        /// </summary>
        public int GetIqOutPortOffset(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqOutPortOffset, channel, out value);
        }

        /// <summary>
        ///Returns the temperature of the I/Q Out circuitry on the device. To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Untis: Degrees Celsius 
        /// 
        /// </summary>
        public int GetIqOutPortTemperature(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqOutPortTemperature, channel, out value);
        }


        /// <summary>
        ///Specifies whether to use the I/Q OUT port for Differential configuration or Single-Ended configuration.    If you set this attribute to NIRFSG_VAL_SINGLE_ENDED, you must terminate the negative I and Q output    connectors with a 50 Ohm termination. 
        ///    If you set this attribute to NIRFSG_VAL_SINGLE_ENDED, the positive I and Q connectors generate the resulting waveform.    If you set this attribute to NIRFSG_VAL_DIFFERENTIAL, both the positive and negative I and Q connectors generate the resulting waveform. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the Differential and Single-Ended Operation (I/Q Interface) topic of the NI RF Signal Generators Help    for more information about differential and single-ended operation.
        /// 
        /// </summary>
        public int SetIqOutPortTerminalConfiguration(string channel, int value)
        {
            return SetInt32(niRFSGProperties.IqOutPortTerminalConfiguration, channel, value);
        }
        /// <summary>
        ///Specifies whether to use the I/Q OUT port for Differential configuration or Single-Ended configuration.    If you set this attribute to NIRFSG_VAL_SINGLE_ENDED, you must terminate the negative I and Q output    connectors with a 50 Ohm termination. 
        ///    If you set this attribute to NIRFSG_VAL_SINGLE_ENDED, the positive I and Q connectors generate the resulting waveform.    If you set this attribute to NIRFSG_VAL_DIFFERENTIAL, both the positive and negative I and Q connectors generate the resulting waveform. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the Differential and Single-Ended Operation (I/Q Interface) topic of the NI RF Signal Generators Help    for more information about differential and single-ended operation.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetIqOutPortTerminalConfiguration(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.IqOutPortTerminalConfiguration, channel, out value);
        }

        /// <summary>
        ///This attribute specifies the I/Q rate of the arbitrary waveform.   The I/Q rate is coerced to what rates the hardware can achieve.   Read this value back after setting it to see what the actual   I/Q rate is. NI-RFSG internally uses an FIR filter with flat   response up to (0.4 × IQ rate). Given a desired signal with   the maximum frequency content f, sample the signal at   an I/Q rate greater than or equal to (f/0.4). 
        ///   This attribute applies only when the NIRFSG_ATTR_GENERATION_MODE   attribute is set to NIRFSG_VAL_ARB_WAVEFORM or NIRFSG_VAL_SCRIPT. 
        ///   Use this attribute to associate an I/Q rate with a waverform.   Refer to the Assigning Properties or Attributes to a Waveform topic of   the NI RF Signal Generators Help for more information about assigning  
        /// 
        /// </summary>
        public int SetIqRate(string channel, double value)
        {
            return SetDouble(niRFSGProperties.IqRate, channel, value);
        }

        /// <summary>
        ///This attribute specifies the I/Q rate of the arbitrary waveform.   The I/Q rate is coerced to what rates the hardware can achieve.   Read this value back after setting it to see what the actual   I/Q rate is. NI-RFSG internally uses an FIR filter with flat   response up to (0.4 × IQ rate). Given a desired signal with   the maximum frequency content f, sample the signal at   an I/Q rate greater than or equal to (f/0.4). 
        ///   This attribute applies only when the NIRFSG_ATTR_GENERATION_MODE   attribute is set to NIRFSG_VAL_ARB_WAVEFORM or NIRFSG_VAL_SCRIPT. 
        ///   Use this attribute to associate an I/Q rate with a waverform.   Refer to the Assigning Properties or Attributes to a Waveform topic of   the NI RF Signal Generators Help for more information about assigning  
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetIqRate(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqRate, channel, out value);
        }

        /// <summary>
        ///Specifies the adjustment of the phase angle between the I and Q vectors.   If this skew is zero, the phase angle is 90 degrees. 
        /// 
        /// </summary>
        public int SetIqSkew(string channel, double value)
        {
            return SetDouble(niRFSGProperties.IqSkew, channel, value);
        }

        /// <summary>
        ///Specifies the adjustment of the phase angle between the I and Q vectors.   If this skew is zero, the phase angle is 90 degrees. 
        /// 
        /// </summary>
        public int GetIqSkew(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.IqSkew, channel, out value);
        }

        /// <summary>
        ///Enables or disables the inverse phase rotation of the IQ signal by   swapping the I and Q inputs.  
        ///   To set this attribute, the NI-RFSG device must   be in the Configuration state.
        /// 
        /// </summary>
        public int SetIqSwapEnabled(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.IqSwapEnabled, channel, value);
        }

        /// <summary>
        ///Enables or disables the inverse phase rotation of the IQ signal by   swapping the I and Q inputs.  
        ///   To set this attribute, the NI-RFSG device must   be in the Configuration state.
        /// 
        /// </summary>
        public int GetIqSwapEnabled(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.IqSwapEnabled, channel, out value);
        }

        /// <summary>
        ///Contains the logical name you specified when opening the current IVI session.   You can pass a logical name to the niRFSG_init   function or the niRFSG_InitWithOptions function. The IVI Configuration   Utility must contain an entry for the logical name. The logical name entry   refers to a driver session section in the IVI Configuration file. The   driver session section specifies a physical device and initial user   options.
        /// 
        /// </summary>
        public int GetLogicalName(string channel, out string value)
        {
            return GetString(niRFSGProperties.LogicalName, channel, out value);
        }

        /// <summary>
        ///Specifies the power level of the signal at the front panel LO IN   connector. 
        ///   NOTE: This attribute is read/write if you are using an external LO.   Otherwise, this attribute is read-only. 
        ///   Units: dBm 
        /// 
        /// </summary>
        public int SetLoInPower(string channel, double value)
        {
            return SetDouble(niRFSGProperties.LoInPower, channel, value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Specifies the power level of the signal at the front panel LO IN   connector. 
        ///   NOTE: This attribute is read/write if you are using an external LO.   Otherwise, this attribute is read-only. 
        ///   Units: dBm 
        /// 
        /// </summary>
        public int GetLoInPower(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.LoInPower, channel, out value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Configures the loop bandwidth of the tuning PLLs.NI 5610/5670/5671/5672 --   this attribute is ignoredfor signal bandwidths greater than or equal to 10   MHz. 
        ///    Note: Setting this attribute to NIRFSG_VAL_HIGH on the    NI 5650/5651/5652/5673/5673E allows the frequency to settle    significantly faster at the expense of increased phase noise.    Setting this attribute to NIRFSG_VAL_MEDIUM is not a valid    option on the NI 5650/5651/5652/5673/5673E. 
        /// 
        /// </summary>
        public int SetLoopBandwidth(string channel, int value)
        {
            return SetInt32(niRFSGProperties.LoopBandwidth, channel, value);
        }

        /// <summary>
        ///Configures the loop bandwidth of the tuning PLLs.NI 5610/5670/5671/5672 --   this attribute is ignoredfor signal bandwidths greater than or equal to 10   MHz. 
        ///    Note: Setting this attribute to NIRFSG_VAL_HIGH on the    NI 5650/5651/5652/5673/5673E allows the frequency to settle    significantly faster at the expense of increased phase noise.    Setting this attribute to NIRFSG_VAL_MEDIUM is not a valid    option on the NI 5650/5651/5652/5673/5673E. 
        /// 
        /// </summary>
        public int GetLoopBandwidth(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.LoopBandwidth, channel, out value);
        }

        /// <summary>
        ///Specifies whether the local oscillator signal is present at the front   panel LO Out connector.
        ///   The local oscillator signal remains at the LO OUT front panel connector   until this attribute is set to VI_FALSE even if the   NIRFSG_ATTR_OUTPUT_ENABLED attribute is set to VI FALSE,   the niRFSG_Abort function is called, or the NI-RFSG sesssion is closed.   
        /// 
        /// </summary>
        public int SetLoOutEnabled(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.LoOutEnabled, channel, value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Specifies whether the local oscillator signal is present at the front   panel LO Out connector.
        ///   The local oscillator signal remains at the LO OUT front panel connector   until this attribute is set to VI_FALSE even if the   NIRFSG_ATTR_OUTPUT_ENABLED attribute is set to VI FALSE,   the niRFSG_Abort function is called, or the NI-RFSG sesssion is closed.   
        /// 
        /// </summary>
        public int GetLoOutEnabled(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.LoOutEnabled, channel, out value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Specifies the power level of the signal at the front panel LO OUT   connector. 
        ///   Units: dBm 
        /// 
        /// </summary>
        public int GetLoOutPower(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.LoOutPower, channel, out value);
        }
        //Casing : Change Lo to LO

        /// <summary>
        ///Specifies whether to use fractional mode for the local oscillator (LO) phase-locked loop (PLL).    This attribute enables or disables fractional frequency tuning in the LO. Fractional mode    provides a finer frequency step resolution and allows smaller values for the   
        /// 
        /// </summary>
        /// <param name="channel">
        /// </param>
        /// <param name="value">
        /// </param>
        public int SetLoPllFractionalModeEnabled(string channel, int value)
        {
            return SetInt32(niRFSGProperties.LoPllFractionalModeEnabled, channel, value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Specifies whether to use fractional mode for the local oscillator (LO) phase-locked loop (PLL).    This attribute enables or disables fractional frequency tuning in the LO. Fractional mode    provides a finer frequency step resolution and allows smaller values for the   
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetLoPllFractionalModeEnabled(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.LoPllFractionalModeEnabled, channel, out value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Specifies whether to use the internal or external local oscillator (LO) source.    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    To use an external LO source, set this attribute to NIRFSG_VAL_LO_SOURCE_LO_IN_STR,    connect a signal to the LO IN connector on the device, and use the    NIRFSG_ATTR_UPCONVERTER_CENTER_FREQUENCY attribute to specify the LO frequency. 
        ///    To use the internal LO source, set the NIRFSG_ATTR_LO_SOURCE attribute to    NIRFSG_VAL_LO_SOURCE_ONBOARD_STR. If you specify an internal LO source,    the LO is generated inside the device itself. 
        /// 
        /// </summary>
        /// <returns>
        /// </returns>
        public int SetLoSource(string channel, string value)
        {
            return SetString(niRFSGProperties.LoSource, channel, value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Specifies whether to use the internal or external local oscillator (LO) source.    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    To use an external LO source, set this attribute to NIRFSG_VAL_LO_SOURCE_LO_IN_STR,    connect a signal to the LO IN connector on the device, and use the    NIRFSG_ATTR_UPCONVERTER_CENTER_FREQUENCY attribute to specify the LO frequency. 
        ///    To use the internal LO source, set the NIRFSG_ATTR_LO_SOURCE attribute to    NIRFSG_VAL_LO_SOURCE_ONBOARD_STR. If you specify an internal LO source,    the LO is generated inside the device itself. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetLoSource(string channel, out string value)
        {
            return GetString(niRFSGProperties.LoSource, channel, out value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Specifies the step size for tuning the local oscillator (LO) phase-locked loop (PLL). 
        ///    When the NIRFSG_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute is enabled, the specified step size    affects the fractional spur performance of the device. When the NIRFSG_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED    attribute is disabled, the specified step size affects the phase noise performance of the device. 
        ///    The valid values for this attribute depend on the NIRFSG_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute.    If you disable the NIRFSG_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute, the specified value is    coerced to the closest valid value. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetLoFrequencyStepSize(string channel, double value)
        {
            return SetDouble(niRFSGProperties.LoFrequencyStepSize, channel, value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Specifies the step size for tuning the local oscillator (LO) phase-locked loop (PLL). 
        ///    When the NIRFSG_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute is enabled, the specified step size    affects the fractional spur performance of the device. When the NIRFSG_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED    attribute is disabled, the specified step size affects the phase noise performance of the device. 
        ///    The valid values for this attribute depend on the NIRFSG_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute.    If you disable the NIRFSG_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute, the specified value is    coerced to the closest valid value. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetLoFrequencyStepSize(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.LoFrequencyStepSize, channel, out value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Indicates the LO module temperature in degrees Celsius. 
        ///   Units: degrees Celsius (°C) 
        /// 
        /// </summary>
        public int GetLoTemperature(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.LoTemperature, channel, out value);
        }
        //Casing : Change Lo to LO
        /// <summary>
        ///Returns the name of the fully-qualified signal name as a string. 
        /// 
        /// </summary>
        public int GetMarkerEventTerminalName(string channel, out string value)
        {
            return GetString(niRFSGProperties.MarkerEventTerminalName, channel, out value);
        }

        /// <summary>
        ///The total amount of memory on the signal generator in bytes. 
        ///   Note: Not all onboard memory can be used for waveform storage. A portion   of onboard memory stores scripts that specify how the waveforms are   generated. These scripts typically require less than 1 KB of   onboard memory.  
        ///     Units: bytes 
        /// 
        /// </summary>
        public int GetMemorySize(string channel, out long value)
        {
            return GetLong(niRFSGProperties.MemorySize, channel, out value);
        }

        /// <summary>
        ///Returns the module revision letter.  If the NI-RFSG session is controlling multiple devices,  this returns the module revision letter of the primary RF device.  The NI-RFSG session is   opened using the primary RF device name.
        /// 
        /// </summary>
        public int GetModuleRevision(string channel, out string value)
        {
            return GetString(niRFSGProperties.ModuleRevision, channel, out value);
        }

        /// <summary>
        ///Specifies whether signal output is enabled. Setting the   NIRFSG_ATTR_OUTPUT_ENABLED attribute to VI_FALSE while in   the Generation state stops signal output, although generation   continues internally. Setting the NIRFSG_ATTR_OUTPUT_ENABLED   attribute while in the Committed state does not transition the   device to the Configuration state, but output changes immediately. 
        ///   Note: When the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST attribute is set   to a valid list name, setting the NIRFSG_ATTR_OUTPUT_ENABLED   attribute transitions the device to the Configuration state. 
        /// 
        /// </summary>
        public int SetOutputEnabled(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.OutputEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether signal output is enabled. Setting the   NIRFSG_ATTR_OUTPUT_ENABLED attribute to VI_FALSE while in   the Generation state stops signal output, although generation   continues internally. Setting the NIRFSG_ATTR_OUTPUT_ENABLED   attribute while in the Committed state does not transition the   device to the Configuration state, but output changes immediately. 
        ///   Note: When the NIRFSG_ATTR_ACTIVE_CONFIGURATION_LIST attribute is set   to a valid list name, setting the NIRFSG_ATTR_OUTPUT_ENABLED   attribute transitions the device to the Configuration state. 
        /// 
        /// </summary>
        public int GetOutputEnabled(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.OutputEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies the connector(s) to use to generate the signal. To set this attribute,    the NI-RFSG device must be in the Configuration state. 
        ///    You must write complex I and Q data for all options. The Q data has no effect if    you set this attribute to I Only and set the NIRFSG_ATTR_IQ_OUT_PORT_CARRIER_FREQUENCY    attribute to 0. If you set the NIRFSG_ATTR_IQ_OUT_PORT_CARRIER_FREQUENCY attribute to a    value other than 0, the onboard signal processing (OSP) frequency shifts I and Q as a complex    value and outputs the real portion of the result on the I connector(s) of the device. 
        ///    If you set the NIRFSG_ATTR_OUTPUT_PORT attribute to NIRFSG_VAL_I_ONLY or NIRFSG_VAL_IQ_OUT,    the NIRFSG_ATTR_IQ_OUT_PORT_TERMINAL_CONFIGURATION attribute applies. 
        /// 
        /// </summary>
        public int SetOutputPort(string channel, int value)
        {
            return SetInt32(niRFSGProperties.OutputPort, channel, value);
        }
        /// <summary>
        ///Specifies the connector(s) to use to generate the signal. To set this attribute,    the NI-RFSG device must be in the Configuration state. 
        ///    You must write complex I and Q data for all options. The Q data has no effect if    you set this attribute to I Only and set the NIRFSG_ATTR_IQ_OUT_PORT_CARRIER_FREQUENCY    attribute to 0. If you set the NIRFSG_ATTR_IQ_OUT_PORT_CARRIER_FREQUENCY attribute to a    value other than 0, the onboard signal processing (OSP) frequency shifts I and Q as a complex    value and outputs the real portion of the result on the I connector(s) of the device. 
        ///    If you set the NIRFSG_ATTR_OUTPUT_PORT attribute to NIRFSG_VAL_I_ONLY or NIRFSG_VAL_IQ_OUT,    the NIRFSG_ATTR_IQ_OUT_PORT_TERMINAL_CONFIGURATION attribute applies. 
        /// 
        /// </summary>
        public int GetOutputPort(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.OutputPort, channel, out value);
        }

        /// <summary>
        ///Specifies the initial amount of data that the writer peer    can transfer over the bus into the configured endpoint when the    peer-to-peer data stream is enabled. If this attribute is not    set and the endpoint is empty, credits equal to the full endpoint    size are issued to the writer peer. If data is written to the    endpoint using the niRFSG_WriteP2PEndpointI16 function prior to    enabling the stream, credits equal to the remaining space available    in the endpoint are issued to the writer peer. This attribute is    coerced up by NI-RFSG to 8-byte boundaries.     This attribute is endpoint based 
        ///    Units: samples per channel 
        /// 
        /// </summary>
        public int SetP2pDataTransferPermissionitialCredits(string channel, long value)
        {
            return SetLong(niRFSGProperties.P2pDataTransferPermissionitialCredits, channel, value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Specifies the initial amount of data that the writer peer    can transfer over the bus into the configured endpoint when the    peer-to-peer data stream is enabled. If this attribute is not    set and the endpoint is empty, credits equal to the full endpoint    size are issued to the writer peer. If data is written to the    endpoint using the niRFSG_WriteP2PEndpointI16 function prior to    enabling the stream, credits equal to the remaining space available    in the endpoint are issued to the writer peer. This attribute is    coerced up by NI-RFSG to 8-byte boundaries.     This attribute is endpoint based 
        ///    Units: samples per channel 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetP2pDataTransferPermissionitialCredits(string channel, out long value)
        {
            return GetLong(niRFSGProperties.P2pDataTransferPermissionitialCredits, channel, out value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Specifies the interval at which the RF signal generator issues    credits to allow the writer peer to transfer data over the bus into    the configured endpoint. Refer to the Flow Control topic in the    NI RF Signal Generators Help for more information. This attribute is    coerced up by NI-RFSG to the nearest 128-byte boundary.    This attribute is endpoint based.   
        ///    Units: samples per channel 
        /// 
        /// </summary>
        public int SetP2pDataTransferPermissionInterval(string channel, long value)
        {
            return SetLong(niRFSGProperties.P2pDataTransferPermissionInterval, channel, value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Specifies the interval at which the RF signal generator issues    credits to allow the writer peer to transfer data over the bus into    the configured endpoint. Refer to the Flow Control topic in the    NI RF Signal Generators Help for more information. This attribute is    coerced up by NI-RFSG to the nearest 128-byte boundary.    This attribute is endpoint based.   
        ///    Units: samples per channel 
        /// 
        /// </summary>
        public int GetP2pDataTransferPermissionInterval(string channel, out long value)
        {
            return GetLong(niRFSGProperties.P2pDataTransferPermissionInterval, channel, out value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Specifies whether the device reads data from the peer-to-peer    endpoint.  This attribute is endpoint-based. 
        /// 
        /// </summary>
        public int SetP2pEnabled(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.P2pEnabled, channel, value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Specifies whether the device reads data from the peer-to-peer    endpoint.  This attribute is endpoint-based. 
        /// 
        /// </summary>
        public int GetP2pEnabled(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.P2pEnabled, channel, out value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Returns the number of peer-to-peer FIFO endpoints supported by the device. 
        /// 
        /// </summary>
        public int GetP2pEndpointCount(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.P2pEndpointCount, channel, out value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Specifies the number of samples needed to be received by the endpoint before    the device starts generation. This attribute applies only when the    NIRFSG_ATTR_START_TRIGGER_TYPE attribute is set to    NIRFSG_VAL_P2P_ENDPOINT_FULLNESS.
        /// 
        /// </summary>
        public int SetP2pEndpointFullnessStartTriggerLevel(string channel, long value)
        {
            return SetLong(niRFSGProperties.P2pEndpointFullnessStartTriggerLevel, channel, value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Specifies the number of samples needed to be received by the endpoint before    the device starts generation. This attribute applies only when the    NIRFSG_ATTR_START_TRIGGER_TYPE attribute is set to    NIRFSG_VAL_P2P_ENDPOINT_FULLNESS.
        /// 
        /// </summary>
        public int GetP2pEndpointFullnessStartTriggerLevel(string channel, out long value)
        {
            return GetLong(niRFSGProperties.P2pEndpointFullnessStartTriggerLevel, channel, out value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Returns the size, in samples, of the device's endpoint.    This attribute is endpoint-based. 
        /// 
        /// </summary>
        public int GetP2pEndpointSize(string channel, out long value)
        {
            return GetLong(niRFSGProperties.P2pEndpointSize, channel, out value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Returns the largest number of samples per channel available in the endpoint since    this attribute was last read. You can use this attribute to determine how much    endpoint space to use as a buffer against bus traffic latencies by reading    the attribute and keeping track of the largest value returned.    This attribute is endpoint based. 
        ///    If you want to minimize the latency for data to move through the endpoint    and be generated by the RF signal generator, use the    NIRFSG_ATTR_P2P_DATA_TRANSFER_PERMISSION_INITIAL_CREDITS attribute to grant    fewer initial credits than the default of the entire endpoint size. 
        ///    Units: samples per channel 
        /// 
        /// </summary>
        public int GetP2pMostSpaceAvailableInEndpoint(string channel, out long value)
        {
            return GetLong(niRFSGProperties.P2pMostSpaceAvailableInEndpoint, channel, out value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Returns the current space available in the endpoint. You can use this    attribute when priming the endpoint with initial data using the    niRFSG_WriteP2PEndpointI16 function to determine how many samples    you can write. You also can use this attribute to characterize the    performance and measure the latency of the peer-to-peer stream as data    moves across the bus. This attribute is endpoint based. 
        ///    Units: samples per channel 
        /// 
        /// </summary>
        public int GetP2pSpaceAvailableInEndpoint(string channel, out long value)
        {
            return GetLong(niRFSGProperties.P2pSpaceAvailableInEndpoint, channel, out value);
        }
        //Confirm casing : P2p or P2P
        /// <summary>
        ///Specifies the maximum instantaneous power of the current RF output signal.   
        ///   Note: This attribute is valid only when the NIRFSG_ATTR_POWER_LEVEL_TYPE   attribute is set to NIRFSG_VAL_AVERAGE_POWER. 
        ///   Units: dBm 
        /// 
        /// </summary>
        public int GetPeakEnvelopePower(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.PeakEnvelopePower, channel, out value);
        }

        /// <summary>
        ///Determines the inheritance behavior of the NIRFSG_ATTR_PEAK_POWER_ADJUSTMENT    attribute when a script inherits values from specified waveforms. 
        /// 
        /// </summary>
        public int SetPeakPowerAdjsutmentInheritance(string channel, int value)
        {
            return SetInt32(niRFSGProperties.PeakPowerAdjsutmentInheritance, channel, value);
        }

        /// <summary>
        ///Determines the inheritance behavior of the NIRFSG_ATTR_PEAK_POWER_ADJUSTMENT    attribute when a script inherits values from specified waveforms. 
        /// 
        /// </summary>
        public int GetPeakPowerAdjsutmentInheritance(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.PeakPowerAdjsutmentInheritance, channel, out value);
        }

        /// <summary>
        ///Specifies the adjustment for the NIRFSG_ATTR_POWER_LEVEL attribute.    The value of the NIRFSG_ATTR_PEAK_POWER_ADJUSTMENT attribute adds    to the NIRFSG_ATTR_POWER_LEVEL attribute. The NIRFSG_ATTR_PEAK_POWER_ADJUSTMENT    attribute typically specifies the peak-to-average power ratio (PAPR) of    a waveform. If the PAPR is specified, the specified power level becomes    the average power level of the waveform, even if the    NIRFSG_ATTR_POWER_LEVEL_TYPE attribute is set to NIRFSG_VAL_PEAK_POWER. 
        ///    Note: Use this attribute to associate a peak power adjustment with a waverform.   Refer to the Assigning Properties or Attributes to a Waveform topic of the    NI RFSG Main Help for more information. 
        /// 
        /// </summary>
        public int SetPeakPowerAdjustment(string channel, double value)
        {
            return SetDouble(niRFSGProperties.PeakPowerAdjustment, channel, value);
        }

        /// <summary>
        ///Specifies the adjustment for the NIRFSG_ATTR_POWER_LEVEL attribute.    The value of the NIRFSG_ATTR_PEAK_POWER_ADJUSTMENT attribute adds    to the NIRFSG_ATTR_POWER_LEVEL attribute. The NIRFSG_ATTR_PEAK_POWER_ADJUSTMENT    attribute typically specifies the peak-to-average power ratio (PAPR) of    a waveform. If the PAPR is specified, the specified power level becomes    the average power level of the waveform, even if the    NIRFSG_ATTR_POWER_LEVEL_TYPE attribute is set to NIRFSG_VAL_PEAK_POWER. 
        ///    Note: Use this attribute to associate a peak power adjustment with a waverform.   Refer to the Assigning Properties or Attributes to a Waveform topic of the    NI RFSG Main Help for more information. 
        /// 
        /// </summary>
        public int GetPeakPowerAdjustment(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.PeakPowerAdjustment, channel, out value);
        }

        /// <summary>
        ///Specifies whether the driver maintains phase continuity in the   arbitrary waveforms. When this attribute is set to   NIRFSG_VAL_ENABLE, NI-RFSG may increase the waveform size. When   this attribute is set to NIRFSG_VAL_ENABLE, the   NIRFSG_ATTR_FREQUENCY_TOLERANCE attribute specifies the maximum   allowable frequency error that can be introduced when keeping the   signal phase-continuous. To set the NIRFSG_ATTR_PHASE_CONTINUITY_ENABLED   attribute, the NI-RFSG device must be in the Configuration state.   NIRFSG_ATTR_PHASE_CONTINUITY_ENABLED applies only when the   NIRFSG_ATTR_GENERATION_MODE attribute is set to   NIRFSG_VAL_ARB_WAVEFORM or NIRFSG_VAL_SCRIPT. 
        ///   On the NI 5671: When using the NI 5671 with I/Q rates less than or equal   to 8.33 MS/s, an input phase-continuous signal is always phase-continuous   upon output, and this attribute has no effect. 
        ///   NI 5672/5673/5673E: Phase continuity is always enabled on this device. 
        /// 
        /// </summary>
        public int SetPhaseContinuityEnabled(string channel, int value)
        {
            return SetInt32(niRFSGProperties.PhaseContinuityEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether the driver maintains phase continuity in the   arbitrary waveforms. When this attribute is set to   NIRFSG_VAL_ENABLE, NI-RFSG may increase the waveform size. When   this attribute is set to NIRFSG_VAL_ENABLE, the   NIRFSG_ATTR_FREQUENCY_TOLERANCE attribute specifies the maximum   allowable frequency error that can be introduced when keeping the   signal phase-continuous. To set the NIRFSG_ATTR_PHASE_CONTINUITY_ENABLED   attribute, the NI-RFSG device must be in the Configuration state.   NIRFSG_ATTR_PHASE_CONTINUITY_ENABLED applies only when the   NIRFSG_ATTR_GENERATION_MODE attribute is set to   NIRFSG_VAL_ARB_WAVEFORM or NIRFSG_VAL_SCRIPT. 
        ///   On the NI 5671: When using the NI 5671 with I/Q rates less than or equal   to 8.33 MS/s, an input phase-continuous signal is always phase-continuous   upon output, and this attribute has no effect. 
        ///   NI 5672/5673/5673E: Phase continuity is always enabled on this device. 
        /// 
        /// </summary>
        public int GetPhaseContinuityEnabled(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.PhaseContinuityEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies the phase of the RF output signal. You can use this attribute   to align the phase of the RF output with the phase of the RF output of   another device, as long as the two devices are phase-coherent. 
        ///   Units: degrees (º) 
        /// 
        /// </summary>
        public int SetPhaseOffset(string channel, double value)
        {
            return SetDouble(niRFSGProperties.PhaseOffset, channel, value);
        }

        /// <summary>
        ///Specifies the phase of the RF output signal. You can use this attribute   to align the phase of the RF output with the phase of the RF output of   another device, as long as the two devices are phase-coherent. 
        ///   Units: degrees (º) 
        /// 
        /// </summary>
        public int GetPhaseOffset(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.PhaseOffset, channel, out value);
        }

        /// <summary>
        ///Specifies either the average power level or peak power level of the   generated RF signal, depending on the NIRFSG_ATTR_POWER_LEVEL_TYPE   attribute setting. average power of the signal or the peak power of the   signal. 
        ///   Refer to the specifications document for your device for allowable   power level settings. 
        ///   Note: This attribute is read-only for the NI 5653 device.   It is read/write for all other supported devices. 
        ///   Units: dBm 
        /// 
        /// </summary>
        public int SetPowerLevel(string channel, double value)
        {
            return SetDouble(niRFSGProperties.PowerLevel, channel, value);
        }

        /// <summary>
        ///Specifies either the average power level or peak power level of the   generated RF signal, depending on the NIRFSG_ATTR_POWER_LEVEL_TYPE   attribute setting. average power of the signal or the peak power of the   signal. 
        ///   Refer to the specifications document for your device for allowable   power level settings. 
        ///   Note: This attribute is read-only for the NI 5653 device.   It is read/write for all other supported devices. 
        ///   Units: dBm 
        /// 
        /// </summary>
        public int GetPowerLevel(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.PowerLevel, channel, out value);
        }

        /// <summary>
        ///Specifies how NI-RFSG interprets the value of the   NIRFSG_ATTR_POWER_LEVEL attribute.  The NIRFSG_ATTR_POWER_LEVEL_TYPE   attribute also affects how waveforms are scaled.
        /// 
        /// </summary>
        public int SetPowerLevelType(string channel, int value)
        {
            return SetInt32(niRFSGProperties.PowerLevelType, channel, value);
        }

        /// <summary>
        ///Specifies how NI-RFSG interprets the value of the   NIRFSG_ATTR_POWER_LEVEL attribute.  The NIRFSG_ATTR_POWER_LEVEL_TYPE   attribute also affects how waveforms are scaled.
        /// 
        /// </summary>
        public int GetPowerLevelType(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.PowerLevelType, channel, out value);
        }

        /// <summary>
        ///Enables or disables pulse modulation.  If this property is enabled and the   signal at the PLS MOD connector is high, the device generates a signal. If   the signal is low, output generation is disabled. 
        /// 
        /// </summary>
        public int SetPulseModulationEnabled(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.PulseModulationEnabled, channel, value);
        }

        /// <summary>
        ///Enables or disables pulse modulation.  If this property is enabled and the   signal at the PLS MOD connector is high, the device generates a signal. If   the signal is low, output generation is disabled. 
        /// 
        /// </summary>
        public int GetPulseModulationEnabled(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.PulseModulationEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies the clock source for driving the PXI 10 MHz backplane reference   clock. This option can only be configured if the NI 5610 upconverter   module is installed in Slot 2 of a PXI chassis. To set this attribute, the   NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetPxiChassisClk10Source(string channel, string value)
        {
            return SetString(niRFSGProperties.PxiChassisClk10Source, channel, value);
        }

        /// <summary>
        ///Specifies the clock source for driving the PXI 10 MHz backplane reference   clock. This option can only be configured if the NI 5610 upconverter   module is installed in Slot 2 of a PXI chassis. To set this attribute, the   NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int GetPxiChassisClk10Source(string channel, out string value)
        {
            return GetString(niRFSGProperties.PxiChassisClk10Source, channel, out value);
        }

        /// <summary>
        ///Specifies whether NI-RFSG queries the NI-RFSG device status   after each operation. Querying the device status is useful   for debugging. After you validate your program, set this attribute   to VI_FALSE to disable status checking and maximize performance.   NI-RFSG can choose to ignore status checking for particular attributes,   regardless of the setting of this attribute. Use the niRFSG_InitWithOptions   function to override the default value. 
        /// 
        /// </summary>
        public int SetQueryInstrumentStatus(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.QueryInstrumentStatus, channel, value);
        }

        /// <summary>
        ///Specifies whether NI-RFSG queries the NI-RFSG device status   after each operation. Querying the device status is useful   for debugging. After you validate your program, set this attribute   to VI_FALSE to disable status checking and maximize performance.   NI-RFSG can choose to ignore status checking for particular attributes,   regardless of the setting of this attribute. Use the niRFSG_InitWithOptions   function to override the default value. 
        /// 
        /// </summary>
        public int GetQueryInstrumentStatus(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.QueryInstrumentStatus, channel, out value);
        }

        /// <summary>
        ///Specifies whether to validate attribute values and function   parameters. Range checking parameters is very useful for debugging.   After you validate your program, set this attribute to VI_FALSE to disable   range checking and maximize performance. Use the niRFSG_InitWithOptions   function to override the default value. 
        /// 
        /// </summary>
        public int SetRangeCheck(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.RangeCheck, channel, value);
        }

        /// <summary>
        ///Specifies whether to validate attribute values and function   parameters. Range checking parameters is very useful for debugging.   After you validate your program, set this attribute to VI_FALSE to disable   range checking and maximize performance. Use the niRFSG_InitWithOptions   function to override the default value. 
        /// 
        /// </summary>
        public int GetRangeCheck(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.RangeCheck, channel, out value);
        }

        /// <summary>
        ///Specifies whether the IVI engine keeps a list of the value coercions it   makes for integer and real type attributes.
        ///   This attribute is currently not supported.
        /// 
        /// </summary>
        public int SetRecordCoercions(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.RecordCoercions, channel, value);
        }

        /// <summary>
        ///Specifies whether the IVI engine keeps a list of the value coercions it   makes for integer and real type attributes.
        ///   This attribute is currently not supported.
        /// 
        /// </summary>
        public int GetRecordCoercions(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.RecordCoercions, channel, out value);
        }

        /// <summary>
        ///Specifies the rate of the reference clock. NI-RFSG supports only   a Reference clock rate of 10 MHz.To set this attribute, the   NI-RFSG device must be in the Configuration state.
        ///    Units: hertz (Hz) 
        /// 
        /// </summary>
        public int SetRefClockRate(string channel, double value)
        {
            return SetDouble(niRFSGProperties.RefClockRate, channel, value);
        }

        /// <summary>
        ///Specifies the rate of the reference clock. NI-RFSG supports only   a Reference clock rate of 10 MHz.To set this attribute, the   NI-RFSG device must be in the Configuration state.
        ///    Units: hertz (Hz) 
        /// 
        /// </summary>
        public int GetRefClockRate(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.RefClockRate, channel, out value);
        }

        /// <summary>
        ///Specifies the reference clock source. To set this attribute, the NI-RFSG   device must be in the Configuration state. Only certain combinations   of this attribute and the NIRFSG_ATTR_PXI_CHASSIS_CLK10_SOURCE   attribute are valid
        ///   Note: NI 5670/5671/5672 devices also allow you to drive the PXI 10 MHz   backplane clock on PXI chassis only using the   NIRFSG_ATTR_PXI_CHASSIS_CLK10_SOURCE attribute. 
        /// 
        /// </summary>
        public int SetRefClockSource(string channel, string value)
        {
            return SetString(niRFSGProperties.RefClockSource, channel, value);
        }

        /// <summary>
        ///Specifies the reference clock source. To set this attribute, the NI-RFSG   device must be in the Configuration state. Only certain combinations   of this attribute and the NIRFSG_ATTR_PXI_CHASSIS_CLK10_SOURCE   attribute are valid
        ///   Note: NI 5670/5671/5672 devices also allow you to drive the PXI 10 MHz   backplane clock on PXI chassis only using the   NIRFSG_ATTR_PXI_CHASSIS_CLK10_SOURCE attribute. 
        /// 
        /// </summary>
        public int GetRefClockSource(string channel, out string value)
        {
            return GetString(niRFSGProperties.RefClockSource, channel, out value);
        }

        /// <summary>
        ///Configures the loop bandwidth of the reference PLL.
        /// 
        /// </summary>
        public int SetRefPllBandwidth(string channel, int value)
        {
            return SetInt32(niRFSGProperties.RefPllBandwidth, channel, value);
        }
        /// <summary>
        ///Configures the loop bandwidth of the reference PLL.
        /// 
        /// </summary>
        public int GetRefPllBandwidth(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.RefPllBandwidth, channel, out value);
        }

        /// <summary>
        ///Specifies the marker event at which RF blanking occurs. RF blanking quickly attenuates the RF OUT signal.    Use marker events to toggle the state of RF blanking. The RF Output always starts in the unblanked state. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    You can specify marker events by using scripts to trigger blanking at a certain point in a waveform.    For example, if you set this attribute to NIRFSG_VAL_MARKER0, and marker0 occurs on samples 1,000    and 2,000 of a script, then the RF Output will be blanked (attenuated) between samples 1,000 and 2,000. 
        ///    Note: The shortest supported blanking interval is eight microseconds. 
        /// 
        /// </summary>
        public int SetRfBlankingSource(string channel, string value)
        {
            return SetString(niRFSGProperties.RfBlankingSource, channel, value);
        }
        //Confirm casing : Rf or RF
        /// <summary>
        ///Specifies the marker event at which RF blanking occurs. RF blanking quickly attenuates the RF OUT signal.    Use marker events to toggle the state of RF blanking. The RF Output always starts in the unblanked state. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    You can specify marker events by using scripts to trigger blanking at a certain point in a waveform.    For example, if you set this attribute to NIRFSG_VAL_MARKER0, and marker0 occurs on samples 1,000    and 2,000 of a script, then the RF Output will be blanked (attenuated) between samples 1,000 and 2,000. 
        ///    Note: The shortest supported blanking interval is eight microseconds. 
        /// 
        /// </summary>
        public int GetRfBlankingSource(string channel, out string value)
        {
            return GetString(niRFSGProperties.RfBlankingSource, channel, out value);
        }
        //Confirm casing : Rf or RF
        /// <summary>
        ///Returns the name of the fully-qualified signal name as a string.
        /// 
        /// </summary>
        public int GetScriptTriggerTerminalName(string channel, out string value)
        {
            return GetString(niRFSGProperties.ScriptTriggerTerminalName, channel, out value);
        }

        /// <summary>
        ///Specifies the script trigger type. Depending upon the value of this   attribute, more attributes may be needed to fully configure the trigger.   To set this attribute, the NI-RFSG device must be in the Configuration   state.
        /// 
        /// </summary>
        public int SetScriptTriggerType(string channel, int value)
        {
            return SetInt32(niRFSGProperties.ScriptTriggerType, channel, value);
        }

        /// <summary>
        ///Specifies the script trigger type. Depending upon the value of this   attribute, more attributes may be needed to fully configure the trigger.   To set this attribute, the NI-RFSG device must be in the Configuration   state.
        /// 
        /// </summary>
        public int GetScriptTriggerType(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.ScriptTriggerType, channel, out value);
        }

        /// <summary>
        ///Specifies the script in onboard memory to generate upon calling the   niRFSG_Initiate function when NIRFSG_ATTR_GENERATION_MODE is set to   NIRFSG_VAL_SCRIPT.  
        ///   The NIRFSG_ATTR_SELECTED_SCRIPT attribute is ignored   when the NIRFSG_ATTR_GENERATION_MODE attribute is set to   NIRFSG_VAL_ARB_WAVEFORM or NIRFSG_VAL_CW. To set the   NIRFSG_ATTR_SELECTED_SCRIPT attribute, the NI-RFSG device must be in the   Configuration state.
        /// 
        /// </summary>
        public int SetSelectedScript(string channel, string value)
        {
            return SetString(niRFSGProperties.SelectedScript, channel, value);
        }

        /// <summary>
        ///Specifies the script in onboard memory to generate upon calling the   niRFSG_Initiate function when NIRFSG_ATTR_GENERATION_MODE is set to   NIRFSG_VAL_SCRIPT.  
        ///   The NIRFSG_ATTR_SELECTED_SCRIPT attribute is ignored   when the NIRFSG_ATTR_GENERATION_MODE attribute is set to   NIRFSG_VAL_ARB_WAVEFORM or NIRFSG_VAL_CW. To set the   NIRFSG_ATTR_SELECTED_SCRIPT attribute, the NI-RFSG device must be in the   Configuration state.
        /// 
        /// </summary>
        public int GetSelectedScript(string channel, out string value)
        {
            return GetString(niRFSGProperties.SelectedScript, channel, out value);
        }

        /// <summary>
        ///Indicates in degrees Celsius the temperature of the device at the time of   the last self calibration. 
        /// 
        /// </summary>
        public int GetSelfCalibrationTemperature(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.SelfCalibrationTemperature, channel, out value);
        }

        /// <summary>
        ///Returns the serial number of the RF module.
        /// 
        /// </summary>
        public int GetSerialNumber(string channel, out string value)
        {
            return GetString(niRFSGProperties.SerialNumber, channel, out value);
        }

        /// <summary>
        ///Specifies the bandwidth of the arbitrary signal. 
        ///   This value must be less than or equal to (0.8 * IQ rate).  
        /// 
        /// </summary>
        public int SetSignalBandwidth(string channel, double value)
        {
            return SetDouble(niRFSGProperties.SignalBandwidth, channel, value);
        }

        /// <summary>
        ///Specifies the bandwidth of the arbitrary signal. 
        ///   This value must be less than or equal to (0.8 * IQ rate).  
        /// 
        /// </summary>
        public int GetSignalBandwidth(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.SignalBandwidth, channel, out value);
        }

        /// <summary>
        ///Returns whether NI-RFSG simulates I/O operations. This attribute   is useful for debugging applications without using hardware.   Once a session is opened, you cannot change the simulation state.   Use the niRFSG_InitWithOptions function to enable simulation.
        /// 
        /// </summary>
        public int GetSimulate(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.Simulate, channel, out value);
        }

        /// <summary>
        ///Returns the major version number of the class specification with which   NI-RFSG is compliant.
        /// 
        /// </summary>
        public int GetSpecificDriverClassSpecMajorVersion(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.SpecificDriverClassSpecMajorVersion, channel, out value);
        }

        /// <summary>
        ///Returns the minor version number of the class specification with which   NI-RFSG is compliant.
        /// 
        /// </summary>
        public int GetSpecificDriverClassSpecMinorVersion(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.SpecificDriverClassSpecMinorVersion, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains a brief description of NI-RFSG.
        /// 
        /// </summary>
        public int GetSpecificDriverDescription(string channel, out string value)
        {
            return GetString(niRFSGProperties.SpecificDriverDescription, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains the prefix for NI-RFSG. The name of each   user-callable function in NI-RFSG starts with this prefix.
        /// 
        /// </summary>
        public int GetSpecificDriverPrefix(string channel, out string value)
        {
            return GetString(niRFSGProperties.SpecificDriverPrefix, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains additional version information about   NI-RFSG.
        /// 
        /// </summary>
        public int GetSpecificDriverRevision(string channel, out string value)
        {
            return GetString(niRFSGProperties.SpecificDriverRevision, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains the name of the vendor that supplies   NI-RFSG.
        /// 
        /// </summary>
        public int GetSpecificDriverVendor(string channel, out string value)
        {
            return GetString(niRFSGProperties.SpecificDriverVendor, channel, out value);
        }

        /// <summary>
        ///Returns the name of the fully-qualified signal name as a string. 
        /// 
        /// </summary>
        public int GetStartedEventTerminalName(string channel, out string value)
        {
            return GetString(niRFSGProperties.StartedEventTerminalName, channel, out value);
        }

        /// <summary>
        ///Returns the name of the fully-qualified signal name as a string.
        /// 
        /// </summary>
        public int GetStartTriggerTerminalName(string channel, out string value)
        {
            return GetString(niRFSGProperties.StartTriggerTerminalName, channel, out value);
        }

        /// <summary>
        ///Specifies the start trigger type. Depending upon the value of this   attribute, more attributes may be needed to fully configure the trigger.   To set this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int SetStartTriggerType(string channel, int value)
        {
            return SetInt32(niRFSGProperties.StartTriggerType, channel, value);
        }

        /// <summary>
        ///Specifies the start trigger type. Depending upon the value of this   attribute, more attributes may be needed to fully configure the trigger.   To set this attribute, the NI-RFSG device must be in the Configuration state.
        /// 
        /// </summary>
        public int GetStartTriggerType(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.StartTriggerType, channel, out value);
        }

        /// <summary>
        ///Enables or disables streaming of waveform data.
        /// 
        /// </summary>
        public int SetStreamingEnabled(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.StreamingEnabled, channel, value);
        }

        /// <summary>
        ///Enables or disables streaming of waveform data.
        /// 
        /// </summary>
        public int GetStreamingEnabled(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.StreamingEnabled, channel, out value);
        }

        /// <summary>
        ///Indicates the space available in samples in the streaming   waveform for writing new data. For optimal performance, write   new data to the waveform in a fixed size that is an integer   divisor of the total size of the streaming waveform.   This waveform size ensures that writes do not have to wrap   around from the end to the beginning of the waveform buffer. 
        ///   To read this attribute, the NI-RFSG device must be in   the Committed state. 
        ///   Units: Samples 
        /// 
        /// </summary>
        public int GetStreamingSpaceAvailableInWaveform(string channel, out long value)
        {
            return GetLong(niRFSGProperties.StreamingSpaceAvailableInWaveform, channel, out value);
        }

        /// <summary>
        ///Specifies the name of the waveform used to continuously stream data during   generation.
        /// 
        /// </summary>
        public int SetStreamingWaveformName(string channel, string value)
        {
            return SetString(niRFSGProperties.StreamingWaveformName, channel, value);
        }

        /// <summary>
        ///Specifies the name of the waveform used to continuously stream data during   generation.
        /// 
        /// </summary>
        public int GetStreamingWaveformName(string channel, out string value)
        {
            return GetString(niRFSGProperties.StreamingWaveformName, channel, out value);
        }

        /// <summary>
        ///Indicates the maximum amount of time allowed to complete a streaming write operation.
        /// 
        /// </summary>
        public int SetStreamingWriteTimeout(string channel, double value)
        {
            return SetDouble(niRFSGProperties.StreamingWriteTimeout, channel, value);
        }

        /// <summary>
        ///Indicates the maximum amount of time allowed to complete a streaming write operation.
        /// 
        /// </summary>
        public int GetStreamingWriteTimeout(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.StreamingWriteTimeout, channel, out value);
        }

        /// <summary>
        ///Returns a model code of the NI-RFSG device.   For drivers that support more than one device,   this attribute contains a comma-separated list of supported devices. 
        /// 
        /// </summary>
        public int GetSupportedInstrumentModels(string channel, out string value)
        {
            return GetString(niRFSGProperties.SupportedInstrumentModels, channel, out value);
        }

        /// <summary>
        ///Specifies which external trigger line distributes the Sample Clock sync signal.    When synchronizing the Sample Clock, configure all devices to use the same Sample Clock sync distribution line.
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state.
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic in the NI RF Signal Generators Help    for more information about NI 5646R device synchronization.
        /// 
        /// </summary>
        public int GetSyncSampleClockDistLine(string channel, out string value)
        {
            return GetString(niRFSGProperties.SyncSampleClockDistLine, channel, out value);
        }

        /// <summary>
        ///Specifies which external trigger line distributes the Sample Clock sync signal.    When synchronizing the Sample Clock, configure all devices to use the same Sample Clock sync distribution line.
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state.
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic in the NI RF Signal Generators Help    for more information about NI 5646R device synchronization.
        /// 
        /// </summary>
        public int SetSyncSampleClockDistLine(string channel, string value)
        {
            return SetString(niRFSGProperties.SyncSampleClockDistLine, channel, value);
        }

        /// <summary>
        ///Specifies whether the device is the master device when synchronizing the Sample Clock between multiple devices. 
        ///    The master device distributes the Sample Clock sync signal to all devices in the system through the Sample     Clock sync distribution line. 
        ///    When synchronizing the Sample Clock, one device must always be designated as the master.    The master device actively drives the Sample Clock sync distribution line. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state.
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic in the NI RF Signal Generators Help    for more information about NI 5646R device synchronization.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetSyncSampleClockMaster(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.SyncSampleClockMaster, channel, out value);
        }

        /// <summary>
        ///Specifies whether the device is the master device when synchronizing the Sample Clock between multiple devices. 
        ///    The master device distributes the Sample Clock sync signal to all devices in the system through the Sample     Clock sync distribution line. 
        ///    When synchronizing the Sample Clock, one device must always be designated as the master.    The master device actively drives the Sample Clock sync distribution line. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state.
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic in the NI RF Signal Generators Help    for more information about NI 5646R device synchronization.
        /// 
        /// </summary>
        public int SetSyncSampleClockMaster(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.SyncSampleClockMaster, channel, value);
        }

        /// <summary>
        ///Specifies which external trigger line distributes the synchronized Script Trigger signal.    When synchronizing the Script Trigger, configure all devices to use the same Script Trigger distribution line. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the    NI RF Signal Generators Help for more information about device synchronization for vector signal transceivers. 
        /// 
        /// </summary>
        public int GetSyncScriptTriggerDistLine(string channel, out string value)
        {
            return GetString(niRFSGProperties.SyncScriptTriggerDistLine, channel, out value);
        }

        /// <summary>
        ///Specifies which external trigger line distributes the synchronized Script Trigger signal.    When synchronizing the Script Trigger, configure all devices to use the same Script Trigger distribution line. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the    NI RF Signal Generators Help for more information about device synchronization for vector signal transceivers. 
        /// 
        /// </summary>
        public int SetSyncScriptTriggerDistLine(string channel, string value)
        {
            return SetString(niRFSGProperties.SyncScriptTriggerDistLine, channel, value);
        }

        /// <summary>
        ///Specifies whether the device is the master device when synchronizing the Script Trigger between multiple devices. 
        ///    The master device distributes the synchronized Script Trigger to all devices in the system through the Script Trigger distribution line. 
        ///    When synchronizing the Script Trigger, one device must always be designated as the master.    The master device actively drives the Script Trigger distribution line. For slave devices, set the    NIRFSG_ATTR_SCRIPT_TRIGGER_TYPE attribute to NIRFSG_VAL_DIGITAL_EDGE, and set the    NIRFSG_ATTR_DIGITAL_EDGE_SCRIPT_TRIGGER_SOURCE attribute to sync_script. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the    NI RF Signal Generators Help for more information about device synchronization for vector signal transceivers. 
        /// 
        /// </summary>
        public int GetSyncScriptTriggerMaster(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.SyncScriptTriggerMaster, channel, out value);
        }

        /// <summary>
        ///Specifies whether the device is the master device when synchronizing the Script Trigger between multiple devices. 
        ///    The master device distributes the synchronized Script Trigger to all devices in the system through the Script Trigger distribution line. 
        ///    When synchronizing the Script Trigger, one device must always be designated as the master.    The master device actively drives the Script Trigger distribution line. For slave devices, set the    NIRFSG_ATTR_SCRIPT_TRIGGER_TYPE attribute to NIRFSG_VAL_DIGITAL_EDGE, and set the    NIRFSG_ATTR_DIGITAL_EDGE_SCRIPT_TRIGGER_SOURCE attribute to sync_script. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the    NI RF Signal Generators Help for more information about device synchronization for vector signal transceivers. 
        /// 
        /// </summary>
        public int SetSyncScriptTriggerMaster(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.SyncScriptTriggerMaster, channel, value);
        }

        /// <summary>
        ///Specifies which external trigger line distributes the synchronized Start Trigger signal. When synchronizing the Start Trigger,    configure all devices to use the same Start Trigger distribution line. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the    NI RF Signal Generators Help for more information about device synchronization for vector signal transceivers. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetSyncStartTriggerDistLine(string channel, out string value)
        {
            return GetString(niRFSGProperties.SyncStartTriggerDistLine, channel, out value);
        }

        /// <summary>
        ///Specifies which external trigger line distributes the synchronized Start Trigger signal. When synchronizing the Start Trigger,    configure all devices to use the same Start Trigger distribution line. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the    NI RF Signal Generators Help for more information about device synchronization for vector signal transceivers. 
        /// 
        /// </summary>
        public int SetSyncStartTriggerDistLine(string channel, string value)
        {
            return SetString(niRFSGProperties.SyncStartTriggerDistLine, channel, value);
        }

        /// <summary>
        ///Specifies whether the device is the master device when synchronizing the Start Trigger between multiple devices. 
        ///    The master device distributes the synchronized Start Trigger to all devices in the system through the Start Trigger distribution line. 
        ///    When synchronizing the Start Trigger, one device must always be designated as the master.    The master device actively drives the Start Trigger distribution line. For slave devices, set the NIRFSG_ATTR_START_TRIGGER_TYPE    attribute to NIRFSG_VAL_DIGITAL_EDGE, and set the NIRFSG_ATTR_DIGITAL_EDGE_START_TRIGGER_SOURCE attribute to sync_script. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the    NI RF Signal Generators Help for more information about device synchronization for vector signal transceivers. 
        /// 
        /// </summary>
        public int GetSyncStartTriggerMaster(string channel, out bool value)
        {
            return GetBoolean(niRFSGProperties.SyncStartTriggerMaster, channel, out value);
        }

        /// <summary>
        ///Specifies whether the device is the master device when synchronizing the Start Trigger between multiple devices. 
        ///    The master device distributes the synchronized Start Trigger to all devices in the system through the Start Trigger distribution line. 
        ///    When synchronizing the Start Trigger, one device must always be designated as the master.    The master device actively drives the Start Trigger distribution line. For slave devices, set the NIRFSG_ATTR_START_TRIGGER_TYPE    ibute to NIRFSG_VAL_DIGITAL_EDGE, and set the NIRFSG_ATTR_DIGITAL_EDGE_START_TRIGGER_SOURCE attribute to sync_script. 
        ///    To set this attribute, the NI-RFSG device must be in the Configuration state. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the    NI RF Signal Generators Help for more information about device synchronization for vector signal transceivers. 
        /// 
        /// </summary>
        public int SetSyncStartTriggerMaster(string channel, bool value)
        {
            return SetBoolean(niRFSGProperties.SyncStartTriggerMaster, channel, value);
        }

        /// <summary>
        ///Specifies the time before the timer emits an event    after the task is started and the time interval    between Timer events after the first one. 
        /// 
        /// </summary>
        public int SetTimerEventInterval(string channel, double value)
        {
            return SetDouble(niRFSGProperties.TimerEventInterval, channel, value);
        }

        /// <summary>
        ///Specifies the time before the timer emits an event    after the task is started and the time interval    between Timer events after the first one. 
        /// 
        /// </summary>
        public int GetTimerEventInterval(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.TimerEventInterval, channel, out value);
        }

        /// <summary>
        ///Indicates the center frequency of the passband containing the upconverted   RF signal.  Writing a value to this attribute while using the    NI 5672/5673/5673E device enables in-band retuning.    In-band retuning increases the speed of   frequency sweeps by reducing the amount of upconverter retunes. 
        ///   This attribute is read-write on the NI 5610/5611/5672/5673/5673E and read-only   on the NI 5670/5671.  This attribute is resettable only on the NI 5673/5673E. 
        ///   Units: Hz 
        /// 
        /// </summary>
        public int SetUpconverterCenterFrequency(string channel, double value)
        {
            return SetDouble(niRFSGProperties.UpconverterCenterFrequency, channel, value);
        }

        /// <summary>
        ///Indicates the center frequency of the passband containing the upconverted   RF signal.  Writing a value to this attribute while using the    NI 5672/5673/5673E device enables in-band retuning.    In-band retuning increases the speed of   frequency sweeps by reducing the amount of upconverter retunes. 
        ///   This attribute is read-write on the NI 5610/5611/5672/5673/5673E and read-only   on the NI 5670/5671.  This attribute is resettable only on the NI 5673/5673E. 
        ///   Units: Hz 
        /// 
        /// </summary>
        public int GetUpconverterCenterFrequency(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.UpconverterCenterFrequency, channel, out value);
        }

        /// <summary>
        ///Specifies which upconverter center frequencies are used. This attribute   can be used to increase the speed of frequency sweeps by reducing the   number of times the upconverter is retuned. 
        /// 
        /// </summary>
        public int SetUpconverterCenterFrequencyIncrement(string channel, double value)
        {
            return SetDouble(niRFSGProperties.UpconverterCenterFrequencyIncrement, channel, value);
        }

        /// <summary>
        ///Specifies which upconverter center frequencies are used. This attribute   can be used to increase the speed of frequency sweeps by reducing the   number of times the upconverter is retuned. 
        /// 
        /// </summary>
        public int GetUpconverterCenterFrequencyIncrement(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.UpconverterCenterFrequencyIncrement, channel, out value);
        }

        /// <summary>
        ///Specifies the reference point for the upconverter center frequencies to   use.This attribute can be used to speed up frequency sweeps by reducing   the number of times the upconverter is retuned. 
        /// 
        /// </summary>
        public int SetUpconverterCenterFrequencyIncrementAnchor(string channel, double value)
        {
            return SetDouble(niRFSGProperties.UpconverterCenterFrequencyIncrementAnchor, channel, value);
        }

        /// <summary>
        ///Specifies the reference point for the upconverter center frequencies to   use.This attribute can be used to speed up frequency sweeps by reducing   the number of times the upconverter is retuned. 
        /// 
        /// </summary>
        public int GetUpconverterCenterFrequencyIncrementAnchor(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.UpconverterCenterFrequencyIncrementAnchor, channel, out value);
        }

        /// <summary>
        ///This attribute offsets the NIRFSG_ATTR_UPCONVERTER_CENTER_FREQUENCY from the RF frequency.    Use this attribute to keep the local oscillator (LO) leakage at a determined offset from the RF signal. 
        ///    Note: You cannot set the NIRFSG_ATTR_UPCONVERTER_CENTER_FREQUENCY attribute or    the NIRFSG_ATTR_ARB_CARRIER_FREQUENCY attribute at the same time as the NIRFSG_ATTR_UPCONVERTER_FREQUENCY_OFFSET attribute. 
        ///    Note: Resetting this attribute disables the upcoverter frequency offset. 
        /// 
        /// </summary>
        public int SetUpconverterFrequencyOffset(string channel, double value)
        {
            return SetDouble(niRFSGProperties.UpconverterFrequencyOffset, channel, value);
        }
        /// <summary>
        ///This attribute offsets the NIRFSG_ATTR_UPCONVERTER_CENTER_FREQUENCY from the RF frequency.    Use this attribute to keep the local oscillator (LO) leakage at a determined offset from the RF signal. 
        ///    Note: You cannot set the NIRFSG_ATTR_UPCONVERTER_CENTER_FREQUENCY attribute or    the NIRFSG_ATTR_ARB_CARRIER_FREQUENCY attribute at the same time as the NIRFSG_ATTR_UPCONVERTER_FREQUENCY_OFFSET attribute. 
        ///    Note: Resetting this attribute disables the upcoverter frequency offset. 
        /// 
        /// </summary>
        public int GetUpconverterFrequencyOffset(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.UpconverterFrequencyOffset, channel, out value);
        }

        /// <summary>
        ///Specifies the gain the upconverter applies to the signal. 
        ///   Units: dB 
        ///   Note: This attribute is read/write on the NI 5610/5611 and   read-only on the NI 5670/5671/5672/5673/5673E. 
        /// 
        /// </summary>
        public int SetUpconverterGain(string channel, double value)
        {
            return SetDouble(niRFSGProperties.UpconverterGain, channel, value);
        }

        /// <summary>
        ///Specifies the gain the upconverter applies to the signal. 
        ///   Units: dB 
        ///   Note: This attribute is read/write on the NI 5610/5611 and   read-only on the NI 5670/5671/5672/5673/5673E. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetUpconverterGain(string channel, out double value)
        {
            return GetDouble(niRFSGProperties.UpconverterGain, channel, out value);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="Channel_Name"></param>
        /// <param name="bufferSize"></param>
        /// <param name="data"></param>
        /// <param name="actualDataSize"></param>
        /// <returns></returns>
        public int GetUserData(string Channel_Name, int bufferSize, out char[] data, out int actualDataSize)
        {
            return PInvoke.GetUserData(this._handle, Channel_Name, bufferSize, out data, out actualDataSize);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="Channel_Name"></param>
        /// <param name="bufferSize"></param>
        /// <param name="data"></param>
        /// <returns></returns>
        public int SetUserData(string Channel_Name, int bufferSize, char[] data)
        {
            return PInvoke.SetUserData(this._handle, Channel_Name, bufferSize, data);
        }

        /// <summary>
        ///Adjusts the dynamics of the current driving the YIG main coil.
        ///    Note: Setting this attribute to NIRFSG_VAL_FAST on the NI 5653    allows the frequency to settle significantly faster for some frequency    transitions at the expense of increased phase noise. 
        /// 
        /// </summary>
        public int SetYigMainCoilDrive(string channel, int value)
        {
            return SetInt32(niRFSGProperties.YigMainCoilDrive, channel, value);
        }

        /// <summary>
        ///Adjusts the dynamics of the current driving the YIG main coil.
        ///    Note: Setting this attribute to NIRFSG_VAL_FAST on the NI 5653    allows the frequency to settle significantly faster for some frequency    transitions at the expense of increased phase noise. 
        /// 
        /// </summary>
        public int GetYigMainCoilDrive(string channel, out int value)
        {
            return GetInt32(niRFSGProperties.YigMainCoilDrive, channel, out value);
        }

        #region OldGetMethods - retained only for backward compatibility
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        public int GetInt32(niRFSGProperties propertyId, string repeatedCapabilityOrChannel)
        {
            int val;
            PInvoke.TestForError(this._handle, PInvoke.GetAttributeViInt32(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out val));
            return val;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        public int GetInt32(niRFSGProperties propertyId)
        {
            return this.GetInt32(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        public long GetLong(niRFSGProperties propertyId, string repeatedCapabilityOrChannel)
        {
            long val;
            PInvoke.TestForError(this._handle, PInvoke.GetAttributeViInt64(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out val));
            return val;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        public long GetLong(niRFSGProperties propertyId)
        {
            return this.GetLong(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        public double GetDouble(niRFSGProperties propertyId, string repeatedCapabilityOrChannel)
        {
            double val;
            PInvoke.TestForError(this._handle, PInvoke.GetAttributeViReal64(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out val));
            return val;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        public double GetDouble(niRFSGProperties propertyId)
        {
            return this.GetDouble(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        public string GetString(niRFSGProperties propertyId, string repeatedCapabilityOrChannel)
        {
            System.Text.StringBuilder newVal = new System.Text.StringBuilder(512);
            int size = PInvoke.GetAttributeViString(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), 512, newVal);
            if ((size < 0))
            {
                PInvoke.ThrowError(this._handle, size);
            }
            else
            {
                if ((size > 0))
                {
                    newVal.Capacity = size;
                    PInvoke.TestForError(this._handle, PInvoke.GetAttributeViString(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), size, newVal));
                }
            }
            return newVal.ToString();
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        public string GetString(niRFSGProperties propertyId)
        {
            return this.GetString(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        public bool GetBoolean(niRFSGProperties propertyId, string repeatedCapabilityOrChannel)
        {
            ushort val;
            PInvoke.TestForError(this._handle, PInvoke.GetAttributeViBoolean(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out val));
            return System.Convert.ToBoolean(val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        public bool GetBoolean(niRFSGProperties propertyId)
        {
            return this.GetBoolean(propertyId, "");
        }
        #endregion
        // Should we add other obsolete methods into this?
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetInt32(niRFSGProperties propertyId, string repeatedCapabilityOrChannel, out int val)
        {
            return PInvoke.TestForError(this._handle, PInvoke.GetAttributeViInt32(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetInt32(niRFSGProperties propertyId, out int val)
        {
            return this.GetInt32(propertyId, "", out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetLong(niRFSGProperties propertyId, string repeatedCapabilityOrChannel, out long val)
        {
            return PInvoke.TestForError(this._handle, PInvoke.GetAttributeViInt64(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetLong(niRFSGProperties propertyId, out long val)
        {
            return this.GetLong(propertyId, "", out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetDouble(niRFSGProperties propertyId, string repeatedCapabilityOrChannel, out double val)
        {
            return PInvoke.TestForError(this._handle, PInvoke.GetAttributeViReal64(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetDouble(niRFSGProperties propertyId, out double val)
        {
            return this.GetDouble(propertyId, "", out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetString(niRFSGProperties propertyId, string repeatedCapabilityOrChannel, out string val)
        {
            val = string.Empty;
            int pInvokeResult = 0;
            System.Text.StringBuilder newVal = new System.Text.StringBuilder(512);
            int size = PInvoke.GetAttributeViString(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), 512, newVal);
            if ((size < 0))
            {
                return PInvoke.ThrowError(this._handle, size);
            }
            else
            {
                if ((size > 0))
                {
                    newVal.Capacity = size;
                    pInvokeResult = PInvoke.TestForError(this._handle, PInvoke.GetAttributeViString(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), size, newVal));
                    val = newVal.ToString();
                }
            }
            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetString(niRFSGProperties propertyId, out string val)
        {
            return this.GetString(propertyId, "", out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetBoolean(niRFSGProperties propertyId, string repeatedCapabilityOrChannel, out bool val)
        {
            ushort value;
            int pInvokeResult = PInvoke.TestForError(this._handle, PInvoke.GetAttributeViBoolean(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), out value));
            val = System.Convert.ToBoolean(value);
            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetBoolean(niRFSGProperties propertyId, out bool val)
        {
            return this.GetBoolean(propertyId, "", out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetInt32(niRFSGProperties propertyId, string repeatedCapabilityOrChannel, int val)
        {
            return PInvoke.TestForError(this._handle, PInvoke.SetAttributeViInt32(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetInt32(niRFSGProperties propertyId, int val)
        {
            return this.SetInt32(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetLong(niRFSGProperties propertyId, string repeatedCapabilityOrChannel, long val)
        {
            return PInvoke.TestForError(this._handle, PInvoke.SetAttributeViInt64(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetLong(niRFSGProperties propertyId, long val)
        {
            return this.SetLong(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetDouble(niRFSGProperties propertyId, string repeatedCapabilityOrChannel, double val)
        {
            return PInvoke.TestForError(this._handle, PInvoke.SetAttributeViReal64(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetDouble(niRFSGProperties propertyId, double val)
        {
            return this.SetDouble(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetString(niRFSGProperties propertyId, string repeatedCapabilityOrChannel, string val)
        {
            return PInvoke.TestForError(this._handle, PInvoke.SetAttributeViString(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetString(niRFSGProperties propertyId, string val)
        {
            return this.SetString(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetBoolean(niRFSGProperties propertyId, string repeatedCapabilityOrChannel, bool val)
        {
            return PInvoke.TestForError(this._handle, PInvoke.SetAttributeViBoolean(this._handle, repeatedCapabilityOrChannel, ((int)(propertyId)), System.Convert.ToUInt16(val)));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetBoolean(niRFSGProperties propertyId, bool val)
        {
            return this.SetBoolean(propertyId, "", val);
        }

        /// <summary>
        /// Retrieves and then clears the IVI error information for the session or the current execution thread.
        /// 
        /// </summary>
        ///<param>
        /// Specifies the error code.
        /// 
        ///</param>
        ///<param>
        /// Specifies the error message returned.
        /// 
        ///</param>
        ///<returns>    
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSG function to determine if an error has occurred.   
        /// The general meaning of the status code is as follows:   
        /// Value           Meaning 
        /// 0               Success 
        /// Positive Values Warnings    
        /// Negative Values Errors  
        /// </returns>
        public static int GetError(HandleRef handle, int code, StringBuilder msg)
        {
            int pInvokeResult = 0;
            int size = PInvoke.GetError(handle, out code, 0, null);
            if ((size >= 0))
            {
                msg.Capacity = size;
                pInvokeResult = PInvoke.GetError(handle, out code, size, msg);
            }
            PInvoke.TestForError(handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Retrieves and then clears the IVI error information for the session or the current execution thread.
        /// 
        /// </summary>
        ///<param>
        /// Specifies the error code.
        /// 
        ///</param>
        ///<param>
        /// Specifies the error message returned.
        /// 
        ///</param>
        ///<returns>    
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSG function to determine if an error has occurred.   
        /// To obtain a text description of the status code and additional information about the error condition, call the niRFSG_GetError function.    
        /// The general meaning of the status code is as follows:   
        /// Value           Meaning 
        /// 0               Success 
        /// Positive Values Warnings    
        /// Negative Values Errors  
        /// </returns>
        public int GetError(int code, StringBuilder msg)
        {
            return niRFSG.GetError(Handle, code, msg);
        }

        /// <summary>
        /// Converts a status code returned by an NI-RFSG function into a user-readable string.
        /// 
        /// </summary>
        ///<param>
        /// Identifies your instrument session. vi is obtained from the niRFSG_init or niRFSG_InitExtCal function and identifies a particular instrument session.
        /// 
        ///</param>
        ///<param>
        /// Passes the Status parameter that is returned from any NI-RFSG function. The default value is 0 (VI_SUCCESS).
        /// 
        ///</param>
        ///<param>
        /// Returns the user-readable message string that corresponds to the status code you specify.
        /// 
        ///</param>
        ///<returns>
        /// Converts a status code returned by an NI-RFSG function into a user-readable string.
        /// 
        ///</returns>
        public static int ErrorMessage(HandleRef handle, int code, StringBuilder msg)
        {
            msg.Capacity = maxErrorMessageSize;
            int pInvokeResult = PInvoke.error_message(handle, code, msg);
            PInvoke.TestForError(handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Converts a status code returned by an NI-RFSG function into a user-readable string.
        /// 
        /// </summary>
        ///<param>
        /// Identifies your instrument session. vi is obtained from the niRFSG_init or niRFSG_InitExtCal function and identifies a particular instrument session.
        /// 
        ///</param>
        ///<param>
        /// Passes the Status parameter that is returned from any NI-RFSG function. The default value is 0 (VI_SUCCESS).
        /// 
        ///</param>
        ///<param>
        /// Returns the user-readable message string that corresponds to the status code you specify.
        /// 
        ///</param>
        ///<returns>
        /// Converts a status code returned by an NI-RFSG function into a user-readable string.
        /// 
        ///</returns>:
        public int ErrorMessage(int code, StringBuilder msg)
        {
            return niRFSG.ErrorMessage(Handle, code, msg);
        }

        private class PInvoke
        {
            const string nativeDllName32 = "niRFSG.dll";

            private const string nativeDllName64 = "niRFSG_64.dll";

            // Define the readonly field to check for process' bitness.
            private static readonly bool Is64BitProcess = (IntPtr.Size == 8);


            [DllImport(nativeDllName32, EntryPoint = "niRFSG_init", CallingConvention = CallingConvention.StdCall)]
            public static extern int init32(string Resource_Name, ushort ID_Query, ushort Reset, out System.IntPtr Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_init", CallingConvention = CallingConvention.StdCall)]
            public static extern int init64(string Resource_Name, ushort ID_Query, ushort Reset, out System.IntPtr Instrument_Handle);

            public static int init(string Resource_Name, ushort ID_Query, ushort Reset, out System.IntPtr Instrument_Handle)
            {
                if (Is64BitProcess)
                    return init64(Resource_Name, ID_Query, Reset, out Instrument_Handle);
                else
                    return init32(Resource_Name, ID_Query, Reset, out Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_InitWithOptions", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitWithOptions32(string Resource_Name, ushort ID_Query, ushort Reset, string Option_String, out System.IntPtr Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_InitWithOptions", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitWithOptions64(string Resource_Name, ushort ID_Query, ushort Reset, string Option_String, out System.IntPtr Instrument_Handle);

            public static int InitWithOptions(string Resource_Name, ushort ID_Query, ushort Reset, string Option_String, out System.IntPtr Instrument_Handle)
            {
                if (Is64BitProcess)
                    return InitWithOptions64(Resource_Name, ID_Query, Reset, Option_String, out Instrument_Handle);
                else
                    return InitWithOptions32(Resource_Name, ID_Query, Reset, Option_String, out Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureRF", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureRF32(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Frequency, double Power_Level);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureRF", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureRF64(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Frequency, double Power_Level);

            public static int ConfigureRF(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Frequency, double Power_Level)
            {
                if (Is64BitProcess)
                    return ConfigureRF64(Instrument_Handle, Frequency, Power_Level);
                else
                    return ConfigureRF32(Instrument_Handle, Frequency, Power_Level);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureGenerationMode", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureGenerationMode32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Generation_Mode);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureGenerationMode", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureGenerationMode64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Generation_Mode);

            public static int ConfigureGenerationMode(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Generation_Mode)
            {
                if (Is64BitProcess)
                    return ConfigureGenerationMode64(Instrument_Handle, Generation_Mode);
                else
                    return ConfigureGenerationMode32(Instrument_Handle, Generation_Mode);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_AllocateArbWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int AllocateArbWaveform32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Size_In_Samples);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_AllocateArbWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int AllocateArbWaveform64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Size_In_Samples);

            public static int AllocateArbWaveform(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Size_In_Samples)
            {
                if (Is64BitProcess)
                    return AllocateArbWaveform64(Instrument_Handle, Name, Size_In_Samples);
                else
                    return AllocateArbWaveform32(Instrument_Handle, Name, Size_In_Samples);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_WriteArbWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveform32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, double[] IData, double[] QData, ushort More_Data_Pending);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_WriteArbWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveform64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, double[] IData, double[] QData, ushort More_Data_Pending);

            public static int WriteArbWaveform(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, double[] IData, double[] QData, ushort More_Data_Pending)
            {
                if (Is64BitProcess)
                    return WriteArbWaveform64(Instrument_Handle, Name, Number_Of_Samples, IData, QData, More_Data_Pending);
                else
                    return WriteArbWaveform32(Instrument_Handle, Name, Number_Of_Samples, IData, QData, More_Data_Pending);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_WriteArbWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveformF3232(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, float[] IData, float[] QData, ushort More_Data_Pending);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_WriteArbWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveformF3264(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, float[] IData, float[] QData, ushort More_Data_Pending);

            public static int WriteArbWaveformF32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, float[] IData, float[] QData, ushort More_Data_Pending)
            {
                if (Is64BitProcess)
                    return WriteArbWaveformF3264(Instrument_Handle, Name, Number_Of_Samples, IData, QData, More_Data_Pending);
                else
                    return WriteArbWaveformF3232(Instrument_Handle, Name, Number_Of_Samples, IData, QData, More_Data_Pending);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_WriteArbWaveformComplexF32", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveformComplexF3232(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, niComplexNumberF32[] wfmData, ushort More_Data_Pending);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_WriteArbWaveformComplexF32", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveformComplexF3264(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, niComplexNumberF32[] wfmData, ushort More_Data_Pending);

            public static int WriteArbWaveformComplexF32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, niComplexNumberF32[] wfmData, ushort More_Data_Pending)
            {
                if (Is64BitProcess)
                    return WriteArbWaveformComplexF3264(Instrument_Handle, Name, Number_Of_Samples, wfmData, More_Data_Pending);
                else
                    return WriteArbWaveformComplexF3232(Instrument_Handle, Name, Number_Of_Samples, wfmData, More_Data_Pending);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_WriteArbWaveformComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveformComplexF6432(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, niComplexNumber[] Data, ushort More_Data_Pending);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_WriteArbWaveformComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveformComplexF6464(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, niComplexNumber[] Data, ushort More_Data_Pending);

            public static int WriteArbWaveformComplexF64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, niComplexNumber[] Data, ushort More_Data_Pending)
            {
                if (Is64BitProcess)
                    return WriteArbWaveformComplexF6464(Instrument_Handle, Name, Number_Of_Samples, Data, More_Data_Pending);
                else
                    return WriteArbWaveformComplexF6432(Instrument_Handle, Name, Number_Of_Samples, Data, More_Data_Pending);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_WriteArbWaveformComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveformComplexI1632(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, niComplexI16[] Data);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_WriteArbWaveformComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveformComplexI1664(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, niComplexI16[] Data);

            public static int WriteArbWaveformComplexI16(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, niComplexI16[] Data)
            {
                if (Is64BitProcess)
                    return WriteArbWaveformComplexI1664(Instrument_Handle, Name, Number_Of_Samples, Data);
                else
                    return WriteArbWaveformComplexI1632(Instrument_Handle, Name, Number_Of_Samples, Data);
            }


            [DllImport(nativeDllName32, EntryPoint = "niRFSG_WriteArbWaveformComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveformComplexI1632(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, RfsgNIComplexI16[] Data);


            [DllImport(nativeDllName64, EntryPoint = "niRFSG_WriteArbWaveformComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteArbWaveformComplexI1664(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, RfsgNIComplexI16[] Data);


            public static int WriteArbWaveformComplexI16(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name, int Number_Of_Samples, RfsgNIComplexI16[] Data)
            {
                if (Is64BitProcess)
                    return WriteArbWaveformComplexI1664(Instrument_Handle, Name, Number_Of_Samples, Data);
                else
                    return WriteArbWaveformComplexI1632(Instrument_Handle, Name, Number_Of_Samples, Data);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SelectArbWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelectArbWaveform32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SelectArbWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelectArbWaveform64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name);

            public static int SelectArbWaveform(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name)
            {
                if (Is64BitProcess)
                    return SelectArbWaveform64(Instrument_Handle, Name);
                else
                    return SelectArbWaveform32(Instrument_Handle, Name);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ClearArbWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int ClearArbWaveform32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ClearArbWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int ClearArbWaveform64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name);

            public static int ClearArbWaveform(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Name)
            {
                if (Is64BitProcess)
                    return ClearArbWaveform64(Instrument_Handle, Name);
                else
                    return ClearArbWaveform32(Instrument_Handle, Name);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ClearAllArbWaveforms", CallingConvention = CallingConvention.StdCall)]
            public static extern int ClearAllArbWaveforms32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ClearAllArbWaveforms", CallingConvention = CallingConvention.StdCall)]
            public static extern int ClearAllArbWaveforms64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int ClearAllArbWaveforms(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return ClearAllArbWaveforms64(Instrument_Handle);
                else
                    return ClearAllArbWaveforms32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureSignalBandwidth", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSignalBandwidth32(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Signal_Bandwidth);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureSignalBandwidth", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSignalBandwidth64(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Signal_Bandwidth);

            public static int ConfigureSignalBandwidth(System.Runtime.InteropServices.HandleRef Instrument_Handle, double Signal_Bandwidth)
            {
                if (Is64BitProcess)
                    return ConfigureSignalBandwidth64(Instrument_Handle, Signal_Bandwidth);
                else
                    return ConfigureSignalBandwidth32(Instrument_Handle, Signal_Bandwidth);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureDigitalModulationUserDefinedWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalModulationUserDefinedWaveform32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Number_Of_Samples, sbyte[] User_Defined_Waveform);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureDigitalModulationUserDefinedWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalModulationUserDefinedWaveform64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Number_Of_Samples, sbyte[] User_Defined_Waveform);

            public static int ConfigureDigitalModulationUserDefinedWaveform(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Number_Of_Samples, sbyte[] User_Defined_Waveform)
            {
                if (Is64BitProcess)
                    return ConfigureDigitalModulationUserDefinedWaveform64(Instrument_Handle, Number_Of_Samples, User_Defined_Waveform);
                else
                    return ConfigureDigitalModulationUserDefinedWaveform32(Instrument_Handle, Number_Of_Samples, User_Defined_Waveform);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigurePowerLevelType", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigurePowerLevelType32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Power_Level_Type);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigurePowerLevelType", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigurePowerLevelType64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Power_Level_Type);

            public static int ConfigurePowerLevelType(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Power_Level_Type)
            {
                if (Is64BitProcess)
                    return ConfigurePowerLevelType64(Instrument_Handle, Power_Level_Type);
                else
                    return ConfigurePowerLevelType32(Instrument_Handle, Power_Level_Type);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_CreateConfigurationList", CallingConvention = CallingConvention.StdCall)]
            public static extern int CreateConfigurationList32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string List_Name, int Number_Of_Attributes, niRFSGProperties[] Configuration_List_Attributes, ushort Set_As_Active_List);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_CreateConfigurationList", CallingConvention = CallingConvention.StdCall)]
            public static extern int CreateConfigurationList64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string List_Name, int Number_Of_Attributes, niRFSGProperties[] Configuration_List_Attributes, ushort Set_As_Active_List);

            public static int CreateConfigurationList(System.Runtime.InteropServices.HandleRef Instrument_Handle, string List_Name, int Number_Of_Attributes, niRFSGProperties[] Configuration_List_Attributes, ushort Set_As_Active_List)
            {
                if (Is64BitProcess)
                    return CreateConfigurationList64(Instrument_Handle, List_Name, Number_Of_Attributes, Configuration_List_Attributes, Set_As_Active_List);
                else
                    return CreateConfigurationList32(Instrument_Handle, List_Name, Number_Of_Attributes, Configuration_List_Attributes, Set_As_Active_List);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_CreateConfigurationListStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int CreateConfigurationListStep32(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Set_As_Active_Step);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_CreateConfigurationListStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int CreateConfigurationListStep64(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Set_As_Active_Step);

            public static int CreateConfigurationListStep(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Set_As_Active_Step)
            {
                if (Is64BitProcess)
                    return CreateConfigurationListStep64(Instrument_Handle, Set_As_Active_Step);
                else
                    return CreateConfigurationListStep32(Instrument_Handle, Set_As_Active_Step);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_DeleteConfigurationList", CallingConvention = CallingConvention.StdCall)]
            public static extern int DeleteConfigurationList32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string List_Name);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_DeleteConfigurationList", CallingConvention = CallingConvention.StdCall)]
            public static extern int DeleteConfigurationList64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string List_Name);

            public static int DeleteConfigurationList(System.Runtime.InteropServices.HandleRef Instrument_Handle, string List_Name)
            {
                if (Is64BitProcess)
                    return DeleteConfigurationList64(Instrument_Handle, List_Name);
                else
                    return DeleteConfigurationList32(Instrument_Handle, List_Name);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureSoftwareStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSoftwareStartTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureSoftwareStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSoftwareStartTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int ConfigureSoftwareStartTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return ConfigureSoftwareStartTrigger64(Instrument_Handle);
                else
                    return ConfigureSoftwareStartTrigger32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureDigitalEdgeStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeStartTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source, int Edge);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureDigitalEdgeStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeStartTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source, int Edge);

            public static int ConfigureDigitalEdgeStartTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source, int Edge)
            {
                if (Is64BitProcess)
                    return ConfigureDigitalEdgeStartTrigger64(Instrument_Handle, Source, Edge);
                else
                    return ConfigureDigitalEdgeStartTrigger32(Instrument_Handle, Source, Edge);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureP2PEndpointFullnessStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureP2PEndpointFullnessStartTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle, long P2P_Endpoint_Fullness_Level);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureP2PEndpointFullnessStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureP2PEndpointFullnessStartTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle, long P2P_Endpoint_Fullness_Level);

            public static int ConfigureP2PEndpointFullnessStartTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle, long P2P_Endpoint_Fullness_Level)
            {
                if (Is64BitProcess)
                    return ConfigureP2PEndpointFullnessStartTrigger64(Instrument_Handle, P2P_Endpoint_Fullness_Level);
                else
                    return ConfigureP2PEndpointFullnessStartTrigger32(Instrument_Handle, P2P_Endpoint_Fullness_Level);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_DisableStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableStartTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_DisableStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableStartTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int DisableStartTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return DisableStartTrigger64(Instrument_Handle);
                else
                    return DisableStartTrigger32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureSoftwareScriptTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSoftwareScriptTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureSoftwareScriptTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSoftwareScriptTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier);

            public static int ConfigureSoftwareScriptTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier)
            {
                if (Is64BitProcess)
                    return ConfigureSoftwareScriptTrigger64(Instrument_Handle, Trigger_Identifier);
                else
                    return ConfigureSoftwareScriptTrigger32(Instrument_Handle, Trigger_Identifier);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureDigitalEdgeScriptTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeScriptTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier, string Source, int Edge);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureDigitalEdgeScriptTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeScriptTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier, string Source, int Edge);

            public static int ConfigureDigitalEdgeScriptTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier, string Source, int Edge)
            {
                if (Is64BitProcess)
                    return ConfigureDigitalEdgeScriptTrigger64(Instrument_Handle, Trigger_Identifier, Source, Edge);
                else
                    return ConfigureDigitalEdgeScriptTrigger32(Instrument_Handle, Trigger_Identifier, Source, Edge);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureDigitalLevelScriptTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalLevelScriptTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier, string Source, int Level);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureDigitalLevelScriptTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalLevelScriptTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier, string Source, int Level);

            public static int ConfigureDigitalLevelScriptTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier, string Source, int Level)
            {
                if (Is64BitProcess)
                    return ConfigureDigitalLevelScriptTrigger64(Instrument_Handle, Trigger_Identifier, Source, Level);
                else
                    return ConfigureDigitalLevelScriptTrigger32(Instrument_Handle, Trigger_Identifier, Source, Level);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_DisableScriptTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableScriptTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_DisableScriptTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableScriptTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier);

            public static int DisableScriptTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Trigger_Identifier)
            {
                if (Is64BitProcess)
                    return DisableScriptTrigger64(Instrument_Handle, Trigger_Identifier);
                else
                    return DisableScriptTrigger32(Instrument_Handle, Trigger_Identifier);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SendSoftwareEdgeTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int SendSoftwareEdgeTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Trigger, string Trigger_Identifier);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SendSoftwareEdgeTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int SendSoftwareEdgeTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Trigger, string Trigger_Identifier);

            public static int SendSoftwareEdgeTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Trigger, string Trigger_Identifier)
            {
                if (Is64BitProcess)
                    return SendSoftwareEdgeTrigger64(Instrument_Handle, Trigger, Trigger_Identifier);
                else
                    return SendSoftwareEdgeTrigger32(Instrument_Handle, Trigger, Trigger_Identifier);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureDigitalEdgeConfigurationListStepTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeConfigurationListStepTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source, int Edge);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureDigitalEdgeConfigurationListStepTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeConfigurationListStepTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source, int Edge);

            public static int ConfigureDigitalEdgeConfigurationListStepTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Source, int Edge)
            {
                if (Is64BitProcess)
                    return ConfigureDigitalEdgeConfigurationListStepTrigger64(Instrument_Handle, Source, Edge);
                else
                    return ConfigureDigitalEdgeConfigurationListStepTrigger32(Instrument_Handle, Source, Edge);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_DisableConfigurationListStepTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableConfigurationListStepTrigger32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_DisableConfigurationListStepTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableConfigurationListStepTrigger64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int DisableConfigurationListStepTrigger(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return DisableConfigurationListStepTrigger64(Instrument_Handle);
                else
                    return DisableConfigurationListStepTrigger32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetTerminalName", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetTerminalName32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Signal, string Signal_Identifier, int Buffer_Size, System.Text.StringBuilder Terminal_Name);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetTerminalName", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetTerminalName64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Signal, string Signal_Identifier, int Buffer_Size, System.Text.StringBuilder Terminal_Name);

            public static int GetTerminalName(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Signal, string Signal_Identifier, int Buffer_Size, System.Text.StringBuilder Terminal_Name)
            {
                if (Is64BitProcess)
                    return GetTerminalName64(Instrument_Handle, Signal, Signal_Identifier, Buffer_Size, Terminal_Name);
                else
                    return GetTerminalName32(Instrument_Handle, Signal, Signal_Identifier, Buffer_Size, Terminal_Name);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureRefClock", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureRefClock32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Ref_Clock_Source, double Ref_Clock_Rate);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureRefClock", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureRefClock64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Ref_Clock_Source, double Ref_Clock_Rate);

            public static int ConfigureRefClock(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Ref_Clock_Source, double Ref_Clock_Rate)
            {
                if (Is64BitProcess)
                    return ConfigureRefClock64(Instrument_Handle, Ref_Clock_Source, Ref_Clock_Rate);
                else
                    return ConfigureRefClock32(Instrument_Handle, Ref_Clock_Source, Ref_Clock_Rate);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigurePXIChassisClk10", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigurePXIChassisClk1032(System.Runtime.InteropServices.HandleRef Instrument_Handle, string PXI_Clk_10_Source);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigurePXIChassisClk10", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigurePXIChassisClk1064(System.Runtime.InteropServices.HandleRef Instrument_Handle, string PXI_Clk_10_Source);

            public static int ConfigurePXIChassisClk10(System.Runtime.InteropServices.HandleRef Instrument_Handle, string PXI_Clk_10_Source)
            {
                if (Is64BitProcess)
                    return ConfigurePXIChassisClk1064(Instrument_Handle, PXI_Clk_10_Source);
                else
                    return ConfigurePXIChassisClk1032(Instrument_Handle, PXI_Clk_10_Source);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ExportSignal", CallingConvention = CallingConvention.StdCall)]
            public static extern int ExportSignal32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Signal, string Signal_Identifier, string Output_Terminal);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ExportSignal", CallingConvention = CallingConvention.StdCall)]
            public static extern int ExportSignal64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Signal, string Signal_Identifier, string Output_Terminal);

            public static int ExportSignal(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Signal, string Signal_Identifier, string Output_Terminal)
            {
                if (Is64BitProcess)
                    return ExportSignal64(Instrument_Handle, Signal, Signal_Identifier, Output_Terminal);
                else
                    return ExportSignal32(Instrument_Handle, Signal, Signal_Identifier, Output_Terminal);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetStreamEndpointHandle", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetStreamEndpointHandle32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Stream_Endpoint, out uint Reader_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetStreamEndpointHandle", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetStreamEndpointHandle64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Stream_Endpoint, out uint Reader_Handle);

            public static int GetStreamEndpointHandle(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Stream_Endpoint, out uint Reader_Handle)
            {
                if (Is64BitProcess)
                    return GetStreamEndpointHandle64(Instrument_Handle, Stream_Endpoint, out Reader_Handle);
                else
                    return GetStreamEndpointHandle32(Instrument_Handle, Stream_Endpoint, out Reader_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_WriteP2PEndpointI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteP2PEndpointI1632(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Stream_Endpoint, int Number_Of_Samples, short[] Endpoint_Data);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_WriteP2PEndpointI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteP2PEndpointI1664(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Stream_Endpoint, int Number_Of_Samples, short[] Endpoint_Data);

            public static int WriteP2PEndpointI16(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Stream_Endpoint, int Number_Of_Samples, short[] Endpoint_Data)
            {
                if (Is64BitProcess)
                    return WriteP2PEndpointI1664(Instrument_Handle, Stream_Endpoint, Number_Of_Samples, Endpoint_Data);
                else
                    return WriteP2PEndpointI1632(Instrument_Handle, Stream_Endpoint, Number_Of_Samples, Endpoint_Data);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_WriteScript", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteScript32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Script);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_WriteScript", CallingConvention = CallingConvention.StdCall)]
            public static extern int WriteScript64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Script);

            public static int WriteScript(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Script)
            {
                if (Is64BitProcess)
                    return WriteScript64(Instrument_Handle, Script);
                else
                    return WriteScript32(Instrument_Handle, Script);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureOutputEnabled", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureOutputEnabled32(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Output_Enabled);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureOutputEnabled", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureOutputEnabled64(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Output_Enabled);

            public static int ConfigureOutputEnabled(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort Output_Enabled)
            {
                if (Is64BitProcess)
                    return ConfigureOutputEnabled64(Instrument_Handle, Output_Enabled);
                else
                    return ConfigureOutputEnabled32(Instrument_Handle, Output_Enabled);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ConfigureIQEnabled", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureIQEnabled32(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort IQ_Enabled);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ConfigureIQEnabled", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureIQEnabled64(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort IQ_Enabled);

            public static int ConfigureIQEnabled(System.Runtime.InteropServices.HandleRef Instrument_Handle, ushort IQ_Enabled)
            {
                if (Is64BitProcess)
                    return ConfigureIQEnabled64(Instrument_Handle, IQ_Enabled);
                else
                    return ConfigureIQEnabled32(Instrument_Handle, IQ_Enabled);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ResetAttribute", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetAttribute32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ResetAttribute", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetAttribute64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID);

            public static int ResetAttribute(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID)
            {
                if (Is64BitProcess)
                    return ResetAttribute64(Instrument_Handle, Channel_Name, Attribute_ID);
                else
                    return ResetAttribute32(Instrument_Handle, Channel_Name, Attribute_ID);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_Initiate", CallingConvention = CallingConvention.StdCall)]
            public static extern int Initiate32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_Initiate", CallingConvention = CallingConvention.StdCall)]
            public static extern int Initiate64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int Initiate(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return Initiate64(Instrument_Handle);
                else
                    return Initiate32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_CheckGenerationStatus", CallingConvention = CallingConvention.StdCall)]
            public static extern int CheckGenerationStatus32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out ushort Is_Done);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_CheckGenerationStatus", CallingConvention = CallingConvention.StdCall)]
            public static extern int CheckGenerationStatus64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out ushort Is_Done);

            public static int CheckGenerationStatus(System.Runtime.InteropServices.HandleRef Instrument_Handle, out ushort Is_Done)
            {
                if (Is64BitProcess)
                    return CheckGenerationStatus64(Instrument_Handle, out Is_Done);
                else
                    return CheckGenerationStatus32(Instrument_Handle, out Is_Done);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_Abort", CallingConvention = CallingConvention.StdCall)]
            public static extern int Abort32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_Abort", CallingConvention = CallingConvention.StdCall)]
            public static extern int Abort64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int Abort(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return Abort64(Instrument_Handle);
                else
                    return Abort32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_Commit", CallingConvention = CallingConvention.StdCall)]
            public static extern int Commit32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_Commit", CallingConvention = CallingConvention.StdCall)]
            public static extern int Commit64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int Commit(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return Commit64(Instrument_Handle);
                else
                    return Commit32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_PerformThermalCorrection", CallingConvention = CallingConvention.StdCall)]
            public static extern int PerformThermalCorrection32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_PerformThermalCorrection", CallingConvention = CallingConvention.StdCall)]
            public static extern int PerformThermalCorrection64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int PerformThermalCorrection(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return PerformThermalCorrection64(Instrument_Handle);
                else
                    return PerformThermalCorrection32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_WaitUntilSettled", CallingConvention = CallingConvention.StdCall)]
            public static extern int WaitUntilSettled32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Max_Time_Milliseconds);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_WaitUntilSettled", CallingConvention = CallingConvention.StdCall)]
            public static extern int WaitUntilSettled64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Max_Time_Milliseconds);

            public static int WaitUntilSettled(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Max_Time_Milliseconds)
            {
                if (Is64BitProcess)
                    return WaitUntilSettled64(Instrument_Handle, Max_Time_Milliseconds);
                else
                    return WaitUntilSettled32(Instrument_Handle, Max_Time_Milliseconds);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_reset", CallingConvention = CallingConvention.StdCall)]
            public static extern int reset32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_reset", CallingConvention = CallingConvention.StdCall)]
            public static extern int reset64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int reset(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return reset64(Instrument_Handle);
                else
                    return reset32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ResetDevice", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetDevice32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ResetDevice", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetDevice64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int ResetDevice(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return ResetDevice64(Instrument_Handle);
                else
                    return ResetDevice32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ResetWithDefaults", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetWithDefaults32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ResetWithDefaults", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetWithDefaults64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int ResetWithDefaults(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return ResetWithDefaults64(Instrument_Handle);
                else
                    return ResetWithDefaults32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetChannelName", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetChannelName32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Index, int BufferSize, System.Text.StringBuilder Channel_Name);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetChannelName", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetChannelName64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Index, int BufferSize, System.Text.StringBuilder Channel_Name);

            public static int GetChannelName(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Index, int BufferSize, System.Text.StringBuilder Channel_Name)
            {
                if (Is64BitProcess)
                    return GetChannelName64(Instrument_Handle, Index, BufferSize, Channel_Name);
                else
                    return GetChannelName32(Instrument_Handle, Index, BufferSize, Channel_Name);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_Disable", CallingConvention = CallingConvention.StdCall)]
            public static extern int Disable32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_Disable", CallingConvention = CallingConvention.StdCall)]
            public static extern int Disable64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int Disable(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return Disable64(Instrument_Handle);
                else
                    return Disable32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_self_test", CallingConvention = CallingConvention.StdCall)]
            public static extern int self_test32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out short Self_Test_Result, System.Text.StringBuilder Self_Test_Message);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_self_test", CallingConvention = CallingConvention.StdCall)]
            public static extern int self_test64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out short Self_Test_Result, System.Text.StringBuilder Self_Test_Message);

            public static int self_test(System.Runtime.InteropServices.HandleRef Instrument_Handle, out short Self_Test_Result, System.Text.StringBuilder Self_Test_Message)
            {
                if (Is64BitProcess)
                    return self_test64(Instrument_Handle, out Self_Test_Result, Self_Test_Message);
                else
                    return self_test32(Instrument_Handle, out Self_Test_Result, Self_Test_Message);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_error_message", CallingConvention = CallingConvention.StdCall)]
            public static extern int error_message32(System.Runtime.InteropServices.HandleRef instrumentHandle, int errorCode, StringBuilder errorMessage);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_error_message", CallingConvention = CallingConvention.StdCall)]
            public static extern int error_message64(System.Runtime.InteropServices.HandleRef instrumentHandle, int errorCode, StringBuilder errorMessage);

            public static int error_message(System.Runtime.InteropServices.HandleRef instrumentHandle, int errorCode, StringBuilder errorMessage)
            {
                if (Is64BitProcess)
                    return error_message64(instrumentHandle, errorCode, errorMessage);
                else
                    return error_message32(instrumentHandle, errorCode, errorMessage);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_error_query", CallingConvention = CallingConvention.StdCall)]
            public static extern int error_query32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Error_Code, System.Text.StringBuilder Error_Message);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_error_query", CallingConvention = CallingConvention.StdCall)]
            public static extern int error_query64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Error_Code, System.Text.StringBuilder Error_Message);

            public static int error_query(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Error_Code, System.Text.StringBuilder Error_Message)
            {
                if (Is64BitProcess)
                    return error_query64(Instrument_Handle, out Error_Code, Error_Message);
                else
                    return error_query32(Instrument_Handle, out Error_Code, Error_Message);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_revision_query", CallingConvention = CallingConvention.StdCall)]
            public static extern int revision_query32(System.Runtime.InteropServices.HandleRef Instrument_Handle, System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_revision_query", CallingConvention = CallingConvention.StdCall)]
            public static extern int revision_query64(System.Runtime.InteropServices.HandleRef Instrument_Handle, System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision);

            public static int revision_query(System.Runtime.InteropServices.HandleRef Instrument_Handle, System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision)
            {
                if (Is64BitProcess)
                    return revision_query64(Instrument_Handle, Instrument_Driver_Revision, Firmware_Revision);
                else
                    return revision_query32(Instrument_Handle, Instrument_Driver_Revision, Firmware_Revision);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_QueryArbWaveformCapabilities", CallingConvention = CallingConvention.StdCall)]
            public static extern int QueryArbWaveformCapabilities32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Max_Number_Waveforms, out int Waveform_Quantum, out int Min_Waveform_Size, out int Max_Waveform_Size);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_QueryArbWaveformCapabilities", CallingConvention = CallingConvention.StdCall)]
            public static extern int QueryArbWaveformCapabilities64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Max_Number_Waveforms, out int Waveform_Quantum, out int Min_Waveform_Size, out int Max_Waveform_Size);

            public static int QueryArbWaveformCapabilities(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Max_Number_Waveforms, out int Waveform_Quantum, out int Min_Waveform_Size, out int Max_Waveform_Size)
            {
                if (Is64BitProcess)
                    return QueryArbWaveformCapabilities64(Instrument_Handle, out Max_Number_Waveforms, out Waveform_Quantum, out Min_Waveform_Size, out Max_Waveform_Size);
                else
                    return QueryArbWaveformCapabilities32(Instrument_Handle, out Max_Number_Waveforms, out Waveform_Quantum, out Min_Waveform_Size, out Max_Waveform_Size);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SelfCal", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelfCal32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SelfCal", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelfCal64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int SelfCal(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return SelfCal64(Instrument_Handle);
                else
                    return SelfCal32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetSelfCalibrationDateAndTime", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetSelfCalibrationDateAndTime32(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Module, out int Year, out int Month, out int Day, out int Hour, out int Minute, out int Second);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetSelfCalibrationDateAndTime", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetSelfCalibrationDateAndTime64(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Module, out int Year, out int Month, out int Day, out int Hour, out int Minute, out int Second);

            public static int SelfCalibrateRange(System.Runtime.InteropServices.HandleRef instrumentHandle, long stepsToOmit, double minFrequency, double maxFrequency, double minPowerLevel, double maxPowerLevel)
            {
                if (Is64BitProcess)
                    return SelfCalibrateRange64(instrumentHandle, stepsToOmit, minFrequency, maxFrequency, minPowerLevel, maxPowerLevel);
                else
                    return SelfCalibrateRange32(instrumentHandle, stepsToOmit, minFrequency, maxFrequency, minPowerLevel, maxPowerLevel);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SelfCalibrateRange", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelfCalibrateRange32(System.Runtime.InteropServices.HandleRef instrumentHandle, long stepsToOmit, double minFrequency, double maxFrequency, double minPowerLevel, double maxPowerLevel);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SelfCalibrateRange", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelfCalibrateRange64(System.Runtime.InteropServices.HandleRef instrumentHandle, long stepsToOmit, double minFrequency, double maxFrequency, double minPowerLevel, double maxPowerLevel);

            public static int GetSelfCalibrationDateAndTime(System.Runtime.InteropServices.HandleRef Instrument_Handle, int Module, out int Year, out int Month, out int Day, out int Hour, out int Minute, out int Second)
            {
                if (Is64BitProcess)
                    return GetSelfCalibrationDateAndTime64(Instrument_Handle, Module, out  Year, out  Month, out  Day, out  Hour, out  Minute, out  Second);
                else
                    return GetSelfCalibrationDateAndTime32(Instrument_Handle, Module, out Year, out  Month, out  Day, out  Hour, out Minute, out Second);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetExternalCalibrationLastDateAndTime", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetExternalCalibrationLastDateAndTime32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Year, out int Month, out int Day, out int Hour, out int Minute, out int Second);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetExternalCalibrationLastDateAndTime", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetExternalCalibrationLastDateAndTime64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Year, out int Month, out int Day, out int Hour, out int Minute, out int Second);

            public static int GetExternalCalibrationLastDateAndTime(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int Year, out int Month, out int Day, out int Hour, out int Minute, out int Second)
            {
                if (Is64BitProcess)
                    return GetExternalCalibrationLastDateAndTime64(Instrument_Handle, out  Year, out  Month, out  Day, out  Hour, out  Minute, out  Second);
                else
                    return GetExternalCalibrationLastDateAndTime32(Instrument_Handle, out  Year, out  Month, out  Day, out  Hour, out Minute, out Second);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_ChangeExternalCalibrationPassword", CallingConvention = CallingConvention.StdCall)]
            public static extern int ChangeExternalCalibrationPassword32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Old_Password, string New_Password);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_ChangeExternalCalibrationPassword", CallingConvention = CallingConvention.StdCall)]
            public static extern int ChangeExternalCalibrationPassword64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Old_Password, string New_Password);

            public static int ChangeExternalCalibrationPassword(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Old_Password, string New_Password)
            {
                if (Is64BitProcess)
                    return ChangeExternalCalibrationPassword64(Instrument_Handle, Old_Password, New_Password);
                else
                    return ChangeExternalCalibrationPassword32(Instrument_Handle, Old_Password, New_Password);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_close", CallingConvention = CallingConvention.StdCall)]
            public static extern int close32(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_close", CallingConvention = CallingConvention.StdCall)]
            public static extern int close64(System.Runtime.InteropServices.HandleRef Instrument_Handle);

            public static int close(System.Runtime.InteropServices.HandleRef Instrument_Handle)
            {
                if (Is64BitProcess)
                    return close64(Instrument_Handle);
                else
                    return close32(Instrument_Handle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViInt3232(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out int Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViInt3264(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out int Attribute_Value);

            public static int GetAttributeViInt32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out int Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViInt3264(Instrument_Handle, Channel_Name, Attribute_ID, out  Attribute_Value);
                else
                    return GetAttributeViInt3232(Instrument_Handle, Channel_Name, Attribute_ID, out Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetAttributeViInt64", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViInt6432(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out long Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetAttributeViInt64", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViInt6464(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out long Attribute_Value);

            public static int GetAttributeViInt64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out long Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViInt6464(Instrument_Handle, Channel_Name, Attribute_ID, out Attribute_Value);
                else
                    return GetAttributeViInt6432(Instrument_Handle, Channel_Name, Attribute_ID, out Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViReal6432(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out double Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViReal6464(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out double Attribute_Value);

            public static int GetAttributeViReal64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out double Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViReal6464(Instrument_Handle, Channel_Name, Attribute_ID, out Attribute_Value);
                else
                    return GetAttributeViReal6432(Instrument_Handle, Channel_Name, Attribute_ID, out Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViString32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Buffer_Size, System.Text.StringBuilder Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViString64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Buffer_Size, System.Text.StringBuilder Attribute_Value);

            public static int GetAttributeViString(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Buffer_Size, System.Text.StringBuilder Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViString64(Instrument_Handle, Channel_Name, Attribute_ID, Buffer_Size, Attribute_Value);
                else
                    return GetAttributeViString32(Instrument_Handle, Channel_Name, Attribute_ID, Buffer_Size, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViBoolean32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out ushort Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViBoolean64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out ushort Attribute_Value);

            public static int GetAttributeViBoolean(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out ushort Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViBoolean64(Instrument_Handle, Channel_Name, Attribute_ID, out Attribute_Value);
                else
                    return GetAttributeViBoolean32(Instrument_Handle, Channel_Name, Attribute_ID, out Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViSession32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out System.Runtime.InteropServices.HandleRef Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViSession64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out System.Runtime.InteropServices.HandleRef Attribute_Value);

            public static int GetAttributeViSession(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, out System.Runtime.InteropServices.HandleRef Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViSession64(Instrument_Handle, Channel_Name, Attribute_ID, out Attribute_Value);
                else
                    return GetAttributeViSession32(Instrument_Handle, Channel_Name, Attribute_ID, out Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViInt3232(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViInt3264(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Attribute_Value);

            public static int SetAttributeViInt32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, int Attribute_Value)
            {
                if (Is64BitProcess) return SetAttributeViInt3264(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViInt3232(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SetAttributeViInt64", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViInt6432(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, long Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SetAttributeViInt64", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViInt6464(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, long Attribute_Value);

            public static int SetAttributeViInt64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, long Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViInt6464(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViInt6432(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViReal6432(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, double Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViReal6464(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, double Attribute_Value);

            public static int SetAttributeViReal64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, double Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViReal6464(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViReal6432(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViString32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, string Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViString64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, string Attribute_Value);

            public static int SetAttributeViString(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, string Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViString64(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViString32(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViBoolean32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, ushort Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViBoolean64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, ushort Attribute_Value);

            public static int SetAttributeViBoolean(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, ushort Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViBoolean64(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViBoolean32(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViSession32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, System.Runtime.InteropServices.HandleRef Attribute_Value);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViSession64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, System.Runtime.InteropServices.HandleRef Attribute_Value);

            public static int SetAttributeViSession(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int Attribute_ID, System.Runtime.InteropServices.HandleRef Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViSession64(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViSession32(Instrument_Handle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetUserData", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetUserData32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int bufferSize, out char[] data, out int actualDataSize);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetUserData", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetUserData64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int bufferSize, out char[] data, out int actualDataSize);

            public static int GetUserData(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int bufferSize, out char[] data, out int actualDataSize)
            {
                if (Is64BitProcess)
                    return GetUserData64(Instrument_Handle, Channel_Name, bufferSize, out data, out actualDataSize);
                else
                    return GetUserData32(Instrument_Handle, Channel_Name, bufferSize, out data, out actualDataSize);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_SetUserData", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetUserData32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int bufferSize, char[] data);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_SetUserData", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetUserData64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int bufferSize, char[] data);

            public static int SetUserData(System.Runtime.InteropServices.HandleRef Instrument_Handle, string Channel_Name, int bufferSize, char[] data)
            {
                if (Is64BitProcess)
                    return SetUserData64(Instrument_Handle, Channel_Name, bufferSize, data);
                else
                    return SetUserData32(Instrument_Handle, Channel_Name, bufferSize, data);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetError", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetError32(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int errorCode, int BufferSize, System.Text.StringBuilder Description);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetError", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetError64(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int errorCode, int BufferSize, System.Text.StringBuilder Description);

            public static int GetError(System.Runtime.InteropServices.HandleRef Instrument_Handle, out int errorCode, int BufferSize, System.Text.StringBuilder Description)
            {
                if (Is64BitProcess)
                    return GetError64(Instrument_Handle, out  errorCode, BufferSize, Description);
                else
                    return GetError32(Instrument_Handle, out errorCode, BufferSize, Description);
            }


            public static int TestForError(System.Runtime.InteropServices.HandleRef handle, int status)
            {
                if ((status < 0))
                {
                    PInvoke.ThrowError(handle, status);
                }
                return status;
            }

            public static int ThrowError(System.Runtime.InteropServices.HandleRef handle, int code)
            {
                int status;
                int size = PInvoke.GetError(handle, out status, 0, null);
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                if ((size >= 0))
                {
                    msg.Capacity = size;
                    PInvoke.GetError(handle, out status, size, msg);
                }
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), code);
            }

            //Added in 14.5

            public static int CheckIfWaveformExists(System.Runtime.InteropServices.HandleRef Instrument_Handle, string waveformName, out bool waveformExists)
            {
                if (Is64BitProcess)
                    return CheckIfWaveformExists64(Instrument_Handle, waveformName, out waveformExists);
                else
                    return CheckIfWaveformExists32(Instrument_Handle, waveformName, out waveformExists);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_CheckIfWaveformExists", CallingConvention = CallingConvention.StdCall)]
            public static extern int CheckIfWaveformExists32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string waveformName, out bool waveformExists);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_CheckIfWaveformExists", CallingConvention = CallingConvention.StdCall)]
            public static extern int CheckIfWaveformExists64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string waveformName, out bool waveformExists);

            public static int CheckIfScriptExists(System.Runtime.InteropServices.HandleRef Instrument_Handle, string scriptName, out bool scriptExists)
            {
                if (Is64BitProcess)
                    return CheckIfScriptExists64(Instrument_Handle, scriptName, out scriptExists);
                else
                    return CheckIfScriptExists32(Instrument_Handle, scriptName, out scriptExists);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_CheckIfScriptExists", CallingConvention = CallingConvention.StdCall)]
            public static extern int CheckIfScriptExists32(System.Runtime.InteropServices.HandleRef Instrument_Handle, string scriptName, out bool scriptExists);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_CheckIfScriptExists", CallingConvention = CallingConvention.StdCall)]
            public static extern int CheckIfScriptExists64(System.Runtime.InteropServices.HandleRef Instrument_Handle, string scriptName, out bool scriptExists);
                        
            public static int CheckIfConfigurationListExists(System.Runtime.InteropServices.HandleRef instrumentHandle, string listName, out bool listExists)
            {
                if (Is64BitProcess)
                    return CheckIfConfigurationListExists64(instrumentHandle, listName, out  listExists);
                else
                    return CheckIfConfigurationListExists32(instrumentHandle, listName, out  listExists);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_CheckIfConfigurationListExists", CallingConvention = CallingConvention.StdCall)]
            public static extern int CheckIfConfigurationListExists32(System.Runtime.InteropServices.HandleRef instrumentHandle, string listName, out bool listExists);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_CheckIfConfigurationListExists", CallingConvention = CallingConvention.StdCall)]
            public static extern int CheckIfConfigurationListExists64(System.Runtime.InteropServices.HandleRef instrumentHandle, string listName, out bool listExists);

            public static int PerformPowerSearch(System.Runtime.InteropServices.HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return PerformPowerSearch64(instrumentHandle);
                else
                    return PerformPowerSearch32(instrumentHandle);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_PerformPowerSearch", CallingConvention = CallingConvention.StdCall)]
            public static extern int PerformPowerSearch32(System.Runtime.InteropServices.HandleRef instrumentHandle);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_PerformPowerSearch", CallingConvention = CallingConvention.StdCall)]
            public static extern int PerformPowerSearch64(System.Runtime.InteropServices.HandleRef instrumentHandle);
                        
            public static int GetSelfCalibrationTemperature(System.Runtime.InteropServices.HandleRef instrumentHandle, int module, out double temperature)
            {
                if (Is64BitProcess)
                    return GetSelfCalibrationTemperature64(instrumentHandle, module, out  temperature);
                else
                    return GetSelfCalibrationTemperature32(instrumentHandle, module, out  temperature);
            }

            [DllImport(nativeDllName32, EntryPoint = "niRFSG_GetSelfCalibrationTemperature", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetSelfCalibrationTemperature32(System.Runtime.InteropServices.HandleRef instrumentHandle, int module, out double temperature);

            [DllImport(nativeDllName64, EntryPoint = "niRFSG_GetSelfCalibrationTemperature", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetSelfCalibrationTemperature64(System.Runtime.InteropServices.HandleRef instrumentHandle, int module, out double temperature);



        }

        //Added in 14.5              
        
        /// <summary>
        /// 
        /// niRFSG_CheckIfWaveformExists
        /// 
        /// C Function Prototype
        /// ViStatus niRFSG_CheckIfWaveformExists ViSession vi, ViConstString waveformName, ViBoolean* waveformExists);
        /// Purpose
        /// Returns whether the waveform that you specify as waveformName exists.
        /// Supported Devices NI 5673/5673E
        /// 
        /// </summary>
        /// <param name="waveformName">
        /// 
        /// waveformName
        /// ViConstString
        /// Specifies the name used to store the waveform. This string is case-insensitive.
        /// 
        /// </param>
        /// <param name="waveformExists">
        /// 
        /// waveformExists
        /// ViBoolean*
        /// Returns VI_TRUE if the waveform exists.
        /// Defined Values:
        /// VI_TRUEThe waveform exists. VI_FALSE The waveform does not exist.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition.
        /// 
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// Value  Meaning
        /// 0  Success
        /// Positive Values  Warnings
        /// Negative Values  Errors
        /// 
        /// </returns>
        public int CheckIfWaveformExists(string waveformName, out bool waveformExists)
        {
            int pInvokeResult = PInvoke.CheckIfWaveformExists(this._handle, waveformName, out waveformExists);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_CheckIfScriptExists
        /// 
        /// C Function Prototype
        /// ViStatus niRFSG_CheckIfScriptExists (ViSession vi, ViConstString scriptName, ViBoolean* scriptExists);
        /// Purpose
        /// Returns whether the script that you specify as scriptName exists. 
        /// Supported Devices NI 5673/5673E
        /// 
        /// </summary>
        /// <param name="scriptName">
        /// 
        /// waveformName
        /// ViConstString
        /// Specifies the name of the script. This string is case-insensitive
        /// 
        /// 
        /// </param>
        /// <param name="scriptExists">
        /// 
        /// scriptExists
        /// ViBoolean*
        /// Returns VI_TRUE if the script exists.
        /// 
        /// Valid Values:
        /// VI_TRUE The script exists.
        /// VI_FALSE The script does not exist.
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition.
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        ///           
        /// The general meaning of the status code is as follows:
        /// Value  Meaning
        /// 0  Success
        /// Positive Values  Warnings
        /// Negative Values  Errors
        /// </returns>
        public int CheckIfScriptExists(string scriptName, out bool scriptExists)
        {
            int pInvokeResult = PInvoke.CheckIfScriptExists(this._handle, scriptName, out scriptExists);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_CheckIfConfigurationListExists
        /// 
        /// C Function Prototype
        /// ViStatus niRFSG_CheckIfConfigurationListExists (ViSession vi, ViConstString listName, ViBoolean* listExists);
        /// Purpose
        /// Returns whether the configuration list that you specify as listName exists.
        /// Supported Devices NI PXIe-5650/5651/5652/5654/5654 with NI 5696, NI 5673E
        /// 
        /// </summary>
        /// <param name = "listName">
        /// listName
        /// ViConstString
        /// Specifies the name of the configuration list. This string is case-insensitive.
        /// 
        /// </param>
        /// <param name = "listExists">
        /// listExists
        /// ViBoolean*
        /// Returns VI_TRUE if the configuration list exists.
        /// Defined Values:
        /// VI_TRUE The configuration list exists. 
        /// VI_FALSE The configuration list does not exist.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// 
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition.
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        /// 
        /// The general meaning of the status code is as follows:
        /// Value  Meaning
        /// 0  Success
        /// Positive Values  Warnings
        /// Negative Values  Errors
        /// </returns>
        public int CheckIfConfigurationListExists(string listName, out bool listExists)
        {
            int pInvokeResult = PInvoke.CheckIfConfigurationListExists(this._handle, listName, out listExists);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_GetSelfCalibrationTemperature
        /// 
        /// C Function Prototype
        /// ViStatus niRFSG_GetSelfCalibrationTemperature&#160;(ViSession vi, ViInt32 module, ViReal64* temperature);
        /// Purpose
        /// Returns the temperature, in degrees Celsius, of the device at the last successful self-calibration. 
        /// Supported Devices: NI 5610, NI 5653, NI 5670/5671/5672/5673/5673E
        /// 
        /// </summary>
        /// <param name = "module">
        ///
        /// Module
        /// ViInt32
        /// 
        /// Specifies from which module to retrieve the last successful self-calibration temperature.
        /// Defined Values:
        /// NIRFSG_VAL_PRIMARY_MODULEThe stand-alone device or the main module in a multi-module device.
        /// NIRFSG_VAL_AWGThe AWG associated with the primary module.
        /// NIRFSG_VAL_LOThe LO associated with the primary module.
        /// Default Value: NIRFSG_VAL_PRIMARY_MODULE
        /// 
        /// </param>
        /// <param name = "temperature">
        ///
        /// temperature
        /// ViReal64*
        /// Returns the temperature, in degrees Celsius, of the device at the last successful self-calibration.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// 
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition.
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        /// 
        /// The general meaning of the status code is as follows:
        /// Value  Meaning
        /// 0  Success
        /// Positive Values  Warnings
        /// Negative Values  Errors
        /// </returns>
        public int GetSelfCalibrationTemperature(int module, out double temperature)
        {
            int pInvokeResult = PInvoke.GetSelfCalibrationTemperature(this._handle, module, out temperature);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// niRFSG_PerformPowerSearch
        /// 
        /// C Function Prototype
        /// ViStatus niRFSG_PerformPowerSearch (ViSession vi);
        /// Purpose
        /// Performs a power search if the NIRFSG_ATTR_ALC_CONTROL attribute is disabled. Calling this function disables modulation for a short time while the device levels the output signal.
        /// Note  Power search temporarily enables the ALC, so ensure the appropriate included cable is connected between the NI 5654 ALC IN connector and the NI 5696 ALC OUT connector to successfully perform a power search.
        /// 
        /// Supported Devices NI 5654 with NI 5696
        /// 
        /// </summary>
        ///<returns>
        /// 
        /// status
        /// ViStatus
        /// 
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition.
        /// To obtain a text description of the error code, call the niRFSG_GetError function.
        /// 
        /// The general meaning of the status code is as follows:
        /// Value  Meaning
        /// 0  Success
        /// Positive Values  Warnings
        /// Negative Values  Errors
        /// 
        ///</returns>
        public int PerformPowerSearch()
        {
            int pInvokeResult = PInvoke.PerformPowerSearch(this._handle);
            PInvoke.TestForError(this._handle, pInvokeResult);
            return pInvokeResult;
        }



    }
    /// <summary>
    /// 
    /// </summary>
    public class niRFSGConstants
    {
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string Rtsi7Str = "RTSI7";
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string Rtsi0Str = "RTSI0";
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string Rtsi4Str = "RTSI4";
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string Rtsi1Str = "RTSI1";
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string Rtsi5Str = "RTSI5";
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string Rtsi2Str = "RTSI2";
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string Rtsi6Str = "RTSI6";
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string Rtsi3Str = "RTSI3";
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string OnBoardClockStr = "OnBoardClock";
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string onboardClockStr = "OnboardClock";
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const string PxiClk10Str = "PXI_CLK10";
        /// <summary>
        /// 
        /// </summary>
        public const int Cw = 1000;
        /// <summary>
        /// 
        /// </summary>
        public const int ArbWaveform = 1001;
        /// <summary>
        /// 
        /// </summary>
        public const int Script = 1002;
        /// <summary>
        /// 
        /// </summary>
        public const int AveragePower = 7000;
        /// <summary>
        /// 
        /// </summary>
        public const int PeakPower = 7001;
        /// <summary>
        /// 
        /// </summary>
        public const string Pfi0Str = "PFI0";
        /// <summary>
        /// 
        /// </summary>
        public const string Pfi1Str = "PFI1";
        /// <summary>
        /// 
        /// </summary>
        public const string Pfi2Str = "PFI2";
        /// <summary>
        /// 
        /// </summary>
        public const string Pfi3Str = "PFI3";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig0Str = "PXI_Trig0";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig1Str = "PXI_Trig1";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig2Str = "PXI_Trig2";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig3Str = "PXI_Trig3";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig4Str = "PXI_Trig4";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig5Str = "PXI_Trig5";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig6Str = "PXI_Trig6";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig7Str = "PXI_Trig7";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiStarStr = "PXI_STAR";
        /// <summary>
        /// 
        /// </summary>
        public const int RisingEdge = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int FallingEdge = 1;
        /// <summary>
        /// 
        /// </summary>
        public const string ScriptTrigger0 = "scriptTrigger0";
        /// <summary>
        /// 
        /// </summary>
        public const string ScriptTrigger1 = "scriptTrigger1";
        /// <summary>
        /// 
        /// </summary>
        public const string ScriptTrigger2 = "scriptTrigger2";
        /// <summary>
        /// 
        /// </summary>
        public const string ScriptTrigger3 = "scriptTrigger3";
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalOmitNone = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalLoSelfCal = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalPowerLevelAccuracy = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalResidualLoPower = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalImageSuppression = 8;
        /// <summary>
        /// 
        /// </summary>
        public const int ActiveHigh = 9000;
        /// <summary>
        /// 
        /// </summary>
        public const int ActiveLow = 9001;
        /// <summary>
        /// 
        /// </summary>
        public const int StartTrigger = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int ScriptTrigger = 1;
        /// <summary>
        /// 
        /// </summary>
        public const string Marker0EventStr = "Marker0Event";
        /// <summary>
        /// 
        /// </summary>
        public const string Marker1EventStr = "Marker1Event";
        /// <summary>
        /// 
        /// </summary>
        public const string Marker2EventStr = "Marker2Event";
        /// <summary>
        /// 
        /// </summary>
        public const string Marker3EventStr = "Marker3Event";
        /// <summary>
        /// 
        /// </summary>
        public const string TimerEventStr = "TimerEvent";
        /// <summary>
        /// 
        /// </summary>
        public const int MarkerEvent = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int RefClock = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int StartedEvent = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int DoneEvent = 5;
        /// <summary>
        /// 
        /// </summary>
        public const int ConfigurationListStepTrigger = 6;
        /// <summary>
        /// 
        /// </summary>
        public const string MarkerEvent0 = "marker0";
        /// <summary>
        /// 
        /// </summary>
        public const string MarkerEvent1 = "marker1";
        /// <summary>
        /// 
        /// </summary>
        public const string MarkerEvent2 = "marker2";
        /// <summary>
        /// 
        /// </summary>
        public const string MarkerEvent3 = "marker3";
        /// <summary>
        /// 
        /// </summary>
        public const string OnboardClockStr = "OnboardClock";
        /// <summary>
        /// 
        /// </summary>
        public const string RefInStr = "RefIn";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiClkStr = "PXI_CLK";
        /// <summary>
        /// 
        /// </summary>
        public const string ClkInStr = "ClkIn";
        /// <summary>
        /// 
        /// </summary>
        public const string NoneStr = "None";
        /// <summary>
        /// 
        /// </summary>
        public const string DoNotExportStr = "";
        /// <summary>
        /// 
        /// </summary>
        public const string RefOutStr = "RefOut";
        /// <summary>
        /// 
        /// </summary>
        public const string RefOut2Str = "RefOut2";
        /// <summary>
        /// 
        /// </summary>
        public const string Pfi4Str = "PFI4";
        /// <summary>
        /// 
        /// </summary>
        public const string Pfi5Str = "PFI5";
        /// <summary>
        /// 
        /// </summary>
        public const string SyncStartTriggerStr = "Sync_Start";
        /// <summary>
        /// 
        /// </summary>
        public const string SyncScriptTriggerStr = "Sync_Script";
        /// <summary>
        /// 
        /// </summary>
        public const string LoSourceOnboardStr = "Onboard";
        /// <summary>
        /// 
        /// </summary>
        public const string LoSourceLoInStr = "LO_In";
        /// <summary>
        /// 
        /// </summary>
        public const int Enable = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Disable = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int Auto = -1;
        /// <summary>
        /// 
        /// </summary>
        public const int ArbFilterTypeNone = 10000;
        /// <summary>
        /// 
        /// </summary>
        public const int ArbFilterTypeRootRaisedCosine = 10001;
        /// <summary>
        /// 
        /// </summary>
        public const int ArbFilterTypeRaisedCosine = 10002;
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const int DucNone = ArbFilterTypeNone;
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const int DucRootRaisedCosine = ArbFilterTypeRootRaisedCosine;
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const int DucRaisedCosine = ArbFilterTypeRaisedCosine;
        /// <summary>
        /// 
        /// </summary>
        public const int HighResolution = 6000;
        /// <summary>
        /// 
        /// </summary>
        public const int DivideDown = 6001;
        /// <summary>
        /// 
        /// </summary>
        public const string ClkOutStr = "ClkOut";
        /// <summary>
        /// 
        /// </summary>
        public const int None = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int Fm = 2000;
        /// <summary>
        /// 
        /// </summary>
        public const int Pm = 2001;
        /// <summary>
        /// 
        /// </summary>
        public const int Sine = 3000;
        /// <summary>
        /// 
        /// </summary>
        public const int Square = 3001;
        /// <summary>
        /// 
        /// </summary>
        public const int Triangle = 3002;
        /// <summary>
        /// 
        /// </summary>
        public const int Fsk = 4000;
        /// <summary>
        /// 
        /// </summary>
        public const int Ook = 4001;
        /// <summary>
        /// 
        /// </summary>
        public const int Psk = 4002;
        /// <summary>
        /// 
        /// </summary>
        public const int Prbs = 5000;
        /// <summary>
        /// 
        /// </summary>
        public const int RfOut = 14000;
        /// <summary>
        /// 
        /// </summary>
        public const int IqOut = 14001;
        /// <summary>
        /// 
        /// </summary>
        public const int CalOut = 14002;
        /// <summary>
        /// 
        /// </summary>
        public const int IOnly = 14003;
        /// <summary>
        /// 
        /// </summary>
        public const int Differential = 15000;
        /// <summary>
        /// 
        /// </summary>
        public const int SingleEnded = 15001;
        /// <summary>
        /// 
        /// </summary>
        public const int UserDefined = 5001;
        /// <summary>
        /// 
        /// </summary>
        public const int Medium = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Wide = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int Slow = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int Fast = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int TimeAfterLock = 12000;
        /// <summary>
        /// 
        /// </summary>
        public const int TimeAfterIo = 12001; //IO?
        /// <summary>
        /// 
        /// </summary>
        public const int Ppm = 12002;
        /// <summary>
        /// 
        /// </summary>
        public const int DigitalEdge = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int DigitalLevel = 8000;
        /// <summary>
        /// 
        /// </summary>
        public const int Software = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int P2pEndpointFullness = 3; //P2P?
        /// <summary>
        /// 
        /// </summary>
        public const int MaxTimeImmediate = 0;
        /// <summary>
        /// 
        /// </summary>
        public const Int64 MaxTimeInfinite = 0xFFFFFFFF;
        /// <summary>
        /// 
        /// </summary>
        public const int ArbTriggerSourceImmediate = None;
        /// <summary>
        /// 
        /// </summary>
        public const int ArbTriggerSourceExternal = DigitalEdge;
        /// <summary>
        /// 
        /// </summary>
        public const int ArbTriggerSourceSoftware = Software;
        /// <summary>
        /// 
        /// </summary>
        public const int ArbExternalTriggerSlopePositive = RisingEdge;
        /// <summary>
        /// 
        /// </summary>
        public const int ArbExternalTriggerSlopeNegative = FallingEdge;
        /// <summary>
        /// 
        /// </summary>
        public const int Percent = 11000;
        /// <summary>
        /// 
        /// </summary>
        public const int Volts = 11001;
        /// <summary>
        /// 
        /// </summary>
        public const int ExactMatch = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int Minimum = 1;

        //NIRFSG_ATTR_ANALOG_MODULATION_TYPE
        /// <summary>
        /// 
        /// </summary>
        public const int FmContinuous = 14000;
        /// <summary>
        /// 
        /// </summary>
        public const int FmBanded = 14001;

        //Added in 14.5

        /// <summary>
        /// 
        /// </summary>
        public const int ConfigurationSettledEvent = 7;
        /// <summary>
        /// 
        /// </summary>
        public const string TrigInStr = "TrigIn";
        /// <summary>
        /// 
        /// </summary>
        public const string TrigOutStr = "TrigOut";
        /// <summary>
        /// 
        /// </summary>
        public const int _10mhz = 10000000;
        /// <summary>
        /// 
        /// </summary>
        public const int ConfigurationListRepeatContinuous = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int ConfigurationListRepeatSingle = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Narrow = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int Am = 2002;
        /// <summary>
        /// 
        /// </summary>
        public const int HighPower = 16000;
        /// <summary>
        /// 
        /// </summary>
        public const int LowHarmonic = 16001;
        /// <summary>
        /// 
        /// </summary>
        public const int Narrowband = 17000;
        /// <summary>
        /// 
        /// </summary>
        public const int Wideband = 17001;
        /// <summary>
        /// 
        /// </summary>
        public const int _100hzTo1khz = 18000;
        /// <summary>
        /// 
        /// </summary>
        public const int _1khzTo10khz = 18001;
        /// <summary>
        /// 
        /// </summary>
        public const int _10khzTo100khz = 18002;
        /// <summary>
        /// 
        /// </summary>
        public const int HighDeviation = 19000;
        /// <summary>
        /// 
        /// </summary>
        public const int LowPhaseNoise = 19001;
        /// <summary>
        /// 
        /// </summary>
        public const int OptimalMatch = 20000;
        /// <summary>
        /// 
        /// </summary>
        public const int HighIsolation = 20001;
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const int ReferenceOscillatorSourceInternal = 0;
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const int ReferenceOscillatorSourceExternal = 1;
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const int RefClockSourcePxiClk = 1001;
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        public const int Low = 0;
    }
    /// <summary>
    /// 
    /// </summary>
    public enum niRFSGProperties
    {
        ///<summary>
        ///System.string
        /// </summary>
        IOResourceDescriptor = 1050304,

        /// <summary>
        /// System.Double
        /// </summary>
        ArbCarrierFrequency = 1150015,

        ///<summary>
        ///System.Boolean
        /// </summary>
        CompensateForFilterGroupDelay = 119740,

        /// <summary>
        /// System.Int32
        /// </summary>
        DataTransferBlockSize = 1150048,

        /// <summary>
        /// System.Boolean
        /// </summary>
        DirectDmaEnabled = 1150049,

        /// <summary>
        /// System.Int32
        /// </summary>
        DirectDmaWindowAddress = 1150050,

        /// <summary>
        /// System.Int32
        /// </summary>
        DirectDmaWindowSize = 1150051,

        /// <summary>
        /// System.Int32
        /// </summary>
        DirectDownload = 1150042,

        /// <summary>
        /// System.Int32
        /// </summary>
        StreamingSpaceAvailableInWaveform = 1150047,

        /// <summary>
        /// System.Boolean
        /// </summary>
        StreamingEnabled = 1150045,

        /// <summary>
        /// System.Double
        /// </summary>
        StreamingWriteTimeout = 1150140,

        /// <summary>
        /// System.String
        /// </summary>
        StreamingWaveformName = 1150046,

        /// <summary>
        /// System.Double
        /// </summary>
        DataTransferMaximumBandwidth = 1150086,

        /// <summary>
        /// System.Int32
        /// </summary>
        DataTransferMaximumInFlightReads = 1150088,

        /// <summary>
        /// System.Int32
        /// </summary>
        DataTransferPreferredPacketSize = 1150087,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalEqualizationEnabled = 1150012,

        /// <summary>
        /// System.Boolean
        /// </summary>
        DigitalPattern = 1150044,

        /// <summary>
        /// System.Int32
        /// </summary>
        GenerationMode = 1150018,

        /// <summary>
        /// System.Double
        /// </summary>
        IqRate = 1250452,

        /// <summary>
        /// System.Boolean
        /// </summary>
        IqSwapEnabled = 1250404,

        /// <summary>
        /// System.Int32
        /// </summary>
        MemorySize = 1150061,

        /// <summary>
        /// System.Int32
        /// </summary>
        PhaseContinuityEnabled = 1150005,

        /// <summary>
        /// System.Double
        /// </summary>
        ArbPower = 1150016,

        /// <summary>
        /// System.Double
        /// </summary>
        ArbPreFilterGain = 1150025,

        /// <summary>
        /// System.Int32
        /// </summary>
        ArbFilterType = 1150056,

        /// <summary>
        /// System.Double
        /// </summary>
        ArbFilterRaisedCosineAlpha = 1150060,

        /// <summary>
        /// System.Double
        /// </summary>
        ArbFilterRootRaisedCosineAlpha = 1150057,

        /// <summary>
        /// System.String
        /// </summary>
        SelectedScript = 1150023,

        /// <summary>
        /// System.Double
        /// </summary>
        SignalBandwidth = 1150007,

        /// <summary>
        /// System.Double
        /// </summary>
        ArbWaveformSoftwareScalingFactor = 1150052,

        /// <summary>
        /// System.Int32
        /// </summary>
        ArbMaxNumberWaveforms = 1250454,

        /// <summary>
        /// System.Int32
        /// </summary>
        ArbWaveformSizeMax = 1250457,

        /// <summary>
        /// System.Int32
        /// </summary>
        ArbWaveformSizeMin = 1250456,

        /// <summary>
        /// System.Int32
        /// </summary>
        ArbWaveformQuantum = 1250455,

        /// <summary>
        /// int
        /// </summary>
        ArbWaveformRepeatCount = 1150158,

        /// <summary>
        /// bool
        /// </summary>
        ArbWaveformRepeatCountIsFinite = 1150157,

        /// <summary>
        /// System.Int32
        /// </summary>
        ArbOscillatorPhaseDacValue = 1150089,

        /// <summary>
        /// System.Int32
        /// </summary>
        ArbOnboardSampleClockMode = 1150029,

        /// <summary>
        /// System.Double
        /// </summary>
        ArbSampleClockRate = 1150031,

        /// <summary>
        /// System.String
        /// </summary>
        ArbSampleClockSource = 1150030,

        /// <summary>
        /// System.String
        /// </summary>
        PxiChassisClk10Source = 1150004,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedRefClockOutputTerminal = 1150053,

        /// <summary>
        /// System.Double
        /// </summary>
        RefClockRate = 1250322,

        /// <summary>
        /// System.String
        /// </summary>
        RefClockSource = 1150001,

        /// <summary>
        /// System.String
        /// </summary>
        ActiveConfigurationList = 1150096,

        /// <summary>
        /// System.Int32
        /// </summary>
        ActiveConfigurationListStep = 1150097,

        /// <summary>
        /// System.Int32
        /// </summary>
        ConfigurationListStepInProgress = 1150122,

        /// <summary>
        /// System.Double
        /// </summary>
        ArbTemperature = 1150068,

        /// <summary>
        /// System.Double
        /// </summary>
        DeviceTemperature = 1150017,

        /// <summary>
        /// System.Double
        /// </summary>
        LoTemperature = 1150075,

        /// <summary>
        /// System.String
        /// </summary>
        SerialNumber = 1150026,

        /// <summary>
        /// System.String
        /// </summary>
        ModuleRevision = 1150084,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedDoneEventOutputTerminal = 1150063,

        /// <summary>
        /// System.String
        /// </summary>
        DoneEventTerminalName = 1150113,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedMarkerEventOutputTerminal = 1150064,

        /// <summary>
        /// System.String
        /// </summary>
        MarkerEventTerminalName = 1150115,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedStartedEventOutputTerminal = 1150065,

        /// <summary>
        /// System.String
        /// </summary>
        StartedEventTerminalName = 1150112,

        /// <summary>
        /// string
        /// </summary>
        SyncSampleClockDistLine = 1150181,

        /// <summary>
        /// bool
        /// </summary>
        SyncSampleClockMaster = 1150180,

        /// <summary>
        /// string
        /// </summary>
        SyncScriptTriggerDistLine = 1150143,

        /// <summary>
        /// bool
        /// </summary>
        SyncScriptTriggerMaster = 1150142,

        /// <summary>
        /// string
        /// </summary>
        SyncStartTriggerDistLine = 1150156,

        /// <summary>
        /// bool
        /// </summary>
        SyncStartTriggerMaster = 1150155,

        /// <summary>
        /// double
        /// </summary>
        EventsDelay = 1150154,

        /// <summary>
        /// double
        /// </summary>
        InterpolationDelay = 1150153,

        /// <summary>
        /// RfsgAttrOutputPort
        /// </summary>
        OutputPort = 1150144,

        /// <summary>
        /// string
        /// </summary>
        LoSource = 1150150,

        /// <summary>
        /// double
        /// </summary>
        LoFrequencyStepSize = 1150151,

        /// <summary>
        /// RfsgAttrDigitalEqualizationEnabled
        /// </summary>
        LoPllFractionalModeEnabled = 1150152,

        /// <summary>
        /// double
        /// </summary>
        IqOutPortCarrierFrequency = 1150145,


        /// <summary>
        /// RfsgAttrIqOutPortTerminalConfiguration
        /// </summary>
        IqOutPortTerminalConfiguration = 1150146,

        /// <summary>
        /// double
        /// </summary>
        IqOutPortLevel = 1150147,

        /// <summary>
        /// double
        /// </summary>
        IqOutPortCommonModeOffset = 1150148,

        /// <summary>
        /// double
        /// </summary>
        IqOutPortOffset = 1150149,

        /// <summary>
        /// double
        /// </summary>
        IqOutPortTemperature = 1150161,

        /// <summary>
        /// double
        /// </summary>
        IqOutPortLoadImpedance = 1150163,

        /// <summary>
        /// string
        /// </summary>
        RfBlankingSource = 1150162,

        /// <summary>
        /// string
        /// </summary>
        FpgaBitfilePath = 1150186,

        /// <summary>
        /// System.Double
        /// </summary>
        TimerEventInterval = 1150100,

        /// <summary>
        /// System.Double
        /// </summary>
        ExternalCalibrationTemperature = 1150077,

        /// <summary>
        /// System.Int32
        /// </summary>
        ExternalCalibrationRecommendedInterval = 1150076,

        /// <summary>
        /// System.String
        /// </summary>
        LogicalName = 1050305,

        /// <summary>
        /// System.String
        /// </summary>
        DriverSetup = 1050007,

        /// <summary>
        /// System.String
        /// </summary>
        GroupCapabilities = 1050401,

        /// <summary>
        /// System.String
        /// </summary>
        SupportedInstrumentModels = 1050327,

        /// <summary>
        /// System.Int32
        /// </summary>
        SpecificDriverClassSpecMajorVersion = 1050515,

        /// <summary>
        /// System.Int32
        /// </summary>
        SpecificDriverClassSpecMinorVersion = 1050516,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverDescription = 1050514,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverPrefix = 1050302,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverVendor = 1050513,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverRevision = 1050551,

        /// <summary>
        /// System.String
        /// </summary>
        InstrumentFirmwareRevision = 1050510,

        /// <summary>
        /// System.String
        /// </summary>
        InstrumentManufacturer = 1050511,

        /// <summary>
        /// System.String
        /// </summary>
        InstrumentModel = 1050512,

        /// <summary>
        /// System.Boolean
        /// </summary>
        Cache = 1050004,

        /// <summary>
        /// System.Boolean
        /// </summary>
        InterchangeCheck = 1050021,

        /// <summary>
        /// System.Boolean
        /// </summary>
        QueryInstrumentStatus = 1050003,

        /// <summary>
        /// System.Boolean
        /// </summary>
        RangeCheck = 1050002,

        /// <summary>
        /// System.Boolean
        /// </summary>
        RecordCoercions = 1050006,

        /// <summary>
        /// System.Boolean
        /// </summary>
        Simulate = 1050005,

        /// <summary>
        /// System.Boolean
        /// </summary>
        IqImpairmentEnabled = 1150069,

        /// <summary>
        /// System.Int32
        /// </summary>
        IqOffsetUnits = 1150081,

        /// <summary>
        /// System.Double
        /// </summary>
        IqIOffset = 1150070,

        /// <summary>
        /// System.Double
        /// </summary>
        IqQOffset = 1150071,

        /// <summary>
        /// System.Double
        /// </summary>
        IqGainImbalance = 1150072,

        /// <summary>
        /// System.Double
        /// </summary>
        IqSkew = 1150073,

        /// <summary>
        /// System.Double
        /// </summary>
        AnalogModulationFmDeviation = 1150035,

        /// <summary>
        /// System.Int32
        /// </summary>
        AnalogModulationType = 1150032,

        /// <summary>
        /// System.Double
        /// </summary>
        AnalogModulationPmDeviation = 1150062,

        /// <summary>
        /// System.Double
        /// </summary>
        AnalogModulationWaveformFrequency = 1150034,

        /// <summary>
        /// System.Int32
        /// </summary>
        AnalogModulationWaveformType = 1150033,

        /// <summary>
        /// System.Double
        /// </summary>
        DigitalModulationFskDeviation = 1150041,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalModulationType = 1150036,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalModulationPrbsOrder = 1150039,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalModulationPrbsSeed = 1150040,

        /// <summary>
        /// System.Double
        /// </summary>
        DigitalModulationSymbolRate = 1150037,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalModulationWaveformType = 1150038,

        /// <summary>
        /// double
        /// </summary>
        UpconverterFrequencyOffset = 1150160,

        /// <summary>
        /// System.Double
        /// </summary>
        UpconverterCenterFrequencyIncrement = 1150058,

        /// <summary>
        /// System.Double
        /// </summary>
        UpconverterCenterFrequencyIncrementAnchor = 1150059,

        /// <summary>
        /// System.Int32
        /// </summary>
        P2pDataTransferPermissionitialCredits = 1150135,

        /// <summary>
        /// System.Int32
        /// </summary>
        P2pDataTransferPermissionInterval = 1150134,

        /// <summary>
        /// System.Boolean
        /// </summary>
        P2pEnabled = 1150123,

        /// <summary>
        /// System.Int32
        /// </summary>
        P2pEndpointCount = 1150127,

        /// <summary>
        /// System.Int32
        /// </summary>
        P2pEndpointSize = 1150124,

        /// <summary>
        /// System.Int32
        /// </summary>
        P2pMostSpaceAvailableInEndpoint = 1150126,

        /// <summary>
        /// System.Int32
        /// </summary>
        P2pSpaceAvailableInEndpoint = 1150125,

        /// <summary>
        /// System.Int32
        /// </summary>
        RefPllBandwidth = 1150133,

        /// <summary>
        /// System.Int32
        /// </summary>
        YigMainCoilDrive = 1150118,

        /// <summary>
        /// System.Int32
        /// </summary>
        AllowOutOfSpecificationUserSettings = 1150014,

        /// <summary>
        /// System.Boolean
        /// </summary>
        AttenuatorHoldEnabled = 1150009,

        /// <summary>
        /// System.Double
        /// </summary>
        AttenuatorHoldMaxPower = 1150010,

        /// <summary>
        /// System.Int32
        /// </summary>
        AutomaticThermalCorrection = 1150008,

        /// <summary>
        /// System.Double
        /// </summary>
        ExternalGain = 1150085,

        /// <summary>
        /// System.Double
        /// </summary>
        Frequency = 1250001,

        /// <summary>
        /// System.Double
        /// </summary>
        FrequencySettling = 1150083,

        /// <summary>
        /// System.Int32
        /// </summary>
        FrequencySettlingUnits = 1150082,

        /// <summary>
        /// System.Double
        /// </summary>
        FrequencyTolerance = 1150006,

        /// <summary>
        /// System.Double
        /// </summary>
        LoInPower = 1150067,

        /// <summary>
        /// System.Boolean
        /// </summary>
        LoOutEnabled = 1150013,

        /// <summary>
        /// System.Double
        /// </summary>
        LoOutPower = 1150066,

        /// <summary>
        /// System.Int32
        /// </summary>
        LoopBandwidth = 1150027,

        /// <summary>
        /// System.Boolean
        /// </summary>
        OutputEnabled = 1250004,

        /// <summary>
        /// System.Double
        /// </summary>
        PeakEnvelopePower = 1150011,

        /// <summary>
        /// System.Double
        /// </summary>
        PeakPowerAdjustment = 1150132,

        /// <summary>
        /// System.Int32
        /// </summary>
        PeakPowerAdjsutmentInheritance = 1150141,

        /// <summary>
        /// System.Double
        /// </summary>
        PhaseOffset = 1150024,

        /// <summary>
        /// System.Double
        /// </summary>
        PowerLevel = 1250002,

        /// <summary>
        /// System.Int32
        /// </summary>
        PowerLevelType = 1150043,

        /// <summary>
        /// System.Double
        /// </summary>
        UpconverterCenterFrequency = 1154098,

        /// <summary>
        /// System.Double
        /// </summary>
        UpconverterGain = 1154097,

        /// <summary>
        /// System.Boolean
        /// </summary>
        PulseModulationEnabled = 1250051,

        /// <summary>
        /// System.Double
        /// </summary>
        SelfCalibrationTemperature = 1150136,

        /// <summary>
        /// System.Int32
        /// </summary>
        ConfigurationListStepTriggerType = 1150098,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedConfigurationListStepTriggerOutputTerminal = 1150105,

        /// <summary>
        /// System.String
        /// </summary>
        ConfigurationListStepTriggerTerminalName = 1150117,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalEdgeConfigurationListStepTriggerEdge = 1150103,

        /// <summary>
        /// System.String
        /// </summary>
        DigitalEdgeConfigurationListStepTriggerSource = 1150099,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalEdgeScriptTriggerEdge = 1150021,

        /// <summary>
        /// System.String
        /// </summary>
        DigitalEdgeScriptTriggerSource = 1150020,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalLevelScriptTriggerActiveLevel = 1150055,

        /// <summary>
        /// System.String
        /// </summary>
        DigitalLevelScriptTriggerSource = 1150054,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedScriptTriggerOutputTerminal = 1150022,

        /// <summary>
        /// System.String
        /// </summary>
        ScriptTriggerTerminalName = 1150116,

        /// <summary>
        /// System.Int32
        /// </summary>
        ScriptTriggerType = 1150019,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalEdgeStartTriggerEdge = 1250459,

        /// <summary>
        /// System.String
        /// </summary>
        DigitalEdgeStartTriggerSource = 1150002,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedStartTriggerOutputTerminal = 1150003,

        /// <summary>
        /// System.Int32
        /// </summary>
        P2pEndpointFullnessStartTriggerLevel = 1150128,

        /// <summary>
        /// System.String
        /// </summary>
        StartTriggerTerminalName = 1150114,

        /// <summary>
        /// System.Int32
        /// </summary>
        StartTriggerType = 1250458,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        ThermalCorrectionEnabled = AutomaticThermalCorrection,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        SampleClockRate = IqRate,

        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        UpconverterTemperature = DeviceTemperature,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        LocalOscillatorOut0Enabled = LoOutEnabled,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        IfCarrierFrequency = ArbCarrierFrequency,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        IfPower = ArbPower,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        DigitalIfEqualizationEnabled = DigitalEqualizationEnabled,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        DucPreFilterGain = ArbPreFilterGain,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        DucFirFilterType = ArbFilterType,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        DucFirFilterRootRaisedCosineAlpha = ArbFilterRootRaisedCosineAlpha,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        DucFirFilterRaisedCosineAlpha = ArbFilterRaisedCosineAlpha,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        UpconverterLoopBandwidth = LoopBandwidth,
        /// <summary>
        /// 
        /// </summary>
        Spy = 1050022,
        /// <summary>
        /// 
        /// </summary>
        UseSpecificSimulation = 1050023,
        /// <summary>
        /// 
        /// </summary>
        ChannelCount = 1050203,
        /// <summary>
        /// 
        /// </summary>
        FunctionCapabilities = 1050402,
        /// <summary>
        /// 
        /// </summary>
        IqNominalVoltage = 1250402,
        /// <summary>
        /// 
        /// </summary>
        IqEnabled = 1250401,
        /// <summary>
        /// 
        /// </summary>
        ArbFilterFrequency = 1250453,
        /// <summary>
        /// 
        /// </summary>
        FgenSession = 1150028,
        /// <summary>
        /// 
        /// </summary>
        LoSession = 1150074,
        /// <summary>
        /// 
        /// </summary>
        ReferenceOscillatorExternalFrequency = RefClockRate,
        /// <summary>
        /// 
        /// </summary>
        ArbTriggerSource = StartTriggerType,

        // Added in 14.5
        /// <summary>
        /// RfsgPulseModulationMode
        /// </summary>
        PulseModulationMode = 1150190,
        /// <summary>
        /// RfsgAnalogModulationFmBand
        /// </summary>
        AnalogModulationFmBand = 1150191,
        /// <summary>
        /// RfsgAnalogModulationFmNarrowbandIntegrator
        /// </summary>
        AnalogModulationFmNarrowbandIntegrator = 1150165,
        /// <summary>
        /// System.Double
        /// </summary>
        AnalogModulationFmSensitivity = 1150166,
        /// <summary>
        /// System.Double
        /// </summary>
        AnalogModulationAmSensitivity = 1150167,
        /// <summary>
        /// System.Double
        /// </summary>
        AnalogModulationPmSensitivity = 1150168,
        /// <summary>
        /// RfsgAnalogModulationPmMode
        /// </summary>
        AnalogModulationPmMode = 1150192,
        /// <summary>
        /// System.String
        /// </summary>
        ExportedConfigurationSettledEventOutputTerminal = 1150129,
        /// <summary>
        /// System.String
        /// </summary>
        ConfigurationSettledEventTerminalName = 1150194,
        /// <summary>
        /// System.Double
        /// </summary>
        AeTemperature = 1150182,
        /// <summary>
        /// 
        /// </summary>
        AeSession = 1150183,
        /// <summary>
        /// System.Double
        /// </summary>
        AmplitudeSettling = 1150137,
        /// <summary>
        /// System.Double
        /// </summary>
        CorrectionTemperature = 1150104,
        /// <summary>
        /// RfsgAlcControl
        /// </summary>
        AlcControl = 1150195,
        /// <summary>
        /// RfsgAlcControl
        /// </summary>
        AutoPowerSearch = 1150196,
        /// <summary>
        /// RfsgAmpPath
        /// </summary>
        AmpPath = 1150185,
        /// <summary>
        /// System.Double
        /// </summary>
        AttenuatorSetting = 1150173,
        /// <summary>
        /// System.Boolean
        /// </summary>
        FastTuningOption = 1150188,
        /// <summary>
        /// RfsgConfigurationListRepeat
        /// </summary>
        ConfigurationListRepeat = 1150102,
        /// <summary>
        /// System.Boolean
        /// </summary>
        ConfigurationListIsDone = 1150175,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        AlcEnabled = 1250003,
        /// <summary>
        /// 
        /// </summary>
        [ObsoleteAttribute]
        ReferenceOscillatorSource = 1250321,
        /// <summary>
        /// System.String
        /// </summary>
        [ObsoleteAttribute]
        ExternalCalibrationUserDefinedInfo = 1150078,

        /// <summary>
        /// System.Int32
        /// </summary>
        [ObsoleteAttribute]
        ExternalCalibrationUserDefinedInfoMaxSize = 1150079,

        
    }

    #region niRFSG types
    /// <summary>
    /// 
    /// </summary>
    [Obsolete("Use structures provided in niInteropCommon.cs")]
    public struct RfsgNIComplexI16
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="Real"></param>
        /// <param name="Imaginary"></param>
        public RfsgNIComplexI16(short Real, short Imaginary)
        {
            _real = Real; _imaginary = Imaginary;
        }

        //==========================================================================================

        //==========================================================================================
        private short _real;
        /// <summary>
        /// 
        /// </summary>
        public short Real
        {
            get
            {
                return _real;
            }
        }

        //==========================================================================================

        //==========================================================================================
        private short _imaginary;
        /// <summary>
        /// 
        /// </summary>
        public short Imaginary
        {
            get
            {
                return _imaginary;
            }
        }

    }
    /// <summary>
    /// 
    /// </summary>
    [Obsolete("Use structures provided in niInteropCommon.cs")]
    public struct RfsgNIComplexNumberF32
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="Real"></param>
        /// <param name="Imaginary"></param>
        public RfsgNIComplexNumberF32(float Real, float Imaginary)
        {
            _real = Real; _imaginary = Imaginary;
        }

        //==========================================================================================

        //==========================================================================================
        private float _real;
        /// <summary>
        /// 
        /// </summary>
        public float Real
        {
            get
            {
                return _real;
            }
        }

        //==========================================================================================

        //==========================================================================================
        private float _imaginary;
        /// <summary>
        /// 
        /// </summary>
        public float Imaginary
        {
            get
            {
                return _imaginary;
            }
        }

    }
    #endregion
}
