//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Measurement Studio for NI-RFSA 15.0.
//     
//     Documentation is available at Start»All Programs»National Instruments»NI-RFSA»NI-RFSA Documentation>>NI RF Vector Signal Analyzers Help.
//      
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace NationalInstruments.ModularInstruments.Interop
{
    /// <summary>
    /// 
    /// </summary>
    public class niRFSA : object, System.IDisposable
    {

        private HandleRef _handle;

        private bool _disposed = true;
        /// <summary>
        /// 
        /// </summary>
        public HandleRef Handle
        {
            get
            {
                return _handle;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        ~niRFSA() 
        { 
            Dispose(false); 
        }

        #region Constructors
        /// <summary>
        /// 
        /// </summary>
        /// <param name="instrumentHandle"></param>
        public niRFSA(System.IntPtr instrumentHandle)
        {
            this._handle = new HandleRef(this, instrumentHandle);
            this._disposed = false;
        }
        
        /// <summary>
        /// 
        /// Creates a new session for the device and performs the following initialization actions:
        /// 
        /// Creates a new instrument driver session to the RF vector signal analyzer, using the downconverter resource name you specify with resourceName.
        /// Sends initialization commands to reset all hardware modules to a known state necessary for NI-RFSA operation.
        /// 
        /// Note:Before initializing the RF vector signal analyzer, an IF digitizer module (and an LO source for the NI 5663 only) must be associated with the RF downconverter module in MAX. After association, pass the RF downconverter device name to this VI to initialize both modules. To change the digitizer and LO source associations, modify the downconverter Properties page in MAX, or use the niRFSA_InitWithOptions function to override the association specified in MAX. Refer to the NI RF Vector Signal                 Analyzers Getting Started Guide, installed at Start&#187;All Programs?National  Instruments&#187;NI-RFSA&#187;Documentation for information about MAX association.
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// </summary>
        /// <param name="Resource_Name">
        /// 
        /// resourceName
        /// ViRsrc
        /// Specifies the resource name of the device to initialize.
        /// 
        /// Example #
        /// Device Type
        /// Syntax
        /// 1
        /// myDAQmxDevice
        /// NI-DAQmx device, device name =
        ///                "myDAQmxDevice"
        /// 2
        /// myLogicalName
        /// IVI logical name, name =
        ///                   "myLogicalName"
        /// 
        /// For NI-DAQmx devices, the syntax is the device name specified in MAX, as shown in
        ///             Example 1. Typical default names for NI-DAQmx devices in MAX are Dev1 or PXI1Slot2. You
        ///             can rename an NI-DAQmx device by right-clicking on the name in MAX and entering a new
        ///             name. You also can pass in the name of an IVI logical name configured with the IVI
        ///             Configuration utility. For additional information, refer to the Installed Devices&#187;IVI topic of the
        ///             Measurement &amp; Automation Explorer Help.
        /// 
        /// Caution&#160;&#160;NI-DAQmx device names are not case-sensitive. However, all IVI logical names are case-sensitive. If you use an IVI logical name, verify the name is identical to the name shown in the IVI Configuration Utility.
        /// 
        /// </param>
        /// <param name="ID_Query">
        /// 
        /// IDQuery
        /// ViBoolean
        /// specifies whether NI-RFSA performs an ID query. When you perform an ID query, NI-RFSA verifies that the device you initialize is supported. 
        ///                                             VI_TRUE (Yes)
        /// 
        ///                     Perform an ID query. This value is the default.
        /// 
        ///                                                             VI_FALSE (No)
        /// 
        ///                     Do not perform an ID query.
        /// 
        /// </param>
        /// <param name="Reset">
        /// 
        /// reset
        /// ViBoolean
        /// Specifies whether the NI-RFSA device is reset during the initialization procedure.
        /// 
        /// VI_TRUE (Yes)The device is reset.
        /// VI_FALSE (No)The device is not reset. This value is the default.
        /// 
        /// </param>
        public niRFSA(string Resource_Name, bool ID_Query, bool Reset)
        {
            System.IntPtr handle;
            int pInvokeResult = PInvoke.init(Resource_Name, System.Convert.ToUInt16(ID_Query), System.Convert.ToUInt16(Reset), out handle);
            _handle = new HandleRef(this, handle);
            TestForError(pInvokeResult);
            this._disposed = false;
        }

        /// <summary>
        /// 
        /// Creates a new session for the device and performs the following initialization actions:
        /// Creates a new instrument driver session to the RF vector signal analyzer, using the downconverter resource name you specify with resourceName.
        /// Sends initialization commands to reset all hardware modules to a known state necessary for NI-RFSA operation.
        /// 
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Resource_Name">
        /// 
        /// resourceName
        /// ViRsrc
        /// Specifies the resource name of the device to initialize.
        /// 
        /// Example #
        /// Device Type
        /// Syntax
        /// 1
        /// myDAQmxDevice
        /// NI-DAQmx device, device name =
        ///                "myDAQmxDevice"
        /// 2
        /// myLogicalName
        /// IVI logical name, name =
        ///                   "myLogicalName"
        /// 
        /// For NI-DAQmx devices, the syntax is the device name specified in MAX, as shown in
        ///             Example 1. Typical default names for NI-DAQmx devices in MAX are Dev1 or PXI1Slot2. You
        ///             can rename an NI-DAQmx device by right-clicking on the name in MAX and entering a new
        ///             name. You also can pass in the name of an IVI logical name configured with the IVI
        ///             Configuration utility. For additional information, refer to the Installed Devices&#187;IVI topic of the
        ///             Measurement &amp; Automation Explorer Help.
        /// 
        /// Caution&#160;&#160;NI-DAQmx device names are not case-sensitive. However, all IVI logical names are case-sensitive. If you use an IVI logical name, verify the name is identical to the name shown in the IVI Configuration Utility.
        ///  
        /// </param>
        /// <param name="ID_Query">
        /// 
        /// IDQuery
        /// ViBoolean
        /// specifies whether NI-RFSA performs an ID query. When you perform an ID query, NI-RFSA verifies that the device you initialize is supported. 
        ///                                             VI_TRUE (Yes)
        /// 
        ///                     Perform an ID query. This value is the default.
        /// 
        ///                                                             VI_FALSE (No)
        /// 
        ///                     Do not perform an ID query.
        /// 
        /// </param>
        /// <param name="Reset">
        /// 
        /// reset
        /// ViBoolean
        /// Specifies whether the NI-RFSA device is reset during the initialization procedure.
        /// 
        /// VI_TRUE (Yes)The device is reset.
        /// VI_FALSE (No)The device is not reset. This value is the default.
        /// 
        /// </param>
        /// <param name="Option_String">
        /// 
        /// optionString
        /// ViConstString
        /// Sets the initial value of certain attributes for the session. The following attributes are used in this parameter.
        /// 
        /// Name
        /// Attribute
        /// RangeCheck
        /// NIRFSA_ATTR_RANGE_CHECK
        /// QueryInstrStatus
        /// NIRFSA_ATTR_QUERY_INSTRUMENT_STATUS
        /// Cache
        /// NIRFSA_ATTR_CACHE
        /// RecordCoercions
        /// NIRFSA_ATTR_RECORD_COERCIONS
        /// DriverSetup
        /// NIRFSA_ATTR_DRIVER_SETUP
        /// 
        /// The format of this string is, "AttributeName=Value" where AttributeName is the name of the attribute and Value is the value to which the attribute will be set.  To set multiple attributes, separate their assignments with a comma.
        /// 
        /// Example Option String:
        /// "RangeCheck=1,QueryInstrStatus=0,Cache=1,DriverSetup=Digitizer:pxi1slot4".
        /// 
        /// If you want to use the NI 5600/5601 with an external digitizer for downconverter-only mode, use the following DriverSetup string: DriverSetup=Digitizer:&lt;external&gt;.
        /// 
        /// NI 5663&#8212;LO source&#8212;Specifies the resource name of the LO source to use for this session. If you want to use the NI&#160;5601 with an LO source other than the NI 5652, use the following DriverSetup tag:DriverSetup=LO:&lt;external&gt;.
        /// 
        /// To specify multiple resources in the DriverSetup string, separate their assignments with a semicolon.
        /// 
        /// </param>
        public niRFSA(string Resource_Name, bool ID_Query, bool Reset, string Option_String)
        {
            System.IntPtr handle;
            int pInvokeResult = PInvoke.InitWithOptions(Resource_Name, System.Convert.ToUInt16(ID_Query), System.Convert.ToUInt16(Reset), Option_String, out handle);
            _handle = new HandleRef(this, handle);
            TestForError(pInvokeResult);
            this._disposed = false;
        }
        #endregion Constructors

        #region ErrorMethods
        private int TestForError(int status)
        {
            if ((status < 0))
            {
                ThrowError(status);
            }
            return status;
        }

        private int ThrowError(int code)
        {
            int size = PInvoke.GetError(Handle, out code, 0, null);
            System.Text.StringBuilder msg = new System.Text.StringBuilder();
            if ((size >= 0))
            {
              msg.Capacity = size;
              PInvoke.GetError(Handle, out code, size, msg);
            }
            throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), code);
        }
        
        // The next two methods are there because of the static versions of 
        // GetError() and ErrorMessage()
        // If those two are not needed, then these two can be gone as well
        private static int TestForError(HandleRef handle, int status)
        {
            if ((status < 0))
            {
              niRFSA.ThrowError(handle, status);
            }
            return status;
        }

        private static int ThrowError(HandleRef handle, int code)
        {
            int size = PInvoke.GetError(handle, out code, 0, null);
            System.Text.StringBuilder msg = new System.Text.StringBuilder();
            if ((size >= 0))
            {
              msg.Capacity = size;
              PInvoke.GetError(handle, out code, size, msg);
            }
            throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), code);
        }
        
        #endregion ErrorMethods
        
        #region DriverMethods
        /// <summary>
        /// Retrieves and then clears the IVI error information for the session or the current execution thread.
        /// 
        /// </summary>
        ///<param>
        /// Identifies your instrument session. vi is obtained from the niRFSA_init or niRFSA_InitExtCal function and identifies a particular instrument session.
        /// 
        ///</param>
        ///<param>
        /// Specifies the error code.
        /// 
        ///</param>
        ///<param>
        /// Specifies the error message returned.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public static int GetError(HandleRef handle, int code, StringBuilder msg)
        {
           int pInvokeResult = 0;
           int size = PInvoke.GetError(handle, out code, 0, null);
           if ((size >= 0))
           {
              msg.Capacity = size;
              pInvokeResult = PInvoke.GetError(handle, out code, size, msg);
              msg.AppendLine("ErrorCode: " + code.ToString());
           }
           niRFSA.TestForError(handle, pInvokeResult);
           return pInvokeResult;
        }

        /// <summary>
        /// Retrieves and then clears the IVI error information for the session or the current execution thread.
        /// 
        /// </summary>
        ///<param>
        /// Specifies the error code.
        /// 
        ///</param>
        ///<param>
        /// Specifies the error message returned.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int GetError(int code, StringBuilder msg)
        {
            return niRFSA.GetError(Handle, code, msg);
        }

        /// <summary>
        /// Converts a status code returned by an NI-RFSA function into a user-readable string.
        /// 
        /// </summary>
        ///<param>
        /// Identifies your instrument session. vi is obtained from the niRFSA_init or niRFSA_InitExtCal function and identifies a particular instrument session.
        /// 
        ///</param>
        ///<param>
        /// Passes the Status parameter that is returned from any NI-RFSA function. The default value is 0 (VI_SUCCESS).
        /// 
        ///</param>
        ///<param>
        /// Returns the user-readable message string that corresponds to the status code you specify.
        /// 
        ///</param>
        ///<returns>
        /// Converts a status code returned by an NI-RFSA function into a user-readable string.
        /// 
        ///</returns>
        public static int ErrorMessage(HandleRef handle, int code, StringBuilder msg)
        {
            int pInvokeResult = 0;
            int size = 256;
            msg.Capacity = size;
            pInvokeResult = PInvoke.error_message(handle, code, msg);
            niRFSA.TestForError(handle, pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Converts a status code returned by an NI-RFSA function into a user-readable string.
        /// 
        /// </summary>
        ///<param>
        /// Passes the Status parameter that is returned from any NI-RFSA function. The default value is 0 (VI_SUCCESS).
        /// 
        ///</param>
        ///<param>
        /// Returns the user-readable message string that corresponds to the status code you specify.
        /// 
        ///</param>
        ///<returns>
        /// Converts a status code returned by an NI-RFSA function into a user-readable string.
        /// 
        ///</returns>
        public int ErrorMessage(int code, StringBuilder msg)
        {
            return niRFSA.ErrorMessage(Handle, code, msg);
        }

        /// <summary>
        /// Closes the rfsa session and releases resources associated with that session. 
        /// </summary>
        public void Close()
        {
            Dispose();
        }

        /// <summary>
        /// 
        /// Configures whether the session acquires I/Q data or computes a power spectrum over the specified frequency range. 
        /// 
        /// </summary>
        /// <param name="Acquisition_Type">
        /// 
        /// acquisitionType
        /// Int32
        /// Configures the type of acquisition.
        /// 
        ///  IQ
        /// Configures the driver for I/Q acquisitions. This value is the default.
        /// Spectrum
        /// Configures the driver for spectrum acquisitions.
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureAcquisitionType(int Acquisition_Type)
        {
            int pInvokeResult = PInvoke.ConfigureAcquisitionType(this._handle, Acquisition_Type);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the reference level. The reference level represents the maximum expected power of an input RF signal.
        /// 
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// string
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Reference_Level">
        /// 
        /// referenceLevel
        /// double
        /// Specifies the expected total integrated power, in dBm, of the RF input signal.
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureReferenceLevel(string Channel_List, double Reference_Level)
        {
            int pInvokeResult = PInvoke.ConfigureReferenceLevel(this._handle, Channel_List, Reference_Level);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }



        /// <summary>
        /// 
        /// Enables or disables SFP session access for the specified instrument.
        /// SFP session access allows the NI-RFSA Soft Front Panel (SFP) to access a device with an existing open session and can help you debug your code. To enable session access, pass VI_TRUE to the enabled parameter. To disable session access, pass false to the enabled parameter.
        /// Refer to Configuring SFP Session Access using LabWindows/CVI or C for more information about SFP session access. 
        /// </summary>
        /// <param name="enable">
        /// 
        /// enable
        /// bool
        /// Enables or disables SFP session access for the specified device. 
        /// True
        /// Enables session access.
        /// False
        /// Disables session access.
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int EnableSessionAccess(bool enable)
        {
            int pInvokeResult = PInvoke.EnableSessionAccess(this._handle, enable);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the carrier frequency of the RF vector signal analyzer hardware for an I/Q acquisition. The carrier frequency is the center frequency of the I/Q acquisition.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// string
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Carrier_Frequency">
        /// 
        /// carrierFrequency
        /// double
        /// Specifies the carrier frequency, in hertz (Hz), of the RF signal to acquire. The RF vector signal analyzer tunes to this frequency. NI-RFSA may coerce this value based on hardware settings and downconversion settings.
        /// 
        /// NI-RFSA sets the NIRFSA_ATTR_IQ_CARRIER_FREQUENCY attribute to this value. Refer to the specifications document that shipped with your device for allowable frequency settings.
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureIQCarrierFrequency(string Channel_List, double Carrier_Frequency)
        {
            int pInvokeResult = PInvoke.ConfigureIQCarrierFrequency(this._handle, Channel_List, Carrier_Frequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        #region Functions added between 2.5.2 and 2.9

        /// <summary>
        /// Supported Devices:  NI&#160;5644R/5645R/5646R, NI&#160;5661/5663/5663E/5665/5667
        /// 
        /// </summary>
        ///<returns>
        /// ViStatus _VI_FUNC niRFSA_Disable(ViSession vi);
        /// Purpose
        /// Supported Devices:  NI&#160;5644R/5645R/5646R, NI&#160;5661/5663/5663E/5665/5667
        /// 
        ///</returns>
        public int Disable()
        {
            int pInvokeResult = PInvoke.Disable(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// </summary>
        [Obsolete("Use overload FetchIQSingleRecordComplexF32(string, Int64, Int64, double, niComplexNumberF32[], out niRFSA_wfmInfo)")]
        public int FetchIQSingleRecordComplexF32(string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, niComplexF32[] Data, out niRFSA_wfmInfo Waveform_Info)
        {
            int pInvokeResult = PInvoke.FetchIQSingleRecordComplexF32(this._handle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// </summary>
        public int FetchIQSingleRecordComplexF32(string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, niComplexNumberF32[] Data, out niRFSA_wfmInfo Waveform_Info)
        {
            int pInvokeResult = PInvoke.FetchIQSingleRecordComplexF32(this._handle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
		/// Specifies the calibration tone power during calibration tone amplitude calibration. You must call the niRFSA_Initiate function before calling this function.
		/// Supported Devices:  NI&#160;5693
		/// 
		/// </summary>
		///<param name = "Channel_List">
		/// Identifies which channels to apply settings. Specify 0 as the value of this parameter.
		/// 
		///</param>
		///<param name = "Measurement">
		/// Specifies the calibration tone power, in dBm, for the current device setting.
		/// 
		///</param>
		///<returns>
		/// 
		///niRFSA_CalAdjustCalTonePower
		/// ViStatus  niRFSA_CalAdjustCalTonePower(ViSession vi,
		///    ViConstString channelList,
		///    ViReal64 measurement);
		/// Purpose
		/// Specifies the calibration tone power during calibration tone amplitude calibration. You must call the niRFSA_Initiate function before calling this function.
		/// Supported Devices:  NI&#160;5693
		/// 
        /// </returns>
        public int CalAdjustCalTonePower(string Channel_List, double Measurement)
        {
            int pInvokeResult = PInvoke.ConfigureIQCarrierFrequency(this._handle, Channel_List, Measurement);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Records measured gain information that is gathered during the Reference Level Calibration step and IF Attenuation Calibration step.
        /// This function internally queries the attributes you set, and you must commit all attributes appropriate for your device calibration procedure prior to calling this function. Refer to ni.com/manuals for the most recent version of the calibration procedure for your device.
        /// Call this function immediately after a measurement is made and while the device under test (DUT) is still in the same state as it was during the measurement.
        /// Supported Devices:  NI&#160;5693/5694
        /// 
        /// </summary>
        ///<param name = "Channel_List">
        /// Identifies which channels to apply settings. Specify 0 as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "Frequency">
        /// Specifies the RF frequency, in Hz, of the measurement taken.
        /// 
        ///</param>
        ///<param name = "Gain">
        /// Specifies the gain measurement, in dB.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_CalAdjustDeviceGain
        /// ViStatus  niRFSA_CalAdjustDeviceGain(ViSession vi,
        ///    ViConstString channelList,
        ///    ViReal64 frequency,
        ///    ViReal64 gain);
        /// Purpose
        /// Records measured gain information that is gathered during the Reference Level Calibration step and IF Attenuation Calibration step.
        /// This function internally queries the attributes you set, and you must commit all attributes appropriate for your device calibration procedure prior to calling this function. Refer to ni.com/manuals for the most recent version of the calibration procedure for your device.
        /// Call this function immediately after a measurement is made and while the device under test (DUT) is still in the same state as it was during the measurement.
        /// Supported Devices:  NI&#160;5693/5694
        /// 
        /// </returns>
        public int CalAdjustDeviceGain(string Channel_List, double Frequency, double Gain)
        {
            int pInvokeResult = PInvoke.CalAdjustDeviceGain(this._handle, Channel_List, Frequency, Gain);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
		/// Self-calibrates all configurations within the specified frequency and reference level limits.
		/// NI recommends that no external signals are present on the RF In port while the calibration is taking place.
		/// For best results, NI recommends that you perform a complete self-calibration without omitting any steps. However, if certain aspects of performance are less important for your application, you can omit that step for faster execution.
		/// Supported Devices: NI&#160;5644R/5645R/5646R   
		/// 
		/// </summary>
		///<param name = "stepsToOmit">
		///     Specifies which calibration steps to skip as part of the self-calibration process. A value of 0 specifies all calibration steps are performed.
		///           Note&#160;&#160;To omit two or more calibration steps, specify a bitwise-OR combination of the following constants. For example, if you wanted to omit NIRFSA_VAL_SELF_CAL_AMPLITUDE_ACCURACY and NIRFSA_VAL_SELF_CAL_LO_SELF_CAL, you would pass the following string to the niRFSA_SelfCalibrate function: NIRFSA_VAL_SELF_CAL_AMPLITUDE_ACCURACY | NIRFSA_VAL_SELF_CAL_LO_SELF_CAL 
		///                         NIRFSA_VAL_SELF_CAL_LO_SELF_CAL
		///           Omits the LO Self Cal step. If you omit this step and the niRFSA_IsSelfCalValid function indicates the calibration data for this step is invalid, the LO PLL may fail to lock.
		///                   NIRFSA_VAL_SELF_CAL_AMPLITUDE_ACCURACY
		///           Omits the Amplitude Accuracy step. If you omit this step, the absolute accuracy of the device is not adjusted.
		///                   NIRFSA_VAL_SELF_CAL_RESIDUAL_LO_POWER
		///           Omits the Residual LO Power step. If you omit this step, the Residual LO Power performance is not adjusted.
		///                   NIRFSA_VAL_SELF_CAL_IMAGE_SUPPRESSION
		///           Omits the Image Suppression step. If you omit this step, the Residual Sideband Image Performance is not adjusted.
		/// 
		///</param>
		///<param name = "minFrequency">
		/// Specifies the minimum RF frequency in Hz.
		/// 
		///</param>
		///<param name = "maxFrequency">
		/// Specifies the maximum RF frequency in Hz.
		/// 
		///</param>
		///<param name = "minReferenceLevel">
		/// Specifies the minimum reference level in dBm.
		/// 
		///</param>
		///<param name = "maxReferenceLevel">
		/// Specifies the maximum reference level in dBm.
		/// 
		///</param>
		///<returns>
		/// 
		///niRFSA_SelfCalibrateRange
		/// ViStatus niRFSA_SelfCalibrateRange (ViSession Instrument_Handle,ViInt64 Steps_To_Omit, ViReal64 Min_Frequency, ViReal64 Max_Frequency, ViReal64 Min_Reference_Level, ViReal64                      Max_Reference_Level);
		/// Purpose
		/// Self-calibrates all configurations within the specified frequency and reference level limits.
		/// NI recommends that no external signals are present on the RF In port while the calibration is taking place.
		/// For best results, NI recommends that you perform a complete self-calibration without omitting any steps. However, if certain aspects of performance are less important for your application, you can omit that step for faster execution.
		/// Supported Devices: NI&#160;5644R/5645R/5646R   
		/// 
		///</returns>
        public int SelfCalibrateRange(long stepsToOmit, double minFrequency, double maxFrequency, double minReferenceLevel, double maxReferenceLevel)
        {
            int pInvokeResult = PInvoke.SelfCalibrateRange(this._handle, stepsToOmit, minFrequency, maxFrequency, minReferenceLevel, maxReferenceLevel);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Resets the attribute to its default value.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5644R/5645R/5646R, NI&#160;5661/5663/5663E/5665/5667, NI&#160;5693/5694
        /// 
        /// </summary>
        ///<returns>
        /// 
        ///niRFSA_ResetWithDefaults
        /// ViStatus _VI_FUNC niRFSA_ResetWithDefaults(ViSession vi);
        /// Purpose
        /// Resets the session to its default value.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5644R/5645R/5646R, NI&#160;5661/5663/5663E/5665/5667, NI&#160;5693/5694
        /// 
        /// </returns>
        public int ResetWithDefaults()
        {
            int pInvokeResult = PInvoke.ResetWithDefaults(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// </summary>
        /// <returns>
        /// </returns>
        public int InvalidateAllAttributes()
        {
            int pInvokeResult = PInvoke.InvalidateAllAttributes(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Fetches I/Q data from multiple records in an acquisition. A fetch transfers acquired waveform data from device memory to computer memory. The data was acquired to onboard memory previously by the hardware after the acquisition was initiated.
        /// This function is not necessary if you use the niRFSA_ReadIQSingleRecordComplexF64 function because the niRFSA_ReadIQSingleRecordComplexF64 function performs the fetch as part of the function.
        /// Supported Devices:  NI&#160;5644R/5645R/5646R, NI&#160;5661/5663/5663E/5665/5667
        /// 
        /// </summary>
        ///<param name = "Channel_List">
        /// Identifies which channels to apply settings. Specify 0 as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "StartingRecord">
        /// Specifies the first record to retrieve. Record numbers are zero-based. The default value is 0.
        /// 
        ///</param>
        ///<param name = "NumberOfRecords">
        /// Specifies the number of records to fetch.
        /// 
        ///</param>
        ///<param name = "Number_of_Samples">
        /// Specifies the number of samples per record.
        /// 
        ///</param>
        ///<param name = "Timeout">
        /// Specifies the time, in seconds, allotted for the function to complete before returning a timeout error. A value of &#8211;1 specifies the function waits until all data is available. A value of 0 specifies the function immediately returns available data.
        /// 
        ///</param>
        ///<param name = "Data">
        /// Returns the acquired waveform for each record fetched. The waveforms are written sequentially in the array. Allocate an array at least as large as numberOfSamples times numberOfRecords for this parameter.
        /// 
        ///</param>
        ///<param name = "Waveform_Info">
        /// Contains the absolute and relative timestamps for the operation, the time interval (dt), and the
        /// actual number of samples read.
        /// The following list provides more information about each of these properties:
        /// absolute timestamp&#8212;Returns the timestamp, in seconds, of the first fetched sample that is comparable between records and acquisitions.
        /// relative timestamp&#8212;Returns a timestamp that corresponds to the difference, in seconds, between the first sample returned and the Reference trigger location.
        /// Note&#160;&#160;For the NI&#160;5644R/5645R/5646R, both timestamps are always set to 0.
        /// dt&#8212;Returns the time interval between data points in the acquired signal. The I/Q data sample rate is the reciprocal of this value.
        /// actual samples read&#8212;Returns an integer representing the number of samples in the waveform.
        /// offset&#8212;Returns the offset to scale data, (b), in mx + b form.
        /// gain&#8212;Returns the gain to scale data, (m), in mx + b form.
        /// Note&#160;&#160;Allocate an array of structures at least as large as numberOfRecords for this parameter.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_FetchIQMultiRecordComplexF32
        /// ViStatus niRFSA_FetchIQMultiRecordComplexF32(ViSession vi, 
        ///    ViConstString channelList, 
        ///    ViInt64 startingRecord, 
        ///    ViInt64 numberOfRecords, 
        ///    ViInt64 numberOfSamples, 
        ///    ViReal64 timeout, 
        ///    NIComplexNumberF32* data,
        ///    niRFSA_wfmInfo* wfmInfo);
        /// Purpose
        /// Fetches I/Q data from multiple records in an acquisition. A fetch transfers acquired waveform data from device memory to computer memory. The data was acquired to onboard memory previously by the hardware after the acquisition was initiated.
        /// This function is not necessary if you use the niRFSA_ReadIQSingleRecordComplexF64 function because the niRFSA_ReadIQSingleRecordComplexF64 function performs the fetch as part of the function.
        /// Supported Devices:  NI&#160;5644R/5645R/5646R, NI&#160;5661/5663/5663E/5665/5667
        /// 
        /// </returns>
        [Obsolete("Use overload FetchIQMultiRecordComplexF32(string, Int64, Int64, Int64, double, niComplexNumberF32[], out niRFSA_wfmInfo)")]
        public int FetchIQMultiRecordComplexF32(string Channel_List, Int64 StartingRecord, Int64 NumberOfRecords, Int64 Number_of_Samples, double Timeout, niComplexF32[] Data, out niRFSA_wfmInfo Waveform_Info)
        {
            int pInvokeResult = PInvoke.FetchIQMultiRecordComplexF32(this._handle, Channel_List, StartingRecord, NumberOfRecords, Number_of_Samples, Timeout, Data, out Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Fetches I/Q data from multiple records in an acquisition. A fetch transfers acquired waveform data from device memory to computer memory. The data was acquired to onboard memory previously by the hardware after the acquisition was initiated.
        /// This function is not necessary if you use the niRFSA_ReadIQSingleRecordComplexF64 function because the niRFSA_ReadIQSingleRecordComplexF64 function performs the fetch as part of the function.
        /// Supported Devices:  NI&#160;5644R/5645R/5646R, NI&#160;5661/5663/5663E/5665/5667
        /// 
        /// </summary>
        ///<param name = "Channel_List">
        /// Identifies which channels to apply settings. Specify 0 as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "StartingRecord">
        /// Specifies the first record to retrieve. Record numbers are zero-based. The default value is 0.
        /// 
        ///</param>
        ///<param name = "NumberOfRecords">
        /// Specifies the number of records to fetch.
        /// 
        ///</param>
        ///<param name = "Number_of_Samples">
        /// Specifies the number of samples per record.
        /// 
        ///</param>
        ///<param name = "Timeout">
        /// Specifies the time, in seconds, allotted for the function to complete before returning a timeout error. A value of &#8211;1 specifies the function waits until all data is available. A value of 0 specifies the function immediately returns available data.
        /// 
        ///</param>
        ///<param name = "Data">
        /// Returns the acquired waveform for each record fetched. The waveforms are written sequentially in the array. Allocate an array at least as large as numberOfSamples times numberOfRecords for this parameter.
        /// 
        ///</param>
        ///<param name = "Waveform_Info">
        /// Contains the absolute and relative timestamps for the operation, the time interval (dt), and the
        /// actual number of samples read.
        /// The following list provides more information about each of these properties:
        /// absolute timestamp&#8212;Returns the timestamp, in seconds, of the first fetched sample that is comparable between records and acquisitions.
        /// relative timestamp&#8212;Returns a timestamp that corresponds to the difference, in seconds, between the first sample returned and the Reference trigger location.
        /// Note&#160;&#160;For the NI&#160;5644R/5645R/5646R, both timestamps are always set to 0.
        /// dt&#8212;Returns the time interval between data points in the acquired signal. The I/Q data sample rate is the reciprocal of this value.
        /// actual samples read&#8212;Returns an integer representing the number of samples in the waveform.
        /// offset&#8212;Returns the offset to scale data, (b), in mx + b form.
        /// gain&#8212;Returns the gain to scale data, (m), in mx + b form.
        /// Note&#160;&#160;Allocate an array of structures at least as large as numberOfRecords for this parameter.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_FetchIQMultiRecordComplexF32
        /// ViStatus niRFSA_FetchIQMultiRecordComplexF32(ViSession vi, 
        ///    ViConstString channelList, 
        ///    ViInt64 startingRecord, 
        ///    ViInt64 numberOfRecords, 
        ///    ViInt64 numberOfSamples, 
        ///    ViReal64 timeout, 
        ///    NIComplexNumberF32* data,
        ///    niRFSA_wfmInfo* wfmInfo);
        /// Purpose
        /// Fetches I/Q data from multiple records in an acquisition. A fetch transfers acquired waveform data from device memory to computer memory. The data was acquired to onboard memory previously by the hardware after the acquisition was initiated.
        /// This function is not necessary if you use the niRFSA_ReadIQSingleRecordComplexF64 function because the niRFSA_ReadIQSingleRecordComplexF64 function performs the fetch as part of the function.
        /// Supported Devices:  NI&#160;5644R/5645R/5646R, NI&#160;5661/5663/5663E/5665/5667
        /// 
        /// </returns>
        public int FetchIQMultiRecordComplexF32(string Channel_List, Int64 StartingRecord, Int64 NumberOfRecords, Int64 Number_of_Samples, double Timeout, niComplexNumberF32[] Data, out niRFSA_wfmInfo Waveform_Info)
        {
            int pInvokeResult = PInvoke.FetchIQMultiRecordComplexF32(this._handle, Channel_List, StartingRecord, NumberOfRecords, Number_of_Samples, Timeout, Data, out Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///</summary>
        public int SetUserData(string identifier, int bufferSize, byte[] data)
        {
            int pInvokeResult = PInvoke.SetUserData(Handle, identifier, bufferSize, data);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///</summary>
        public int GetUserData(string identifier, int bufferSize, byte[] data, ref int actualDataSize)
        {
            int pInvokeResult = PInvoke.GetUserData(Handle, identifier, bufferSize, data, ref actualDataSize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        #endregion

        #region Properties added between 2.9 and 14.1
        ///<summary>
        ///Description
        ///Returns the actual frequency, in hertz (Hz), of the digitizer Sample Clock.
        ///Units: hertz (Hz)
        ///Supported Devices: NI 5668R
        ///</summary>
        public int SetDigitizerSampleClockRate(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DigitizerSampleClockRate, channel, value);
        }
        ///<summary>
        ///Description
        ///Returns the actual frequency, in hertz (Hz), of the digitizer Sample Clock.
        ///Units: hertz (Hz)
        ///Supported Devices: NI 5668R
        ///</summary>
        public int GetDigitizerSampleClockRate(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DigitizerSampleClockRate, channel, out value);
        }

        ///<summary>
        ///Specifies the terminal at which to export the Digitizer Sample Clock.
        ///Valid Values: "" (empty string), "ClkOut"
        ///Default Value: "" (empty string)
        ///Supported Devices: NI 5668R
        ///</summary>
        public int SetExportedDigitizerSampleClockOutputTerminal(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ExportedDigitizerSampleClockOutputTerminal, channel, value);
        }
        ///<summary>
        ///Specifies the terminal at which to export the Digitizer Sample Clock.
        ///Valid Values: "" (empty string), "ClkOut"
        ///Default Value: "" (empty string)
        ///Supported Devices: NI 5668R
        ///</summary>
        public int GetExportedDigitizerSampleClockOutputTerminal(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ExportedDigitizerSampleClockOutputTerminal, channel, out value);
        }

        ///<summary>
        ///Specifies whether to enable the LO2 OUT terminal on the installed devices.
        ///Set this attribute to TRUE to export the 4 GHz LO signal from the device LO2 IN terminal to the LO2 OUT terminal.
        ///You can also export the LO2 signal by setting the Lo2ExportEnabled attribute by call SetLo2ExportEnabled function with parameter true.
        ///Default Value: false
        ///Supported Devices: NI 5603/5605/5606 (external digitizer mode), NI 5665/5668R
        ///</summary>
        public int SetLo2ExportEnabled(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.Lo2ExportEnabled, channel, value);
        }
        ///<summary>
        ///Specifies whether to enable the LO2 OUT terminal on the installed devices.
        ///Set this attribute to TRUE to export the 4 GHz LO signal from the device LO2 IN terminal to the LO2 OUT terminal.
        ///You can also export the LO2 signal by setting the Lo2ExportEnabled attribute by call SetLo2ExportEnabled function with parameter true.
        ///Default Value: false
        ///Supported Devices: NI 5603/5605/5606 (external digitizer mode), NI 5665/5668R
        ///</summary>
        public int GetLo2ExportEnabled(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.Lo2ExportEnabled, channel, out value);
        }


        ///<summary>
        ///Specifies the internal gain self-calibration correction for the 100 MHz IF filter path. The value you specify using this attribute overrides any previously-set value.
        ///Units: dB
        ///Default Value: 0 
        ///Supported Devices: NI 5606
        ///</summary>
        public int SetCalibrationCorrection100mhzFilter(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalibrationCorrection100mhzFilter, channel, value);
        }
        ///<summary>
        ///Specifies the internal gain self-calibration correction for the 100 MHz IF filter path. The value you specify using this attribute overrides any previously-set value.
        ///Units: dB
        ///Default Value: 0 
        ///Supported Devices: NI 5606
        ///</summary>
        public int GetCalibrationCorrection100mhzFilter(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalibrationCorrection100mhzFilter, channel, out value);
        }

        ///<summary>
        ///Specifies the internal gain self-calibration correction for the 320 MHz IF filter path. The value you specify using this attribute overrides any previously-set value.
        ///Units: dB
        ///Default Value: 0 
        ///Supported Devices: NI 5606
        ///</summary>
        public int SetCalibrationCorrection320mhzFilter(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalibrationCorrection320mhzFilter, channel, value);
        }
        ///<summary>
        ///Specifies the internal gain self-calibration correction for the 320 MHz IF filter path. The value you specify using this attribute overrides any previously-set value.
        ///Units: dB
        ///Default Value: 0 
        ///Supported Devices: NI 5606
        ///</summary>
        public int GetCalibrationCorrection320mhzFilter(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalibrationCorrection320mhzFilter, channel, out value);
        }

        ///<summary>
        ///Specifies the internal gain self-calibration correction for the 765 MHz IF filter path. The value you specify using this attribute overrides any previously-set value.
        ///Units: dB
        ///Default Value: 0 
        ///Supported Devices: NI 5606
        ///</summary>
        public int SetCalibrationCorrection765mhzFilter(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalibrationCorrection765mhzFilter, channel, value);
        }
        ///<summary>
        ///Specifies the internal gain self-calibration correction for the 765 MHz IF filter path. The value you specify using this attribute overrides any previously-set value.
        ///Units: dB
        ///Default Value: 0 
        ///Supported Devices: NI 5606
        ///</summary>
        public int GetCalibrationCorrection765mhzFilter(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalibrationCorrection765mhzFilter, channel, out value);
        }

        ///<summary>
        ///Specifies the digitizer ID used during self calibration.
        ///Default Value: "" (empty string) 
        ///Supported Devices: NI 5603/5605/5606
        ///</summary>
        public int SetCalDigitizerId(string channel, string value)
        {
            return this.SetString(niRFSAProperties.CalDigitizerId, channel, value);
        }
        ///<summary>
        ///Specifies the digitizer ID used during self calibration.
        ///Default Value: "" (empty string) 
        ///Supported Devices: NI 5603/5605/5606
        ///</summary>
        public int GetCalDigitizerId(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.CalDigitizerId, channel, out value);
        }

        ///<summary>
        ///Specifies the RF lowband signal conditioning path.
        ///Valid Values: niRfsaConstants.ExtCalRfLowbandSignalConditioningPath1, niRfsaConstants.ExtCalRfLowbandSignalConditioningPath2, niRfsaConstants.ExtCalRfLowbandSignalConditioningPath3, niRfsaConstants.ExtCalRfLowbandSignalConditioningPath4, niRfsaConstants.ExtCalRfLowbandSignalConditioningPath5
        ///Default Value: niRfsaConstants.ExtCalRfLowbandSignalConditioningPath1
        ///Supported Devices: NI 5606
        ///</summary>
        public int SetCalRfLowbandSignalConditioningPathSelection(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.CalRfLowbandSignalConditioningPathSelection, channel, value);
        }
        ///<summary>
        ///Specifies the RF lowband signal conditioning path.
        ///Valid Values: niRfsaConstants.ExtCalRfLowbandSignalConditioningPath1, niRfsaConstants.ExtCalRfLowbandSignalConditioningPath2, niRfsaConstants.ExtCalRfLowbandSignalConditioningPath3, niRfsaConstants.ExtCalRfLowbandSignalConditioningPath4, niRfsaConstants.ExtCalRfLowbandSignalConditioningPath5
        ///Default Value: niRfsaConstants.ExtCalRfLowbandSignalConditioningPath1
        ///Supported Devices: NI 5606
        ///</summary>
        public int GetCalRfLowbandSignalConditioningPathSelection(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.CalRfLowbandSignalConditioningPathSelection, channel, out value);
        }

        ///<summary>
        ///Specifies the maximum corner frequency of the high pass filter in the RF signal path. The device uses the highest frequency high-pass filter option below or equal to the value you specify and returns a coerced value. Specifying a value of 0 disables high pass filtering.
        ///For multispan acquisitions, the device uses the appropriate filter for each subspan during acquisition, depending on the details of your application and the value you specify. In multispan acquisition spectrum applications, this attribute returns the value you specified rather than a coerced value if multiple high-pass filters are used during the acquisition.
        ///The NI 5606 features high pass filters at 1.35 GHz and 2.2 GHz.
        ///Valid Values: 0 to 26.5
        ///Default Value: 0
        ///Supported Devices: NI 5606
        ///</summary>
        public int SetRfHighPassFiltering(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.RfHighPassFiltering, channel, value);
        }
        ///<summary>
        ///Specifies the maximum corner frequency of the high pass filter in the RF signal path. The device uses the highest frequency high-pass filter option below or equal to the value you specify and returns a coerced value. Specifying a value of 0 disables high pass filtering.
        ///For multispan acquisitions, the device uses the appropriate filter for each subspan during acquisition, depending on the details of your application and the value you specify. In multispan acquisition spectrum applications, this attribute returns the value you specified rather than a coerced value if multiple high-pass filters are used during the acquisition.
        ///The NI 5606 features high pass filters at 1.35 GHz and 2.2 GHz.
        ///Valid Values: 0 to 26.5
        ///Default Value: 0
        ///Supported Devices: NI 5606
        ///</summary>
        public int GetRfHighPassFilteringe(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.RfHighPassFiltering, channel, out value);
        }

        ///<summary>
        ///Returns the size of the selected IF attenuation table.
        ///Valid Values: 0-132
        ///Default Value: 0
        ///Supported Devices: NI 5606
        ///</summary>
        public int SetCalIfAttenuationTableSize(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.CalIfAttenuationTableSize, channel, value);
        }
        ///<summary>
        ///Returns the size of the selected IF attenuation table.
        ///Valid Values: 0-132
        ///Default Value: 0
        ///Supported Devices: NI 5606
        ///</summary>
        public int GetCalIfAttenuationTableSize(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.CalIfAttenuationTableSize, channel, out value);
        }

        ///<summary>
        ///Returns the maximum instantaneous bandwidth of the device.
        ///Default Value: N/A
        ///Supported Devices: NI 5600/5601/5603/5605/5606 (external digitizer mode), NI 5661/5663/5663E/5665/5667/5668R, NI 5693/5694
        ///</summary>
        public int SetMaxDeviceInstantaneousBandwidth(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.MaxDeviceInstantaneousBandwidth, channel, value);
        }
        ///<summary>
        ///Returns the maximum instantaneous bandwidth of the device.
        ///Default Value: N/A
        ///Supported Devices: NI 5600/5601/5603/5605/5606 (external digitizer mode), NI 5661/5663/5663E/5665/5667/5668R, NI 5693/5694
        ///</summary>
        public int GetMaxDeviceInstantaneousBandwidth(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.MaxDeviceInstantaneousBandwidth, channel, out value);
        }

        ///<summary>
        ///Returns the maximum I/Q rate.
        ///Default Value: N/A
        ///Supported Devices: NI 5661/5663/5663E/5665/5667/5668R
        ///</summary>
        public int SetMaxIQRate(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.MaxIQRate, channel, value);
        }
        ///<summary>
        ///Returns the maximum I/Q rate.
        ///Default Value: N/A
        ///Supported Devices: NI 5661/5663/5663E/5665/5667/5668R
        ///</summary>
        public int GetMaxIQRate(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.MaxIQRate, channel, out value);
        }

        ///<summary>
        ///Enables the 28 V DC source on the device front panel.
        ///Units: dB
        ///Default Value: Disabled
        ///Supported Devices: NI 5606, NI 5668R
        ///</summary>
        public int SetNoiseSourcePowerEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.NoiseSourcePowerEnabled, channel, value);
        }
        ///<summary>
        ///Enables the 28 V DC source on the device front panel.
        ///Units: dB
        ///Default Value: Disabled
        ///Supported Devices: NI 5606, NI 5668R
        ///</summary>
        public int GetNoiseSourcePowerEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.NoiseSourcePowerEnabled, channel, out value);
        }

        ///<summary>
        ///Returns a string containing the name of the FPGA target being used. This name can be used with the RIO open session to open a reference to the FPGA.
        ///This attribute is channel dependent if multiple targets are supported.
        ///Supported Devices: NI 5668R
        ///</summary>
        public int SetFpgaTargetName(string channel, string value)
        {
            return this.SetString(niRFSAProperties.FpgaTargetName, channel, value);
        }
        ///<summary>
        ///Returns a string containing the name of the FPGA target being used. This name can be used with the RIO open session to open a reference to the FPGA.
        ///This attribute is channel dependent if multiple targets are supported.
        ///Supported Devices: NI 5668R
        ///</summary>
        public int GetFpgaTargetName(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.FpgaTargetName, channel, out value);
        }

        ///<summary>
        ///Specifies the amount of overlap between consecutive subspans in a multispan acquisition. Overlapping subspans can reduce the power level of spurs in acquired data. The value you specify determines the amount of shift as a percentage of subspan width.
        ///Specifying a value of 0 disables subspan overlap. In this case, NI-RFSA uses either a single-span acquisition or a multispan acquisition without overlap, depending on the frequency range requested and the current device settings.
        ///Specifying a value greater than 0 causes NI-RFSA to use a multispan acquisition with the specified overlap even in situations in which it would normally use a single-span acquisition. NI-RFSA acquires data within the overlapped percentage and uses the minimum of the acquired values.
        ///NoteNI: RFSA may apply further shifts to the specified value to accommodate fixed-frequency edges of components such as preselectors. 
        ///Valid Values: 0 to &lt;100
        ///Default Value: 0
        ///Supported Devices: NI 5665/5668R
        ///</summary>
        ///<param name="channel"></param>
        ///<param name="value"></param>
        public int SetSubspanOverlap(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.SubspanOverlap, channel, value);
        }
        ///<summary>
        ///Specifies the amount of overlap between consecutive subspans in a multispan acquisition. Overlapping subspans can reduce the power level of spurs in acquired data. The value you specify determines the amount of shift as a percentage of subspan width.
        ///Specifying a value of 0 disables subspan overlap. In this case, NI-RFSA uses either a single-span acquisition or a multispan acquisition without overlap, depending on the frequency range requested and the current device settings.
        ///Specifying a value greater than 0 causes NI-RFSA to use a multispan acquisition with the specified overlap even in situations in which it would normally use a single-span acquisition. NI-RFSA acquires data within the overlapped percentage and uses the minimum of the acquired values.
        ///NoteNI: RFSA may apply further shifts to the specified value to accommodate fixed-frequency edges of components such as preselectors. 
        ///Valid Values: 0 to &lt;100
        ///Default Value: 0
        ///Supported Devices: NI 5665/5668R
        ///</summary>
        ///<param name="channel"></param>
        ///<param name="value"></param>
        public int GetSubspanOverlap(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.SubspanOverlap, channel, out value);
        }

        #endregion

        

        
		
		
		
		/// <summary>
        /// 
        /// Configures the rate at which the device samples I/Q values. The utilized downconverter bandwidth is equal to the coerced iqRate times 0.8.
        /// 
        /// NI 5661&#8212;You should not need to configure an iqRate higher than 25 Samples per second (S/s) because the NI 5600 RF downconverter bandwidth is 20 MHz. If you choose to configure a higher I/Q rate, you may see aliasing effects at negative frequencies because the IF frequency of the NI 5600 RF downconverter is 15 MHz.
        /// NI 5663&#8212;Your maximum allowed instantaneous bandwidth depends on the I/Q carrier frequency you use. Refer to the NI 5601 RF downconverter overview for more information about instantaneous bandwidth.
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// string
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="IQ_Rate">
        /// 
        /// iqRate
        /// double
        /// Specifies the I/Q rate for the acquisition. The value is expressed in samples per second (S/s).
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureIQRate(string Channel_List, double IQ_Rate)
        {
            int pInvokeResult = PInvoke.ConfigureIQRate(this._handle, Channel_List, IQ_Rate);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the number of samples in a finite acquisition or configures the device to continuously acquire samples.
        /// If you configure the device for finite acquisition, it acquires the specified number of samples and then stops the acquisition. You can configure the device to acquire multiple records using the niRFSA_ConfigureNumberOfRecords function. Each record contains the number of samples specified in this function. The default number of records to acquire is 1.
        /// 
        /// If you configure the device to continuously acquire samples, it continues acquiring data until you call the Abort() function to abort the acquisition. The device stores data in onboard memory in a circular fashion. After the device fills the memory, it starts overwriting previously acquired data from the beginning of the memory buffer. Retrieve the samples as they are being acquired using the niRFSA fetch IQ functions to avoid overwriting data before you retrieve it.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// string
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Number_of_Samples_Is_Finite">
        /// 
        /// numberOfSamplesIsFinite
        /// bool
        /// Specifies whether to configure the device to acquire a finite number of samples or to acquire samples continuously.
        /// 
        /// true The device acquires a finite number of samples.
        /// false The device continuously acquires samples.
        /// 
        /// </param>
        /// <param name="Samples_Per_Record">
        /// 
        /// samplesPerRecord
        /// int64
        /// Specifies the number of samples per record if numberOfSamplesIsFinite is set to true.
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureNumberOfSamples(string Channel_List, bool Number_of_Samples_Is_Finite, Int64 Samples_Per_Record)
        {
            int pInvokeResult = PInvoke.ConfigureNumberOfSamples(this._handle, Channel_List, System.Convert.ToUInt16(Number_of_Samples_Is_Finite), Samples_Per_Record);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the number of records in a finite acquisition or configures the device to continuously acquire records. You can only configure the device to acquire multiple records if the numberOfRecordsIsFinite parameter is set to true.
        /// 
        /// If you configure the device to acquire records continuously, it continues acquiring records until you call the Abort() function to abort the acquisition. The device stores records in onboard memory in a circular fashion. Once the device fills the memory, it starts overwriting previously acquired records from the beginning of the memory buffer. Fetch the records as they are acquired to avoid overwriting data before you retrieve it.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// string
        /// Identifies which channels to apply settings. Use "" (an empty string) or NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Number_of_Records_Is_Finite">
        /// 
        /// numberOfRecordsIsFinite
        /// bool
        /// Specifies whether to configure the device to acquire a finite number of records or to acquire records continuously.
        /// 
        /// true The device acquires a finite number of records.
        /// false The device continuously acquires records.
        /// 
        /// </param>
        /// <param name="Number_of_Records">
        /// 
        /// numberOfRecords
        /// Int64
        /// Specifies the number of records to acquire if numberOfRecordsIsFinite is set to true. The default number of records to acquire is 1.
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureNumberOfRecords(string Channel_List, bool Number_of_Records_Is_Finite, Int64 Number_of_Records)
        {
            int pInvokeResult = PInvoke.ConfigureNumberOfRecords(this._handle, Channel_List, System.Convert.ToUInt16(Number_of_Records_Is_Finite), Number_of_Records);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the span and center frequency of the spectrum read by NI-RFSA. A spectrum acquisition consists of data surrounding the center frequency.
        /// 
        /// Note:If you configure the spectrum span to a value larger than the instantaneous bandwidth of the device, NI-RFSA
        ///             performs multiple acquisitions and combines them into a spectrum of the size you
        ///             requested.
        /// 
        /// Note:For the NI 5663, NI-RFSA does not support continuous acquisitions from frequency bands for which the instantaneous bandwidth differs. Refer to the NI 5601 RF Downconverter topic for more information about instantaneous bandwidth.
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// string
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Center_Frequency">
        /// 
        /// centerFrequency
        /// double
        /// Specifies the center frequency of a spectrum acquisition. The value is expressed in hertz (Hz). The NI-RFSA device you use determines the valid range. Refer to your device specifications document for more information about frequency range.
        /// 
        /// </param>
        /// <param name="Span">
        /// 
        /// span
        /// double
        /// Specifies the span of a spectrum acquisition. The value is expressed in hertz (Hz).
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureSpectrumFrequencyCenterSpan(string Channel_List, double Center_Frequency, double Span)
        {
            int pInvokeResult = PInvoke.ConfigureSpectrumFrequencyCenterSpan(this._handle, Channel_List, Center_Frequency, Span);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the start and stop frequencies of the spectrum read by NI-RFSA.
        /// 
        /// Note:If you configure the spectrum span (stopFrequency &#8211;
        ///                 startFrequency) to a value larger than the instantaneous bandwidth of the device, NI-RFSA
        ///             performs multiple acquisitions and combines them into a spectrum of the size you
        ///             request.
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// string
        /// Identifies which channels to apply settings. Use "" (an empty string) or NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Start_Frequency">
        /// 
        /// startFrequency
        /// double
        /// Specifies the lower limit of a span of frequencies. This value is expressed in hertz (Hz).
        /// 
        /// </param>
        /// <param name="Stop_Frequency">
        /// 
        /// stopFrequency
        /// double
        /// Specifies the upper limit of a span of frequencies. This value is expressed in hertz (Hz).
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureSpectrumFrequencyStartStop(string Channel_List, double Start_Frequency, double Stop_Frequency)
        {
            int pInvokeResult = PInvoke.ConfigureSpectrumFrequencyStartStop(this._handle, Channel_List, Start_Frequency, Stop_Frequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the resolution bandwidth of a spectrum acquisition. The resolution bandwidth controls the width of the frequency bins in the power spectrum computed by NI-RFSA. A larger value for resolution bandwidth means the frequency bins are wider, and hence you get fewer bins, or spectral lines.
        /// By default, the resolution bandwidth value corresponds to the 3 decibels (dB) bandwidth of the window type NI-RFSA uses to compute the spectrum. To specify the frequency bin width directly, change the ResolutionBandwidthType attribute to RbwBinWidth.
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// string
        /// Identifies which channels to apply settings. Use an empty string or NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Resolution_Bandwidth">
        /// 
        /// resolutionBandwidth
        /// double
        /// Specifies the resolution bandwidth of a spectrum acquisition. The value is expressed in hertz (Hz). Configure the type of resolution bandwidth with the ResolutionBandwidthType attribute.
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureResolutionBandwidth(string Channel_List, double Resolution_Bandwidth)
        {
            int pInvokeResult = PInvoke.ConfigureResolutionBandwidth(this._handle, Channel_List, Resolution_Bandwidth);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the device to wait for a digital edge Start trigger at the beginning of the acquisition.
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Source">
        /// 
        /// source
        /// string
        /// Specifies the source of the digital edge for the Start trigger.
        /// 
        /// PFI0
        /// The trigger is received on PFI 0.
        /// PFI1
        /// The trigger is received on PFI 1.
        /// PXI_Trig0
        /// The trigger is received on PXI trigger line 0.
        /// PXI_Trig1
        /// The trigger is received on PXI trigger line 1.
        /// PXI_Trig2
        /// The trigger is received on PXI trigger line 2.
        /// PXI_Trig3
        /// The trigger is received on PXI trigger line 3.
        /// PXI_Trig4
        /// The trigger is received on PXI trigger line 4.
        /// PXI_Trig5
        /// The trigger is received on PXI trigger line 5.
        /// PXI_Trig6
        /// The trigger is received on PXI trigger line 6.
        /// PXI_Trig7
        /// The trigger is received on PXI trigger line 7.
        /// PXI_STAR
        /// The trigger is received on the PXI star trigger line.
        /// 
        /// </param>
        /// <param name="Edge">
        /// 
        /// edge
        /// ViInt32
        /// Specifies the edge to detect.
        /// 
        /// Rising EdgeNI-RFSA detects a rising edge.
        /// Falling EdgeNI-RFSA detects a falling edge.
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureDigitalEdgeStartTrigger(string Source, int Edge)
        {
            int pInvokeResult = PInvoke.ConfigureDigitalEdgeStartTrigger(this._handle, Source, Edge);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the device to wait for a software Start trigger at the beginning of the acquisition. The device  waits until you call the SendSoftwareEdgeTrigger function to assert the trigger.
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureSoftwareEdgeStartTrigger()
        {
            int pInvokeResult = PInvoke.ConfigureSoftwareEdgeStartTrigger(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the device to not wait for a Start trigger at the beginning of the acquisition. This function is only necessary if you configured a Start trigger in the past and now want to disable it.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int DisableStartTrigger()
        {
            int pInvokeResult = PInvoke.DisableStartTrigger(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the device to wait for a digital edge Reference trigger to mark a reference point within the record.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Source">
        /// 
        /// source
        /// ConstString
        /// Specifies the source of the digital edge for the Reference trigger.
        /// 
        ///  NIRFSA_VAL_PFI0_STR  ("PFI0")
        /// The trigger is received on PFI 0.
        /// NIRFSA_VAL_PFI1_STR  ("PFI1")
        /// The trigger is received on PFI 1.
        ///  NIRFSA_VAL_PXI_TRIG0_STR ("PXI_Trig0")
        /// The trigger is received on PXI trigger line 0.
        ///  NIRFSA_VAL_PXI_TRIG1_STR ("PXI_Trig1")
        /// The trigger is received on PXI trigger line 1.
        ///  NIRFSA_VAL_PXI_TRIG2_STR ("PXI_Trig2")
        /// The trigger is received on PXI trigger line 2.
        ///  NIRFSA_VAL_PXI_TRIG3_STR ("PXI_Trig3")
        /// The trigger is received on PXI trigger line 3.
        ///  NIRFSA_VAL_PXI_TRIG4_STR ("PXI_Trig4")
        /// The trigger is received on PXI trigger line 4.
        ///  NIRFSA_VAL_PXI_TRIG5_STR ("PXI_Trig5")
        /// The trigger is received on PXI trigger line 5.
        ///  NIRFSA_VAL_PXI_TRIG6_STR ("PXI_Trig6")
        /// The trigger is received on PXI trigger line 6.
        ///  NIRFSA_VAL_PXI_TRIG7_STR ("PXI_Trig7")
        /// The trigger is received on PXI trigger line 7.
        ///  NIRFSA_VAL_PXI_STAR_STR ("PXI_STAR")
        /// The trigger is received on the PXI star trigger line.
        /// 
        /// </param>
        /// <param name="Edge">
        /// 
        /// edge
        /// Int32
        /// Specifies the trigger edge to detect.
        /// 
        /// NIRFSA_VAL_RISING_EDGE (900)NI-RFSA detects a rising edge.
        /// NIRFSA_VAL_FALLING_EDGE (901)NI-RFSA detects a falling edge.
        /// 
        /// </param>
        /// <param name="Pretrigger_Samples">
        /// 
        /// pretriggerSamples
        /// Int64
        /// Specifies the number of samples to store for each record that was acquired in the time period immediately before the trigger occurred. 
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureDigitalEdgeRefTrigger(string Source, int Edge, Int64 Pretrigger_Samples)
        {
            int pInvokeResult = PInvoke.ConfigureDigitalEdgeRefTrigger(this._handle, Source, Edge, Pretrigger_Samples);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the device to wait for the complex power of the I/Q data to cross the specified threshold to mark a reference point within the record.
        /// 
        /// To trigger on bursted signals, add a minimum quiet time (configured with the NIRFSA_ATTR_IQ_POWER_EDGE_REF_TRIGGER_MINIMUM_QUIET_TIME attribute) to ensure the trigger does not occur in the middle of a burst if the acquisition starts while a burst is being generated. The quiet time should be set to a value smaller than the time between bursts, but large enough to ignore power changes within a burst.
        /// 
        /// Supported Devices: NI 5661/5663
        /// </summary>
        /// <param name="Source">
        /// 
        /// source
        /// ConstString
        /// Specifies the source of the RF signal for the power edge Reference trigger. The only supported value is channel "0".
        /// 
        /// </param>
        /// <param name="Level">
        /// 
        /// level
        /// double
        /// Specifies the threshold above or below which the device  triggers.
        /// 
        /// </param>
        /// <param name="Slope">
        /// 
        /// slope
        /// Int32
        /// Specifies whether the device detects a positive or negative slope on the trigger signal.
        /// 
        /// NIRFSA_VAL_RISING_SLOPE (1000)NI-RFSA detects a rising edge (positive slope). This value is the default.
        /// NIRFSA_VAL_FALLING_SLOPE (1001)NI-RFSA detects a falling edge (negative slope).
        /// 
        /// </param>
        /// <param name="Pretrigger_Samples">
        /// 
        /// pretriggerSamples
        /// Int64
        /// Specifies the number of samples to store for each record that was acquired in the time period immediately before the trigger occurred. 
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureIQPowerEdgeRefTrigger(string Source, double Level, int Slope, Int64 Pretrigger_Samples)
        {
            int pInvokeResult = PInvoke.ConfigureIQPowerEdgeRefTrigger(this._handle, Source, Level, Slope, Pretrigger_Samples);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the device to wait for a software Reference trigger to mark a reference point within the record. The device waits until you call the SendSoftwareEdgeTrigger function to assert the trigger.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Pretrigger_Samples">
        /// 
        /// pretriggerSamples
        /// Int64
        /// Specifies the number of samples to store for each record that was acquired in the time period immediately before the trigger occurred. 
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureSoftwareEdgeRefTrigger(Int64 Pretrigger_Samples)
        {
            int pInvokeResult = PInvoke.ConfigureSoftwareEdgeRefTrigger(this._handle, Pretrigger_Samples);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the device to not wait for a Reference trigger to mark a reference point within a record. This function is only necessary if you configured a Reference trigger in the past and now want to disable it.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int DisableRefTrigger()
        {
            int pInvokeResult = PInvoke.DisableRefTrigger(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the device to wait for a digital edge Advance trigger. The Advance trigger indicates where a new record begins.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Source">
        /// 
        /// source
        /// ConstString
        /// Specifies the source of the digital edge for the Advance trigger.
        /// 
        ///  NIRFSA_VAL_PFI0_STR  ("PFI0")
        /// The trigger is received on PFI 0.
        /// NIRFSA_VAL_PFI1_STR  ("PFI1")
        /// The trigger is received on PFI 1.
        ///  NIRFSA_VAL_PXI_TRIG0_STR ("PXI_Trig0")
        /// The trigger is received on PXI trigger line 0.
        ///  NIRFSA_VAL_PXI_TRIG1_STR ("PXI_Trig1")
        /// The trigger is received on PXI trigger line 1.
        ///  NIRFSA_VAL_PXI_TRIG2_STR ("PXI_Trig2")
        /// The trigger is received on PXI trigger line 2.
        ///  NIRFSA_VAL_PXI_TRIG3_STR ("PXI_Trig3")
        /// The trigger is received on PXI trigger line 3.
        ///  NIRFSA_VAL_PXI_TRIG4_STR ("PXI_Trig4")
        /// The trigger is received on PXI trigger line 4.
        ///  NIRFSA_VAL_PXI_TRIG5_STR ("PXI_Trig5")
        /// The trigger is received on PXI trigger line 5.
        ///  NIRFSA_VAL_PXI_TRIG6_STR ("PXI_Trig6")
        /// The trigger is received on PXI trigger line 6.
        ///  NIRFSA_VAL_PXI_TRIG7_STR ("PXI_Trig7")
        /// The trigger is received on PXI trigger line 7.
        ///  NIRFSA_VAL_PXI_STAR_STR ("PXI_STAR")
        /// The trigger is received on the PXI star trigger line.
        /// 
        /// </param>
        /// <param name="Edge">
        /// 
        /// edge
        /// Int32
        /// Specifies the trigger edge to detect.
        /// 
        /// NIRFSA_VAL_RISING_EDGE (900)NI-RFSA detects a rising edge.
        /// NIRFSA_VAL_FALLING_EDGE (901)NI-RFSA detects a falling edge.
        /// 
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureDigitalEdgeAdvanceTrigger(string Source, int Edge)
        {
            int pInvokeResult = PInvoke.ConfigureDigitalEdgeAdvanceTrigger(this._handle, Source, Edge);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the device to wait for a digital edge Advance trigger. The Advance trigger indicates where a new record begins. The device waits until you call the SendSoftwareEdgeTrigger function to assert the trigger.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int ConfigureSoftwareEdgeAdvanceTrigger()
        {
            int pInvokeResult = PInvoke.ConfigureSoftwareEdgeAdvanceTrigger(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the device to not use an Advance trigger. This function is only necessary if you configured an Advance trigger in the past and now want to disable it.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        /// </returns>
        public int DisableAdvanceTrigger()
        {
            int pInvokeResult = PInvoke.DisableAdvanceTrigger(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Sends a trigger to the device when you configure a software version of a supported trigger and the device is waiting for the trigger to be sent. This function also can be used to override a hardware trigger.
        /// This function returns an error in the following situations:
        /// You configure an invalid trigger.
        /// The instrument driver is in spectrum mode.
        /// You have not previously called the niRFSA_Initiate function.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Trigger">
        /// 
        /// trigger
        /// Int32
        /// Specifies the software signal to send.
        /// 
        /// StartTrigger (1100)NI-RFSA sends a Start software trigger.
        /// RefTrigger (702)NI-RFSA sends a Reference software trigger.
        /// AdvanceTrigger (1102)NI-RFSA sends an Advance software trigger.
        /// ArmRefTrigger (1103)NI-RFSA sends an Arm Reference software trigger.
        /// 
        /// </param>
        /// <param name="Trigger_Identifier">
        /// 
        /// triggerIdentifier
        /// ConstString
        /// Specifies a particular instance of a trigger. NI-RFSA does not currently support this parameter.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// Status
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int SendSoftwareEdgeTrigger(int Trigger, string Trigger_Identifier)
        {
            int pInvokeResult = PInvoke.SendSoftwareEdgeTrigger(this._handle, Trigger, Trigger_Identifier);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Routes signals (triggers, clocks, and events) to the specified output terminal.
        /// 
        /// If you export a signal with this function and  commit the session, the signal is routed to the output terminal you specify. If you then reconfigure the signal to have a different output terminal, the previous output terminal is tristated when the session is next committed. If you change the outputTerminal to NIRFSA_VAL_DO_NOT_EXPORT and commit, the previous output terminal is tristated.
        /// 
        /// Any signals, except for those exported over PXI trigger lines, that are exported within a session persist after the session closes to prevent signal glitches between sessions. PXI trigger lines are always set to tristate when a session is closed. If you wish to have the output terminal tristated when the session closes, first change the outputTerminal for the exported signal to NIRFSA_VAL_DO_NOT_EXPORT and commit the session again before closing it.
        /// 
        /// You can also tristate all PFI lines by setting the resetDevice parameter in the niRFSA_init function or by using the niRFSA_reset function.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Signal">
        /// 
        /// signal
        /// ViInt32
        /// Specifies the type of signal to route. You can choose to export the Start, Reference, and Advance triggers and the Ready for Start, Ready for Advance, Ready for Ref, End of Record, and Done events.
        /// 
        /// NIRFSA_VAL_START_TRIGGER (1100)NI-RFSA routes a Start trigger signal.
        /// NIRFSA_VAL_REF_TRIGGER (702)NI-RFSA routes a Reference trigger signal.
        /// NIRFSA_VAL_ADVANCE_TRIGGER (1102)NI-RFSA routes an Advance trigger signal.
        /// NIRFSA_VAL_READY_FOR_START_EVENT (1200)NI-RFSA routes a Ready for Start event signal.
        /// NIRFSA_VAL_READY_FOR_ADVANCE_EVENT (1202)NI-RFSA routes a  Ready for Advance event signal.
        /// NIRFSA_VAL_READY_FOR_REF_EVENT (1201)NI-RFSA routes a Ready for Reference event signal.
        /// NIRFSA_VAL_END_OF_RECORD_EVENT (1203)NI-RFSA routes an End of Record event signal.
        /// NIRFSA_VAL_DONE_EVENT (1204)NI-RFSA routes a Done event signal.
        /// NIRFSA_VAL_REF_CLOCK (1205)NI-RFSA routes a Reference clock signal.
        /// </param>
        /// <param name="Signal_Identifier">
        /// 
        /// signalIdentifier
        /// ViConstString
        /// Specifies a particular instance of a trigger. NI-RFSA does not currently support this parameter.
        /// 
        /// </param>
        /// <param name="Output_Terminal">
        /// 
        /// outputTerminal
        /// ViConstString
        /// Specifies the terminal where the signal will be exported. You can also choose not to export any signal.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int ExportSignal(int Signal, string Signal_Identifier, string Output_Terminal)
        {
            int pInvokeResult = PInvoke.ExportSignal(this._handle, Signal, Signal_Identifier, Output_Terminal);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Configures the NI-RFSA device Reference clock.
        /// 
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Ref_Clock_Source">
        /// 
        /// refClockSource
        /// ViConstString
        /// Specifies the Reference clock source.
        /// 
        /// NIRFSA_VAL_ONBOARD_CLOCK_STR ("OnboardClock")
        /// NI 5661&#8212;Lock the NI-RFSA device to the NI 5600 RF downconverter onboard clock.
        /// 
        /// NI 5663&#8212;Lock the NI 5622 to the NI 5652 LO source onboard clock. Connect the REF IN/OUT connector on the NI 5652 to the CLK IN terminal on the NI 5622.
        /// NIRFSA_VAL_REF_IN_STR ("RefIn")
        /// NI 5661&#8212;Lock the NI-RFSA device to the signal at the external FREQ REF IN connector on the
        ///                   NI 5600.
        /// 
        /// NI 5663&#8212;Connect the external signal to the NI&#160;5652 REF IN/OUT connector. Only use this configuration in downconverter-only mode.
        /// NIRFSA_VAL_CLK_IN_STR ("ClkIn")
        /// NI 5661&#8212;This configuration does not apply to the NI 5661.
        /// 
        /// NI 5663&#8212;Lock the NI 5622 to an external 10 MHz signal. Connect the external signal to the CLK IN connector on the NI 5622, and connect the NI 5622 CLK&#160;OUT connector to the REF IN/OUT connector on the NI 5652.
        /// NIRFSA_VAL_PXI_CLK_STR ("PXI_Clk")
        /// NI 5661&#8212;Lock the NI-RFSA device to the PXI backplane clock using the NI&#160;5600. You must connect the PXI 10 MHz connector to the FREQ REF IN connector on the
        ///                   NI&#160;5600 front panel to use this option.
        /// 
        /// NI 5663&#8212;Lock the NI 5663 to the PXI backplane clock.
        /// 
        /// </param>
        /// <param name="Ref_Clock_Rate">
        /// 
        /// refClockRate
        /// ViReal64
        /// Specifies the reference clock rate, expressed in hertz (Hz). The default value is 10 MHz, which is the only supported value.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int ConfigureRefClock(string Ref_Clock_Source, double Ref_Clock_Rate)
        {
            int pInvokeResult = PInvoke.ConfigureRefClock(this._handle, Ref_Clock_Source, Ref_Clock_Rate);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Specifies the signal to drive the 10&#160;MHz Reference clock on the PXI backplane. This option can only be configured when the NI&#160;5600 is installed in Slot&#160;2 of the PXI chassis. 
        /// 
        /// Supported Devices: NI 5600 (downconverter only mode), NI 5661
        /// </summary>
        /// <param name="PXI_Clk_10_Source">
        /// 
        /// PXIClk10Source
        /// ViConstString
        /// Specifies the signal to drive the 10 MHz Reference clock on the PXI backplane. This option can only be configured when the NI&#160;5600 is in Slot&#160;2 of the PXI chassis. 
        /// 
        ///                                                              NIRFSA_VAL_NONE_STR ("None")
        /// 
        ///                     The device does not drive the PXI 10 MHz backplane Reference
        ///                   clock.
        /// 
        ///                                                             NIRFSA_VAL_ONBOARD_CLOCK_STR ("OnboardClock")
        /// 
        ///                     The device drives the PXI 10 MHz backplane Reference clock with
        ///                   the NI&#160;5600 onboard clock. You must connect the 10 MHz OUT connector to the
        ///                   PXI 10 MHz I/O connector on the NI&#160;5600 front panel to use this option.
        /// 
        ///                                                             NIRFSA_VAL_REF_IN_STR ("RefIn")
        /// 
        ///                     The device drives the PXI 10 MHz backplane Reference clock with
        ///                   the reference source attached to the NI&#160;5600 FREQ REF IN connector. You must
        ///                   connect the 10&#160;MHz&#160;OUT connector to the PXI&#160;10&#160;MHz&#160;I/O connector on the NI&#160;5600 front
        ///                   panel to use this option.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int ConfigurePXIChassisClk10(string PXI_Clk_10_Source)
        {
            int pInvokeResult = PInvoke.ConfigurePXIChassisClk10(this._handle, PXI_Clk_10_Source);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Resets the attribute to its default value.
        /// 
        /// Supported Devices: 
        /// 
        /// </summary>
        /// <param name="Channel_Name">
        /// 
        /// channelName
        /// ViConstString
        /// Specifies the name of the channel on which to reset the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to "" (empty string) or VI_NULL.
        /// 
        /// </param>
        /// <param name="Attribute_ID">
        /// 
        /// attributeID
        /// ViAttr
        /// Pass the ID of an attribute.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int ResetAttribute(string Channel_Name, int Attribute_ID)
        {
            int pInvokeResult = PInvoke.ResetAttribute(this._handle, Channel_Name, Attribute_ID);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Starts an I/Q acquisition. You may use this function in conjunction with the NI-RFSA fetch IQ functions to retrieve acquired I/Q data, or use the NI-RFSA read IQ functions to both initiate the acquisition and retrieve I/Q data at one time.
        /// 
        /// For improved accuracy, add a wait after calling the niRFSA_Commit function and before calling the niRFSA_Initiate function to allow the device additional settling time. Refer to the specifications document that shipped with your device for information about settling time and accuracy.
        /// 
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int Initiate()
        {
            int pInvokeResult = PInvoke.Initiate(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Fetches binary I/Q data from a single record in an acquisition. The fetch transfers acquired waveform data from device memory to computer memory. The data was acquired to onboard memory previously by the hardware after the acquisition was initiated.
        /// 
        /// This function is not necessary if you use the niRFSA_ReadIQSingleRecordComplexF64 function, as a fetch is performed as part of that function.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Record_Number">
        /// 
        /// recordNumber
        /// ViInt64
        /// Specifies the record to retrieve. Record numbers are zero-based.
        /// 
        /// </param>
        /// <param name="Number_of_Samples">
        /// 
        /// numberOfSamples
        /// ViInt64
        /// Specifies the number of samples to fetch. A value of &#8211;1 specifies that NI-RFSA will fetch all samples. The default value is 1000.
        /// 
        /// </param>
        /// <param name="Timeout">
        /// 
        /// timeout
        /// ViReal64
        /// Specifies the time, in seconds, allotted for the function to complete before returning a timeout error. A value of &#8211;1 specifies the function waits until all data is available. A value of 0 specifies the function immediately returns available data. The default value is 10.
        /// 
        /// </param>
        /// <param name="Data">
        /// 
        /// data
        /// NIComplexI16*
        /// Returns the acquired waveform. Allocate an NI ComplexI16 array at least as large as numberOfSamples.
        /// 
        /// </param>
        /// <param name="Waveform_Info">
        /// 
        /// wfmInfo
        /// niRFSA_wfmInfo*
        /// Contains the absolute and relative timestamps for the operation, the time interval, and the actual number of samples read.
        /// 
        /// The following list provides more information about each of these properties:
        /// absolute timestamp&#8212;returns the timestamp, in seconds, of the first fetched sample that is comparable between records and acquisitions.
        /// relative timestamp&#8212;returns a timestamp that corresponds to the difference, in seconds, between the first sample returned and the Reference trigger location.
        /// dt&#8212;returns the time interval between data points in the acquired signal. The I/Q data sampling rate is the reciprocal of this value.
        /// actual samples read&#8212;returns an integer representing the number of samples in the waveform.
        /// offset&#8212;returns the offset to scale data (b) in mx+b form.
        /// gain&#8212;returns the gain to scale data (m) in mx+b form.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        [Obsolete("This method is obsolete; use the method FetchIQSingleRecordComplexI16 which receives an array of niComplexI16 instead")]
        public int FetchIQSingleRecordComplexI16(string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, short[] Data, out niRFSA_wfmInfo Waveform_Info)
        {
            int pInvokeResult = PInvoke.FetchIQSingleRecordComplexI16(this._handle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Fetches binary I/Q data from a single record in an acquisition. The fetch transfers acquired waveform data from device memory to computer memory. The data was acquired to onboard memory previously by the hardware after the acquisition was initiated.
        /// This function is not necessary if you use the niRFSA_ReadIQSingleRecordComplexF64 function, as a fetch is performed as part of that function.
        /// Supported Devices: NI 5661/5663
        /// </summary>
        /// <param name = "Channel_List">
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// </param>
        /// <param name = "Record_Number">
        /// recordNumber
        /// ViInt64
        /// Specifies the record to retrieve. Record numbers are zero-based.
        /// </param>
        /// <param name = "Number_of_Samples">
        /// numberOfSamples
        /// ViInt64
        /// Specifies the number of samples to fetch. A value of &#8211;1 specifies that NI-RFSA will fetch all samples. The default value is 1000.
        /// </param>
        /// <param name = "Timeout">
        /// timeout
        /// ViReal64
        /// Specifies the time, in seconds, allotted for the function to complete before returning a timeout error. A value of &#8211;1 specifies the function waits until all data is available. A value of 0 specifies the function immediately returns available data. The default value is 10.
        /// </param>
        /// <param name = "Data">
        /// data
        /// NIComplexI16*
        /// Returns the acquired waveform. Allocate an NI ComplexI16 array at least as large as numberOfSamples.
        /// </param>
        /// <param name = "Waveform_Info">
        /// wfmInfo
        /// niRFSA_wfmInfo*
        /// Contains the absolute and relative timestamps for the operation, the time interval, and the actual number of samples read.
        /// The following list provides more information about each of these properties:
        /// absolute timestamp&#8212;returns the timestamp, in seconds, of the first fetched sample that is comparable between records and acquisitions.
        /// relative timestamp&#8212;returns a timestamp that corresponds to the difference, in seconds, between the first sample returned and the Reference trigger location.
        /// dt&#8212;returns the time interval between data points in the acquired signal. The I/Q data sampling rate is the reciprocal of this value.
        /// actual samples read&#8212;returns an integer representing the number of samples in the waveform.
        /// offset&#8212;returns the offset to scale data (b) in mx+b form.
        /// gain&#8212;returns the gain to scale data (m) in mx+b form.
        /// </param>
        /// <returns>
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// </returns>
        public int FetchIQSingleRecordComplexI16(string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, niComplexI16[] Data, out niRFSA_wfmInfo Waveform_Info)
        {
            int pInvokeResult = PInvoke.FetchIQSingleRecordComplexI16(this._handle, Channel_List, Record_Number, Number_of_Samples, Timeout, ref Data, out Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// 
        /// Fetches I/Q data from a single record in an acquisition. The fetch transfers acquired waveform data from device memory to computer memory. The data was acquired to onboard memory previously by the hardware after the acquisition was initiated.
        /// 
        /// This function is not necessary if you use the niRFSA_ReadIQSingleRecordComplexF64 function, as the fetch is performed as part of that function.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Record_Number">
        /// 
        /// recordNumber
        /// ViInt64
        /// Specifies the record to retrieve. Record numbers are zero-based.
        /// 
        /// </param>
        /// <param name="Number_of_Samples">
        /// 
        /// numberOfSamples
        /// ViInt64
        /// Specifies the number of samples to fetch.
        /// 
        /// </param>
        /// <param name="Timeout">
        /// 
        /// timeout
        /// ViReal64
        /// Specifies the time, in seconds, allotted for the function to complete before returning a timeout error. A value of &#8211;1 specifies the function waits until all data is available. A value of 0 specifies the function immediately returns available data. The default value is 10.
        /// 
        /// </param>
        /// <param name="Data">
        /// 
        /// data
        /// NIComplexNumber*
        /// Returns the acquired waveform. Allocate an NIComplexNumber array at least as large as numberOfSamples.
        /// 
        /// </param>
        /// <param name="Waveform_Info">
        /// 
        /// wfmInfo
        /// niRFSA_wfmInfo*
        /// Returns the absolute and relative timestamps for the operation, the time interval, and the actual number of samples read.
        /// 
        /// The following list provides more information about each of these properties:
        /// absolute timestamp&#8212;returns the timestamp, in seconds, of the first fetched sample that is comparable between records and acquisitions.
        /// relative timestamp&#8212;returns a timestamp that corresponds to the difference, in seconds, between the first sample returned and the Reference trigger location.
        /// dt&#8212;returns the time interval between data points in the acquired signal. The I/Q data sampling rate is the reciprocal of this value.
        /// actual samples read&#8212;returns an integer representing the number of samples in the waveform.
        /// offset&#8212;returns the offset to scale data (b) in mx+b form.
        /// gain&#8212;returns the gain to scale data (m) in mx+b form.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int FetchIQSingleRecordComplexF64(string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, niComplexNumber[] Data, out niRFSA_wfmInfo Waveform_Info)
        {
            int pInvokeResult = PInvoke.FetchIQSingleRecordComplexF64(this._handle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Initiates an acquisition and fetches a single I/Q data record. Do not use this function if you have configured the device to continuously acquire data samples or to acquire multiple records.
        /// 
        /// Supported Devices: NI 5661/5663
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Timeout">
        /// 
        /// timeout
        /// ViReal64
        /// Specifies in seconds the time allotted for the function to complete before returning a timeout error. A value of &#8211;1 specifies the function waits until all data is available.
        /// 
        /// </param>
        /// <param name="Data">
        /// 
        /// data
        /// NIComplexNumber*
        /// Returns the acquired waveform. Allocate an NIComplexNumber array at least as large as numberOfSamples.
        /// 
        /// </param>
        /// <param name="Data_Array_Size">
        /// 
        /// dataArraySize
        /// ViInt64
        /// Specifies the size of the array for the data parameter. The array needs to be at least as large as the number of samples configured in the niRFSA_ConfigureNumberOfSamples function.
        /// 
        /// </param>
        /// <param name="Waveform_Info">
        /// 
        /// wfmInfo*
        /// niRFSA_wfmInfo
        /// Returns additional information about the data array.
        /// 
        /// The following list provides more information about each of these properties:
        /// absolute timestamp&#8212;returns the timestamp, in seconds, of the first fetched sample that is comparable between records and acquisitions.
        /// relative timestamp&#8212;returns a timestamp that corresponds to the difference, in seconds, between the first sample returned and the Reference trigger location.
        /// dt&#8212;returns the time interval between data points in the acquired signal. The I/Q data sampling rate is the reciprocal of this value.
        /// actual samples read&#8212;returns an integer representing the number of samples in the waveform.
        /// offset&#8212;returns the offset to scale data (b) in mx+b form.
        /// gain&#8212;returns the gain to scale data (m) in mx+b form.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int ReadIQSingleRecordComplexF64(string Channel_List, double Timeout, niComplexNumber[] Data, Int64 Data_Array_Size, out niRFSA_wfmInfo Waveform_Info)
        {
            int pInvokeResult = PInvoke.ReadIQSingleRecordComplexF64(this._handle, Channel_List, Timeout, Data, Data_Array_Size, out Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Fetches binary I/Q data from multiple records in an acquisition. Fetching transfers acquired waveform data from device memory to computer memory. The data was acquired to onboard memory previously by the hardware after the acquisition was initiated.
        /// 
        /// This function is not necessary if you use the niRFSA_ReadIQSingleRecordComplexF64 function, as the fetch is performed as part of that function.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Starting_Record">
        /// 
        /// startingRecord
        /// ViInt64
        /// Specifies the first record to retrieve. Record numbers are zero-based.
        /// 
        /// </param>
        /// <param name="Number_of_Records">
        /// 
        /// numberOfRecords
        /// ViInt64
        /// Specifies the number of records to fetch. A value of &#8211;1 specifies that NI-RFSA fetches all records in an acquisition starting with the record specified by startingRecord. Record numbers are zero-based. The default value is &#8211;1.
        /// 
        /// </param>
        /// <param name="Number_of_Samples">
        /// 
        /// numberofSamples
        /// ViInt64
        /// Specifies the number of samples per record.
        /// </param>
        /// <param name="Timeout">
        /// 
        /// timeout
        /// ViReal64
        /// Specifies the time, in seconds, allotted for the function to complete before returning a timeout error. A value of &#8211;1 specifies the function waits until all data is available. A value of 0 specifies the function immediately returns available data. The default value is 10.
        /// 
        /// </param>
        /// <param name="Data">
        /// 
        /// data
        /// NIComplexI16*
        /// Returns the acquired waveform for each record fetched. The waveforms are written sequentially in the array. Allocate an array at least as large as numberOfSamples times numberOfRecords for this parameter.
        /// 
        /// </param>
        /// <param name="Waveform_Info">
        /// 
        /// wfmInfo
        /// niRFSA_wfmInfo*
        /// Returns an array of structures containing information about each record fetched. Each structure contains the absolute and relative timestamps, the dt, and the actual number of samples read for the corresponding record.
        /// 
        /// The following list provides more information about each of these properties:
        /// absolute timestamp&#8212;returns the timestamp in seconds of the first fetched sample that is comparable between records and acquisitions.
        /// relative timestamp&#8212;returns a timestamp that corresponds to the difference in seconds between the first sample returned and the Reference trigger location.
        /// dt&#8212;returns the time interval between data points in the acquired signal. The IQ data sampling rate is the reciprocal of this value.
        /// actual samples read&#8212;returns an integer representing the number of samples in the waveform.
        /// offset&#8212;returns the offset to scale data in mx+b form.
        /// gain&#8212;returns the gain to scale data in mx+b form.
        /// Note:Allocate an array of structures at least as large as numberOfRecords for this parameter.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        [Obsolete("This method is obsolete; use the method FetchIQMultiRecordComplexI16 which receives an array of niComplexI16 instead")]
        public int FetchIQMultiRecordComplexI16(string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, short[] Data, niRFSA_wfmInfo[] Waveform_Info)
        {
            int pInvokeResult = PInvoke.FetchIQMultiRecordComplexI16(this._handle, Channel_List, Starting_Record, Number_of_Records, Number_of_Samples, Timeout, Data, Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Fetches binary I/Q data from multiple records in an acquisition. Fetching transfers acquired waveform data from device memory to computer memory. The data was acquired to onboard memory previously by the hardware after the acquisition was initiated.
        /// This function is not necessary if you use the niRFSA_ReadIQSingleRecordComplexF64 function, as the fetch is performed as part of that function.
        /// Supported Devices: NI 5661/5663
        /// </summary>
        /// <param name = "Channel_List">
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// </param>
        /// <param name = "Starting_Record">
        /// startingRecord
        /// ViInt64
        /// Specifies the first record to retrieve. Record numbers are zero-based.
        /// </param>
        /// <param name = "Number_of_Records">
        /// numberOfRecords
        /// ViInt64
        /// Specifies the number of records to fetch. A value of &#8211;1 specifies that NI-RFSA fetches all records in an acquisition starting with the record specified by startingRecord. Record numbers are zero-based. The default value is &#8211;1.
        /// </param>
        /// <param name = "Number_of_Samples">
        /// numberofSamples
        /// ViInt64
        /// Specifies the number of samples per record.
        /// </param>
        /// <param name = "Timeout">
        /// timeout
        /// ViReal64
        /// Specifies the time, in seconds, allotted for the function to complete before returning a timeout error. A value of &#8211;1 specifies the function waits until all data is available. A value of 0 specifies the function immediately returns available data. The default value is 10.
        /// </param>
        /// <param name = "Data">
        /// data
        /// NIComplexI16*
        /// Returns the acquired waveform for each record fetched. The waveforms are written sequentially in the array. Allocate an array at least as large as numberOfSamples times numberOfRecords for this parameter.
        /// </param>
        /// <param name = "Waveform_Info">
        /// wfmInfo
        /// niRFSA_wfmInfo*
        /// Returns an array of structures containing information about each record fetched. Each structure contains the absolute and relative timestamps, the dt, and the actual number of samples read for the corresponding record.
        /// The following list provides more information about each of these properties:
        /// absolute timestamp&#8212;returns the timestamp in seconds of the first fetched sample that is comparable between records and acquisitions.
        /// relative timestamp&#8212;returns a timestamp that corresponds to the difference in seconds between the first sample returned and the Reference trigger location.
        /// dt&#8212;returns the time interval between data points in the acquired signal. The IQ data sampling rate is the reciprocal of this value.
        /// actual samples read&#8212;returns an integer representing the number of samples in the waveform.
        /// offset&#8212;returns the offset to scale data in mx+b form.
        /// gain&#8212;returns the gain to scale data in mx+b form.
        /// Note:Allocate an array of structures at least as large as numberOfRecords for this parameter.
        /// </param>
        /// <returns>
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// The general meaning of the status code is as follows:
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// </returns>
        public int FetchIQMultiRecordComplexI16(string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, niComplexI16[] Data, niRFSA_wfmInfo[] Waveform_Info)
        {
            int pInvokeResult = PInvoke.FetchIQMultiRecordComplexI16(this._handle, Channel_List, Starting_Record, Number_of_Records, Number_of_Samples, Timeout, ref Data, Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Fetches I/Q data from multiple records in an acquisition. A fetch transfers acquired waveform data from device memory to computer memory. The data was acquired to onboard memory previously by the hardware after the acquisition was initiated.
        /// 
        /// This function is not necessary if you use the niRFSA_ReadIQSingleRecordComplexF64 function, as the fetch is performed as part of that function.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Starting_Record">
        /// 
        /// startingRecord
        /// ViInt64
        /// Specifies the first record to retrieve. Record numbers are zero-based.
        /// 
        /// </param>
        /// <param name="Number_of_Records">
        /// 
        /// numberOfRecords
        /// ViInt64
        /// Specifies the number of records to fetch. A value of &#8211;1 specifies that NI-RFSA fetches all records in an acquisition starting with the record specified by startingRecord. Record numbers are zero-based.  The default value is &#8211;1.
        /// 
        /// </param>
        /// <param name="Number_of_Samples">
        /// 
        /// numberOfSamples
        /// ViInt64
        /// Specifies the number of samples per record.
        /// 
        /// </param>
        /// <param name="Timeout">
        /// 
        /// timeout
        /// ViReal64
        /// Specifies the time, in seconds, allotted for the function to complete before returning a timeout error. A value of &#8211;1 specifies the function waits until all data is available. A value of 0 specifies the function immediately returns available data. The default value is 10.
        /// 
        /// </param>
        /// <param name="Data">
        /// 
        /// data
        /// NIComplexNumber*
        /// Returns the acquired waveform for each record fetched. The waveforms are written sequentially in the array. Allocate an array at least as large as numberOfSamples times numberOfRecords for this parameter.
        /// 
        /// </param>
        /// <param name="Waveform_Info">
        /// 
        /// wfmInfo
        /// niRFSA_wfmInfo*
        /// Returns an array of structures containing information about each record fetched. Each structure contains the absolute and relative timestamps, the dt, and the actual number of samples read for the corresponding record.
        /// 
        /// The following list provides more information about each of these properties:
        /// absolute timestamp&#8212;returns the timestamp in seconds of the first fetched sample that is comparable between records and acquisitions.
        /// relative timestamp&#8212;returns a timestamp that corresponds to the difference in seconds between the first sample returned and the Reference trigger location.
        /// dt&#8212;returns the time interval between data points in the acquired signal. The IQ data sampling rate is the reciprocal of this value.
        /// actual samples read&#8212;returns an integer representing the number of samples in the waveform.
        /// offset&#8212;returns the offset to scale data in mx+b form.
        /// gain&#8212;returns the gain to scale data in mx+b form.
        /// Note:Allocate an array of structures at least as large as numberOfRecords for this parameter.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int FetchIQMultiRecordComplexF64(string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, niComplexNumber[] Data, niRFSA_wfmInfo[] Waveform_Info)
        {
            int pInvokeResult = PInvoke.FetchIQMultiRecordComplexF64(this._handle, Channel_List, Starting_Record, Number_of_Records, Number_of_Samples, Timeout, Data, Waveform_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Stops an acquisition previously started with the niRFSA_Initiate function. Calling this function is optional, unless you want to stop an acquisition before it is complete or you are continuously acquiring data.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int Abort()
        {
            int pInvokeResult = PInvoke.Abort(Handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Initiates a spectrum acquisition and returns power spectrum data.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Timeout">
        /// 
        /// timeout
        /// ViReal64
        /// Specifies the time, in seconds, allotted for the function to complete before returning a timeout error. A value of &#8211;1 specifies the function waits until all data is available. The default value is 10.
        /// 
        /// </param>
        /// <param name="Power_Spectrum_Data">
        /// 
        /// powerSpectrumData[]
        /// ViReal64
        /// Returns power spectrum data. Allocate an array as large as dataArraySize.
        /// 
        /// </param>
        /// <param name="Data_Array_Size">
        /// 
        /// dataArraySize
        /// ViInt64
        /// Specifies the size of the array you specify for the powerSpectrumData parameter. Use the niRFSA_GetNumberOfSpectralLines function to obtain the array size to allocate. The array must be at least as large as the number of spectral lines that NI-RFSA computes for the power spectrum.
        /// 
        /// </param>
        /// <param name="Spectrum_Info">
        /// 
        /// spectrumInfo
        /// niRFSA_spectrumInfo*
        /// Returns additional information about the powerSpectrumData array. This information includes the frequency, in hertz (Hz) corresponding to the first element in the array, the frequency increment, in Hz, between adjacent array elements, and the number of spectral lines the function returned.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int ReadPowerSpectrumF64(string Channel_List, double Timeout, double[] Power_Spectrum_Data, int Data_Array_Size, out niRFSA_spectrumInfo Spectrum_Info)
        {
            int pInvokeResult = PInvoke.ReadPowerSpectrumF64(this._handle, Channel_List, Timeout, Power_Spectrum_Data, Data_Array_Size, out Spectrum_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Returns the number of spectral lines that NI-RFSA will compute with the current power spectrum configuration.
        /// 
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Number_of_Spectral_Lines">
        /// 
        /// numberOfSpectralLines
        /// ViInt32*
        /// Returns the value of the NIRFSA_ATTR_NUM_SPECTRAL_LINES attribute.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int GetNumberOfSpectralLines(string Channel_List, out int Number_of_Spectral_Lines)
        {
            int pInvokeResult = PInvoke.GetNumberOfSpectralLines(this._handle, Channel_List, out Number_of_Spectral_Lines);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Checks the status of the acquisition. Use this function to check for any errors that may occur during signal acquisition or to check whether the device has completed the acquisition operation. 
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Is_Done">
        /// 
        /// isDone
        /// ViBoolean*
        /// Returns signal acquisition status.
        /// 
        /// VI_TRUESignal acquisition is complete.
        /// VI_FALSESignal acquisition is not complete.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int CheckAcquisitionStatus(out bool Is_Done)
        {
            ushort Is_DoneAsUShort;
            int pInvokeResult = PInvoke.CheckAcquisitionStatus(this._handle, out Is_DoneAsUShort);
            Is_Done = System.Convert.ToBoolean(Is_DoneAsUShort);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Resets the device to a default initialization state.
        /// 
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int reset()
        {
            int pInvokeResult = PInvoke.reset(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Commits settings to hardware. Calling this function is optional. Settings are automatically committed to hardware when you call the niRFSA_Initiate function, a read IQ function, or the niRFSA_ReadPowerSpectrumF64 function. 
        /// 
        /// For improved accuracy, add a wait after calling this function and before calling the niRFSA_Initiate function to allow the device additional settling time. Refer to the specifications document that shipped with your device for information about settling time and accuracy.
        /// 
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int Commit()
        {
            int pInvokeResult = PInvoke.Commit(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Performs a self-test on the NI-RFSA device and returns the test result. This function performs a simple series of tests verifying that the NI-RFSA device is powered on and responding.
        /// 
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// 
        /// </summary>
        /// <param name="testResult">
        /// 
        /// testResult
        /// ViInt16*
        /// Returns the value from the device self-test. A value of 0 means success.
        /// 
        /// </param>
        /// <param name="testMessage">
        /// 
        /// testMessage[]
        /// ViChar
        /// Returns the self-test response string from the NI-RFSA device.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int self_test(out short testResult, System.Text.StringBuilder testMessage)
        {
            int pInvokeResult = PInvoke.self_test(this._handle, out testResult, testMessage);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Self-calibrates the IF digitizer associated with the NI-RFSA device. If self calibration is performed successfully, the new calibration constants are immediately stored in the self calibration area of the digitizer EEPROM. Refer to the NI High-Speed Digitizers Help for more information about how often to self-calibrate. 
        /// 
        /// Call this function to obtain more accurate acquisition results when the environmental conditions change significantly.
        /// 
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        [Obsolete("The function is obslete and is no longer supported")]
        public int SelfCal()
        {
            int pInvokeResult = PInvoke.SelfCal(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Corrects for temperature variations while acquiring the same signal for extended periods of time in a continuous acquisition. Measurements are affected by changes in temperature. NI-RFSA internally acquires the
        ///             temperature every time you initiate an acquisition. If you are performing a continuous acquisition, National Instruments recommends calling this function once every 10&#160;minutes in a stable temperature environment to periodically update temperature calibration.
        ///             Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int PerformThermalCorrection()
        {
            int pInvokeResult = PInvoke.PerformThermalCorrection(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Returns the number of points acquired that have not been fetched yet.
        /// 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Record_Number">
        /// 
        /// recordNumber
        /// ViInt64
        /// Specifies the record from which to read the backlog. Record numbers are zero-based. The default value is 0.
        /// 
        /// </param>
        /// <param name="Backlog">
        /// 
        /// backlog
        /// ViInt64*
        /// Returns the number of samples available to read for the requested record.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int GetFetchBacklog(string Channel_List, Int64 Record_Number, out Int64 Backlog)
        {
            int pInvokeResult = PInvoke.GetFetchBacklog(this._handle, Channel_List, Record_Number, out Backlog);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Returns the revision numbers of the NI-RFSA instrument driver.
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// </summary>
        /// <param name="Instrument_Driver_Revision">
        /// 
        /// driverRev
        /// ViChar[]
        /// Returns the instrument driver software revision numbers in the form of a string. The value of the NIRFSA_ATTR_SPECIFIC_DRIVER_REVISION attribute is returned.
        /// 
        /// You must pass a ViChar array with at least 256&#160;bytes.
        /// 
        /// </param>
        /// <param name="Firmware_Revision">
        /// 
        /// instRev
        /// ViChar[]
        /// Returns the instrument firmware revision numbers in the form of a string. The value of the NIRFSA_ATTR_INSTRUMENT_FIRMWARE_REVISION attribute is returned.
        /// 
        /// You must pass a ViChar array with at least 256&#160;bytes.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int revision_query(System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision)
        {
            int pInvokeResult = PInvoke.revision_query(this._handle, Instrument_Driver_Revision, Firmware_Revision);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Returns information about the power spectrum NI-RFSA computes.
        /// 
        /// Note:The NI Spectral Measurements Toolkit (SMT) requires this information. 
        /// Supported Devices: NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Spectrum_Info">
        /// 
        /// spectrumInfo
        /// SmtSpectrumInfo*
        /// Returns a cluster containing information about the power spectrum NI-RFSA computes that is needed by the SMT.
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int GetSpectralInfoForSMT(out SmtSpectrumInfo Spectrum_Info)
        {
            int pInvokeResult = PInvoke.GetSpectralInfoForSMT(this._handle, out Spectrum_Info);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Returns the IF response, based upon current NI-RFSA settings. The NI 5661/5663 automatically corrects for the IF response when Digital IF Equalization is enabled, which is the default state. If you are using downconverter only mode, you can use information returned from this VI to correct your measurement.
        /// Supported Devices: NI 5600/5601 (downconverter only mode), NI 5661/5663
        /// 
        /// </summary>
        /// <param name="Channel_List">
        /// 
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Use "" (an empty string) or VI_NULL to specify all channels.
        /// 
        /// </param>
        /// <param name="Buffer_Size">
        /// 
        /// bufferSize
        /// ViInt32
        /// Specifies the size of the array you specify for the powerSpectrumData parameter. Use the niRFSA_GetNumberOfSpectralLines function to learn the array size you need to allocate. The array must be at least as large as the number of spectral lines that NI-RFSA computes for the power spectrum.
        /// 
        /// </param>
        /// <param name="Frequencies">
        /// 
        /// frequencies[]
        /// ViReal64
        /// Returns an array containing the frequencies, in hertz (Hz), that correspond to the response data.
        /// 
        /// Pass VI_NULL if you do not want to use this parameter.
        /// 
        /// </param>
        /// <param name="Magnitude_Response">
        /// 
        /// magnitudeResponse[]
        /// ViReal64
        /// Returns an array containing the magnitude IF response, in decibels (dB). The magnitude IF response is normalized to the center frequency at each frequency in the frequencies array.
        /// 
        /// Pass VI_NULL if you do not want to use this parameter.
        /// 
        /// </param>
        /// <param name="Phase_Response">
        /// 
        /// phaseResponse[]
        /// ViReal64
        /// Returns an array containing the phase IF response, in degrees. The phase IF response is normalized to the center frequency at each frequency entry in the frequencies array.
        /// 
        /// Pass VI_NULL if you do not want to use this parameter.
        /// 
        /// </param>
        /// <param name="Number_of_Frequencies">
        /// 
        /// numberOfFrequencies
        /// ViInt32*
        /// Returns the required number of elements in the frequencies array and the response arrays. If bufferSize is 0, this parameter returns the expected array size. The expected array size depends on which NI-RFSA device you use (NI&#160;5661 or NI&#160;5663) and on the current settings (NI&#160;5663 only).
        /// 
        /// </param>
        /// <returns>
        /// 
        /// status
        /// ViStatus
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.
        /// 
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.
        /// 
        /// The general meaning of the status code is as follows:
        /// 
        /// Value
        /// Meaning
        /// 0
        /// Success
        /// Positive Values
        /// Warnings
        /// Negative Values
        /// Errors
        /// 
        /// </returns>
        public int GetFrequencyResponse(string Channel_List, int Buffer_Size, double[] Frequencies, double[] Magnitude_Response, double[] Phase_Response, out int Number_of_Frequencies)
        {
            int pInvokeResult = PInvoke.GetFrequencyResponse(this._handle, Channel_List, Buffer_Size, Frequencies, Magnitude_Response, Phase_Response, out Number_of_Frequencies);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Specifies the IF attenuation settings. Call this function for every measurement taken.
        /// Supported Devices: NI 5601
        /// 
        /// </summary>
        ///<param name = "channelList">
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Specify 0 as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "iFFilter">
        /// IFFilter
        /// ViInt32
        /// Specifies the IF filter used.
        /// NIRFSA_VAL_187_5_MHZ_WIDE (1400)
        /// Uses the 187.5 MHz wide bandwidth filter.
        /// NIRFSA_VAL_187_5_MHZ_NARROW (1401)
        /// Uses the 187.5 MHz narrow bandwidth filter.
        /// NIRFSA_VAL_53_MHZ (1402)
        /// Uses the 53 MHz filter.
        /// NIRFSA_VAL_BYPASS (1403)
        /// Bypasses the IF filter.
        /// 
        ///</param>
        ///<param name = "numberofAttenuators">
        /// numberOfAttenuators
        /// ViInt32
        /// Specifies the number of attenuators to use during the IF attenuation adjustment.
        /// 
        ///</param>
        ///<param name = "attenuatorSettings">
        /// attenuatorSettings
        /// ViReal64* 
        /// Specifies the IF attenuator settings for the measurement. The first element in the array corresponds with IF1, the next element corresponds to IF2, and so on.
        /// 
        ///</param>
        ///<param name = "measurement">
        /// measurement
        /// ViReal64
        /// Specifies the measurement taken for the current input configuration.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int CalAdjustIFAttenuationCalibration(string channelList, int iFFilter, int numberofAttenuators, double[] attenuatorSettings, double measurement)
        {
            int pInvokeResult = PInvoke.CalAdjustIFAttenuationCalibration(this._handle, channelList, iFFilter, numberofAttenuators, attenuatorSettings, measurement);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Specifies the IF response settings for the driver.
        /// Supported Devices: NI 5601
        /// 
        /// </summary>
        ///<param name = "channelList">
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Specify 0 as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "iFFilter">
        /// IFFilter
        /// ViInt32
        /// Specifies the IF filter used.
        /// NIRFSA_VAL_187_5_MHZ_WIDE (1400)
        /// Uses the 187.5 MHz wide bandwidth path.
        /// NIRFSA_VAL_187_5_MHZ_NARROW (1401)
        /// Uses the 187.5 MHz narrow bandwidth path.
        /// NIRFSA_VAL_53_MHZ (1402)
        /// Uses the 53 MHz path.
        /// NIRFSA_VAL_BYPASS (1403)
        /// Bypasses the IF path.
        /// 
        ///</param>
        ///<param name = "rFFrequency">
        /// RFFrequency
        /// ViReal64
        /// Specifies the RF frequency used during the IF response adjustment.
        /// 
        ///</param>
        ///<param name = "bandwidth">
        /// bandwidth
        /// ViReal64
        /// Specifies the bandwidth to use for the IF response adjustment.
        /// 
        ///</param>
        ///<param name = "numberofMeasurements">
        /// numberOfMeasurements
        /// ViInt32
        /// Specifies the number of measurements to make.
        /// 
        ///</param>
        ///<param name = "measurements">
        /// measurements
        /// ViReal64*
        /// Specifies the relevant measurements taken for each IF filter configuration.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int CalAdjustIFResponseCalibration(string channelList, int iFFilter, double rFFrequency, double bandwidth, int numberofMeasurements, double[] measurements)
        {
            int pInvokeResult = PInvoke.CalAdjustIFResponseCalibration(this._handle, channelList, iFFilter, rFFrequency, bandwidth, numberofMeasurements, measurements);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Write the reference level settings to the driver. The reference level calibration data is split into either the default configuration data or the mechanical relay disabled configuration data.
        /// Supported Devices: NI 5601
        /// 
        /// </summary>
        ///<param name = "channelList">
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Specify 0 as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "referenceLevelCalDataType">
        /// referenceLevelCalDataType
        /// ViInt32
        /// Specifies whether the reference level calibration data being used is the default configuration data or the mechanical relay disabled configuration data.
        /// NIRFSA_VAL_EXT_CAL_DEFAULT (1800)
        /// The data is the default configuration data.
        /// NIRFSA_VAL_EXT_CAL_MECHANICAL_ATTENUATOR_DISABLED (1801)
        /// The data is the configuration data when the mechanical relay is disabled. Use this option to save uncalibrated measurements for more advanced operation.
        /// 
        ///</param>
        ///<param name = "rFBand">
        /// RFBand
        /// ViInt32
        /// Specifies the RF band used during the reference level calibration.
        /// NIRFSA_VAL_RF_BAND_1
        /// The RF band 1 path is used.
        /// NIRFSA_VAL_RF_BAND_2
        /// The RF band 2 path is used.
        /// NIRFSA_VAL_RF_BAND_3
        /// The RF band 3 path is used.
        /// NIRFSA_VAL_RF_BAND_4
        /// The RF band 4 path is used.
        /// 
        ///</param>
        ///<param name = "attenuatorTableNumber">
        /// attenuatorTableNumber
        /// ViInt32
        /// Specifies which attenuation table you are using. Valid values are 0 to 2.
        /// 
        ///</param>
        ///<param name = "frequency">
        /// frequency
        /// ViReal64
        /// Specifies the frequency for the reference level adjustment.
        /// 
        ///</param>
        ///<param name = "measurement">
        /// measurement
        /// ViReal64
        /// Specifies the relevant measurement taken for the current configuration.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int CalAdjustRefLevelCalibration(string channelList, int referenceLevelCalDataType, int rFBand, int attenuatorTableNumber, double frequency, double measurement)
        {
            int pInvokeResult = PInvoke.CalAdjustRefLevelCalibration(this._handle, channelList, referenceLevelCalDataType, rFBand, attenuatorTableNumber, frequency, measurement);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Writes the calibration temperature to the driver. 
        /// Supported Devices: NI 5601
        /// 
        /// </summary>
        ///<param name = "temperaturedegreesC">
        /// temperature
        /// ViReal64
        /// Specifies the calibration temperature.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int CalSetTemperature(double temperaturedegreesC)
        {
            int pInvokeResult = PInvoke.CalSetTemperature(this._handle, temperaturedegreesC);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Changes the password that is required to initialize an external calibration session.
        /// Supported Devices: NI 5601
        /// 
        /// </summary>
        ///<param name = "oldpassword">
        /// ViConstString
        /// oldPassword
        /// Specifies the previous password used to protect the calibration values.
        /// 
        ///</param>
        ///<param name = "newpassword">
        /// ViConstString
        /// newPassword
        /// Specifies the new password to use to protect the calibration values.
        /// The maximum length of the password varies by device. The NI 5601 can have a password that is up to 10 characters long.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int ChangeExtCalPassword(string oldpassword, string newpassword)
        {
            int pInvokeResult = PInvoke.ChangeExtCalPassword(this._handle, oldpassword, newpassword);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Closes an EEPROM-specific calibration step. This step ensures that all the measurements required for this particular calibration step haven been recorded by the user via the adjust function calls. 
        /// Supported Devices: NI 5601
        /// 
        /// </summary>
        ///<returns>
        /// Closes an EEPROM-specific calibration step. This step ensures that all the measurements required for this particular calibration step haven been recorded by the user via the adjust function calls. 
        /// Supported Devices: NI 5601
        /// 
        ///</returns>
        public int CloseCalibrationStep()
        {
            int pInvokeResult = PInvoke.CloseCalibrationStep(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Closes an NI-RFSA external calibration session and, if specified, stores the new calibration constants and calibration data, such as time, in the onboard EEPROM.
        /// Supported Devices: NI 5661/5663/5663E
        /// 
        /// </summary>
        ///<param name = "action">
        /// action
        /// ViInt32
        /// Specifies how to use the calibration values from this session as the session is closed.
        /// Defined Values:
        ///           NIRFSA_VAL_EXT_CAL_ABORT               The old calibration constants are kept, and the new ones are discarded.
        /// NIRFSA_VAL_EXT_CAL_COMMITThe new calibration constants are stored in the EEPROM.
        /// 
        ///</param>
        ///<returns>
        /// Closes an NI-RFSA external calibration session and, if specified, stores the new calibration constants and calibration data, such as time, in the onboard EEPROM.
        /// Supported Devices: NI 5661/5663/5663E
        /// 
        ///</returns>
        public int CloseExtCal(int action)
        {
            int pInvokeResult = PInvoke.CloseExtCal(this._handle, action);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Creates an empty RF configuration list for RF list mode. An RF configuration list is composed of configuration list steps. Each step specifies the state of the instrument by specifying values for attributes/properties.
        /// After a configuration list is created, the list is enabled using the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST attribute or by setting setAsActiveList to  VI_TRUE. Call the niRFSA_CreateConfigurationListStep function to add steps to the configuration list.
        /// Supported Devices: NI 5663E
        /// 
        /// </summary>
        ///<param name = "listName">
        /// listName
        /// ViConstString
        /// Specifies the name of the configuration list. This string  may not contain spaces, special characters, or punctuation marks.
        /// 
        ///</param>
        ///<param name = "numberOfListAttributes">
        /// numberOfListAttributes
        /// ViInt32
        /// Specifies the number of list attributes to set.
        /// 
        ///</param>
        ///<param name = "listAttributeIDs">
        /// listAttributeIDs
        /// ViAttr[]
        /// Specifies the configuration list attributes that will be set.
        /// You can include the following properties in your configuration list:
        /// NIRFSA_ATTR_IQ_CARRIER_FREQUENCY
        /// NIRFSA_ATTR_REFERENCE_LEVEL
        /// NIRFSA_ATTR_DOWNCONVERTER_CENTER_FREQUENCY
        /// NIRFSA_ATTR_IQ_POWER_EDGE_REF_TRIGGER_LEVEL
        /// NIRFSA_ATTR_TIMER_EVENT_INTERVAL
        /// NIRFSA_ATTR_FREQUENCY_SETTLING
        /// 
        ///</param>
        ///<param name = "setAsActiveList">
        /// setAsActiveList
        /// ViBoolean
        /// Sets the current list as the active configuration list when this parameter is set to TRUE. 
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int CreateConfigurationList(string listName, int numberOfListAttributes, niRFSAProperties[] listAttributeIDs, bool setAsActiveList)
        {
            int pInvokeResult = PInvoke.CreateConfigurationList(this._handle, listName, numberOfListAttributes, listAttributeIDs, setAsActiveList);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Creates a new configuration list step in the configuration list for RF list mode specified by the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST attribute. When you create a configuration list step, a new instance of each attribute specified by the configuration list is created. Configuration list attributes are specified when a configuration list is created.  
        /// Supported Devices: NI 5663E
        /// 
        /// </summary>
        ///<param name = "setAsActiveStep">
        /// setAsActiveStep
        /// ViBoolean
        /// Sets this step as the active step for the active configuration list. If you do not set this parameter, use the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST_STEP attribute to set the active step.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int CreateConfigurationListStep(bool setAsActiveStep)
        {
            int pInvokeResult = PInvoke.CreateConfigurationListStep(this._handle, setAsActiveStep);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Deletes a previously created configuration list and all the configuration list steps in the RF list mode configuration list. When a configuration list step is deleted, all the instances of the properties associated with the configuration list step are also removed.
        /// Supported Devices: NI 5663E
        /// 
        /// </summary>
        ///<param name = "listName">
        /// listName
        /// ViConstString
        /// Specifies the name of the configuration list. This string  may not contain spaces, special characters, or punctuation marks.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int DeleteConfigurationList(string listName)
        {
            int pInvokeResult = PInvoke.DeleteConfigurationList(this._handle, listName);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns user-defined information from the onboard EEPROM.
        /// Supported Devices: NI 5661/5663/5663E
        /// 
        /// </summary>
        ///<param name = "userdefinedinfo">
        /// info
        /// ViChar[]
        /// Returns the user-defined information stored in the device onboard EEPROM.
        /// 
        ///</param>
        ///<returns>
        /// Returns user-defined information from the onboard EEPROM.
        /// Supported Devices: NI 5661/5663/5663E
        /// 
        ///</returns>
        public int GetCalUserDefinedInfo(StringBuilder userdefinedinfo)
        {
            int pInvokeResult = PInvoke.GetCalUserDefinedInfo(this._handle, userdefinedinfo);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns user-defined information from the onboard EEPROM. The size of the cal user defined information is 21 characters.
        /// Supported Devices: NI 5661/5663/5663E
        /// 
        /// </summary>
        ///<param name = "infoSize">
        /// infoSize
        /// ViInt32* 
        /// Returns the number of characters of user-defined information that can be stored in the device onboard EEPROM.
        /// 
        ///</param>
        ///<returns>
        /// Returns user-defined information from the onboard EEPROM. The size of the cal user defined information is 21 characters.
        /// Supported Devices: NI 5661/5663/5663E
        /// 
        ///</returns>
        public int GetCalUserDefinedInfoMaxSize(out int infoSize)
        {
            int pInvokeResult = PInvoke.GetCalUserDefinedInfoMaxSize(this._handle, out infoSize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the date and time of the last successful external calibration. The time returned is 24-hour local time; for example, if the device was calibrated at 2:30 PM, this function returns 14 for the hours parameter and 30 for the minutes parameter.
        /// Supported Devices: NI 5600/5601 and NI 5661/5663/5663E
        /// 
        /// </summary>
        ///<param name = "year">
        /// year
        /// ViInt32*
        /// Returns the year of the last external calibration. It is expressed as an integer.
        /// 
        ///</param>
        ///<param name = "month">
        /// month
        /// ViInt32*
        /// Returns the month of the last external calibration. It is expressed as an integer. For example, December is represented as 12.
        /// 
        ///</param>
        ///<param name = "day">
        /// day
        /// ViInt32*
        /// Returns the day of the last external calibration. It is expressed as an integer.
        /// 
        ///</param>
        ///<param name = "hour">
        /// hour
        /// ViInt32*
        /// Returns the year of the last external calibration. It is expressed as an integer.
        /// 
        ///</param>
        ///<param name = "minute">
        /// minute
        /// ViInt32*
        /// Returns the minute of the last external calibration. It is expressed as an integer.
        /// 
        ///</param>
        ///<returns>
        /// Returns the date and time of the last successful external calibration. The time returned is 24-hour local time; for example, if the device was calibrated at 2:30 PM, this function returns 14 for the hours parameter and 30 for the minutes parameter.
        /// Supported Devices: NI 5600/5601 and NI 5661/5663/5663E
        /// 
        ///</returns>
        public int GetExtCalLastDateAndTime(out int year, out int month, out int day, out int hour, out int minute)
        {
            int pInvokeResult = PInvoke.GetExtCalLastDateAndTime(this._handle, out year, out month, out day, out hour, out minute);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the temperature recorded at the last successful external calibration. The temperature is returned in degrees Celsius.
        /// Supported Devices: NI 5661/5663/5663E
        /// 
        /// </summary>
        ///<param name = "temperature">
        /// temperature
        /// ViReal64*
        /// Returns the temperature of the last external calibration. It is expressed in degrees Celsius.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int GetExtCalLastTemp(out double temperature)
        {
            int pInvokeResult = PInvoke.GetExtCalLastTemp(this._handle, out temperature);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the recommended interval between external calibrations in months.
        /// Supported Devices: NI 5600/5601 and NI 5661/5663/5663E
        /// 
        /// </summary>
        ///<param name = "months">
        /// months
        /// ViInt32*
        /// Specifies the recommended maximum interval between external calibrations in months.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int GetExtCalRecommendedInterval(out int months)
        {
            int pInvokeResult = PInvoke.GetExtCalRecommendedInterval(this._handle, out months);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns coefficients for the specified channel list that you can use to convert binary data to normalized and calibrated data.
        /// The raw data of an acquisition may not perfectly map to the digitizer vertical range. The difference is due to the digitizer's internal hardware settings being set so that NI-RFSA can handle issues such as range overflow. This function returns niRFSA_coefficientInfo structures in the coefficientInfo array that provide gain and offset values that you can use normalize the data. The coefficientInfo array returns one element for each channel specified in the channelList parameter. The element order matches the order specified by the channelList parameter.
        /// To get data that maps to the digitizer vertical range, normalize the raw data from an acquisition by multiplying it by the gain value of the appropriate coefficientInfo element, then adding the offset value from the same element.
        /// Note  The coefficients are calculated by NI-RFSA for the current configuration of the device, so they are only valid for acquisitions obtained with the same device configuration.
        /// After applying the gain and offset, the normalized data is such that:
        /// The maximum possible positive binary value maps to the maximum positive value of the NIRFSA_ATTR_DIGITIZER_VERTICAL_RANGE attribute. 
        /// The maximum possible negative binary value maps to the maximum negative value of the NIRFSA_ATTR_DIGITIZER_VERTICAL_RANGE attribute. 
        /// The value of the NIRFSA_ATTR_DIGITIZER_VERTICAL_RANGE attribute. is divided evenly across the possible binary values.
        /// To get the required size of the array, call this function with bufferSize set to 0 and NULL for the coefficientInfo array. This function returns the required size in the numberOfCoefficientSets parameter.
        /// Supported Devices: NI 5663/5663E
        /// 
        /// </summary>
        ///<param name = "channelList">
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Specify 0 as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "bufferSize">
        /// bufferSize
        /// ViInt32
        /// Specifies the size of the array you specify for the coefficientInfo parameter.
        /// 
        ///</param>
        ///<param name = "coefficientInfo">
        /// coefficientInfo
        /// niRFSA_coefficientInfo[]
        /// Specifies the array for storing the coefficient info.
        /// offset is the number that should be added to the data from a peer-to-peer stream after the gain has been applied if you want to scale unscaled data.
        /// gain returns the multiplier that you should use to scale data obtained from a peer-to-peer stream.
        /// 
        ///</param>
        ///<param name = "numberofCoefficientSets">
        /// numberOfCoefficientSets
        /// ViInt32*
        /// Returns the number of valid coefficient sets. 
        /// 
        ///</param>
        ///<returns>
        /// Returns coefficients for the specified channel list that you can use to convert binary data to normalized and calibrated data.
        /// The raw data of an acquisition may not perfectly map to the digitizer vertical range. The difference is due to the digitizer's internal hardware settings being set so that NI-RFSA can handle issues such as range overflow. This function returns niRFSA_coefficientInfo structures in the coefficientInfo array that provide gain and offset values that you can use normalize the data. The coefficientInfo array returns one element for each channel specified in the channelList parameter. The element order matches the order specified by the channelList parameter.
        /// To get data that maps to the digitizer vertical range, normalize the raw data from an acquisition by multiplying it by the gain value of the appropriate coefficientInfo element, then adding the offset value from the same element.
        /// Note  The coefficients are calculated by NI-RFSA for the current configuration of the device, so they are only valid for acquisitions obtained with the same device configuration.
        /// After applying the gain and offset, the normalized data is such that:
        /// The maximum possible positive binary value maps to the maximum positive value of the NIRFSA_ATTR_DIGITIZER_VERTICAL_RANGE attribute. 
        /// The maximum possible negative binary value maps to the maximum negative value of the NIRFSA_ATTR_DIGITIZER_VERTICAL_RANGE attribute. 
        /// The value of the NIRFSA_ATTR_DIGITIZER_VERTICAL_RANGE attribute. is divided evenly across the possible binary values.
        /// To get the required size of the array, call this function with bufferSize set to 0 and NULL for the coefficientInfo array. This function returns the required size in the numberOfCoefficientSets parameter.
        /// Supported Devices: NI 5663/5663E
        /// 
        ///</returns>
        public int GetNormalizationCoefficients(string channelList, int bufferSize, out niRFSA_coefficientInfo coefficientInfo, out int numberofCoefficientSets)
        {
            int pInvokeResult = PInvoke.GetNormalizationCoefficients(this._handle, channelList, bufferSize, out coefficientInfo, out numberofCoefficientSets);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns coefficients for the specified channel list that you can use to convert unscaled data to scaled I/Q data.
        /// Data from an acquisition may be unscaled if sent by a peer-to-peer stream or fetched as unscaled data. You can use this function to obtain niRFSA_coefficientInfo structures in the coefficientInfo array that provide gain and offset values you can use scale this data into the actual I/Q values. The coefficientInfo array returns one element for each channel specified in the channelList parameter. The element order matches the order specified by the channelList parameter. To get the actual I/Q values, scale the unscaled data from an acquisition by multiplying it by the gain value of the appropriate coefficientInfo element then adding the offset from the same element.
        /// Note  The coefficients are calculated by NI-RFSA for the current configuration of the device, so they are only valid for acquisitions obtained with the same device configuration.
        /// To get the required size of the array, call this function with bufferSize set to 0 and NULL for the coefficientInfo array. This function returns the required size in the numberOfCoefficientSets parameter.
        /// Supported Devices: NI 5663/5663E
        /// 
        /// </summary>
        ///<param name = "channelList">
        /// channelList
        /// ViConstString
        /// Identifies which channels to apply settings. Specify 0 as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "arraySize">
        /// arraySize
        /// ViInt32
        /// Specifies the size of the array you specify for the coefficientInfo parameter.
        /// 
        ///</param>
        ///<param name = "coefficientInfo">
        /// coefficientInfo
        /// niRFSA_coefficientInfo[]
        /// Specifies the array for storing the coefficient info.
        /// offset is the number that should be added to the data from a peer-to-peer stream after the gain has been applied if you want to scale unscaled data.
        /// gain returns the multiplier that you should use to scale data obtained from a peer-to-peer stream.
        /// 
        ///</param>
        ///<param name = "numberOfCoefficientSets">
        /// numberOfCoefficientSets
        /// ViInt32*
        /// Returns the number of valid coefficient sets. 
        /// 
        ///</param>
        ///<returns>
        /// Returns coefficients for the specified channel list that you can use to convert unscaled data to scaled I/Q data.
        /// Data from an acquisition may be unscaled if sent by a peer-to-peer stream or fetched as unscaled data. You can use this function to obtain niRFSA_coefficientInfo structures in the coefficientInfo array that provide gain and offset values you can use scale this data into the actual I/Q values. The coefficientInfo array returns one element for each channel specified in the channelList parameter. The element order matches the order specified by the channelList parameter. To get the actual I/Q values, scale the unscaled data from an acquisition by multiplying it by the gain value of the appropriate coefficientInfo element then adding the offset from the same element.
        /// Note  The coefficients are calculated by NI-RFSA for the current configuration of the device, so they are only valid for acquisitions obtained with the same device configuration.
        /// To get the required size of the array, call this function with bufferSize set to 0 and NULL for the coefficientInfo array. This function returns the required size in the numberOfCoefficientSets parameter.
        /// Supported Devices: NI 5663/5663E
        /// 
        ///</returns>
        public int GetScalingCoefficients(string channelList, int arraySize, out niRFSA_coefficientInfo coefficientInfo, out int numberOfCoefficientSets)
        {
            int pInvokeResult = PInvoke.GetScalingCoefficients(this._handle, channelList, arraySize, out coefficientInfo, out numberOfCoefficientSets);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns a writer endpoint handle that can be used with NI-P2P to configure a peer-to-peer stream with the digitizer as an endpoint.
        /// Supported Devices: NI 5663/5663E
        /// 
        /// </summary>
        ///<param name = "streamEndpoint">
        /// streamEndpoint
        /// ViConstString
        /// Specifies the name of the stream resources you want to use.
        /// 
        ///</param>
        ///<param name = "writerHandle">
        /// writerHandle
        /// ViUInt32*
        /// Returns the writer endpoint handle which will be used with NI-P2P API to create a stream with the digitizer as an endpoint.
        /// 
        ///</param>
        ///<returns>
        /// Returns a writer endpoint handle that can be used with NI-P2P to configure a peer-to-peer stream with the digitizer as an endpoint.
        /// Supported Devices: NI 5663/5663E
        /// 
        ///</returns>
        public int GetStreamEndpointHandle(string streamEndpoint, out uint writerHandle)
        {
            int pInvokeResult = PInvoke.GetStreamEndpointHandle(this._handle, streamEndpoint, out writerHandle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Creates and initializes a special NI-RFSA external calibration session. The instrumentHandle returned is an NI-RFSA session that can be used to configure the device using normal attributes and functions. However, flags have been set that allow you to program an external calibration procedure using the special calibration attributes and functions.
        /// Supported Devices: NI 5601
        /// 
        /// </summary>
        ///<param name = "resourceName">
        ///<table><tr><td>
        /// resourceName
        /// ViRsrc
        /// Specifies the resource name of the device to initialize.
        /// Example #
        /// Device Type
        /// Syntax
        /// 1
        /// myDAQmxDevice
        /// NI-DAQmx device, device name =
        ///                &#34;myDAQmxDevice&#34;
        /// 2
        /// myLogicalName
        /// IVI logical name, name =
        ///                   &#34;myLogicalName&#34;
        /// For NI-DAQmx devices, the syntax is the device name specified in MAX, as shown in
        ///             Example 1. Typical default names for NI-DAQmx devices in MAX are Dev1 or PXI1Slot2. You
        ///             can rename an NI-DAQmx device by right-clicking on the name in MAX and entering a new
        ///             name. You also can pass in the name of an IVI logical name configured with the IVI
        ///             Configuration utility. For additional information, refer to the Installed Devices&#187;IVI topic of the
        ///             Measurement &#38; Automation Explorer Help.
        /// Caution&#160;&#160;NI-DAQmx device names are not case-sensitive. However, IVI logical names are case-sensitive. If you use an IVI logical name, verify the name is identical to the name shown in the IVI Configuration Utility.
        /// </td>
        ///  </tr></table>
        /// 
        ///</param>
        ///<param name = "password">
        /// password
        /// ViConstString
        /// Specifies the password for opening a calibration session. The initial password is factory configured to "NI". password can be a maximum of ten alphanumeric characters.
        /// 
        ///</param>
        ///<param name = "optionstring">
        /// optionString
        /// ViConstString
        /// Sets the initial value of certain options for the session.
        /// The following options are used in this parameter.
        /// calAction:create&#08211;Use this option when starting a calibration step for the first time.
        /// calAction:append&#08211;Use this option when appending to existing calibration data.
        /// 
        ///</param>
        ///<param name = "instrumentHandle">
        /// vi
        /// ViSession
        /// Identifies your instrument session.
        /// 
        ///</param>
        ///<returns>
        /// Creates and initializes a special NI-RFSA external calibration session. The instrumentHandle returned is an NI-RFSA session that can be used to configure the device using normal attributes and functions. However, flags have been set that allow you to program an external calibration procedure using the special calibration attributes and functions.
        /// Supported Devices: NI 5601
        /// 
        ///</returns>
        public int InitExtCal(string resourceName, string password, string optionstring, out HandleRef instrumentHandle)
        {
            IntPtr handle;
            int pInvokeResult = PInvoke.InitExtCal(resourceName, password, optionstring, out handle);
            TestForError(pInvokeResult);
            instrumentHandle = new HandleRef(this, handle);
            return pInvokeResult;
        }

        /// <summary>
        /// Initializes an EEPROM-specific calibration step.
        /// Supported Devices: NI 5601
        /// 
        /// </summary>
        ///<param name = "calibrationstep">
        /// calibrationStep
        /// ViInt32
        /// Specifies the EEPROM-specific calibration step to initialize.
        /// Defined Values:
        /// NIRFSA_VAL_EXT_CAL_IF_ATTENUATION_CALIBRATION
        /// Initializes the IF attenuation calibration step.
        /// NIRFSA_VAL_EXT_CAL_IF_RESPONSE_CALIBRATION
        /// Initializes the IF response calibration step.
        /// NIRFSA_VAL_EXT_CAL_REF_LEVEL_CALIBRATION
        /// Initializes the reference level calibration step.
        /// 
        ///</param>
        ///<returns>
        /// Initializes an EEPROM-specific calibration step.
        /// Supported Devices: NI 5601
        /// 
        ///</returns>
        public int InitializeCalibrationStep(int calibrationstep)
        {
            int pInvokeResult = PInvoke.InitializeCalibrationStep(this._handle, calibrationstep);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Performs a hard reset on the device which consists of the following actions:
        /// Signal acquisition is stopped
        /// All routes are released
        /// External bidirectional terminals are tristated
        /// FPGAs are reset
        /// Hardware is configured to its default state
        /// All session attributes are reset to their default states
        /// During a device reset, routes of signals between this and other devices are released, regardless of which device created the route.
        /// On the NI 5600, if you are using PXI_CLK10, you continue to drive the clock even after a device reset.
        /// Supported Devices: NI 5600/5601 (external digitizer mode), NI 5661/5663/5663E
        /// 
        /// </summary>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int ResetDevice()
        {
            int pInvokeResult = PInvoke.ResetDevice(this._handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// niRFSA_SetCalUserDefinedInfo
        /// ViStatus _VI_FUNC niRFSA_SetCalUserDefinedInfo(ViSession vi, 
        ///    ViConstString info);
        /// Purpose
        /// Stores user-defined information in the onboard EEPROM.
        /// Supported Devices: NI 5601
        /// 
        /// </summary>
        ///<param name = "userdefinedinfo">
        /// info
        /// ViConstString
        /// Specifies the string to store in the device onboard EEPROM. This string can be up to 21 characters long.
        /// 
        ///</param>
        ///<returns>
        /// niRFSA_SetCalUserDefinedInfo
        /// ViStatus _VI_FUNC niRFSA_SetCalUserDefinedInfo(ViSession vi, 
        ///    ViConstString info);
        /// Purpose
        /// Stores user-defined information in the onboard EEPROM.
        /// Supported Devices: NI 5601
        /// 
        ///</returns>
        public int SetCalUserDefinedInfo(string userdefinedinfo)
        {
            int pInvokeResult = PInvoke.SetCalUserDefinedInfo(this._handle, userdefinedinfo);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Indicates which calibration steps contain valid calibration data. To omit the unnecessary self-calibration of steps with valid calibration data, you can pass the validSteps parameter to the stepsToOmit parameter of the niRFSA_SelfCalibrate function.
        /// Supported Devices: NI&#160;5661/5663/5663E/5665
        /// 
        /// </summary>
        ///<param name = "selfCalValid">
        /// Returns VI_TRUE if all the calibration data is valid and VI_FALSE if any of the calibration data is invalid.
        /// 
        ///</param>
        ///<param name = "validSteps">
        /// Returns valid steps.
        /// Note&#160;&#160;If two or more calibration steps are valid, this parameter returns a bitwise-OR combination of the calibration steps. For example, if both NIRFSA_VAL_SELF_CAL_IF_FLATNESS and NIRFSA_VAL_SELF_CAL_LO_SELF_CAL steps are valid, NI-RFSA returns the following string: NIRFSA_VAL_SELF_CAL_IF_FLATNESS | NIRFSA_VAL_SELF_CAL_LO_SELF_CAL    
        /// NIRFSA_VAL_SELF_CAL_GAIN_REFERENCE
        /// Indicates the Gain Reference calibration data is valid. This step measures the changes in gain since the last external calibration was run.
        ///  NIRFSA_VAL_SELF_CAL_IF_FLATNESS
        /// Indicates the IF Flatness calibration data is valid. This step measures the IF response of the entire system for each of the supported IF filters.
        ///  NIRFSA_VAL_SELF_CAL_DIGITIZER_SELF_CAL
        /// Indicates the Digitizer Self Cal calibration data is valid. This step calls for digitizer self-calibration if the digitizer is associated with the RF downconverter.
        ///   NIRFSA_VAL_SELF_CAL_LO_SELF_CAL
        /// Indicates the LO Self Cal calibration data is valid. This step calls for LO self-calibration if the LO source module is associated with the RF downconverter.
        ///  NIRFSA_VAL_SELF_CAL_PRESELECTOR_ALIGNMENT
        /// Indicates the Preselector Alignment calibration data is valid. This step generates coefficients to align the preselector across the frequency range of 3.6 GHz to 14 GHz.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_IsSelfCalValid
        /// ViStatus niRFSA_IsSelfCalValid(ViSession vi, ViBoolean* selfCalValid, ViInt64* validSteps);
        /// Purpose
        /// Indicates which calibration steps contain valid calibration data. To omit the unnecessary self-calibration of steps with valid calibration data, you can pass the validSteps parameter to the stepsToOmit parameter of the niRFSA_SelfCalibrate function.
        /// Supported Devices: NI&#160;5661/5663/5663E/5665
        /// 
        ///</returns>
        public int IsSelfCalValid(out bool selfCalValid, out long validSteps)
        {
            int pInvokeResult = PInvoke.IsSelfCalValid(Handle, out selfCalValid, out validSteps);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Initializes an EEPROM-specific external alignment step.
        /// Supported Devices: NI&#160;5605
        /// 
        /// </summary>
        ///<param name = "externalAlignmentStep">
        /// Specifies which external alignment step you want to initialize. 
        /// NIRFSA_VAL_PRESELECTOR_ALIGNMENT
        /// Initiates preselector alignment. This step generates coefficients to align the preselector across the frequency range of 3.6 GHz to 14 GHz.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_InitializeExternalAlignmentStep
        /// ViStatus niRFSA_InitializeExternalAlignmentStep(ViSession vi,
        ///    ViInt32 externalAlignmentStep);
        /// Purpose
        /// Initializes an EEPROM-specific external alignment step.
        /// Supported Devices: NI&#160;5605
        /// 
        ///</returns>
        public int InitializeExternalAlignmentStep(int externalAlignmentStep)
        {
            int pInvokeResult = PInvoke.InitializeExternalAlignmentStep(Handle, externalAlignmentStep);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Creates and initializes a special NI-RFSA external alignment session.
        ///  The ViSession returned is an NI-RFSA session that you can use to configure the device using normal attributes and functions. However, NI-RFSA sets flags that allow you to program an external alignment procedure using the external alignment attributes and functions.
        /// Supported Devices: NI&#160;5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "resourceName">
        /// Specifies the resource name of the device to initialize.
        /// Example #
        /// Device Type
        /// Syntax
        /// 1
        /// myDAQmxDevice
        /// NI-DAQmx device, device name =
        ///                &#34;myDAQmxDevice&#34;
        /// 2
        /// myLogicalName
        /// IVI logical name, name =
        ///                   &#34;myLogicalName&#34;
        /// For NI-DAQmx devices, the syntax is the device name specified in MAX, as shown in
        ///             Example 1. Typical default names for NI-DAQmx devices in MAX are Dev1 or PXI1Slot2. You
        ///             can rename an NI-DAQmx device by right-clicking the name in MAX, selecting Rename from the drop-down menu, and entering a new name. You can also pass in the name of an IVI logical name configured with the IVI
        ///             Configuration utility. For additional information, refer to the Installed Devices&#187;IVI topic of the
        ///             Measurement &#38; Automation Explorer Help.
        /// Caution&#160;&#160;NI-DAQmx device names are not case-sensitive. However, IVI logical names are case-sensitive. If you use an IVI logical name, verify the name is identical to the name shown in the IVI Configuration Utility.
        /// 
        ///</param>
        ///<param name = "optionstring">
        /// Sets the initial value of certain attributes for the session. The attributes shown in the following table are used in this parameter.
        /// Name
        /// Attribute
        /// RangeCheck
        /// NIRFSA_ATTR_RANGE_CHECK
        /// QueryInstrStatus
        /// NIRFSA_ATTR_QUERY_INSTRUMENT_STATUS
        /// Cache
        /// NIRFSA_ATTR_CACHE
        /// RecordCoercions
        /// NIRFSA_ATTR_RECORD_COERCIONS
        /// DriverSetup
        /// NIRFSA_ATTR_DRIVER_SETUP
        /// Simulate
        /// NIRFSA_ATTR_SIMULATE
        /// The format of this string is &#34;AttributeName=Value&#34;, where AttributeName is the name of the attribute and Value is the value to which the attribute will be set. To set multiple attributes, separate their assignments with a comma.
        /// 
        ///</param>
        ///<param name="instrumentHandle"></param>
        ///<returns>
        /// 
        ///niRFSA_InitializeExternalAlignment
        /// ViStatus niRFSA_InitializeExternalAlignment(ViRsrc resourceName, 
        ///    ViConstString optionString,
        ///    ViSession* vi);
        /// Purpose
        /// Creates and initializes a special NI-RFSA external alignment session.
        ///  The ViSession returned is an NI-RFSA session that you can use to configure the device using normal attributes and functions. However, NI-RFSA sets flags that allow you to program an external alignment procedure using the external alignment attributes and functions.
        /// Supported Devices: NI&#160;5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        public int InitializeExternalAlignment(string resourceName, string optionstring, out HandleRef instrumentHandle)
        {
            int pInvokeResult = PInvoke.InitializeExternalAlignment(resourceName, optionstring, out instrumentHandle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the temperature, in degrees Celsius, at the last successful self-calibration.
        /// Supported Devices:  NI 5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "selfCalibrationStep">
        /// Specifies the self-calibration step to query for the last successful self-calibration temperature data.
        /// NIRFSA_VAL_SELF_CAL_PRESELECTOR_ALIGNMENT
        /// Selects the Preselector Alignment self-calibration step.
        /// NIRFSA_VAL_SELF_CAL_GAIN_REFERENCE
        /// Selects the Gain Reference self-calibration step.
        ///  NIRFSA_VAL_SELF_CAL_IF_FLATNESS
        /// Selects the IF Flatness self-calibration step.
        ///  NIRFSA_VAL_SELF_CAL_DIGITIZER_SELF_CAL
        /// Selects the Digitizer Self Cal self-calibration step.
        ///   NIRFSA_VAL_SELF_CAL_LO_SELF_CAL
        /// Selects the LO Self Cal self-calibration step.
        /// 
        ///</param>
        ///<param name = "temperature">
        /// The temperature, in degrees Celsius, of the last self-calibration.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetSelfCalLastTemp
        /// ViStatus niRFSA_GetSelfCalLastTemp(ViSession vi,
        ///    ViInt64 selfCalibrationStep,
        ///    ViReal64* temp);
        /// Purpose
        /// Returns the temperature, in degrees Celsius, at the last successful self-calibration.
        /// Supported Devices:  NI 5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        public int GetSelfCalLastTemp(long selfCalibrationStep, out double temperature)
        {
            int pInvokeResult = PInvoke.GetSelfCalLastTemp(Handle, selfCalibrationStep, out temperature);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the date and time of the last successful self-calibration.
        /// The time returned is 24-hour local time and the date is returned as integer values. For example, if the device was calibrated at 2:30 PM on December 31, 2010, this function returns 14 for the hour parameter, 30 for the minute parameter, 12 for the month parameter, 31 for the day parameter, and 2010 for the year parameter.
        /// Supported Devices:  NI 5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "selfCalibrationStep">
        /// Specifies the self-calibration step to query for the last successful self-calibration date and time data.
        /// NIRFSA_VAL_SELF_CAL_GAIN_REFERENCE
        /// Selects the Gain Reference self-calibration step.
        ///  NIRFSA_VAL_SELF_CAL_IF_FLATNESS
        /// Selects the IF Flatness self-calibration step.
        ///  NIRFSA_VAL_SELF_CAL_DIGITIZER_SELF_CAL
        /// Selects the Digitizer Self Cal self-calibration step.
        ///   NIRFSA_VAL_SELF_CAL_LO_SELF_CAL
        /// Selects the LO Self Cal self-calibration step.
        /// NIRFSA_VAL_SELF_CAL_PRESELECTOR_ALIGNMENT
        /// Selects the Preselector Alignment self-calibration step.
        /// 
        ///</param>
        ///<param name = "year">
        /// Returns the year of the last external calibration. 
        /// 
        ///</param>
        ///<param name = "month">
        /// Returns the month of the last external calibration. 
        /// 
        ///</param>
        ///<param name = "day">
        /// Returns the day of the last external calibration. 
        /// 
        ///</param>
        ///<param name = "hour">
        /// Returns the year of the last external calibration. It is expressed as an integer.
        /// 
        ///</param>
        ///<param name = "minute">
        /// Returns the minute of the last external calibration. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetSelfCalLastDateAndTime
        /// ViStatus  niRFSA_GetSelfCalLastDateAndTime(ViSession vi, ViInt64 selfCalibrationStep,
        ///    ViInt32* year, 
        ///    ViInt32* month, 
        ///    ViInt32* day, 
        ///    ViInt32* hour, 
        ///    ViInt32* minute);
        /// Purpose
        /// Returns the date and time of the last successful self-calibration.
        /// The time returned is 24-hour local time and the date is returned as integer values. For example, if the device was calibrated at 2:30 PM on December 31, 2010, this function returns 14 for the hour parameter, 30 for the minute parameter, 12 for the month parameter, 31 for the day parameter, and 2010 for the year parameter.
        /// Supported Devices:  NI 5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        public int GetSelfCalLastDateAndTime(long selfCalibrationStep, out int year, out int month, out int day, out int hour, out int minute)
        {
            int pInvokeResult = PInvoke.GetSelfCalLastDateAndTime(Handle, selfCalibrationStep, out year, out month, out day, out hour, out minute);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns an array consisting of all the relay counts for your device. When you call this function and pass a VI_NULL pointer to the operationsCount parameter, bufferSize is populated with the number of relays on the device. When you call this function and specify a value for bufferSize that is greater than or equal to the number of relays, the operationsCount parameter returns the appropriate value.
        /// Supported Devices: NI&#160;5603/5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelList">
        /// Identifies which channels to apply settings. Specify an empty string as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "operationsCountArray">
        /// Specifies the operations count array, when used as an input. You can select VI_NULL or a pointer to a ViInt32 array. VI_NULL is the default. 
        ///   When bufferSize is greater than or equal to the number of relays, operationsCount returns the number of relay operations.
        /// 
        ///</param>
        ///<param name = "bufferSize">
        /// Functions as an input or an output. bufferSize receives or returns the number of relays that are on the device.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetRelayOperationsCount
        /// ViStatus niRFSA_GetRelayOperationsCount(ViSession vi,
        ///    ViConstString channelList,
        ///    ViInt32 operationsCount[],
        ///    ViInt32* bufferSize);
        /// Purpose
        /// Returns an array consisting of all the relay counts for your device. When you call this function and pass a VI_NULL pointer to the operationsCount parameter, bufferSize is populated with the number of relays on the device. When you call this function and specify a value for bufferSize that is greater than or equal to the number of relays, the operationsCount parameter returns the appropriate value.
        /// Supported Devices: NI&#160;5603/5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        public int GetRelayOperationsCount(string channelList, int[] operationsCountArray, out int bufferSize)
        {
            int pInvokeResult = PInvoke.GetRelayOperationsCount(Handle, channelList, operationsCountArray, out bufferSize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns the name of a relay for your device. When you call this function and pass a VI_NULL pointer to the name parameter, bufferSize is populated with the number of relays on the device. When you call this function and specify a value for bufferSize that is greater than or equal to the name of relay, the name parameter returns the appropriate value.
        /// Supported Devices: NI&#160;5603/5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelList">
        /// Identifies which channels to apply settings. Specify an empty string as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "indexofRelay">
        /// Specifies the index of the relay. 
        /// 
        ///</param>
        ///<param name = "name">
        /// Specifies the relay name, when used as an input. You can select VI_NULL or a pointer to a ViInt32 array. VI_NULL is the default.  When bufferSize is greater than or equal to the number of relays, name returns the relay name.
        /// 
        ///</param>
        ///<param name = "bufferSize">
        /// When a VI_NULL pointer is passed in for the name, bufferSize is populated with the number of relays on the device. When bufferSize equals the size of the name, the relay is identified in the name parameter.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetRelayName
        /// ViStatus niRFSA_GetRelayName(ViSession vi,
        ///    ViConstString channelList,
        ///    ViInt32 index,
        ///    ViChar name[],
        ///    ViInt32* bufferSize);
        /// Purpose
        /// Returns the name of a relay for your device. When you call this function and pass a VI_NULL pointer to the name parameter, bufferSize is populated with the number of relays on the device. When you call this function and specify a value for bufferSize that is greater than or equal to the name of relay, the name parameter returns the appropriate value.
        /// Supported Devices: NI&#160;5603/5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        public int GetRelayName(string channelList, int indexofRelay, StringBuilder name, out int bufferSize)
        {
            int pInvokeResult = PInvoke.GetRelayName(Handle, channelList, indexofRelay, name, out bufferSize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the gain reference calibration constants. 
        /// Supported Devices: NI&#160;5603/5605 (external digitizer mode), NI 5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "bufferSize">
        /// Specifies the buffer size.
        /// 
        ///</param>
        ///<param name = "gainReferenceCalConstants">
        /// Returns the gain reference calibration constants. 
        /// 
        ///</param>
        ///<param name = "numberofRefCalConstants">
        /// Specifies the number of elements in the gainReferenceCalConstants array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetGainReferenceCalBaseline
        /// ViStatus niRFSA_GetGainReferenceCalBaseline(ViSession vi, ViInt32 bufferSize, ViReal64 gainReferenceCalConstants[], ViInt32* numberOfRefCalConstants);
        /// Purpose
        /// Returns the gain reference calibration constants. 
        /// Supported Devices: NI&#160;5603/5605 (external digitizer mode), NI 5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        public int GetGainReferenceCalBaseline(int bufferSize, double[] gainReferenceCalConstants, out int numberofRefCalConstants)
        {
            int pInvokeResult = PInvoke.GetGainReferenceCalBaseline(Handle, bufferSize, gainReferenceCalConstants, out numberofRefCalConstants);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the requested response type, based on current NI-RFSA settings. The NI&#160;5661/5663/5663E/5665 automatically corrects for the IF and RF response when you set the NIRFSA_ATTR_DIGITAL_IF_EQUALIZATION_ENABLED attribute to VI_TRUE. If you are using external digitizer mode, you can use information returned from this function to correct your measurement.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelList">
        /// Identifies which channels to apply settings. Specify an empty string as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "responseType">
        /// Specifies the IF, RF, or combined (IF and RF) response of the downconverter or RF vector signal analyzer (VSA) that NI-RFSA returns. The default value is NIRFSA_VAL_DOWNCONVERTER_IF_RESPONSE.
        ///  NIRFSA_VAL_DOWNCONVERTER_IF_RESPONSE
        /// Returns the IF response of the downconverter.
        /// NIRFSA_VAL_DOWNCONVERTER_RF_RESPONSE
        /// Returns the RF response of the downconverter. This value is supported only for the NI&#160;5603/5605/5665.
        /// NIRFSA_VAL_DOWNCONVERTER_COMBINED_RESPONSE
        /// Returns the combined RF and IF response of the downconverter. The combined response is in terms of IF frequency. This value is supported only for the NI&#160;5603/5605/5665.
        /// NIRFSA_VAL_VSA_IF_RESPONSE
        /// Returns the IF response of the entire RF vector signal analyzer. This value is supported only for the NI&#160;5665.
        /// NIRFSA_VAL_VSA_COMBINED_RESPONSE
        /// Returns the combined IF and RF response of the entire RF vector signal analyzer. The combined response is in terms of IF frequency. This value is supported only for the NI&#160;5665.
        /// 
        ///</param>
        ///<param name = "bufferSize">
        /// Specifies the size of the array you specify for the frequencies, magnitudeResponse, and phaseResponse parameters.
        /// 
        ///</param>
        ///<param name = "frequencies">
        /// Returns an array containing the frequencies, in hertz (Hz), that correspond to the response data.
        /// Pass VI_NULL if you do not want to use this parameter.
        /// 
        ///</param>
        ///<param name = "magnitudeResponse">
        /// Returns an array containing the magnitude of the requested response, in decibels (dB). The magnitude response is normalized to the center frequency at each frequency in the frequencies array.
        /// Pass VI_NULL if you do not want to use this parameter.
        /// 
        ///</param>
        ///<param name = "phaseResponse">
        /// Returns an array containing the phase of the requested response, in radians. The phase response is normalized to the center frequency at each frequency entry in the frequencies array.
        /// Pass VI_NULL if you do not want to use this parameter.
        /// 
        ///</param>
        ///<param name = "numberofFrequencies">
        /// Returns the required number of elements in the frequencies array and the response arrays. If bufferSize is 0, this parameter returns the expected array size. The expected array size depends on which NI-RFSA device you use (NI&#160;5661/5663/5663E/5665) and on the current settings (NI&#160;5663/5663E/5665 only).
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetDeviceResponse
        /// ViStatus niRFSA_GetDeviceResponse(ViSession vi,
        ///    ViConstString channelList,
        ///    ViInt32 bufferSize,
        ///    ViInt32 responseType,
        ///    ViReal64 frequencies[],
        ///    ViReal64 magnitudeResponse[],
        ///    ViReal64 phaseResponse[],
        ///    ViInt32* numberOfFrequencies);
        /// Purpose
        /// Returns the requested response type, based on current NI-RFSA settings. The NI&#160;5661/5663/5663E/5665 automatically corrects for the IF and RF response when you set the NIRFSA_ATTR_DIGITAL_IF_EQUALIZATION_ENABLED attribute to VI_TRUE. If you are using external digitizer mode, you can use information returned from this function to correct your measurement.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        public int GetDeviceResponse(string channelList, int responseType, int bufferSize, double[] frequencies, double[] magnitudeResponse, double[] phaseResponse, out int numberofFrequencies)
        {
            int pInvokeResult = PInvoke.GetDeviceResponse(Handle, channelList, responseType, bufferSize, frequencies, magnitudeResponse, phaseResponse, out numberofFrequencies);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// 
		/// Enables or disables SFP session access for the specified instrument.
		/// SFP session access allows the NI-RFSA Soft Front Panel (SFP) to access a device with an existing open session and can help you debug your code. To enable session access, pass VI_TRUE to the enabled parameter. To disable session access, pass VI_FALSE to the enabled parameter.
		/// Refer to Configuring SFP Session Access in LabWindows/CVI or C for more information about SFP session access.
		/// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5644R/5645R/5646R, NI&#160;5661/5663/5663E/5665/5667, NI&#160;5693/5694
		/// 
		/// </summary>
        /// <param name="channelList"></param>
		///<param name = "enable">
		/// Enables or disables SFP session access for the specified device.
		/// VI_TRUEEnables session access.
		/// VI_FALSEDisables session access.
		/// 
		///</param>
		///<returns>
		/// 
		///niRFSA_EnableSessionAccess
		/// ViStatus niRFSA_EnableSessionAccess(ViSession vi,
		///    ViBoolean enable);
		/// Purpose
		/// Enables or disables SFP session access for the specified instrument.
		/// SFP session access allows the NI-RFSA Soft Front Panel (SFP) to access a device with an existing open session and can help you debug your code. To enable session access, pass VI_TRUE to the enabled parameter. To disable session access, pass VI_FALSE to the enabled parameter.
		/// Refer to Configuring SFP Session Access in LabWindows/CVI or C for more information about SFP session access.
		/// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5644R/5645R/5646R, NI&#160;5661/5663/5663E/5665/5667, NI&#160;5693/5694
		/// 
        ///</returns>
        public int EnableSessionAccess(string channelList, bool enable)
        {
            int pInvokeResult = PInvoke.EnableSessionAccess(Handle, channelList, enable);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        /// Stores the preselector alignment coefficients that NI-RFSA uses to compute the preselector-tuning DAC value whenever the preselector is enabled. These coefficients are based on the desired center frequency for the preselector. 
        /// Supported Devices: NI 5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "numberOfCoefficients">
        /// Specifies the length for the coefficients array.
        /// 
        ///</param>
        ///<param name = "coefficients">
        /// Specifies the coefficients in the polynomial used to map the preselector center frequency to a preselector-tuning DAC value. Enter the coefficients in the array in order of highest order coefficient first (index 0) down to lowest order coefficient last. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_ExternalAlignmentAdjustPreselector
        /// ViStatus  niRFSA_ExternalAlignmentAdjustPreselector(ViSession vi,
        ///    ViInt32 numberOfCoefficients,
        ///    ViReal64* coefficients);
        /// Purpose
        /// Stores the preselector alignment coefficients that NI-RFSA uses to compute the preselector-tuning DAC value whenever the preselector is enabled. These coefficients are based on the desired center frequency for the preselector. 
        /// Supported Devices: NI 5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        public int ExternalAlignmentAdjustPreselector(int numberOfCoefficients, double[] coefficients)
        {
            int pInvokeResult = PInvoke.ExternalAlignmentAdjustPreselector(Handle, numberOfCoefficients, coefficients);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Specifies the external calibration step to run and stores the associated constants in the device memory so that they can be compared with the computed constants at run time. A password is required to run the function.
        /// Supported Devices: NI&#160;5603/5605/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "password">
        /// Specifies the password for the calibration session. The initial password is factory configured to NI. password can be a maximum of ten alphanumeric characters.
        /// 
        ///</param>
        ///<param name = "stepToRun">
        /// Specifies the step for which constants are computed. 
        /// NIRFSA_VAL_SELF_CAL_PRESELECTOR_ALIGNMENT
        /// Calls for preselector alignment.
        /// NIRFSA_VAL_SELF_CAL_GAIN_REFERENCE
        /// Measures the changes in gain since the last external calibration was run.
        ///  NIRFSA_VAL_SELF_CAL_IF_FLATNESS
        /// Measures the IF response of the entire system for each of the supported IF filters.
        ///  NIRFSA_VAL_SELF_CAL_DIGITIZER_SELF_CAL
        /// Calls for digitizer self-calibration, if the digitizer is associated with the RF downconverter.
        ///   NIRFSA_VAL_SELF_CAL_LO_SELF_CALL
        /// Calls for LO self-calibration, if the LO source module is associated with the RF downconverter.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_ExtCalStoreBaselineForSelfCalibration
        /// ViStatus niRFSA_ExtCalStoreBaselineForSelfCalibration(ViSession vi, ViConstString password, ViReal64 stepToRun);
        /// Purpose
        /// Specifies the external calibration step to run and stores the associated constants in the device memory so that they can be compared with the computed constants at run time. A password is required to run the function.
        /// Supported Devices: NI&#160;5603/5605/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        public int ExtCalStoreBaselineForSelfCalibration(string password, long stepToRun)
        {
            int pInvokeResult = PInvoke.ExtCalStoreBaselineForSelfCalibration(Handle, password, stepToRun);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Closes an EEPROM-specific external alignment step.
        /// Supported Devices: NI&#160;5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<returns>
        /// 
        ///niRFSA_CloseExternalAlignmentStep
        /// ViStatus  niRFSA_CloseExternalAlignmentStep(ViSession vi);
        /// Purpose
        /// Closes an EEPROM-specific external alignment step.
        /// Supported Devices: NI&#160;5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        public int CloseExternalAlignmentStep()
        {
            int pInvokeResult = PInvoke.CloseExternalAlignmentStep(Handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Records measured gain information that is gathered during the Reference Level Calibration step and IF Attenuation Calibration step.
        /// This function internally queries the attributes you set, and you must set and commit the following attributes prior to calling this function.
        /// NIRFSA_ATTR_CAL_RF_ELECTRONIC_ATTENUATION_INDEX (This attribute is required only when the NIRFSA_ATTR_CAL_RF_PATH_SELECTION attribute is set to NIRFSA_VAL_EXT_CAL_RF_BAND_1.)
        /// NIRFSA_ATTR_CAL_RF_MECHANICAL_ATTENUATION_INDEX
        /// NIRFSA_ATTR_CAL_IF_ATTENUATION_TABLE_SELECTION
        /// NIRFSA_ATTR_CAL_IF_ATTENUATION_INDEX
        /// NIRFSA_ATTR_CAL_IF_FILTER_SELECTION
        /// NIRFSA_ATTR_CHANNEL_COUPLING
        /// NIRFSA_ATTR_RF_PREAMP_ENABLED
        /// Call this function immediately after a measurement is made and while the device under test (DUT) is still in the same state as it was during the measurement.
        /// Supported Devices: NI&#160;5603/5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelList">
        /// Identifies which channels to apply settings. Specify an empty string as the value of this parameter.
        /// 
        ///</param>
        ///<param name = "frequency">
        /// Specifies the RF frequency, in Hz, of the measurement taken.
        /// 
        ///</param>
        ///<param name = "gain">
        /// Specifies the gain measurement, in dB.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_CalAdjustDownconverterGain
        /// ViStatus  niRFSA_CalAdjustDownconverterGain(ViSession vi,
        ///    ViConstString channelList,
        ///    ViReal64 frequency,
        ///    ViReal64 gain);
        /// Purpose
        /// Records measured gain information that is gathered during the Reference Level Calibration step and IF Attenuation Calibration step.
        /// This function internally queries the attributes you set, and you must set and commit the following attributes prior to calling this function.
        /// NIRFSA_ATTR_CAL_RF_ELECTRONIC_ATTENUATION_INDEX (This attribute is required only when the NIRFSA_ATTR_CAL_RF_PATH_SELECTION attribute is set to NIRFSA_VAL_EXT_CAL_RF_BAND_1.)
        /// NIRFSA_ATTR_CAL_RF_MECHANICAL_ATTENUATION_INDEX
        /// NIRFSA_ATTR_CAL_IF_ATTENUATION_TABLE_SELECTION
        /// NIRFSA_ATTR_CAL_IF_ATTENUATION_INDEX
        /// NIRFSA_ATTR_CAL_IF_FILTER_SELECTION
        /// NIRFSA_ATTR_CHANNEL_COUPLING
        /// NIRFSA_ATTR_RF_PREAMP_ENABLED
        /// Call this function immediately after a measurement is made and while the device under test (DUT) is still in the same state as it was during the measurement.
        /// Supported Devices: NI&#160;5603/5605
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("Use CalAdjustDeviceGain instead")]
        public int CalAdjustDownconverterGain(string channelList, double frequency, double gain)
        {
            int pInvokeResult = PInvoke.CalAdjustDownconverterGain(Handle, channelList, frequency, gain);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
		/// Self-calibrates the modules associated with the NI RF vector signal analyzer that support self-calibration. If self-calibration is performed successfully, the new calibration constants are stored immediately in the self-calibration area of the module EEPROM. Refer to the specifications document for your device for more information about how often to self-calibrate. 
		/// For best results, NI recommends that you perform a complete self-calibration without omitting any steps. However, if the niRFSA_IsSelfCalValid function indicates that the calibration data for a specific step is still valid, you can omit that step for faster execution. 
		/// Note&#160;&#160;The IF Flatness step can take approximately 15 minutes to complete on the NI&#160;5603 and approximately 25 minutes to complete on the NI&#160;5605.
		/// Supported Devices: NI&#160;5661/5663/5663E/5665
		/// 
		/// </summary>
		///<param name = "stepsToOmit">
		/// Specifies which calibration steps to skip as part of the self-calibration process. A value of 0 specifies that no calibration steps are omitted.
		/// Note&#160;&#160;To omit two or more calibration steps, specify a bitwise-OR combination of the following constants. For example, if you wanted to omit NIRFSA_VAL_SELF_CAL_IF_FLATNESS and NIRFSA_VAL_SELF_CAL_LO_SELF_CAL, you would pass the following string to the niRFSA_SelfCalibrate function: NIRFSA_VAL_SELF_CAL_IF_FLATNESS | NIRFSA_VAL_SELF_CAL_LO_SELF_CAL   
		/// NIRFSA_VAL_SELF_CAL_GAIN_REFERENCE
		/// Omits the Gain Reference step. If you omit this step and the  niRFSA_IsSelfCalValid function indicates the calibration data for this step is invalid, the absolute accuracy of the device is not guaranteed.
		///  NIRFSA_VAL_SELF_CAL_IF_FLATNESS
		/// Omits the IF Flatness step. If you omit this step and the niRFSA_IsSelfCalValid function indicates the calibration data for this step is invalid, the IF flatness specifications are not guaranteed.
		///  NIRFSA_VAL_SELF_CAL_DIGITIZER_SELF_CAL
		/// Omits the Digitizer Self Cal step. If you omit this step and the niRFSA_IsSelfCalValid function indicates the calibration data for this step is invalid, the absolute accuracy of the device is not guaranteed.
		///   NIRFSA_VAL_SELF_CAL_LO_SELF_CAL
		/// Omits the LO Self Cal step. If you omit this step and the niRFSA_IsSelfCalValid function indicates the calibration data for this step is invalid, the LO PLL may fail to lock.
		/// NIRFSA_VAL_SELF_CAL_PRESELECTOR_ALIGNMENT
		/// Omits the Preselector Alignment step. If you omit this step and the niRFSA_IsSelfCalValid function indicates the calibration data for this step is invalid, the preselector alignment specifications are not guaranteed. 
		/// 
		///</param>
		///<returns>
		/// 
		///niRFSA_SelfCalibrate
		/// ViStatus niRFSA_SelfCalibrate(ViSession vi, 
		///    ViInt64 stepsToOmit);
		/// Purpose
		/// Self-calibrates the modules associated with the NI RF vector signal analyzer that support self-calibration. If self-calibration is performed successfully, the new calibration constants are stored immediately in the self-calibration area of the module EEPROM. Refer to the specifications document for your device for more information about how often to self-calibrate. 
		/// For best results, NI recommends that you perform a complete self-calibration without omitting any steps. However, if the niRFSA_IsSelfCalValid function indicates that the calibration data for a specific step is still valid, you can omit that step for faster execution. 
		/// Note&#160;&#160;The IF Flatness step can take approximately 15 minutes to complete on the NI&#160;5603 and approximately 25 minutes to complete on the NI&#160;5605.
		/// Supported Devices: NI&#160;5661/5663/5663E/5665
		/// 
		///</returns>
        public int SelfCalibrate(long stepsToOmit)
        {
            int pInvokeResult = PInvoke.SelfCalibrate(Handle, stepsToOmit);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        
        /// <summary>
		/// Returns the fully qualified name of the signal being queried. Signals can be triggers, clocks, or events.
		/// You can pass the terminalName parameter that is returned to the source parameter of a configure trigger function.
		/// Supported Devices: NI&#160;5663/5663E/5665
		/// 
		/// </summary>
		///<param name = "signal">
		/// Specifies the signal for which you want to query the terminal.
		/// NIRFSA_VAL_START_TRIGGER (1100)NI-RFSA returns the terminal name for the Start trigger.
		/// NIRFSA_VAL_REF_TRIGGER (702)NI-RFSA returns the terminal name for the Reference trigger.
		/// NIRFSA_VAL_ADVANCE_TRIGGER (1102)NI-RFSA returns the terminal name for the Advance trigger.
		/// NIRFSA_VAL_READY_FOR_START_EVENT (1200)NI-RFSA returns the terminal name for the Ready for Start event.
		/// NIRFSA_VAL_READY_FOR_ADVANCE_EVENT (1202)NI-RFSA returns the terminal name for the Ready for Advance event.
		/// NIRFSA_VAL_READY_FOR_REF_EVENT (1201)NI-RFSA returns the terminal name for the Ready for Reference event.
		/// NIRFSA_VAL_END_OF_RECORD_EVENT (1203)NI-RFSA returns the terminal name for the End of Record event.
		/// NIRFSA_VAL_DONE_EVENT (1204)NI-RFSA returns the terminal name for the Done event.
		/// NIRFSA_VAL_REF_CLOCK (1205)NI-RFSA does not support this option for the niRFSA_GetTerminalName function. 
		/// 
		///</param>
		///<param name = "signalIdentifier">
		/// Specifies a particular instance of a trigger. NI-RFSA does not support this parameter.
		/// 
		///</param>
		///<param name = "bufferSize">
		/// Passes the number of bytes in the ViChar buffer that you allocate for the terminalName parameter.
		/// If you pass a negative number, the function copies the value to the buffer regardless of the number of bytes in the buffer.
		/// 
		///</param>
		///<param name = "terminalName">
		/// Returns the fully qualified name of the signal being queried. For example, if you select NIRFSA_VAL_START_TRIGGER 
		///  as the signal, this parameter returns /DigitizerName/StartTrigger, where DigitizerName is the name of your associated digitizer module in MAX.
		/// 
		///</param>
		///<returns>
		/// 
		///niRFSA_GetTerminalName
		/// ViStatus niRFSA_GetTerminalName(ViSession vi, 
		///    ViInt32 signal, 
		///    ViConstString signalIdentifier, 
		///    ViInt32 bufferSize,
		///    ViChar terminalName[]);
		/// Purpose
		/// Returns the fully qualified name of the signal being queried. Signals can be triggers, clocks, or events.
		/// You can pass the terminalName parameter that is returned to the source parameter of a configure trigger function.
		/// Supported Devices: NI&#160;5663/5663E/5665
		/// 
		///</returns>
        public int GetTerminalName(int signal, string signalIdentifier, int bufferSize, StringBuilder terminalName)
        {
            int pInvokeResult = PInvoke.GetTerminalName(Handle, signal, signalIdentifier, bufferSize, terminalName);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        
        /// <summary>
		/// LO export calibration measures the NI&#160;5603/5605 LO output power level.
		///  The LO output power measurements are taken from the NI&#160;5653 module. In MIMO applications, when the LO is exported from one NI&#160;5603/5605 module to another subsequent NI&#160;5603/5605, an output power signal of approximately +7 dBm is expected on each LO connector (LO1, LO2, and LO3). This function records the LO attenuation that results in an output power of +7 dBm (or greater) on the three LO output terminals.
		/// The NI 5665 uses three LOs, but only LO1 is variable in frequency. This VI takes an array of frequencies and attenuations; however, for LO2 and LO3, this array must have only one element because these two LO sources operate only at one frequency. LO1 can have multiple values for specific frequencies.
		/// Supported Devices: NI&#160;5603/5605
		/// 
		/// </summary>
		///<param name = "channelList">
		/// Identifies which channels to apply settings. Specify 0 as the value of this parameter.
		/// 
		///</param>
		///<param name = "LONumber">
		/// Specifies the LO source to use for the LO export calibration.
		/// NIRFSA_VAL_EXT_CAL_LO1 &#160;&#160;&#160; (2200)
		/// Selects LO1, which is the 3.2&#160;GHz to 8.3&#160;GHz variable signal path.
		/// NIRFSA_VAL_EXT_CAL_LO2 &#160;&#160;&#160; (2201)
		/// Selects LO2, which is the 4&#160;GHz signal path.
		/// NIRFSA_VAL_EXT_CAL_LO3 &#160;&#160;&#160; (2202)
		/// Selects LO3, which is the 800&#160;MHz signal path.
		/// 
		///</param>
		///<param name = "numberOfFrequencyPoints">
		/// Specifies the length of the frequencies and LOAttenuation arrays.
		/// 
		///</param>
		///<param name = "frequencies">
		/// Specifies frequencies for the LO output power measurement.  The length of this array equals the numberOfFrequencyPoints parameter.
		/// 
		///</param>
		///<param name = "LOAttenuations">
		/// Specifies the attenuation value of the corresponding frequency point that results in a +7 dBm output signal on the respective LO OUT connector. The length of this array equals the numberOfFrequencyPoints parameter.
		/// 
		///</param>
		///<returns>
		/// 
		///niRFSA_CalAdjustLOExportCalibration
		/// ViStatus  niRFSA_CalAdjustLOExportCalibration(ViSession vi, 
		///    ViConstString channelList, 
		///    ViInt32 LONumber, 
		///    ViInt32 numberOfFrequencyPoints, 
		///    ViReal64* frequencyPoints, 
		///    ViReal64* LOAttenuation);
		/// Purpose
		/// LO export calibration measures the NI&#160;5603/5605 LO output power level.
		///  The LO output power measurements are taken from the NI&#160;5653 module. In MIMO applications, when the LO is exported from one NI&#160;5603/5605 module to another subsequent NI&#160;5603/5605, an output power signal of approximately +7 dBm is expected on each LO connector (LO1, LO2, and LO3). This function records the LO attenuation that results in an output power of +7 dBm (or greater) on the three LO output terminals.
		/// The NI 5665 uses three LOs, but only LO1 is variable in frequency. This VI takes an array of frequencies and attenuations; however, for LO2 and LO3, this array must have only one element because these two LO sources operate only at one frequency. LO1 can have multiple values for specific frequencies.
		/// Supported Devices: NI&#160;5603/5605
		/// 
		///</returns>
        public int CalAdjustLOExportCalibration(string channelList, int LONumber, int numberOfFrequencyPoints, double[] frequencies, double[] LOAttenuations)
        {
            int pInvokeResult = PInvoke.CalAdjustLOExportCalibration(Handle, channelList, LONumber, numberOfFrequencyPoints, frequencies, LOAttenuations);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Clears the error information associated with the session. 
		/// Supported Devices: NI&#160;5600/5661/5663/5663E/5665
		/// 
		/// </summary>
		///<returns>
		/// 
		///ClearError()
		/// ViStatus ClearError(ViSession vi);
		/// Purpose
        /// Clears the error information associated with the session. 
		/// Supported Devices: NI&#160;5600/5661/5663/5663E/5665
		/// 
		///</returns>
        public int ClearError() 
        {
            int pInvokeResult = PInvoke.ClearError(Handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        
        /// <summary>
        /// Obtains a multithread lock on the instrument session. Before doing so, this function waits until all other execution threads have released their locks on the instrument session.
        /// Other threads might have obtained a lock on this session in the following ways:
        ///   - Your application already called this function.
        ///   - A call to NI-RFSA locked the session.
        ///
        /// After the call to this function returns successfully, no other threads can access the instrument session until you call the niRFSA_UnlockSession function. Use the niRFSA_LockSession function and the niRFSA_UnlockSession function around a sequence of calls to NI-RFSA functions if you require that the NI-RFSA device retain its settings through the end of the sequence.
        /// You can safely make nested calls to the niRFSA_LockSession function within the same thread. To completely unlock the session, balance each call to the niRFSA_LockSession function with a call to the niRFSA_UnlockSession function.  
        /// If, however, you use callerHasLock in all calls to the niRFSA_LockSession function and the niRFSA_UnlockSession function within a function, the IVI Library locks the session only once within the function regardless of the number of calls you make to the niRFSA_LockSession function. 
        /// Locking the session only once allows you to call the niRFSA_UnlockSession function just once at the end of the function.
		/// Supported Devices: NI&#160;5600/5661/5663/5663E/5665
		/// 
		///</summary>
		///<param name = "callerHasLock">
		/// Keeps track of whether you obtain a lock and therefore need to unlock the session in complex functions.   
		/// Pass a reference to a local boolean variable.  In the declaration of the local variable, initialize it to false. Pass the address of the same local variable to any other calls you make to this function or the niRFSA_UnlockSession function in the same function
        /// The niRFSA_LockSession function and the niRFSA_UnlockSession function each inspect the current value and take the following actions:
        /// niRFSA_LockSession
        ///   - true:     The niRFSA_LockSession function does not lock the session again.
        ///   - false:    The niRFSA_LockSession function obtains the lock and sets the value of the parameter to true.
        /// niRFSA_UnlockSession
        ///   - true:     The niRFSA_UnlockSession function releases the lock and sets the value of the parameter to false.
        ///   - false:    The niRFSA_UnlockSession function does not attempt to unlock the session
        ///
		///</param>
		///<returns>
		/// 
		///niRFSA_LockSession
		/// ViStatus niRFSA_LockSession(ViSession vi,
		///    ViBoolean *callerHasLock);
		/// Purpose
        /// Obtains a multithread lock on the instrument session. Before doing so, this function waits until all other execution threads have released their locks on the instrument session.
        /// Other threads might have obtained a lock on this session in the following ways:
        ///   - Your application already called this function.
        ///   - A call to NI-RFSA locked the session.
        ///
        /// After the call to this function returns successfully, no other threads can access the instrument session until you call the niRFSA_UnlockSession function. Use the niRFSA_LockSession function and the niRFSA_UnlockSession function around a sequence of calls to NI-RFSA functions if you require that the NI-RFSA device retain its settings through the end of the sequence.
        /// You can safely make nested calls to the niRFSA_LockSession function within the same thread. To completely unlock the session, balance each call to the niRFSA_LockSession function with a call to the niRFSA_UnlockSession function.  
        /// If, however, you use callerHasLock in all calls to the niRFSA_LockSession function and the niRFSA_UnlockSession function within a function, the IVI Library locks the session only once within the function regardless of the number of calls you make to the niRFSA_LockSession function. 
        /// Locking the session only once allows you to call the niRFSA_UnlockSession function just once at the end of the function.
		/// Supported Devices: NI&#160;5600/5661/5663/5663E/5665
        ///
		///</returns>
        public int LockSession(ref bool callerHasLock) 
        {
            ushort callerHasLockAsUShort = System.Convert.ToUInt16(callerHasLock);
            int pInvokeResult = PInvoke.LockSession(Handle, ref callerHasLockAsUShort);
            callerHasLock = System.Convert.ToBoolean(callerHasLockAsUShort);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Releases a lock obtained on an NI-RFSA device session by calling the niRFSA_LockSession function.
        ///
		/// Supported Devices: NI&#160;5600/5661/5663/5663E/5665
		/// 
		///</summary>
		///<param name = "callerHasLock">
		/// Reference to a local boolean variable previously initialized by a call to the niRFSA_LockSession function
        /// The niRFSA_LockSession function and the niRFSA_UnlockSession function each inspect the current value and take the following actions:
        /// niRFSA_LockSession
        ///   - true:     The niRFSA_LockSession function does not lock the session again.
        ///   - false:    The niRFSA_LockSession function obtains the lock and sets the value of the parameter to true.
        /// niRFSA_UnlockSession
        ///   - true:     The niRFSA_UnlockSession function releases the lock and sets the value of the parameter to false.
        ///   - false:    The niRFSA_UnlockSession function does not attempt to unlock the session
        ///
        /// Thus, you can call the niRFSA_UnlockSession function at the end of your function regardless of whether you actually have the lock.
        ///
		///</param>
		///<returns>
		/// 
		///niRFSA_UnlockSession
		/// ViStatus niRFSA_UnlockSession(ViSession vi,
		///    ViBoolean *callerHasLock);
		/// Purpose
        /// Releases a lock obtained on an NI-RFSA device session by calling the niRFSA_LockSession function.
        ///
		/// Supported Devices: NI&#160;5600/5661/5663/5663E/5665
        ///
		///</returns>
        public int UnlockSession(ref bool callerHasLock) 
        {
            ushort callerHasLockAsUShort = System.Convert.ToUInt16(callerHasLock);
            int pInvokeResult = PInvoke.UnlockSession(Handle, ref callerHasLockAsUShort);
            callerHasLock = System.Convert.ToBoolean(callerHasLockAsUShort);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        // Added in 15.0

        /// <summary>
        /// Resets all properties to default values and specifies steps to omit during the reset process, such as signal routes.
        /// For the NI 5600, this function does not reset the PXI Clock signal that is driven by devices installed in the Star Trigger Controller Slot, also known as the System Timing Slot.
        /// By default, this function resets all properties to their default values, aborts generation, clears all routes, and resets session properties to initial values.
        /// You can specify steps to omit using the steps to omit parameter. 
        /// For example, if you specify NIRFSA_VAL_RESET_WITH_OPTIONS_ROUTES for the steps to omit parameter, this function does not release signal routes during the reset process.
        /// When routes of signals between two devices are released, they are released regardless of which device created the route.
        /// 
        /// Supported Devices:  NI 5600/5601/5603/5605/5606 (external digitizer mode), NI 5644R/5645R/5646R, NI 5661/5663/5663E/5665/5667/5668R, NI 5693/5694
        /// 
        /// </summary>
        /// <param name="stepsToOmit">
        /// Specifies a list of steps to skip during the reset process.
        /// 
        /// The default value is NIRFSA_VAL_RESET_WITH_OPTIONS_NONE, which specifies that no step is omitted during reset.
        /// 
        /// NIRFSA_VAL_RESET_WITH_OPTIONS_NONE (0) : No step is omitted during reset. 
        /// NIRFSA_VAL_RESET_WITH_OPTIONS_ROUTES (1) :  Omits the routing reset step. Routing is preserved after a reset. However, routing related properties are reset to default, and routing is released if the default properties are committed after a reset. 
        /// 
        ///  Note  NIRFSA_VAL_RESET_WITH_OPTIONS_ROUTES is not supported in external calibration or alignment sessions. 
        ///  Note  NIRFSA_VAL_RESET_WITH_OPTIONS_ROUTES is not supported for the NI 5600/5661. 
        ///  
        /// </param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition. Examine the status code from each call to an NI-RFSA function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the GetError() function. To clear the error information from NI-RFSA, call the ClearError() function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int ResetWithOptions(ulong stepsToOmit)
        {
            int pInvokeResult = PInvoke.ResetWithOptions(this._handle, stepsToOmit);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        #endregion DriverMethods

        #region DisposeMethods
        /// <summary>
        /// Closes the rfsa session and releases resources associated with that session. 
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            System.GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this._disposed == false)
            {
                //Dispose unmanaged resources
                PInvoke.close(this._handle);
                this._handle = new HandleRef(null, System.IntPtr.Zero);
            }
            // Note disposing has been done.
            this._disposed = true;
        }
        #endregion DisposeMethods

        // These set and get methods are retained for Backward compatibility reasons
        // The new method with the out argument should be used instead
        #region OldGetMethods
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetInt32(niRFSAProperties propertyId, string repeatedCapabilityOrChannel)
        {
            int val;
            this.GetInt32(propertyId, repeatedCapabilityOrChannel, out val);
            return val;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetInt32(niRFSAProperties propertyId)
        {
            return this.GetInt32(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        [Obsolete]
        public double GetDouble(niRFSAProperties propertyId, string repeatedCapabilityOrChannel)
        {
            double val;
            this.GetDouble(propertyId, repeatedCapabilityOrChannel, out val);
            return val;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        [Obsolete]
        public double GetDouble(niRFSAProperties propertyId)
        {
            return this.GetDouble(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        [Obsolete]
        public bool GetBoolean(niRFSAProperties propertyId, string repeatedCapabilityOrChannel)
        {
            bool val;
            this.GetBoolean(propertyId, repeatedCapabilityOrChannel, out val);
            return val;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        [Obsolete]
        public bool GetBoolean(niRFSAProperties propertyId)
        {
            return this.GetBoolean(propertyId, "");
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <returns></returns>
        [Obsolete]
        public string GetString(niRFSAProperties propertyId, string repeatedCapabilityOrChannel)
        {
            string val;
            this.GetString(propertyId, repeatedCapabilityOrChannel, out val);
            return val;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <returns></returns>
        [Obsolete]
        public string GetString(niRFSAProperties propertyId)
        {
            return this.GetString(propertyId, "");
        }

        #endregion OldGetMethods

        #region SetGetMethods
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetInt32(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, int val)
        {
           return TestForError(PInvoke.SetAttributeViInt32(this._handle, repeatedCapabilityOrChannel, propertyId, val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetInt32(niRFSAProperties propertyId, int val)
        {
           return this.SetInt32(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetInt32(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, out int val)
        {
           return TestForError(PInvoke.GetAttributeViInt32(this._handle, repeatedCapabilityOrChannel, propertyId, out val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetInt32(niRFSAProperties propertyId, out int val)
        {
           return this.GetInt32(propertyId, "", out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetDouble(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, double val)
        {
           return TestForError(PInvoke.SetAttributeViReal64(this._handle, repeatedCapabilityOrChannel, propertyId, val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetDouble(niRFSAProperties propertyId, double val)
        {
           return this.SetDouble(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetDouble(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, out double val)
        {
           return TestForError(PInvoke.GetAttributeViReal64(this._handle, repeatedCapabilityOrChannel, propertyId, out val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetDouble(niRFSAProperties propertyId, out double val)
        {
           return this.GetDouble(propertyId, "", out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetBoolean(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, bool val)
        {
           return TestForError(PInvoke.SetAttributeViBoolean(this._handle, repeatedCapabilityOrChannel, propertyId, System.Convert.ToUInt16(val)));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetBoolean(niRFSAProperties propertyId, bool val)
        {
           return this.SetBoolean(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetBoolean(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, out bool val)
        {
           ushort boolAsShort;
           int ret = PInvoke.GetAttributeViBoolean(this._handle, repeatedCapabilityOrChannel, propertyId, out boolAsShort);
           val = System.Convert.ToBoolean(boolAsShort);
           return TestForError(ret);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetBoolean(niRFSAProperties propertyId, out bool val)
        {
           return this.GetBoolean(propertyId, "", out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetString(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, string val)
        {
           return TestForError(PInvoke.SetAttributeViString(this._handle, repeatedCapabilityOrChannel, propertyId, val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetString(niRFSAProperties propertyId, string val)
        {
           return this.SetString(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetString(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, out string val)
        {
           System.Text.StringBuilder newVal = new System.Text.StringBuilder(512);
           int size = PInvoke.GetAttributeViString(this._handle, repeatedCapabilityOrChannel, propertyId, 512, newVal);
           int ret = 0;
           val = "";
           if ((size < 0))
           {
              return ThrowError(size);
           }
           else
           {
              if ((size > 0))
              {
                 newVal.Capacity = size;
                 ret = PInvoke.GetAttributeViString(this._handle, repeatedCapabilityOrChannel, propertyId, size, newVal);
                 val = newVal.ToString();
              }
           }
           return TestForError(ret);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetString(niRFSAProperties propertyId, out string val)
        {
           return this.GetString(propertyId, "", out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetInt64(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, Int64 val)
        {
           return TestForError(PInvoke.SetAttributeViInt64(this._handle, repeatedCapabilityOrChannel, propertyId, val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetInt64(niRFSAProperties propertyId, Int64 val)
        {
           return this.SetInt64(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetInt64(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, out Int64 val)
        {
           return TestForError(PInvoke.GetAttributeViInt64(this._handle, repeatedCapabilityOrChannel, propertyId, out val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetInt64(niRFSAProperties propertyId, out Int64 val)
        {
           return this.GetInt64(propertyId, "", out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        [Obsolete("This method is obsolete; use the override where the propertyID is the first argument")]
        public int GetInt64(string repeatedCapabilityOrChannel, niRFSAProperties propertyId, out Int64 val)
        {
           return this.GetInt64(propertyId, repeatedCapabilityOrChannel, out val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetSession(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, System.IntPtr val)
        {
           return TestForError(PInvoke.SetAttributeViSession(this._handle, repeatedCapabilityOrChannel, propertyId, val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int SetSession(niRFSAProperties propertyId, System.IntPtr val)
        {
           return SetSession(propertyId, "", val);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="repeatedCapabilityOrChannel"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetSession(niRFSAProperties propertyId, string repeatedCapabilityOrChannel, out System.IntPtr val)
        {
           return TestForError(PInvoke.GetAttributeViSession(this._handle, repeatedCapabilityOrChannel, propertyId, out val));
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="propertyId"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public int GetSession(niRFSAProperties propertyId, out System.IntPtr val)
        {
           return GetSession(propertyId, "", out val);
        }

        #endregion SetGetMethods

        #region SetGetAttributeMethods
        /// <summary>
        /// Sets the value of a ViBoolean attribute.
        /// Use this low-level function to set the values of inherent IVI attributes and instrument-specific attributes.
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI&#160;recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Pass the value to which you want to set the attribute.
        /// Note&#160;&#160;Some of the values might not be valid depending on the
        /// current state of the instrument session.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_SetAttributeViBoolean
        /// ViStatus niRFSA_SetAttributeViBoolean(ViSession vi, ViConstString channelName, ViAttr attributeId, ViBoolean value);
        /// Purpose
        /// Sets the value of a ViBoolean attribute.
        /// Use this low-level function to set the values of inherent IVI attributes and instrument-specific attributes.
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI&#160;recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use SetBoolean() instead")]
        public int SetAttributeBoolean(string channelName, niRFSAProperties attributeID, bool attributeValue)
        {
            int pInvokeResult = PInvoke.SetAttributeViBoolean(Handle, channelName, attributeID, attributeValue ? (ushort)1 : (ushort)0);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Sets the value of a ViInt32 attribute.
        /// Use this low-level function to set the values of inherent IVI attributes and instrument-specific attributes.
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel-based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Pass the value to which you want to set the attribute.
        /// Note&#160;&#160;Some of the values might not be valid depending on the
        /// current state of the instrument session.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_SetAttributeViInt32
        /// ViStatus niRFSA_SetAttributeViInt32(ViSession vi, ViConstString channelName, ViAttr attributeId, ViInt32 value);
        /// Purpose
        /// Sets the value of a ViInt32 attribute.
        /// Use this low-level function to set the values of inherent IVI attributes and instrument-specific attributes.
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use SetInt32() instead")]
        public int SetAttributeInt32(string channelName, niRFSAProperties attributeID, int attributeValue)
        {
            int pInvokeResult = PInvoke.SetAttributeViInt32(Handle, channelName, attributeID, attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Sets the value of a ViInt64 attribute.
        /// Use this low-level function to set the values of inherent IVI attributes and instrument-specific attributes. 
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Pass the value to which you want to set the attribute.
        /// Note&#160;&#160;Some of the values might not be valid depending on the
        /// current state of the instrument session.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_SetAttributeViInt64
        /// ViStatus niRFSA_SetAttributeViInt64(ViSession vi, ViConstString channelName, ViAttr attributeId, ViInt64 value);
        /// Purpose
        /// Sets the value of a ViInt64 attribute.
        /// Use this low-level function to set the values of inherent IVI attributes and instrument-specific attributes. 
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use SetInt64() instead")]
        public int SetAttributeInt64(string channelName, niRFSAProperties attributeID, long attributeValue)
        {
            int pInvokeResult = PInvoke.SetAttributeViInt64(Handle, channelName, attributeID, attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Sets the value of a ViReal64 attribute.
        /// Use this low-level function to set the values of inherent IVI attributes, and instrument-specific attributes. 
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI&#160;recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread-locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Pass the value to which you want to set the attribute.
        /// Note&#160;&#160;Some of the values might not be valid depending on the
        /// current state of the instrument session.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_SetAttributeViReal64
        /// ViStatus niRFSA_SetAttributeViReal64(ViSession vi, ViConstString channelName, ViAttr attributeId, ViReal64 value);
        /// Purpose
        /// Sets the value of a ViReal64 attribute.
        /// Use this low-level function to set the values of inherent IVI attributes, and instrument-specific attributes. 
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI&#160;recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread-locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use SetDouble() instead")]
        public int SetAttributeReal64(string channelName, niRFSAProperties attributeID, double attributeValue)
        {
            int pInvokeResult = PInvoke.SetAttributeViReal64(Handle, channelName, attributeID, attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Sets the value of a ViSession attribute.
        /// Use this low-level function to set the values of inherent IVI attributes and instrument-specific attributes.
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI&#160;recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Pass the value to which you want to set the attribute.
        /// Note&#160;&#160;Some of the values might not be valid depending on the
        /// current state of the instrument session.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_SetAttributeViSession
        /// ViStatus niRFSA_SetAttributeViSession(ViSession vi, ViConstString channelName, ViAttr attributeId, ViSession value);
        /// Purpose
        /// Sets the value of a ViSession attribute.
        /// Use this low-level function to set the values of inherent IVI attributes and instrument-specific attributes.
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI&#160;recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use SetSession() instead")]
        public int SetAttributeSession(string channelName, niRFSAProperties attributeID, IntPtr attributeValue)
        {
            int pInvokeResult = PInvoke.SetAttributeViSession(Handle, channelName, attributeID, attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Sets the value of a ViString attribute.
        /// Use this low-level function to set the values of inherent IVI attributes and instrument-specific attributes.
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI&#160;recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Pass the value to which you want to set the attribute.
        /// Note&#160;&#160;Some of the values might not be valid depending on the
        /// current state of the instrument session.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_SetAttributeViString
        /// ViStatus niRFSA_SetAttributeViString(ViSession vi, ViConstString channelName, ViAttr attributeId, ViConstString value);
        /// Purpose
        /// Sets the value of a ViString attribute.
        /// Use this low-level function to set the values of inherent IVI attributes and instrument-specific attributes.
        /// NI-RFSA contains high-level functions that set most of the instrument attributes. NI&#160;recommends you use the high-level functions as much as possible. High-level functions handle order dependencies and multithread locking for you.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use SetString() instead")]
        public int SetAttributeString(string channelName, niRFSAProperties attributeID, string attributeValue)
        {
            int pInvokeResult = PInvoke.SetAttributeViString(Handle, channelName, attributeID, attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Queries the value of a ViBoolean attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes.  
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Returns the current value of the attribute. Pass the address of a ViBoolean variable.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetAttributeViBoolean
        /// ViStatus niRFSA_GetAttributeViBoolean(ViSession vi, ViConstString channelName, ViAttr attributeId, ViBoolean *value);
        /// Purpose
        /// Queries the value of a ViBoolean attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes.  
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use GetBoolean() instead")]
        public int GetAttributeBoolean(string channelName, niRFSAProperties attributeID, out bool attributeValue)
        {
            ushort val;
            int pInvokeResult = PInvoke.GetAttributeViBoolean(Handle, channelName, attributeID, out val);
            TestForError(pInvokeResult);
            attributeValue = val == (ushort)1;
            return pInvokeResult;
        }

        /// <summary>
        /// Queries the value of a ViInt32 attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes. 
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Returns the current value of the attribute. Pass the address of a ViInt32 variable.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetAttributeViInt32
        /// ViStatus niRFSA_GetAttributeViInt32(ViSession vi, ViConstString channelName, ViAttr attributeId, ViInt32 *value);
        /// Purpose
        /// Queries the value of a ViInt32 attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes. 
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use GetInt32() instead")]
        public int GetAttributeInt32(string channelName, niRFSAProperties attributeID, out int attributeValue)
        {
            int pInvokeResult = PInvoke.GetAttributeViInt32(Handle, channelName, attributeID, out attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Queries the value of a ViInt64 attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes. 
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Returns the current value of the attribute. Pass the address of a ViInt64 variable.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetAttributeViInt64
        /// ViStatus niRFSA_GetAttributeViInt64(ViSession vi, ViConstString channelName, ViAttr attributeId, ViInt64 *value);
        /// Purpose
        /// Queries the value of a ViInt64 attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes. 
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use GetInt64() instead")]
        public int GetAttributeInt64(string channelName, niRFSAProperties attributeID, out long attributeValue)
        {
            int pInvokeResult = PInvoke.GetAttributeViInt64(Handle, channelName, attributeID, out attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Queries the value of a ViReal64 attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes. 
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Returns the current value of the attribute. Pass the address of a ViReal64 variable.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetAttributeViReal64
        /// ViStatus niRFSA_GetAttributeViReal64(ViSession vi, ViConstString channelName, ViAttr attributeId, ViReal64 *value);
        /// Purpose
        /// Queries the value of a ViReal64 attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes. 
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use GetDouble() instead")]
        public int GetAttributeReal64(string channelName, niRFSAProperties attributeID, out double attributeValue)
        {
            int pInvokeResult = PInvoke.GetAttributeViReal64(Handle, channelName, attributeID, out attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Queries the value of a ViSession attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes. 
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Returns the current value of the attribute. Pass the address of a ViSession variable.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetAttributeViSession
        /// ViStatus niRFSA_GetAttributeViSession(ViSession vi, ViConstString channelName, ViAttr attributeId, ViSession *value);
        /// Purpose
        /// Queries the value of a ViSession attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes. 
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use GetSession() instead")]
        public int GetAttributeSession(string channelName, niRFSAProperties attributeID, out IntPtr attributeValue)
        {
            int pInvokeResult = PInvoke.GetAttributeViSession(Handle, channelName, attributeID, out attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Queries the value of a ViString attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes. 
        /// You must provide a ViChar array to serve as a buffer for the value. You pass the number of bytes in the buffer as the bufferSize parameter. If the current value of the attribute, including the terminating NULL byte, is larger than the size you indicate in the bufferSize parameter, the function copies buffer size &#8211;&#160;1&#160;bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the buffer size you must pass to get the entire value. For example, if the value is &#34;123456&#34; and the buffer size is 4, the function places &#34;123&#34; into the buffer and returns 7.
        /// If you want to call this function just to get the required buffer size, you can pass 0 for bufferSize and VI_NULL for the attributeValue buffer.
        /// If you want the function to fill in the buffer regardless of the number of bytes in the value, pass a negative number for bufferSize.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        /// </summary>
        ///<param name = "channelName">
        /// Specifies the name of the channel on which to check the attribute value if the attribute is channel based. If the attribute is not channel based, set this parameter to &#34;&#34; (empty string) or VI_NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Pass the ID of an attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// The buffer in which the function returns the current value of the attribute.  The buffer must be of type ViChar and have at least as many bytes as indicated in bufferSize.
        /// If you specify 0 for the bufferSize parameter, you can pass VI_NULL for this parameter.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niRFSA_GetAttributeViString
        /// ViStatus niRFSA_GetAttributeViString(ViSession vi, ViConstString channelName, ViAttr attributeId, ViChar value[]);
        /// Purpose
        /// Queries the value of a ViString attribute.
        /// You can use this low-level function to get the values of inherent IVI attributes and instrument-specific attributes. 
        /// You must provide a ViChar array to serve as a buffer for the value. You pass the number of bytes in the buffer as the bufferSize parameter. If the current value of the attribute, including the terminating NULL byte, is larger than the size you indicate in the bufferSize parameter, the function copies buffer size &#8211;&#160;1&#160;bytes into the buffer, places an ASCII NULL byte at the end of the buffer, and returns the buffer size you must pass to get the entire value. For example, if the value is &#34;123456&#34; and the buffer size is 4, the function places &#34;123&#34; into the buffer and returns 7.
        /// If you want to call this function just to get the required buffer size, you can pass 0 for bufferSize and VI_NULL for the attributeValue buffer.
        /// If you want the function to fill in the buffer regardless of the number of bytes in the value, pass a negative number for bufferSize.
        /// Supported Devices: NI&#160;5600/5601/5603/5605 (external digitizer mode), NI&#160;5661/5663/5663E/5665
        /// if(typeof(Print_Link)=="function")  {
        /// Print_Link();
        /// }
        /// 
        ///</returns>
        [Obsolete("This method is obsolete; use GetString() instead")]
        public int GetAttributeString(string channelName, niRFSAProperties attributeID, out string attributeValue)
        {
            System.Text.StringBuilder newVal = new System.Text.StringBuilder(512);
            int size = PInvoke.GetAttributeViString(this._handle, channelName, attributeID, 512, newVal);
            if ((size < 0))
            {
                ThrowError(size);
            }
            else
            {
                if ((size > 0))
                {
                    newVal.Capacity = size;
                    int pInvokeResult = PInvoke.GetAttributeViString(this._handle, channelName, attributeID, size, newVal);
                    TestForError(pInvokeResult);
                    attributeValue = newVal.ToString();
                    return pInvokeResult;
                }
            }
            attributeValue = newVal.ToString();
            return size; 
        }

        #endregion SetGetAttributeMethods

        #region GetSetMethodsForAttributes

        #region Properties added between 2.5 and 2.9

        /// <summary>
        ///Specifies whether to enable or disable the step gain amplifier. 
        ///    Default Value: NIRFSA_VAL_STEP_GAIN_DISABLED 
        ///    Supported Devices: NI 5694         
        /// 
        /// </summary>
        public int SetStepGainEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.StepGainEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to enable or disable the step gain amplifier. 
        ///    Default Value: NIRFSA_VAL_STEP_GAIN_DISABLED 
        ///    Supported Devices: NI 5694         
        /// 
        /// </summary>
        public int GetStepGainEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.StepGainEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether the preselector is enabled on the downconverter. 
        ///    NOTE: All devices support setting this attribute to NIRFSA_VAL_PRESELECTOR_DISABLED. Only devices with a preselector support setting this attribute to NIRFSA_VAL_PRESLECTOR_ENABLED or NIRFSA_VAL_PRESELECTOR_ENABLED_WHEN_IN_SIGNAL_PATH. 
        ///    Default Value: NIRFSA_VAL_PRESELECTOR_DISABLED if the device has no preselector. 
        ///    NIRFSA_VAL_PRESELECTOR_ENABLED_WHEN_IN_SIGNAL_PATH if the device has a preselector.  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDownconvertorPreselectorEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.DownconvertorPreselectorEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether the preselector is enabled on the downconverter. 
        ///    NOTE: All devices support setting this attribute to NIRFSA_VAL_PRESELECTOR_DISABLED. Only devices with a preselector support setting this attribute to NIRFSA_VAL_PRESLECTOR_ENABLED or NIRFSA_VAL_PRESELECTOR_ENABLED_WHEN_IN_SIGNAL_PATH. 
        ///    Default Value: NIRFSA_VAL_PRESELECTOR_DISABLED if the device has no preselector. 
        ///    NIRFSA_VAL_PRESELECTOR_ENABLED_WHEN_IN_SIGNAL_PATH if the device has a preselector.  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDownconvertorPreselectorEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.DownconvertorPreselectorEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies the RF preselector filter to use. 
        ///    Default Values: 
        ///    NI 5667, NI 5693: NIRFSA_VAL_RF_PRESELECTOR_FILTER_PATH_9 
        ///    NI 5665: NIRFSA_VAL_RF_PRESELECTOR_FILTER_PATH_NONE 
        ///    Supported Devices: NI 5665/5667, NI 5693        
        /// 
        /// </summary>
        public int SetRfPreselectorFilter(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.RfPreselectorFilter, channel, value);
        }
        /// <summary>
        ///Specifies the RF preselector filter to use. 
        ///    Default Values: 
        ///    NI 5667, NI 5693: NIRFSA_VAL_RF_PRESELECTOR_FILTER_PATH_9 
        ///    NI 5665: NIRFSA_VAL_RF_PRESELECTOR_FILTER_PATH_NONE 
        ///    Supported Devices: NI 5665/5667, NI 5693        
        /// 
        /// </summary>
        
        public int GetRfPreselectorFilter(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.RfPreselectorFilter, channel, out value);
        }

        /// <summary>
        ///Specifies whether to use the low-frequency bypass path for the incoming RF signal. 
        ///    Default Value: NIRFSA_VAL_DISABLED 
        ///    Supported Devices: NI 5693, NI 5667        
        /// 
        /// </summary>
        public int SetLowFrequencyByPassEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.LowFrequencyByPassEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to use the low-frequency bypass path for the incoming RF signal. 
        ///    Default Value: NIRFSA_VAL_DISABLED 
        ///    Supported Devices: NI 5693, NI 5667        
        /// 
        /// </summary>
        public int GetLowFrequencyByPassEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.LowFrequencyByPassEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether the notch filter is enabled on the RF conditioning module. 
        ///    Default Value: NIRFSA_VAL_NOTCH_FILTER_DISABLED 
        ///    Supported Devices: NI 5661/5663/5663E/5665/5667, NI 5693        
        /// 
        /// </summary>
        public int SetNotchFilterEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.NotchFilterEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether the notch filter is enabled on the RF conditioning module. 
        ///    Default Value: NIRFSA_VAL_NOTCH_FILTER_DISABLED 
        ///    Supported Devices: NI 5661/5663/5663E/5665/5667, NI 5693        
        /// 
        /// </summary>
        public int GetNotchFilterEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.NotchFilterEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether all signal conditioning is enabled on the NI 5694. 
        ///    NOTE: If you set this attribute to NIRFSA_VAL_SIGNAL_CONDITIONING_BYPASSED,    NI-RFSA bypasses all signal conditioning, prevents any signal downconversion,    and fixes the values for NIRFSA_ATTR_DOWNCONVERTER_GAIN attribute, the    NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH attribute, and the NIRFSA_ATTR_IF_FILTER_BANDWIDTH attribute. 
        ///    Default Value: NIRFSA_VAL_SIGNAL_CONDITIONING_ENABLED 
        ///    Supported Devices:NI 5694        
        ///
        /// </summary>
        public int SetSignalConditioningEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.SignalConditioningEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether all signal conditioning is enabled on the NI 5694. 
        ///    NOTE: If you set this attribute to NIRFSA_VAL_SIGNAL_CONDITIONING_BYPASSED,    NI-RFSA bypasses all signal conditioning, prevents any signal downconversion,    and fixes the values for NIRFSA_ATTR_DOWNCONVERTER_GAIN attribute, the    NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH attribute, and the NIRFSA_ATTR_IF_FILTER_BANDWIDTH attribute. 
        ///    Default Value: NIRFSA_VAL_SIGNAL_CONDITIONING_ENABLED 
        ///    Supported Devices:NI 5694        
        ///
        /// </summary>
        public int GetSignalConditioningEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.SignalConditioningEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether downconversion to 21.4 MHz is enabled for the IF conditioning module.    The IF output frequency is 21.4 MHz when you enable this attribute, and it is 193.6 MHz    when you disable this attribute. 
        ///    NOTE: If you set the NIRFSA_ATTR_SIGNAL_CONDITIONING_ENABLED attribute to    NIRFSA_VAL_SIGNAL_CONDITIONING_BYPASSED, you cannot set the    NIRFSA_ATTR_IF_CONDITIONING_DOWN_CONVERSION_ENABLED attribute to NIRFSA_VAL_ENABLED. 
        ///    NOTE: For the NI 5661/5663/5663E/5665, the only valid value for this attribute is NIRFSA_VAL_DISABLED. 
        ///    Default Values: NIRFSA_VAL_DISABLED 
        ///    
        /// </summary>
        public int SetIfConditioningDownConversionEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.IfConditioningDownConversionEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether downconversion to 21.4 MHz is enabled for the IF conditioning module.    The IF output frequency is 21.4 MHz when you enable this attribute, and it is 193.6 MHz    when you disable this attribute. 
        ///    NOTE: If you set the NIRFSA_ATTR_SIGNAL_CONDITIONING_ENABLED attribute to    NIRFSA_VAL_SIGNAL_CONDITIONING_BYPASSED, you cannot set the    NIRFSA_ATTR_IF_CONDITIONING_DOWN_CONVERSION_ENABLED attribute to NIRFSA_VAL_ENABLED. 
        ///    NOTE: For the NI 5661/5663/5663E/5665, the only valid value for this attribute is NIRFSA_VAL_DISABLED. 
        ///    Default Values: NIRFSA_VAL_DISABLED 
        ///    
        /// </summary>
        public int GetIfConditioningDownConversionEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.IfConditioningDownConversionEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies the IF filter path bandwidth for your device configuration. 
        ///    NOTE: For composite devices, such as the NI 5663/5663E/5665/5667, the IF filter path    bandwidth includes all IF filters across the component modules of a composite device. 
        ///    NOTE: For the NI 5601 and NI 5663/5663E, set the NIRFSA_ATTR_IF_FILTER attribute to choose    the IF filter you want to use. Read the value of the NIRFSA_ATTR_IF_FILTER_BANDWIDTH attribute    to determine the IF filters used by the NI 5601 and NI 5663/5663E. 
        ///    Default Values: For spectrum acquisition types the default is greater than or    equal to the NIRFSA_ATTR_SPECTRUM_SPAN attribute. NI-RFSA chooses the default    value of the NIRFSA_ATTR_IF_FILTER_BANDWIDTH attribute to correspond to the    appropriate IF filter. For I/Q acquisition types NI-RFSA chooses the default    value corresponding to the widest IF filter possible for your equipment setup.
        ///    Supported Devices: NI 5601/5603/5605, NI 5663/5663E/5665/5667, NI 5694        
        /// 
        /// </summary>
        public int SetIfFilterBandwidth(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IfFilterBandwidth, channel, value);
        }
        /// <summary>
        ///Specifies the IF filter path bandwidth for your device configuration. 
        ///    NOTE: For composite devices, such as the NI 5663/5663E/5665/5667, the IF filter path    bandwidth includes all IF filters across the component modules of a composite device. 
        ///    NOTE: For the NI 5601 and NI 5663/5663E, set the NIRFSA_ATTR_IF_FILTER attribute to choose    the IF filter you want to use. Read the value of the NIRFSA_ATTR_IF_FILTER_BANDWIDTH attribute    to determine the IF filters used by the NI 5601 and NI 5663/5663E. 
        ///    Default Values: For spectrum acquisition types the default is greater than or    equal to the NIRFSA_ATTR_SPECTRUM_SPAN attribute. NI-RFSA chooses the default    value of the NIRFSA_ATTR_IF_FILTER_BANDWIDTH attribute to correspond to the    appropriate IF filter. For I/Q acquisition types NI-RFSA chooses the default    value corresponding to the widest IF filter possible for your equipment setup.
        ///    Supported Devices: NI 5601/5603/5605, NI 5663/5663E/5665/5667, NI 5694        
        /// 
        /// </summary>
        public int GetIfFilterBandwidth(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IfFilterBandwidth, channel, out value);
        }

        /// <summary>
        ///Specifies the center frequency in a spectrum acquisition.    An acquisition consists of a span of data surrounding    the center frequency.  The value is expressed in hertz (Hz).
        ///     NOTE: Use this attribute to tune the downconverter when using external digitizer mode. 
        ///    Units: hertz (Hz) 
        ///    Default Value: 1 GHz 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetCenterFrequency(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CenterFrequency, channel, value);
        }
        /// <summary>
        ///Specifies the center frequency in a spectrum acquisition.    An acquisition consists of a span of data surrounding    the center frequency.  The value is expressed in hertz (Hz).
        ///     NOTE: Use this attribute to tune the downconverter when using external digitizer mode. 
        ///    Units: hertz (Hz) 
        ///    Default Value: 1 GHz 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetCenterFrequency(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CenterFrequency, channel, out value);
        }

        /// <summary>
        /// Enables smooth spectrum.
        /// Default Value: Disabled
        /// </summary>
        public int SetSmoothSpectrumEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.SmoothSpectrumEnabled, channel, value);
        }
        /// <summary>
        /// Enables smooth spectrum.
        /// Default Value: Disabled
        /// </summary>
        public int GetSmoothSpectrumEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.SmoothSpectrumEnabled, channel, out value);
        }

        /// <summary>
        ///Returns the shape factor of the window used in the fast Fourier transform (FFT).    The Window Shape Factor is defined as ratio of the 60 dB to 6 dB bandwidths. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5661/5663/5663E/5665/5667        
        /// 
        /// </summary>
        public int GetFftWindowShapeFactor(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.FftWindowShapeFactor, channel, out value);
        }

        /// <summary>
        ///Returns the current temperature, in degrees Celsius, of the RF conditioning module. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5667        
        /// 
        /// </summary>
        public int GetRfConditioningTemperature(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.RfConditioningTemperature, channel, out value);
        }

        /// <summary>
        ///Returns the current temperature, in degrees Celsius, of the IF conditioning module. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5667        
        /// 
        /// </summary>
        public int GetIfConditioningTemperature(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IfConditioningTemperature, channel, out value);
        }

        /// <summary>
        ///Specifies the source for the LO to be used to down convert.
        ///    If no down conversion is required, this attribute will be ignored.   Default Value: NIRFSA_VAL_ONBOARD_STR   Supported Devices: NI 5694        
        /// 
        /// </summary>
        public int SetLoSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.LoSource, channel, value);
        }

        /// <summary>
        ///Specifies the source for the LO to be used to down convert.
        ///    If no down conversion is required, this attribute will be ignored.   Default Value: NIRFSA_VAL_ONBOARD_STR   Supported Devices: NI 5694        
        /// 
        /// </summary>
        public int GetLoSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.LoSource, channel, out value);
        }

        /// <summary>
        ///This attribute is not for customer use. 
        /// 
        /// </summary>
        [Obsolete("use ReconfigurationTriggerSource instead")]
        public int SetConfigurationListStepTriggerSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ConfigurationListStepTriggerSource, channel, value);
        }
        /// <summary>
        ///This attribute is not for customer use. 
        /// 
        /// </summary>
        [Obsolete("use ReconfigurationTriggerSource instead")]
        public int GetConfigurationListStepTriggerSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ConfigurationListStepTriggerSource, channel, out value);
        }


        /// <summary>
        ///This attribute is not for customer use. 
        /// 
        /// </summary>
        public int SetDdcRefTriggerOverride(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.DdcRefTriggerOverride, channel, value);
        }
        /// <summary>
        ///This attribute is not for customer use. 
        /// 
        /// </summary>
        public int GetDdcRefTriggerOverride(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.DdcRefTriggerOverride, channel, out value);
        }

        /// <summary>
        ///This attribute is not for customer use. 
        ///    Default Value: 0 
        /// 
        /// </summary>
        public int SetMinimumReconfigTime(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.MinimumReconfigTime, channel, value);
        }
        /// <summary>
        ///This attribute is not for customer use. 
        ///    Default Value: 0 
        /// 
        /// </summary>
        public int GetMinimumReconfigTime(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.MinimumReconfigTime, channel, out value);
        }

        /// <summary>
        /// 
        ///This attribute is not for customer use. 
        /// 
        /// </summary>
        public int SetContiguousMultiRecord(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.ContiguousMultiRecord, channel, value);
        }

        /// <summary>
        /// 
        ///This attribute is not for customer use. 
        /// 
        /// </summary>
        public int GetContiguousMultiRecord(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.ContiguousMultiRecord, channel, out value);
        }

        /// <summary>
        /// This property is not for customer use.
        /// </summary>
        public int SetTimerStartSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.TimerStartSource, channel, value);
        }
        /// <summary>
        /// This property is not for customer use.
        /// </summary>
        public int GetTimerStartSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.TimerStartSource, channel, out value);
        }

        /// <summary>
        ///This attribute is not for customer use. 
        /// 
        /// </summary>
        public int SetStartTriggerDelay(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.StartTriggerDelay, channel, value);
        }
        /// <summary>
        ///This attribute is not for customer use. 
        /// 
        /// </summary>
        public int GetStartTriggerDelay(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.StartTriggerDelay, channel, out value);
        }

        /// <summary>
        ///Specifies the location in a path where a calibration tone is injected or whether    the tone is disabled. 
        ///    Default Value: NIRFSA_VAL_CAL_TONE_DISABLED  
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int SetDownconvertorCalToneMode(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.DownconvertorCalToneMode, channel, value);
        }
        /// <summary>
        ///Specifies the location in a path where a calibration tone is injected or whether    the tone is disabled. 
        ///    Default Value: NIRFSA_VAL_CAL_TONE_DISABLED  
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int GetDownconvertorCalToneMode(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.DownconvertorCalToneMode, channel, out value);
        }


        /// <summary>
        ///Specifies the frequency of the calibration tone, in hertz (Hz).    Default Value: 612.5 MHz 
        ///    Supported Devices: NI 5603/5605          
        /// 
        /// </summary>
        public int SetDownconvertorCalToneFrequency(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DownconvertorCalToneFrequency, channel, value);
        }
        /// <summary>
        ///Specifies the frequency of the calibration tone, in hertz (Hz).    Default Value: 612.5 MHz 
        ///    Supported Devices: NI 5603/5605          
        /// 
        /// </summary>
        public int GetDownconvertorCalToneFrequency(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DownconvertorCalToneFrequency, channel, out value);
        }

        /// <summary>
        ///Specifies the location in a signal path where an RF preselector calibration    tone is injected or whether the tone is disabled. 
        ///    Default Value: NIRFSA_VAL_CAL_TONE_DISABLED  
        ///    Supported Devices: NI 5667, NI 5693         
        /// 
        ///
        /// </summary>
        public int SetRfPreselectorCalToneMode(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.RfPreselectorCalToneMode, channel, value);
        }
        /// <summary>
        ///Specifies the location in a signal path where an RF preselector calibration    tone is injected or whether the tone is disabled. 
        ///    Default Value: NIRFSA_VAL_CAL_TONE_DISABLED  
        ///    Supported Devices: NI 5667, NI 5693         
        /// 
        ///
        /// </summary>
        public int GetRfPreselectorCalToneMode(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.RfPreselectorCalToneMode, channel, out value);
        }

        /// <summary>
        ///Specifies the frequency of the RF preselector calibration tone, in hertz (Hz). 
        ///     Valid Values: 34.5 MHz to 7.5 GHz 
        ///    Default Value: 612.5 MHz 
        ///    Supported Devices: NI 5667, NI 5693          
        /// 
        /// 
        /// </summary>
        public int SetRfPreselectorCalToneFrequency(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.RfPreselectorCalToneFrequency, channel, value);
        }
        ///<summary>
        /// Specifies the frequency of the RF preselector calibration tone, in hertz (Hz). 
        ///     Valid Values: 34.5 MHz to 7.5 GHz 
        ///    Default Value: 612.5 MHz 
        ///    Supported Devices: NI 5667, NI 5693          
        /// </summary>
        public int GetRfPreselectorCalToneFrequency(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.RfPreselectorCalToneFrequency, channel, out value);
        }

        /// <summary>
        /// Specifies the step attenuator to engage in the calibration tone path. This property is valid only during a calibration session.
        /// Units: dB
        /// Valid Values: 2.00, 10.00
        /// Default Value: 2.00 dB
        /// 
        /// </summary>
        public int SetCalToneStepAttenuation(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalToneStepAttenuation, channel, value);
        }
        /// <summary>
        /// Specifies the step attenuator to engage in the calibration tone path. This property is valid only during a calibration session.
        /// Units: dB
        /// Valid Values: 2.00, 10.00
        /// Default Value: 2.00 dB
        /// 
        /// </summary>
        public int GetCalToneStepAttenuation(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalToneStepAttenuation, channel, out value);
        }


        /// <summary>
        ///Returns the power of a virtual signal connected to the RF IN connector on the    NI 5693 front panel when the calibration tone is enabled. 
        ///    You can enable a calibration tone for the NI 5693 by setting the    NIRFSA_ATTR_RF_PRESELECTOR_CAL_TONE_MODE attribute to    NIRFSA_VAL_CAL_TONE_LOWBAND_RF or NIRFSA_VAL_CAL_TONE_HIGHBAND_RF. 
        ///    Units: dBm 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5693          
        /// 
        /// </summary>
        public int SetCalTonePowerReferredToRfIn(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalTonePowerReferredToRfIn, channel, value);
        }
        /// <summary>
        ///Returns the power of a virtual signal connected to the RF IN connector on the    NI 5693 front panel when the calibration tone is enabled. 
        ///    You can enable a calibration tone for the NI 5693 by setting the    NIRFSA_ATTR_RF_PRESELECTOR_CAL_TONE_MODE attribute to    NIRFSA_VAL_CAL_TONE_LOWBAND_RF or NIRFSA_VAL_CAL_TONE_HIGHBAND_RF. 
        ///    Units: dBm 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5693          
        /// 
        /// </summary>
        public int GetCalTonePowerReferredToRfIn(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalTonePowerReferredToRfIn, channel, out value);
        }


        /// <summary>
        ///Specifies the connector(s) to use to acquire the signal.    To set this attribute, the NI-RFSA device must be in the    Configuration state. 
        ///    Default Value: NIRFSA_VAL_RF_IN 
        ///    Supported Devices: NI 5644R/5645R    
        /// 
        /// </summary>
        public int GetInputPort(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.InputPort, channel, out value);
        }
        /// <summary>
        ///Specifies the connector(s) to use to acquire the signal.    To set this attribute, the NI-RFSA device must be in the    Configuration state. 
        ///    Default Value: NIRFSA_VAL_RF_IN 
        ///    Supported Devices: NI 5644R/5645R    
        /// 
        /// </summary>
        public int SetInputPort(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.InputPort, channel, value);
        }

        /// <summary>
        ///Returns the power level, in dBm, expected at the LO IN terminal    when the NIRFSA_ATTR_LO_SOURCE attribute is set to NIRFSA_VAL_LO_IN_STR. 
        ///    Supported Devices: NI 5644R/5645R    
        /// 
        /// </summary>
        public int GetLoInPower(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.LoInPower, channel, out value);
        }
        /// <summary>
        ///Returns the power level, in dBm, expected at the LO IN terminal    when the NIRFSA_ATTR_LO_SOURCE attribute is set to NIRFSA_VAL_LO_IN_STR. 
        ///    Supported Devices: NI 5644R/5645R    
        /// 
        /// </summary>
        public int SetLoInPower(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.LoInPower, channel, value);
        }


        /// <summary>
        ///Specifies whether to use fractional mode for the LO PLL or not. Fractional mode    gives a finer frequency step resolution, but may result in non-harmonic spurs.    Refer to the NI PXIe-5644R Specifications or the NI PXIe-5645R Specifications    for more information about fractional mode and non harmonic spurs. 
        ///    NOTE: The NIRFSA_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute is only    applicable when using the internal LO. 
        ///    Default Value: NIRFSA_VAL_ENABLED 
        ///    Supported Devices: NI 5644R/5645R 
        /// 
        /// </summary>
        public int GetLoPllFractionalModeEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.LoPllFractionalModeEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to use fractional mode for the LO PLL or not. Fractional mode    gives a finer frequency step resolution, but may result in non-harmonic spurs.    Refer to the NI PXIe-5644R Specifications or the NI PXIe-5645R Specifications    for more information about fractional mode and non harmonic spurs. 
        ///    NOTE: The NIRFSA_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute is only    applicable when using the internal LO. 
        ///    Default Value: NIRFSA_VAL_ENABLED 
        ///    Supported Devices: NI 5644R/5645R 
        /// 
        /// </summary>
        public int SetLoPllFractionalModeEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.LoPllFractionalModeEnabled, channel, value);
        }

        /// <summary>
        ///Specifies the step size for tuning the local oscillator (LO) phase-locked loop (PLL). 
        ///    The LO frequency can only be tuned by multiples of the NIRFSA_ATTR_LO_FREQUENCY_STEP_SIZE    attribute. The LO frequency can therefore be offset from the requested    center frequency by as much as half of the NIRFSA_ATTR_LO_FREQUENCY_STEP_SIZE    attribute. This offset is corrected by digitally frequency shifting the    NIRFSA_ATTR_LO_FREQUENCY attribute to the value requested in either the    NIRFSA_ATTR_IQ_CARRIER_FREQUENCY attribute or the NIRFSA_ATTR_SPECTRUM_CENTER_FREQUENCY attribute. 
        ///    When the NIRFSA_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute is set to    NIRFSA_VAL_ENABLED, the NIRFSA_ATTR_LO_FREQUENCY_STEP_SIZE attribute can    accept any value from 50 kHz to 24 MHz. 
        ///    When the NIRFSA_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute is set to    NIRFSA_VAL_DISABLED, the NIRFSA_ATTR_LO_FREQUENCY_STEP_SIZE attribute is    coerced to 4 MHz, 5 MHz, 6 MHz, 12 MHz or 24 MHz. 
        ///    Valid Values: 50 kHz to 24 MHz 
        ///    Default Value: 200 kHz 
        ///    Supported Devices: NI 5644R/5645R      
        /// 
        /// </summary>
        public int GetLoFrequencyStepSize(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.LoFrequencyStepSize, channel, out value);
        }
        /// <summary>
        ///Specifies the step size for tuning the local oscillator (LO) phase-locked loop (PLL). 
        ///    The LO frequency can only be tuned by multiples of the NIRFSA_ATTR_LO_FREQUENCY_STEP_SIZE    attribute. The LO frequency can therefore be offset from the requested    center frequency by as much as half of the NIRFSA_ATTR_LO_FREQUENCY_STEP_SIZE    attribute. This offset is corrected by digitally frequency shifting the    NIRFSA_ATTR_LO_FREQUENCY attribute to the value requested in either the    NIRFSA_ATTR_IQ_CARRIER_FREQUENCY attribute or the NIRFSA_ATTR_SPECTRUM_CENTER_FREQUENCY attribute. 
        ///    When the NIRFSA_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute is set to    NIRFSA_VAL_ENABLED, the NIRFSA_ATTR_LO_FREQUENCY_STEP_SIZE attribute can    accept any value from 50 kHz to 24 MHz. 
        ///    When the NIRFSA_ATTR_LO_PLL_FRACTIONAL_MODE_ENABLED attribute is set to    NIRFSA_VAL_DISABLED, the NIRFSA_ATTR_LO_FREQUENCY_STEP_SIZE attribute is    coerced to 4 MHz, 5 MHz, 6 MHz, 12 MHz or 24 MHz. 
        ///    Valid Values: 50 kHz to 24 MHz 
        ///    Default Value: 200 kHz 
        ///    Supported Devices: NI 5644R/5645R      
        /// 
        /// </summary>
        public int SetLoFrequencyStepSize(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.LoFrequencyStepSize, channel, value);
        }

        /// <summary>
        ///Configures the frequency of the signal. The onboard signal    processing (OSP) will frequency shift the signal at this    frequency to baseband prior to acquiring it. 
        ///    Valid Values: -60 MHz to +60 MHz 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5644R/5645R 
        /// 
        /// </summary>
        public int GetIqInPortCarrierFrequency(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IqInPortCarrierrFrequency, channel, out value);
        }
        /// <summary>
        ///Configures the frequency of the signal. The onboard signal    processing (OSP) will frequency shift the signal at this    frequency to baseband prior to acquiring it. 
        ///    Valid Values: -60 MHz to +60 MHz 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5644R/5645R 
        /// 
        /// </summary>
        public int SetIqInPortCarrierFrequency(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IqInPortCarrierrFrequency, channel, value);
        }


        /// <summary>
        ///Configures the terminal configuration of the I/Q terminals. 
        ///    Default Value: NIRFSA_VAL_DIFFERENTIAL    
        /// 
        /// </summary>
        public int GetIqInportTerminalConfiguration(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.IqInportTerminalConfiguration, channel, out value);
        }

        /// <summary>
        ///Configures the terminal configuration of the I/Q terminals. 
        ///    Default Value: NIRFSA_VAL_DIFFERENTIAL    
        /// 
        /// </summary>
        public int SetIqInportTerminalConfiguration(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.IqInportTerminalConfiguration, channel, value);
        }


        /// <summary>
        ///Specifies the voltage range for the I/Q terminals. 
        ///    The voltage range in differential mode is configurable from 2 Vpk-pk to 0.032 Vpk-pk in    1 dB steps. In single-ended mode, valid ranges are half those for    differential. Values are always coerced up to the next valid range. 
        ///    Valid Values: 0 Vpk-pk to 2 Vpk-pk for differential terminal configuration,    0 Vpk-pk to 1 Vpk-pk for single-ended terminal configuration.
        ///    Default Value: 2 Vpk-pk 
        ///    Supported Devices: NI 5644R/5645R 
        /// 
        /// </summary>
        public int GetIqInPortVerticalRange(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IqInPortVerticalRange, channel, out value);
        }

        /// <summary>
        ///Specifies the voltage range for the I/Q terminals. 
        ///    The voltage range in differential mode is configurable from 2 Vpk-pk to 0.032 Vpk-pk in    1 dB steps. In single-ended mode, valid ranges are half those for    differential. Values are always coerced up to the next valid range. 
        ///    Valid Values: 0 Vpk-pk to 2 Vpk-pk for differential terminal configuration,    0 Vpk-pk to 1 Vpk-pk for single-ended terminal configuration.
        ///    Default Value: 2 Vpk-pk 
        ///    Supported Devices: NI 5644R/5645R 
        /// 
        /// </summary>
        public int SetIqInPortVerticalRange(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IqInPortVerticalRange, channel, value);
        }

        /// <summary>
        ///Returns the temperature of the I/Q IN circuitry on the device. 
        ///    Units: degrees C 
        ///    Supported Devices: NI 5644R/5645R         
        /// 
        /// </summary>
        public int GetIqInPortTemperature(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IqInPortTemperature, channel, out value);
        }

        /// <summary>
        ///Returns the temperature of the I/Q IN circuitry on the device. 
        ///    Units: degrees C 
        ///    Supported Devices: NI 5644R/5645R         
        /// 
        /// </summary>
        public int SetIqInPortTemperature(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IqInPortTemperature, channel, value);
        }

        /// <summary>
        /// 
        ///Specifies whether the device is the master for synchronizing the shared    Start Trigger between multiple devices. The master device distributes the    synchronized Start Trigger to all devices in the system through the    Start Trigger distribution line. 
        ///    When synchronizing the Start Trigger, one device must always be designated    as the master. When the device is configured as a master, it actively drives    the Start Trigger distribution line. When the device is configured as a slave,    set the NIRFSA_ATTR_START_TRIGGER_TYPE attribute to NIRFSA_VAL_DIGITAL_EDGE,    and the NIRFSA_ATTR_DIGITAL_EDGE_START_TRIGGER_SOURCE attribute to NIRFSA_VAL_SYNC_START_TRIGGER_STR. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Default Value: VI_FALSE 
        ///    Supported Devices: NI 5644R/5645R      
        /// 
        /// </summary>
        public int SetSyncStartTriggerMaster(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.SyncStartTriggerMaster, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies whether the device is the master for synchronizing the shared    Start Trigger between multiple devices. The master device distributes the    synchronized Start Trigger to all devices in the system through the    Start Trigger distribution line. 
        ///    When synchronizing the Start Trigger, one device must always be designated    as the master. When the device is configured as a master, it actively drives    the Start Trigger distribution line. When the device is configured as a slave,    set the NIRFSA_ATTR_START_TRIGGER_TYPE attribute to NIRFSA_VAL_DIGITAL_EDGE,    and the NIRFSA_ATTR_DIGITAL_EDGE_START_TRIGGER_SOURCE attribute to NIRFSA_VAL_SYNC_START_TRIGGER_STR. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Default Value: VI_FALSE 
        ///    Supported Devices: NI 5644R/5645R      
        /// 
        /// </summary>
        public int GetSyncStartTriggerMaster(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.SyncStartTriggerMaster, channel, out value);
        }

        /// <summary>
        /// 
        ///Specifies whether the device is the master for synchronizing the shared    Reference Trigger between multiple devices. The master device distributes    the synchronized Reference Trigger to all devices in the system through    the Reference Trigger distribution line. 
        ///    When synchronizing the Reference Trigger, one device must always be designated    as the master. When the device is configured as a master, it actively drives    the Reference Trigger distribution line. When the device is configured as a    slave, set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to NIRFSA_VAL_DIGITAL_EDGE,    and the NIRFSA_ATTR_DIGITAL_EDGE_REF_TRIGGER_SOURCE attribute to NIRFSA_VAL_SYNC_REF_TRIGGER_STR. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Default Value: VI_FALSE 
        ///    Supported Devices: NI 5644R/5645R      
        /// 
        /// </summary>
        public int SetSyncRefTriggerMaster(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.SyncRefTriggerMaster, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies whether the device is the master for synchronizing the shared    Reference Trigger between multiple devices. The master device distributes    the synchronized Reference Trigger to all devices in the system through    the Reference Trigger distribution line. 
        ///    When synchronizing the Reference Trigger, one device must always be designated    as the master. When the device is configured as a master, it actively drives    the Reference Trigger distribution line. When the device is configured as a    slave, set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to NIRFSA_VAL_DIGITAL_EDGE,    and the NIRFSA_ATTR_DIGITAL_EDGE_REF_TRIGGER_SOURCE attribute to NIRFSA_VAL_SYNC_REF_TRIGGER_STR. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Default Value: VI_FALSE 
        ///    Supported Devices: NI 5644R/5645R      
        /// 
        /// </summary>
        public int GetSyncRefTriggerMaster(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.SyncRefTriggerMaster, channel, out value);
        }

        /// <summary>
        /// 
        ///Specifies which external trigger line distributes the synchronized Start    Trigger signal. When synchronizing the Start Trigger, configure all    devices to use the same Start Trigger distribution line. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Valid Values: PXI_Trig0, PXI_Trig1, PXI_Trig2, PXI_Trig3, PXI_Trig4,    PXI_Trig5, PXI_Trig6, PXI_Trig7, PFI0 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetSyncStartTriggerDistLine(string channel, string value)
        {
            return this.SetString(niRFSAProperties.SyncStartTriggerDistLine, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies which external trigger line distributes the synchronized Start    Trigger signal. When synchronizing the Start Trigger, configure all    devices to use the same Start Trigger distribution line. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Valid Values: PXI_Trig0, PXI_Trig1, PXI_Trig2, PXI_Trig3, PXI_Trig4,    PXI_Trig5, PXI_Trig6, PXI_Trig7, PFI0 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetSyncStartTriggerDistLine(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.SyncStartTriggerDistLine, channel, out value);
        }

        /// <summary>
        /// 
        ///Specifies which external trigger line distributes the synchronized    Reference Trigger signal. When synchronizing the Reference Trigger,    configure all devices to use the same Reference Trigger distribution line. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Valid Values: PXI_Trig0, PXI_Trig1, PXI_Trig2, PXI_Trig3, PXI_Trig4,    PXI_Trig5, PXI_Trig6, PXI_Trig7, PFI0 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetSyncRefTriggerDistLine(string channel, string value)
        {
            return this.SetString(niRFSAProperties.SyncRefTriggerDistLine, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies which external trigger line distributes the synchronized    Reference Trigger signal. When synchronizing the Reference Trigger,    configure all devices to use the same Reference Trigger distribution line. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Valid Values: PXI_Trig0, PXI_Trig1, PXI_Trig2, PXI_Trig3, PXI_Trig4,    PXI_Trig5, PXI_Trig6, PXI_Trig7, PFI0 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetSyncRefTriggerDistLine(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.SyncRefTriggerDistLine, channel, out value);
        }

        /// <summary>
        /// 
        ///Specifies whether the Reference Trigger is delayed with the data. Set this    attribute to NIRFSA_VAL_DISABLED when the NIRFSA_ATTR_REF_TRIGGER_TYPE    attribute is set to NIRFSA_VAL_IQ_POWER_EDGE or NIRFSA_VAL_IQ_ANALOG_EDGE. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Default Value: NIRFSA_VAL_DISABLED 
        ///    Supported Devices: NI 5644R/5645R 
        /// 
        /// </summary>
        public int SetSyncRefTriggerDelayEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.SyncRefTriggerDelayEnabled, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies whether the Reference Trigger is delayed with the data. Set this    attribute to NIRFSA_VAL_DISABLED when the NIRFSA_ATTR_REF_TRIGGER_TYPE    attribute is set to NIRFSA_VAL_IQ_POWER_EDGE or NIRFSA_VAL_IQ_ANALOG_EDGE. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Default Value: NIRFSA_VAL_DISABLED 
        ///    Supported Devices: NI 5644R/5645R 
        /// 
        /// </summary>
        public int GetSyncRefTriggerDelayEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.SyncRefTriggerDelayEnabled, channel, out value);
        }

        /// <summary>
        /// 
        ///Specifies whether the device is the master for synchronizing the    shared Advance Trigger between multiple devices. The master device    distributes the synchronized Advance Trigger to all devices in the    system through the Advance Trigger distribution line. 
        ///    When synchronizing the Advance Trigger, one device must always be designated    as the master. When the device is configured as a master, it actively drives    the Advance Trigger distribution line. When the device is configured as a slave,    set the NIRFSA_ATTR_ADVANCE_TRIGGER_TYPE attribute to NIRFSA_VAL_DIGITAL_EDGE,    and the NIRFSA_ATTR_DIGITAL_EDGE_ADVANCE_TRIGGER_SOURCE attribute to    NIRFSA_VAL_SYNC_ADVANCE_TRIGGER_STR. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Default Value: VI_FALSE 
        ///    Supported Devices: NI 5644R/5645R      
        /// 
        /// </summary>
        public int SetSyncAdvanceTriggerMaster(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.SyncAdvanceTriggerMaster, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies whether the device is the master for synchronizing the    shared Advance Trigger between multiple devices. The master device    distributes the synchronized Advance Trigger to all devices in the    system through the Advance Trigger distribution line. 
        ///    When synchronizing the Advance Trigger, one device must always be designated    as the master. When the device is configured as a master, it actively drives    the Advance Trigger distribution line. When the device is configured as a slave,    set the NIRFSA_ATTR_ADVANCE_TRIGGER_TYPE attribute to NIRFSA_VAL_DIGITAL_EDGE,    and the NIRFSA_ATTR_DIGITAL_EDGE_ADVANCE_TRIGGER_SOURCE attribute to    NIRFSA_VAL_SYNC_ADVANCE_TRIGGER_STR. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Default Value: VI_FALSE 
        ///    Supported Devices: NI 5644R/5645R      
        /// 
        /// </summary>
        public int GetSyncAdvanceTriggerMaster(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.SyncAdvanceTriggerMaster, channel, out value);
        }


        /// <summary>
        /// 
        ///Specifies which external trigger line distributes the synchronized Advance    Trigger signal. When synchronizing the Advance Trigger, configure all    devices to use the same Advance Trigger distribution line. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Valid Values: PXI_Trig0, PXI_Trig1, PXI_Trig2, PXI_Trig3, PXI_Trig4,    PXI_Trig5, PXI_Trig6, PXI_Trig7, PFI0 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetSyncAdvanceTriggerDistLine(string channel, string value)
        {
            return this.SetString(niRFSAProperties.SyncAdvanceTriggerDistLine, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies which external trigger line distributes the synchronized Advance    Trigger signal. When synchronizing the Advance Trigger, configure all    devices to use the same Advance Trigger distribution line. 
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your    device in the NI RF Vector Signal Analyzers Help for more information about    device synchronization for vector signal transceivers.
        ///    Valid Values: PXI_Trig0, PXI_Trig1, PXI_Trig2, PXI_Trig3, PXI_Trig4,    PXI_Trig5, PXI_Trig6, PXI_Trig7, PFI0 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetSyncAdvanceTriggerDistLine(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.SyncAdvanceTriggerDistLine, channel, out value);
        }

        /// <summary>
        /// 
        ///Specifies whether the device is the master for synchronizing the sample clock between multiple devices.
        ///    The master device distributes the sync signal to all devices in the system through the Sync Sample Clock distribution line. 
        ///    When synchronizing the Sample Clock, one device must always be designated as the master. When the device is configured as a master, it actively drives the Sync Sample Clock distribution line.
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the NI RF Vector Signal Analyzers Help for more information about device synchronization for vector signal transceivers.
        /// 
        /// </summary>
        public int SetSyncSampleClockMaster(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.SyncSampleClockMaster, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies whether the device is the master for synchronizing the sample clock between multiple devices.
        ///    The master device distributes the sync signal to all devices in the system through the Sync Sample Clock distribution line. 
        ///    When synchronizing the Sample Clock, one device must always be designated as the master. When the device is configured as a master, it actively drives the Sync Sample Clock distribution line.
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the NI RF Vector Signal Analyzers Help for more information about device synchronization for vector signal transceivers.
        /// 
        /// </summary>
        public int GetSyncSampleClockMaster(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.SyncSampleClockMaster, channel, out value);
        }

        /// <summary>
        /// 
        ///Specifies which external trigger line distributes the Sample Clock Sync signal. When synchronizing the Sample Clock, configure all devices to use the same Sync Sample Clock distribution line.
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the NI RF Vector Signal Analyzers Help for more information about device synchronization for vector signal transceivers.
        /// 
        /// </summary>
        public int SetSyncSampleClockDistLine(string channel, string value)
        {
            return this.SetString(niRFSAProperties.SyncSampleClockDistLine, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies which external trigger line distributes the Sample Clock Sync signal. When synchronizing the Sample Clock, configure all devices to use the same Sync Sample Clock distribution line.
        ///    Refer to the Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the NI RF Vector Signal Analyzers Help for more information about device synchronization for vector signal transceivers.
        /// 
        /// </summary>
        public int GetSyncSampleClockDistLine(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.SyncSampleClockDistLine, channel, out value);
        }


        /// <summary>
        /// 
        ///Specifies the channel from which the device monitors the trigger.    Use a value of I to monitor the I channel. Use a value of Q to monitor    the Q channel. Use a value of IQ to monitor both I and Q channels.    This attribute affects the device operation only when the    NIRFSA_ATTR_REF_TRIGGER_TYPE attribute is set to NIRFSA_VAL_IQ_ANALOG_EDGE. 
        ///    Valid Values: I, Q, IQ, QI 
        ///    Default Value: I 
        ///    Supported Devices: NI 5644R/5645R    
        ///
        /// </summary>
        public int SetIqAnalogEdgeRefTriggerSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.IqAnalogEdgeRefTriggerSource, channel, value);
        }

        /// <summary>
        /// 
        ///Specifies the channel from which the device monitors the trigger.    Use a value of I to monitor the I channel. Use a value of Q to monitor    the Q channel. Use a value of IQ to monitor both I and Q channels.    This attribute affects the device operation only when the    NIRFSA_ATTR_REF_TRIGGER_TYPE attribute is set to NIRFSA_VAL_IQ_ANALOG_EDGE. 
        ///    Valid Values: I, Q, IQ, QI 
        ///    Default Value: I 
        ///    Supported Devices: NI 5644R/5645R    
        ///
        /// </summary>
        public int GetIqAnalogEdgeRefTriggerSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.IqAnalogEdgeRefTriggerSource, channel, out value);
        }

        /// <summary>
        ///Specifies whether the device asserts the trigger when the voltage level is    rising or falling. When you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute    to NIRFSA_VAL_IQ_ANALOG_EDGE, the device asserts the trigger when the signal    level exceeds the specified level with the slope you specify. This attribute    affects the device operation only when the NIRFSA_ATTR_REF_TRIGGER_TYPE    attribute is set to NIRFSA_VAL_IQ_ANALOG_EDGE. 
        ///    Default Value: NIRFSA_VAL_RISING_SLOPE 
        ///    Supported Devices: NI 5644R/5645R    
        /// 
        /// </summary>
        public int SetIqAnalogEdgeRefTriggerSlope(string channel, int value)
        {
            return SetInt32(niRFSAProperties.IqAnalogEdgeRefTriggerSlope, channel, value);
        }

        /// <summary>
        ///Specifies whether the device asserts the trigger when the voltage level is    rising or falling. When you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute    to NIRFSA_VAL_IQ_ANALOG_EDGE, the device asserts the trigger when the signal    level exceeds the specified level with the slope you specify. This attribute    affects the device operation only when the NIRFSA_ATTR_REF_TRIGGER_TYPE    attribute is set to NIRFSA_VAL_IQ_ANALOG_EDGE. 
        ///    Default Value: NIRFSA_VAL_RISING_SLOPE 
        ///    Supported Devices: NI 5644R/5645R    
        /// 
        /// </summary>
        public int GetIqAnalogEdgeRefTriggerSlope(string channel, out int value)
        {
            return GetInt32(niRFSAProperties.IqAnalogEdgeRefTriggerSlope, channel, out value);
        }

        /// <summary>
        /// 
        ///Specifies the analog level, in volts, at which the device triggers.    The device asserts the trigger when the signal exceeds the level    specified by the value of this property, taking into consideration    the specified slope. This attribute affects the device operation only    when the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute is set to NIRFSA_VAL_IQ_ANALOG_EDGE. 
        ///    Default Value: 0 V 
        ///    Supported Devices: NI 5644R/5645R    
        /// 
        /// </summary>
        public int SetIqAnalogEdgeRefTriggerLevel(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IqAnalogEdgeRefTriggerLevel, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies the analog level, in volts, at which the device triggers.    The device asserts the trigger when the signal exceeds the level    specified by the value of this property, taking into consideration    the specified slope. This attribute affects the device operation only    when the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute is set to NIRFSA_VAL_IQ_ANALOG_EDGE. 
        ///    Default Value: 0 V 
        ///    Supported Devices: NI 5644R/5645R    
        /// 
        /// </summary>
        public int GetIqAnalogEdgeRefTriggerLevel(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IqAnalogEdgeRefTriggerLevel, channel, out value);
        }

        /// <summary>
        /// 
        ///Specifies the size of the hysteresis window on either side of the trigger    level. The device triggers when the signal passes through the threshold    you specify with the NIRFSA_ATTR_IQ_ANALOG_EDGE_REF_TRIGGER_LEVEL attribute,    has the slope you specify with the NIRFSA_ATTR_IQ_ANALOG_EDGE_REF_TRIGGER_SLOPE    attribute, and passes through the hysteresis window that you specify with this    attribute. This attribute affects the device operation only when the    NIRFSA_ATTR_REF_TRIGGER_TYPE attribute is set to NIRFSA_VAL_IQ_ANALOG_EDGE. 
        ///    Valid Values: 0 to (Voltage Range/2 + Trigger Level) for Rising Slope.    0 to (Voltage Range/2  Trigger Level) for Falling Slope. These values limit    the hysteresis to the entire voltage range that is below the trigger level for    Rising Slope or that is above the trigger level for Falling Slope.
        ///    Default Value: The default is calculated by the driver as (Range x 0.025). 
        ///    Supported Devices: NI 5644R/5645R 
        /// 
        /// </summary>
        public int SetIqAnalogEdgeRefTriggerHysteresis(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IqAnalogEdgeRefTriggerHysteresis, channel, value);
        }
        /// <summary>
        /// 
        ///Specifies the size of the hysteresis window on either side of the trigger    level. The device triggers when the signal passes through the threshold    you specify with the NIRFSA_ATTR_IQ_ANALOG_EDGE_REF_TRIGGER_LEVEL attribute,    has the slope you specify with the NIRFSA_ATTR_IQ_ANALOG_EDGE_REF_TRIGGER_SLOPE    attribute, and passes through the hysteresis window that you specify with this    attribute. This attribute affects the device operation only when the    NIRFSA_ATTR_REF_TRIGGER_TYPE attribute is set to NIRFSA_VAL_IQ_ANALOG_EDGE. 
        ///    Valid Values: 0 to (Voltage Range/2 + Trigger Level) for Rising Slope.    0 to (Voltage Range/2  Trigger Level) for Falling Slope. These values limit    the hysteresis to the entire voltage range that is below the trigger level for    Rising Slope or that is above the trigger level for Falling Slope.
        ///    Default Value: The default is calculated by the driver as (Range x 0.025). 
        ///    Supported Devices: NI 5644R/5645R 
        /// 
        /// </summary>
        public int GetIqAnalogEdgeRefTriggerHysteresis(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IqAnalogEdgeRefTriggerHysteresis, channel, out value);
        }

        /// <summary>
        /// 
        ///Specifies the sub-sample delay, in seconds, to apply to the    acquired signal. To set this property, the NI-RFSA device    must be in the Configuration state. 
        ///    Valid Values: -4.16 ns to +4.16 ns 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5644R/5645R    
        /// 
        /// </summary>
        public int SetDecimationDelay(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DecimationDelay, channel, value);
        }

        /// <summary>
        /// 
        ///Specifies the sub-sample delay, in seconds, to apply to the    acquired signal. To set this property, the NI-RFSA device    must be in the Configuration state. 
        ///    Valid Values: -4.16 ns to +4.16 ns 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5644R/5645R    
        /// 
        /// </summary>
        public int GetDecimationDelay(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DecimationDelay, channel, out value);
        }

        /// <summary>
        ///Specifies an offset from the I/Q carrier frequency for the downconverter.    If you set this attribute, any measurements outside the instantaneous bandwidth    of the device are invalid. After you set this attribute, the RF downconverter is    locked to that frequency offset until the value is changed or the attribute is reset. 
        ///    Valid Values: -42 MHz to +42 MHz 
        ///    Default Values: For spectrum acquisition types the driver automatically calculates    the default to avoid residual LO power. For I/Q acquisition types the default is 0 Hz.    If the center frequency is set to a non-multiple of the    NIRFSA_ATTR_SIGNAL_PATH_LO_FREQUENCY_STEP_SIZE attribute, the    NIRFSA_ATTR_DOWNCONVERTER_FREQUENCY_OFFSET attribute is set to compensate for the difference.
        ///    Supported Devices: NI 5644R/5645R      
        /// 
        /// 
        /// </summary>
        public int SetDownconvertorFrequencyOffset(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DownconvertorFrequencyOffset, channel, value);
        }
        /// <summary>
        ///Specifies an offset from the I/Q carrier frequency for the downconverter.    If you set this attribute, any measurements outside the instantaneous bandwidth    of the device are invalid. After you set this attribute, the RF downconverter is    locked to that frequency offset until the value is changed or the attribute is reset. 
        ///    Valid Values: -42 MHz to +42 MHz 
        ///    Default Values: For spectrum acquisition types the driver automatically calculates    the default to avoid residual LO power. For I/Q acquisition types the default is 0 Hz.    If the center frequency is set to a non-multiple of the    NIRFSA_ATTR_SIGNAL_PATH_LO_FREQUENCY_STEP_SIZE attribute, the    NIRFSA_ATTR_DOWNCONVERTER_FREQUENCY_OFFSET attribute is set to compensate for the difference.
        ///    Supported Devices: NI 5644R/5645R      
        /// 
        /// 
        /// </summary>
        public int GetDownconvertorFrequencyOffset(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DownconvertorFrequencyOffset, channel, out value);
        }


        /// <summary>
        /// 
        ///Returns a string containing the path to the location of the current FPGA Extensions bitfile, a .lvbitx file, that is programmed on the device. 
        ///    An FPGA Extensions bitfile controls the behavior of the FPGA. You can use a custom bitfile with the NI-RFSA instrument driver to override the default FPGA bitfile and change the default behavior of the FPGA. Before reading this property, you must specify the bitfile location using the Driver Setup keyword in the options string parameter of the niRFSA_InitWithOptions function. 
        /// 
        /// </summary>
        public int GetFpgaBitFilePath(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.FpgaBitFilePath, channel, out value);
        }

        #endregion


        /// <summary>
        ///Specifies the preselector tuning DAC value during the preselector external alignment step.    This value is valid only during a external alignment session.
        ///    Valid Values: 0 to 16,383 
        ///    Defined Values: 0 to 15.5 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5605 (external digitizer mode)         
        /// 
        /// </summary>
        public int SetPreselectorTuningDacValue5665(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.PreselectorTuningDacValue5665, channel, value);
        }
        /// <summary>
        ///Specifies the preselector tuning DAC value during the preselector external alignment step.    This value is valid only during a external alignment session.
        ///    Valid Values: 0 to 16,383 
        ///    Defined Values: 0 to 15.5 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5605 (external digitizer mode)         
        /// 
        /// </summary>
        public int GetPreselectorTuningDacValue5665(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.PreselectorTuningDacValue5665, channel, out value);
        }

        /// <summary>
        ///Configures the session to either acquire I/Q data or to compute a power    spectrum over the specified frequency range.
        ///    Default Value: NIRFSA_VAL_IQ 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetAcquisitionType(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.AcquisitionType, channel, value);
        }
        /// <summary>
        ///Configures the session to either acquire I/Q data or to compute a power    spectrum over the specified frequency range.
        ///    Default Value: NIRFSA_VAL_IQ 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetAcquisitionType(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.AcquisitionType, channel, out value);
        }

        /// <summary>
        ///Specifies the configuration list for RF list mode to make active    for configuration or initiation. 
        ///    Activating a list makes all attributes in the list reflect the value of the attributes    that correspond to the set specified by the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST and    the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST_STEP attributes. Set this attribute to an empty    string to disable RF list mode. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetActiveConfigurationList(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ActiveConfigurationList, channel, value);
        }
        /// <summary>
        ///Specifies the configuration list for RF list mode to make active    for configuration or initiation. 
        ///    Activating a list makes all attributes in the list reflect the value of the attributes    that correspond to the set specified by the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST and    the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST_STEP attributes. Set this attribute to an empty    string to disable RF list mode. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetActiveConfigurationList(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ActiveConfigurationList, channel, out value);
        }

        /// <summary>
        ///Specifies the step in the configuration list for RF list mode to make active    for configuration or initiation. 
        ///    Activating a list makes all attributes in the list reflect the value of the attributes    that correspond to the set specified by the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST and    the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST_STEP attributes. 
        ///    Default Value: 0 for devices that support RF list mode. For all other devices, the default value is N/A.
        ///    Supported Devices: NI 5663E/5665        
        /// 
        /// </summary>
        public int SetActiveConfigurationListStep(string channel, long value)
        {
            return this.SetInt64(niRFSAProperties.ActiveConfigurationListStep, channel, value);
        }
        /// <summary>
        ///Specifies the step in the configuration list for RF list mode to make active    for configuration or initiation. 
        ///    Activating a list makes all attributes in the list reflect the value of the attributes    that correspond to the set specified by the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST and    the NIRFSA_ATTR_ACTIVE_CONFIGURATION_LIST_STEP attributes. 
        ///    Default Value: 0 for devices that support RF list mode. For all other devices, the default value is N/A.
        ///    Supported Devices: NI 5663E/5665        
        /// 
        /// </summary>
        public int GetActiveConfigurationListStep(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.ActiveConfigurationListStep, channel, out value);
        }

        /// <summary>
        ///Returns the fully qualified signal name as a string. 
        ///    Default Value: /DigitizerName/AdvanceTrigger, where DigitizerName is the name associated with your digitizer module in MAX.  
        ///    Supported Devices: NI 5663/5663E/5665      	 
        /// 
        /// </summary>
        public int GetAdvanceTriggerTerminalName(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.AdvanceTriggerTerminalName, channel, out value);
        }

        /// <summary>
        ///Specifies whether you want the Advance trigger to be a digital edge or    software trigger. 
        ///    Default Value: NIRFSA_VAL_NONE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetAdvanceTriggerType(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.AdvanceTriggerType, channel, value);
        }
        /// <summary>
        ///Specifies whether you want the Advance trigger to be a digital edge or    software trigger. 
        ///    Default Value: NIRFSA_VAL_NONE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetAdvanceTriggerType(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.AdvanceTriggerType, channel, out value);
        }

        /// <summary>
        ///Specifies whether to allow the device to acquire more records than will fit in the device memory of the NI 5622. 
        ///      NOTE: If you set the attribute to FALSE and attempt to acquire more records than fit into the device memory of the NI 5622,    NI-RFSA returns an error. If this attribute is set to TRUE, NI-RFSA returns an error only in the event of an acquisition buffer overflow.
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetAllowMoreRecordsThanMemory(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.AllowMoreRecordsThanMemory, channel, value);
        }
        /// <summary>
        ///Specifies whether to allow the device to acquire more records than will fit in the device memory of the NI 5622. 
        ///      NOTE: If you set the attribute to FALSE and attempt to acquire more records than fit into the device memory of the NI 5622,    NI-RFSA returns an error. If this attribute is set to TRUE, NI-RFSA returns an error only in the event of an acquisition buffer overflow.
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetAllowMoreRecordsThanMemory(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.AllowMoreRecordsThanMemory, channel, out value);
        }


        /// <summary>
        ///Specifies whether you want the Arm Reference trigger to be a digital edge or software trigger. 
        ///    Default Value: NIRFSA_VAL_NONE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetArmRefTriggerType(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.ArmRefTriggerType, channel, value);
        }
        /// <summary>
        ///Specifies whether you want the Arm Reference trigger to be a digital edge or software trigger. 
        ///    Default Value: NIRFSA_VAL_NONE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetArmRefTriggerType(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.ArmRefTriggerType, channel, out value);
        }

        /// <summary>
        ///Specifies the downconverter module attenuation setting, in dB. NI-RFSA automatically chooses    an attenuation setting for the reference level you configure.
        ///    NI 5600/5661-You can change the attenuation value to modify the amount of noise and distortion.    Higher attenuation levels increase the noise level while decreasing distortion; lower    attenuation levels    decrease the noise level while increasing distortion.
        ///    NI 5601/5663/5663E-You can change the attenuation value     to modify the amount of noise and distortion. Higher attenuation    levels increase the noise level while decreasing distortion; lower attenuation levels    decrease the noise    level while increasing distortion.
        ///    NI 5603/5605/5665-You can set multiple attributes to modify the attenuation values for the device.    Refer to NI 5665 RF Attenuation and Signal Levels for more information about    configuring attenuation. 
        ///     Units: dB 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetAttenuation(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.Attenuation, channel, value);
        }
        /// <summary>
        ///Specifies the downconverter module attenuation setting, in dB. NI-RFSA automatically chooses    an attenuation setting for the reference level you configure.
        ///    NI 5600/5661-You can change the attenuation value to modify the amount of noise and distortion.    Higher attenuation levels increase the noise level while decreasing distortion; lower    attenuation levels    decrease the noise level while increasing distortion.
        ///    NI 5601/5663/5663E-You can change the attenuation value     to modify the amount of noise and distortion. Higher attenuation    levels increase the noise level while decreasing distortion; lower attenuation levels    decrease the noise    level while increasing distortion.
        ///    NI 5603/5605/5665-You can set multiple attributes to modify the attenuation values for the device.    Refer to NI 5665 RF Attenuation and Signal Levels for more information about    configuring attenuation. 
        ///     Units: dB 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetAttenuation(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.Attenuation, channel, out value);
        }

        /// <summary>
        ///Specifies whether to cache the value of attributes. If you set this attribute to VI_TRUE,    NI-RFSA tracks the current NI-RFSA device settings and avoids sending redundant commands    to the device. 
        ///    NI-RFSA can always cache or never cache    particular attributes, regardless of the setting of this attribute.
        ///    Use the niRFSA_InitWithOptions function to override the default value.
        ///    Default Value: VI_TRUE  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665         
        /// 
        /// </summary>
        public int SetCache(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.Cache, channel, value);
        }
        /// <summary>
        ///Specifies whether to cache the value of attributes. If you set this attribute to VI_TRUE,    NI-RFSA tracks the current NI-RFSA device settings and avoids sending redundant commands    to the device. 
        ///    NI-RFSA can always cache or never cache    particular attributes, regardless of the setting of this attribute.
        ///    Use the niRFSA_InitWithOptions function to override the default value.
        ///    Default Value: VI_TRUE  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665         
        /// 
        /// </summary>
        public int GetCache(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.Cache, channel, out value);
        }

        /// <summary>
        ///Overrides the internal gain self-calibration correction for the 300 kHz IF filter path. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int SetCalibrationCorrection300KhzFilter(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalibrationCorrection300KhzFilter, channel, value);
        }
        /// <summary>
        ///Overrides the internal gain self-calibration correction for the 300 kHz IF filter path. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int GetCalibrationCorrection300KhzFilter(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalibrationCorrection300KhzFilter, channel, out value);
        }

        /// <summary>
        ///Overrides the internal gain self-calibration correction for the 5 MHz IF filter path.
        ///    Default Value: 0 
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int SetCalibrationCorrection5MhzFilter(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalibrationCorrection5MhzFilter, channel, value);
        }
        /// <summary>
        ///Overrides the internal gain self-calibration correction for the 5 MHz IF filter path.
        ///    Default Value: 0 
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int GetCalibrationCorrection5MhzFilter(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalibrationCorrection5MhzFilter, channel, out value);
        }

        /// <summary>
        ///Overrides the internal gain self-calibration correction for the IF filter through path. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int SetCalibrationCorrectionThroughFilter(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalibrationCorrectionThroughFilter, channel, value);
        }
        /// <summary>
        ///Overrides the internal gain self-calibration correction for the IF filter through path. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int GetCalibrationCorrectionThroughFilter(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalibrationCorrectionThroughFilter, channel, out value);
        }

        /// <summary>
        ///Specifies the IF attenuation index from a table of valid settings. To select a correct    attenuation table, use this attribute in conjunction with the    NIRFSA_ATTR_CAL_IF_FILTER_SELECTION and NIRFSA_ATTR_CAL_IF_ATTENUATION_TABLE_SELECTION    attributes. This attribute is valid only during a calibration session. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int SetCalIfAttenuationIndex(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.CalIfAttenuationIndex, channel, value);
        }
        /// <summary>
        ///Specifies the IF attenuation index from a table of valid settings. To select a correct    attenuation table, use this attribute in conjunction with the    NIRFSA_ATTR_CAL_IF_FILTER_SELECTION and NIRFSA_ATTR_CAL_IF_ATTENUATION_TABLE_SELECTION    attributes. This attribute is valid only during a calibration session. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int GetCalIfAttenuationIndex(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.CalIfAttenuationIndex, channel, out value);
        }

        /// <summary>
        ///Specifies the IF attenuation table to be used for external calibration. This attribute is    valid only in a calibration session. 
        ///    Default Value: NIRFSA_VAL_EXT_CAL_IF_ATTENUATION_TABLE_STANDARD  
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int SetCalIfAttenuationTableSelection(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.CalIfAttenuationTableSelection, channel, value);
        }
        /// <summary>
        ///Specifies the IF attenuation table to be used for external calibration. This attribute is    valid only in a calibration session. 
        ///    Default Value: NIRFSA_VAL_EXT_CAL_IF_ATTENUATION_TABLE_STANDARD  
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int GetCalIfAttenuationTableSelection(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.CalIfAttenuationTableSelection, channel, out value);
        }

        /// <summary>
        ///Specifies the IF filter path during calibration. The attribute is valid only during a    calibration session. 
        ///    Default Value: NIRFSA_VAL_EXT_CAL_IF_FILTER_PATH_3  
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int SetCalIfFilterSelection(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.CalIfFilterSelection, channel, value);
        }
        /// <summary>
        ///Specifies the IF filter path during calibration. The attribute is valid only during a    calibration session. 
        ///    Default Value: NIRFSA_VAL_EXT_CAL_IF_FILTER_PATH_3  
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int GetCalIfFilterSelection(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.CalIfFilterSelection, channel, out value);
        }

        /// <summary>
        ///Specifies the LO1 attenuation, in dB, during a calibration session. The default value is    31.5 dB. This attribute is valid only during a calibration session. 
        ///    Valid Values: 0 to 31.5 
        ///    Default Value: 31.5  
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int SetCalLo1Attenuation(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalLo1Attenuation, channel, value);
        }
        /// <summary>
        ///Specifies the LO1 attenuation, in dB, during a calibration session. The default value is    31.5 dB. This attribute is valid only during a calibration session. 
        ///    Valid Values: 0 to 31.5 
        ///    Default Value: 31.5  
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int GetCalLo1Attenuation(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalLo1Attenuation, channel, out value);
        }

        /// <summary>
        ///Specifies the LO2 attenuation, in dB, during a calibration session. The default value is    15.5 dB. This attribute is valid only during a    calibration session. 
        ///    Valid Values: 0 to 15.5 
        ///    Default Value: 15.5 
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int SetCalLo2Attenuation(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalLo2Attenuation, channel, value);
        }
        /// <summary>
        ///Specifies the LO2 attenuation, in dB, during a calibration session. The default value is    15.5 dB. This attribute is valid only during a    calibration session. 
        ///    Valid Values: 0 to 15.5 
        ///    Default Value: 15.5 
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int GetCalLo2Attenuation(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalLo2Attenuation, channel, out value);
        }

        /// <summary>
        ///Specifies the LO3 attenuation, in dB, during a calibration session. The default    value is 15.5 dB. This attribute is valid only during a calibration session. 
        ///    Valid Values: 0 to 15.5 
        ///    Default Value: 15.5  
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int SetCalLo3Attenuation(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalLo3Attenuation, channel, value);
        }
        /// <summary>
        ///Specifies the LO3 attenuation, in dB, during a calibration session. The default    value is 15.5 dB. This attribute is valid only during a calibration session. 
        ///    Valid Values: 0 to 15.5 
        ///    Default Value: 15.5  
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        public int GetCalLo3Attenuation(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalLo3Attenuation, channel, out value);
        }

        /// <summary>
        ///Selects the LO signal path used during calibration. During noncalibration sessions,    NI-RFSA implicitly derives the LO signal path from the center frequency. During    calibration sessions, you must explicitly specify the LO signal path. This attribute is    valid only during a calibration session. 
        ///    Default Value: NIRFSA_VAL_EXT_CAL_LO_PATH_1  
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int SetCalLoPathSelection(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.CalLoPathSelection, channel, value);
        }
        /// <summary>
        ///Selects the LO signal path used during calibration. During noncalibration sessions,    NI-RFSA implicitly derives the LO signal path from the center frequency. During    calibration sessions, you must explicitly specify the LO signal path. This attribute is    valid only during a calibration session. 
        ///    Default Value: NIRFSA_VAL_EXT_CAL_LO_PATH_1  
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int GetCalLoPathSelection(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.CalLoPathSelection, channel, out value);
        }

        /// <summary>
        ///Selects the value of RF electronic attenuation from a table of valid configurations.    This attribute is valid only during a calibration session and when you set    the NIRFSA_ATTR_CAL_RF_PATH_SELECTION attribute to NIRFSA_ATTR_VAL_EXT_CAL_RF_BAND_1. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int SetCalRfElectronicAttenuationIndex(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.CalRfElectronicAttenuationIndex, channel, value);
        }
        /// <summary>
        ///Selects the value of RF electronic attenuation from a table of valid configurations.    This attribute is valid only during a calibration session and when you set    the NIRFSA_ATTR_CAL_RF_PATH_SELECTION attribute to NIRFSA_ATTR_VAL_EXT_CAL_RF_BAND_1. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int GetCalRfElectronicAttenuationIndex(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.CalRfElectronicAttenuationIndex, channel, out value);
        }

        /// <summary>
        ///Selects the value of the RF mechanical attenuation configuration from a table of    valid configurations. This attribute is valid only during a calibration session. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int SetCalRfMechanicalAttenuationIndex(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.CalRfMechanicalAttenuationIndex, channel, value);
        }
        /// <summary>
        ///Selects the value of the RF mechanical attenuation configuration from a table of    valid configurations. This attribute is valid only during a calibration session. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5603/5605        
        /// 
        /// </summary>
        public int GetCalRfMechanicalAttenuationIndex(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.CalRfMechanicalAttenuationIndex, channel, out value);
        }

        /// <summary>
        ///Specifies the RF path to use during calibration. This attribute is valid only during a    calibration session. When you set this attribute, NI-RFSA does not select the RF path based    on the downconverter center frequency.
        ///    The following RF bands and associated frequency ranges apply to the NI 5601:
        ///    RF band 1: 3 GHz to 6.6 GHz 
        ///    RF band 2: 330 MHz to 3 GHz 
        ///    RF band 3: 120 MHz to 330 MHz  
        ///    RF band 4: 10 MHz to 120 MHz 
        ///    NI 5601-NIRFSA_VAL_EXT_CAL_RF_BAND_1 
        ///    Supported Devices: NI 5601        
        /// 
        /// </summary>
        public int SetCalRfPathSelection(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.CalRfPathSelection, channel, value);
        }
        /// <summary>
        ///Specifies the RF path to use during calibration. This attribute is valid only during a    calibration session. When you set this attribute, NI-RFSA does not select the RF path based    on the downconverter center frequency.
        ///    The following RF bands and associated frequency ranges apply to the NI 5601:
        ///    RF band 1: 3 GHz to 6.6 GHz 
        ///    RF band 2: 330 MHz to 3 GHz 
        ///    RF band 3: 120 MHz to 330 MHz  
        ///    RF band 4: 10 MHz to 120 MHz 
        ///    NI 5601-NIRFSA_VAL_EXT_CAL_RF_BAND_1 
        ///    Supported Devices: NI 5601        
        /// 
        /// </summary>
        public int GetCalRfPathSelection(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.CalRfPathSelection, channel, out value);
        }

        /// <summary>
        ///Specifies the frequency of the calibration tone, in hertz (Hz).    Default Value: 612.5 MHz 
        ///    Supported Devices: NI 5603/5605          
        /// 
        /// </summary>
        [Obsolete("Use DownconvertorCalToneFrequency instead")]
        public int SetCalToneFrequency(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.CalToneFrequency, channel, value);
        }
        /// <summary>
        ///Specifies the frequency of the calibration tone, in hertz (Hz).    Default Value: 612.5 MHz 
        ///    Supported Devices: NI 5603/5605          
        /// 
        /// </summary>
        [Obsolete("Use DownconvertorCalToneFrequency instead")]
        public int GetCalToneFrequency(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.CalToneFrequency, channel, out value);
        }

        /// <summary>
        ///Specifies the location in a path where a calibration tone is injected or whether    the tone is disabled. 
        ///    Default Value: NIRFSA_VAL_CAL_TONE_DISABLED  
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        [Obsolete(" Use DownconvertorCalToneMode instead")]
        public int SetCalToneMode(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.CalToneMode, channel, value);
        }
        /// <summary>
        ///Specifies the location in a path where a calibration tone is injected or whether    the tone is disabled. 
        ///    Default Value: NIRFSA_VAL_CAL_TONE_DISABLED  
        ///    Supported Devices: NI 5603/5605         
        /// 
        /// </summary>
        [Obsolete(" Use DownconvertorCalToneMode instead")]
        public int GetCalToneMode(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.CalToneMode, channel, out value);
        }



        /// <summary>
        ///Specifies whether the RF input channel is AC- or DC-coupled on a downconverter. 
        ///    NOTE: For the NI 5605/5665, this attribute must be set to NIRFSA_VAL_AC when the DC block    is present and set to NIRFSA_VAL_DC when the DC block is not present to ensure device    specifications are met and to ensure the use of proper calibration data. For more    information about removing or attaching the DC block on the NI 5605, refer to the    NI 5665 Theory of Operation topic and the NI 5605 RF Downconverter Front Panel topic in this help file. 
        ///    Default Value: NIRFSA_VAL_AC 
        ///    Supported Devices: NI 5603/5605 (external digitizer mode), NI 5665        
        /// 
        /// </summary>
        public int SetChannelCoupling(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.ChannelCoupling, channel, value);
        }
        /// <summary>
        ///Specifies whether the RF input channel is AC- or DC-coupled on a downconverter. 
        ///    NOTE: For the NI 5605/5665, this attribute must be set to NIRFSA_VAL_AC when the DC block    is present and set to NIRFSA_VAL_DC when the DC block is not present to ensure device    specifications are met and to ensure the use of proper calibration data. For more    information about removing or attaching the DC block on the NI 5605, refer to the    NI 5665 Theory of Operation topic and the NI 5605 RF Downconverter Front Panel topic in this help file. 
        ///    Default Value: NIRFSA_VAL_AC 
        ///    Supported Devices: NI 5603/5605 (external digitizer mode), NI 5665        
        /// 
        /// </summary>
        public int GetChannelCoupling(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.ChannelCoupling, channel, out value);
        }

        /// <summary>
        ///Returns the index of the current RF configuration list step that is executing in RF list    mode. The list is zero-indexed. You can query this attribute only when a list is executed. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5663E/5665   	 
        /// 
        /// </summary>
        public int GetConfigurationListStepInProgress(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.ConfigurationListStepInProgress, channel, out value);
        }

        /// <summary>
        ///Specifies the maximum number of samples to transfer at one time from    the device to host memory. Increasing this number should result in better    fetching performance because the driver does not need to restart the transfers    as often. However, increasing this number may increase the amount of page-locked    memory required from the system. 
        ///    Default Value: 0x400000 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDataTransferBlockSize(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.DataTransferBlockSize, channel, value);
        }
        /// <summary>
        ///Specifies the maximum number of samples to transfer at one time from    the device to host memory. Increasing this number should result in better    fetching performance because the driver does not need to restart the transfers    as often. However, increasing this number may increase the amount of page-locked    memory required from the system. 
        ///    Default Value: 0x400000 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDataTransferBlockSize(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.DataTransferBlockSize, channel, out value);
        }

        /// <summary>
        ///Specifies the maximum bandwidth that the device can consume. 
        ///     NOTE: The NI device limits itself to transfer fewer bytes per second on the PCI Express bus    than the value you specify for this attribute. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDataTransferMaximumBandwidth(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DataTransferMaximumBandwidth, channel, value);
        }
        /// <summary>
        ///Specifies the maximum bandwidth that the device can consume. 
        ///     NOTE: The NI device limits itself to transfer fewer bytes per second on the PCI Express bus    than the value you specify for this attribute. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDataTransferMaximumBandwidth(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DataTransferMaximumBandwidth, channel, out value);
        }

        /// <summary>
        ///Specifies the temperature, in degrees Celsius, that NI-RFSA uses to calculate the device configuration settings. 
        ///    NOTE: For most applications, you can choose not to set this property, so NI-RFSA uses the device    temperature to calculate best attenuation settings. Set this property only if you want NI-RFSA    to maintain the same device configuration settings from acquisition to acquisition, independent  of device temperature changes.
        ///    Units:  degrees C 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDeviceConfigurationTemperature(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DeviceConfigurationTemperature, channel, value);
        }
        /// <summary>
        ///Specifies the temperature, in degrees Celsius, that NI-RFSA uses to calculate the device configuration settings. 
        ///    NOTE: For most applications, you can choose not to set this property, so NI-RFSA uses the device    temperature to calculate best attenuation settings. Set this property only if you want NI-RFSA    to maintain the same device configuration settings from acquisition to acquisition, independent  of device temperature changes.
        ///    Units:  degrees C 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDeviceConfigurationTemperature(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DeviceConfigurationTemperature, channel, out value);
        }




        /// <summary>
        ///Specifies the instantaneous bandwidth of the device. The instantaneous bandwidth is    the effective real-time bandwidth of the signal path for your configuration. The value    is expressed in hertz (Hz). 
        ///    NI 5661-The NI 5600 RF downconverter bandwidth is 20 MHz.
        ///    NI 5663/5663E-Your maximum allowed instantaneous bandwidth depends on the downconverter center    frequency you use. Refer to the NI 5601 RF downconverter overview for more information about    instantaneous bandwidth.
        ///    NOTE: For the NI 5663/5663E, NI-RFSA does not support multispan acquisitions from frequency ranges that    correspond with different instantaneous bandwidths. For example, you cannot configure a multispan acquisition that acquires one     span from 110 MHz to 120 MHz and a second from 120 MHz to 130 MHz because the bandwidths that correspond with each span are    different (10 MHz and 20 MHz, respectively). 
        ///    NI 5665-Your maximum allowed instantaneous bandwidth is independent of the downconverter center frequency.    Refer to the NI PXIe-5665 Specifications for more information about instantaneous bandwidth.
        ///    NOTE: If you set the device instantaneous bandwidth for the NI 5603/5605/5665 to a value less than 300 kHz, NI-RFSA uses the 300 kHz IF filter.    For the NI 5605, if you set the device instantaneous bandwidth to a value greater than 300 kHz, NI-RFSA uses the 5 MHz IF filter.    When used with an external digitizer, the NI 5603 and the low band signal path of the NI 5605 provide a nominal 80 MHz bandwidth at -6 dB.    At frequencies greater than 3.6 GHz, the NI 5605 provides a nominal bandwidth of 40 MHz at -6 dB with the preselector (YIG-tuned filter) enabled.
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDeviceInstantaneousBandwidth(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DeviceInstantaneousBandwidth, channel, value);
        }
        /// <summary>
        ///Specifies the instantaneous bandwidth of the device. The instantaneous bandwidth is    the effective real-time bandwidth of the signal path for your configuration. The value    is expressed in hertz (Hz). 
        ///    NI 5661-The NI 5600 RF downconverter bandwidth is 20 MHz.
        ///    NI 5663/5663E-Your maximum allowed instantaneous bandwidth depends on the downconverter center    frequency you use. Refer to the NI 5601 RF downconverter overview for more information about    instantaneous bandwidth.
        ///    NOTE: For the NI 5663/5663E, NI-RFSA does not support multispan acquisitions from frequency ranges that    correspond with different instantaneous bandwidths. For example, you cannot configure a multispan acquisition that acquires one     span from 110 MHz to 120 MHz and a second from 120 MHz to 130 MHz because the bandwidths that correspond with each span are    different (10 MHz and 20 MHz, respectively). 
        ///    NI 5665-Your maximum allowed instantaneous bandwidth is independent of the downconverter center frequency.    Refer to the NI PXIe-5665 Specifications for more information about instantaneous bandwidth.
        ///    NOTE: If you set the device instantaneous bandwidth for the NI 5603/5605/5665 to a value less than 300 kHz, NI-RFSA uses the 300 kHz IF filter.    For the NI 5605, if you set the device instantaneous bandwidth to a value greater than 300 kHz, NI-RFSA uses the 5 MHz IF filter.    When used with an external digitizer, the NI 5603 and the low band signal path of the NI 5605 provide a nominal 80 MHz bandwidth at -6 dB.    At frequencies greater than 3.6 GHz, the NI 5605 provides a nominal bandwidth of 40 MHz at -6 dB with the preselector (YIG-tuned filter) enabled.
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDeviceInstantaneousBandwidth(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DeviceInstantaneousBandwidth, channel, out value);
        }

        /// <summary>
        ///Returns the current temperature, in degrees Celsius, of the RF downconverter module. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDeviceTemperature(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DeviceTemperature, channel, out value);
        }

        /// <summary>
        ///Specifies the source terminal for the Advance trigger. This attribute is used    only when the NIRFSA_ATTR_ADVANCE_TRIGGER_TYPE attribute is set to    NIRFSA_VAL_DIGITAL_EDGE. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetDigitalEdgeAdvanceTriggerSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.DigitalEdgeAdvanceTriggerSource, channel, value);
        }
        /// <summary>
        ///Specifies the source terminal for the Advance trigger. This attribute is used    only when the NIRFSA_ATTR_ADVANCE_TRIGGER_TYPE attribute is set to    NIRFSA_VAL_DIGITAL_EDGE. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetDigitalEdgeAdvanceTriggerSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.DigitalEdgeAdvanceTriggerSource, channel, out value);
        }

        /// <summary>
        ///Specifies the source terminal for the digital edge Arm Reference trigger. This attribute    is used only when the NIRFSA_ATTR_ARM_REF_TRIGGER_TYPE attribute    is set to NIRFSA_VAL_DIGITAL_EDGE. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetDigitalEdgeArmRefTriggerSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.DigitalEdgeArmRefTriggerSource, channel, value);
        }
        /// <summary>
        ///Specifies the source terminal for the digital edge Arm Reference trigger. This attribute    is used only when the NIRFSA_ATTR_ARM_REF_TRIGGER_TYPE attribute    is set to NIRFSA_VAL_DIGITAL_EDGE. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetDigitalEdgeArmRefTriggerSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.DigitalEdgeArmRefTriggerSource, channel, out value);
        }

        /// <summary>
        ///Specifies the active edge for the Reference trigger. This attribute is used only    when the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute is set to    NIRFSA_VAL_DIGITAL_EDGE.   Default Value: NIRFSA_VAL_RISING_EDGE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDigitalEdgeRefTriggerEdge(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.DigitalEdgeRefTriggerEdge, channel, value);
        }
        /// <summary>
        ///Specifies the active edge for the Reference trigger. This attribute is used only    when the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute is set to    NIRFSA_VAL_DIGITAL_EDGE.   Default Value: NIRFSA_VAL_RISING_EDGE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDigitalEdgeRefTriggerEdge(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.DigitalEdgeRefTriggerEdge, channel, out value);
        }

        /// <summary>
        ///Specifies the source terminal for the digital edge Reference trigger. This    attribute is used only when the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute is set    to NIRFSA_VAL_DIGITAL_EDGE. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetDigitalEdgeRefTriggerSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.DigitalEdgeRefTriggerSource, channel, value);
        }
        /// <summary>
        ///Specifies the source terminal for the digital edge Reference trigger. This    attribute is used only when the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute is set    to NIRFSA_VAL_DIGITAL_EDGE. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetDigitalEdgeRefTriggerSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.DigitalEdgeRefTriggerSource, channel, out value);
        }

        /// <summary>
        ///Specifies the active edge for the Start trigger. This attribute is used only    when NIRFSA_ATTR_START_TRIGGER_TYPE is set to NIRFSA_VAL_DIGITAL_EDGE. 
        ///    Default Value: NIRFSA_VAL_RISING_EDGE 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDigitalEdgeStartTriggerEdge(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.DigitalEdgeStartTriggerEdge, channel, value);
        }
        /// <summary>
        ///Specifies the active edge for the Start trigger. This attribute is used only    when NIRFSA_ATTR_START_TRIGGER_TYPE is set to NIRFSA_VAL_DIGITAL_EDGE. 
        ///    Default Value: NIRFSA_VAL_RISING_EDGE 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDigitalEdgeStartTriggerEdge(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.DigitalEdgeStartTriggerEdge, channel, out value);
        }

        /// <summary>
        ///Specifies the source terminal for the Start trigger. This attribute is used    only when the NIRFSA_ATTR_START_TRIGGER_TYPE attribute is set to    NIRFSA_VAL_DIGITAL_EDGE.
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetDigitalEdgeStartTriggerSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.DigitalEdgeStartTriggerSource, channel, value);
        }
        /// <summary>
        ///Specifies the source terminal for the Start trigger. This attribute is used    only when the NIRFSA_ATTR_START_TRIGGER_TYPE attribute is set to    NIRFSA_VAL_DIGITAL_EDGE.
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetDigitalEdgeStartTriggerSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.DigitalEdgeStartTriggerSource, channel, out value);
        }

        /// <summary>
        ///Enables use of the digital equalization filter for the RF downconverter.
        ///    NOTE: Digital IF Equalization is supported only with a 150 MHz clock. You    cannot set this attribute    to VI_TRUE if the NIRFSA_ATTR_DIGITIZER_SAMPLE_CLOCK_TIMEBASE_SOURCE attribute    is set to NIRFSA_VAL_LO_REF_CLK_STR.
        ///    NOTE: The NI 5665 enables digital IF equalization by default if you set the    acquisition mode to NIRFSA_VAL_SPECTRUM    using the niRFSA_ConfigureAcquisitionType function. If you set the    acquisition mode to NIRFSA_VAL_IQ,    digital IF equalization is enabled for instantaneous bandwidths larger    than 300 kHz. You cannot perform digital    IF equalization for instantaneous bandwidths less than or equal to 300 kHz.
        ///    Default Value: VI_TRUE, if the device configuration is supported. 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDigitalIfEqualizationEnabled(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.DigitalIfEqualizationEnabled, channel, value);
        }
        /// <summary>
        ///Enables use of the digital equalization filter for the RF downconverter.
        ///    NOTE: Digital IF Equalization is supported only with a 150 MHz clock. You    cannot set this attribute    to VI_TRUE if the NIRFSA_ATTR_DIGITIZER_SAMPLE_CLOCK_TIMEBASE_SOURCE attribute    is set to NIRFSA_VAL_LO_REF_CLK_STR.
        ///    NOTE: The NI 5665 enables digital IF equalization by default if you set the    acquisition mode to NIRFSA_VAL_SPECTRUM    using the niRFSA_ConfigureAcquisitionType function. If you set the    acquisition mode to NIRFSA_VAL_IQ,    digital IF equalization is enabled for instantaneous bandwidths larger    than 300 kHz. You cannot perform digital    IF equalization for instantaneous bandwidths less than or equal to 300 kHz.
        ///    Default Value: VI_TRUE, if the device configuration is supported. 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDigitalIfEqualizationEnabled(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.DigitalIfEqualizationEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether dithering is enabled on the digitizer. 
        ///    Dithering adds band-limited noise in the analog signal path to help reduce    the quantization effects    of the A/D converter and improve spectral performance. On the NI PXIe-5622,    this out-of-band noise is    added at low frequencies up to approximately 12 MHz.
        ///    When you enable dithering, the maximum signal level is reduced by up to 3 dB.    This signal level reduction    is accounted for in the nominal input ranges of the NI PXIe-5622. Therefore,    you can overrange the input    by up to 3 dB with dither disabled. For example, the +4 dBm input range can handle signal    levels up to +7    dBm with dither disabled. For wider bandwidth acquisitions, such as 40 MHz,  dithering     should be disabled to eliminate residual leakage of the dither signal into the    lower frequencies of the IF passband, which starts at 12.5 MHz and ends at 62.5 MHz.    This leakage can slightly raise the noise floor in the lower frequencies, thus    degrading the performance in high-sensitivity applications. When taking spectral    measurements, this leakage can appear also as a wide, low-amplitude signal    near 12.5 MHz and 62.5 MHz. The width and amplitude of the signal depends on your    resolution bandwidth and the type of time-domain window you apply to your FFT. 
        ///    Default Value: NIRFSA_VAL_ENABLED 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDigitizerDitherEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.DigitizerDitherEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether dithering is enabled on the digitizer. 
        ///    Dithering adds band-limited noise in the analog signal path to help reduce    the quantization effects    of the A/D converter and improve spectral performance. On the NI PXIe-5622,    this out-of-band noise is    added at low frequencies up to approximately 12 MHz.
        ///    When you enable dithering, the maximum signal level is reduced by up to 3 dB.    This signal level reduction    is accounted for in the nominal input ranges of the NI PXIe-5622. Therefore,    you can overrange the input    by up to 3 dB with dither disabled. For example, the +4 dBm input range can handle signal    levels up to +7    dBm with dither disabled. For wider bandwidth acquisitions, such as 40 MHz,  dithering     should be disabled to eliminate residual leakage of the dither signal into the    lower frequencies of the IF passband, which starts at 12.5 MHz and ends at 62.5 MHz.    This leakage can slightly raise the noise floor in the lower frequencies, thus    degrading the performance in high-sensitivity applications. When taking spectral    measurements, this leakage can appear also as a wide, low-amplitude signal    near 12.5 MHz and 62.5 MHz. The width and amplitude of the signal depends on your    resolution bandwidth and the type of time-domain window you apply to your FFT. 
        ///    Default Value: NIRFSA_VAL_ENABLED 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDigitizerDitherEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.DigitizerDitherEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies the frequency, in hertz (Hz), of the external clock used as the timebase    source if you set the NIRFSA_ATTR_DIGITIZER_SAMPLE_CLOCK_TIMEBASE_SOURCE attribute    to an external source, such as NIRFSA_VAL_CLK_IN_STR or NIRFSA_VAL_LO_REF_CLK_STR. 
        ///    NI 5661-If this attribute is set to a value less than 60 MHz, signals at frequencies    just above the 20 MHz passband of the downconverter may be aliased back into the    passband. This aliasing occurs because the IF frequency of the downconverter is 15 MHz,    and the upper end of the passband is 25 MHz. At sampling rates below 60 MHz, the    Nyquist frequency is close to the end of the passband and creates aliases that are    not filtered effectively by the downconverter.
        ///    NI 5663/5663E/5665-The NI 5663/5663E/5665 supports only a 150 MHz external clock. 
        ///    Units: hertz (Hz) 
        ///    Default Value: 150 MHz 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDigitizerSampleClockTimebaseRate(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DigitizerSampleClockTimebaseRate, channel, value);
        }
        /// <summary>
        ///Specifies the frequency, in hertz (Hz), of the external clock used as the timebase    source if you set the NIRFSA_ATTR_DIGITIZER_SAMPLE_CLOCK_TIMEBASE_SOURCE attribute    to an external source, such as NIRFSA_VAL_CLK_IN_STR or NIRFSA_VAL_LO_REF_CLK_STR. 
        ///    NI 5661-If this attribute is set to a value less than 60 MHz, signals at frequencies    just above the 20 MHz passband of the downconverter may be aliased back into the    passband. This aliasing occurs because the IF frequency of the downconverter is 15 MHz,    and the upper end of the passband is 25 MHz. At sampling rates below 60 MHz, the    Nyquist frequency is close to the end of the passband and creates aliases that are    not filtered effectively by the downconverter.
        ///    NI 5663/5663E/5665-The NI 5663/5663E/5665 supports only a 150 MHz external clock. 
        ///    Units: hertz (Hz) 
        ///    Default Value: 150 MHz 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDigitizerSampleClockTimebaseRate(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DigitizerSampleClockTimebaseRate, channel, out value);
        }

        /// <summary>
        ///Specifies the source of the Sample clock timebase, which is the timebase used    to control waveform sampling.
        ///    Default Value: NIRFSA_VAL_ONBOARD_CLOCK_STR  
        ///    Supported Devices: NI 5661/5663/5663E/5665 
        /// 
        /// </summary>
        public int SetDigitizerSampleClockTimebaseSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.DigitizerSampleClockTimebaseSource, channel, value);
        }
        /// <summary>
        ///Specifies the source of the Sample clock timebase, which is the timebase used    to control waveform sampling.
        ///    Default Value: NIRFSA_VAL_ONBOARD_CLOCK_STR  
        ///    Supported Devices: NI 5661/5663/5663E/5665 
        /// 
        /// </summary>
        public int GetDigitizerSampleClockTimebaseSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.DigitizerSampleClockTimebaseSource, channel, out value);
        }

        
        /// <summary>
        /// </summary>
        public int SetIqAnalogEdgeRefTrigger(string channel, string value)
        {
            return this.SetString(niRFSAProperties.IqAnalogEdgeRefTrigger, channel, value);
        }
        /// <summary>
        /// </summary>
        public int GetIqAnalogEdgeRefTrigger(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.IqAnalogEdgeRefTrigger, channel, out value);
        }

        /// <summary>
        ///Returns the current temperature, in degrees Celsius, of the digitizer module. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDigitizerTemperature(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DigitizerTemperature, channel, out value);
        }

        /// <summary>
        ///Specifies the vertical range of the digitizer. The vertical range is defined    as the absolute value of the input range for a channel. The default vertical range works    for all device configurations. This attribute can be used to optimize performance if you    know the signal level at the digitizer input terminal is low.
        ///    NOTE: For most applications, NI-RFSA selects an appropriate value for this attribute. 
        ///    This value is expressed in volts. For example, to acquire a sine wave that    spans between -0.05 V and +0.05 V, set this attribute to 1.0. 
        ///    Default Value: 1.0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDigitizerVerticalRange(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DigitizerVerticalRange, channel, value);
        }
        /// <summary>
        ///Specifies the vertical range of the digitizer. The vertical range is defined    as the absolute value of the input range for a channel. The default vertical range works    for all device configurations. This attribute can be used to optimize performance if you    know the signal level at the digitizer input terminal is low.
        ///    NOTE: For most applications, NI-RFSA selects an appropriate value for this attribute. 
        ///    This value is expressed in volts. For example, to acquire a sine wave that    spans between -0.05 V and +0.05 V, set this attribute to 1.0. 
        ///    Default Value: 1.0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDigitizerVerticalRange(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DigitizerVerticalRange, channel, out value);
        }

        /// <summary>
        ///Returns the fully qualified signal name as a string. 
        ///    Default Value: /DigitizerName/EndOfRecordEvent, where DigitizerName is the name associated with your digitizer module in MAX.  
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDoneEventTerminalName(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.DoneEventTerminalName, channel, out value);
        }

        /// <summary>
        ///Enables in-band retuning and specifies the current frequency, in hertz (Hz),    of the downconverter.     If you set this attribute, any measurements outside the instantaneous bandwidth    of the device are invalid.    To disable in-band retuning, reset the attribute or call the call the niRFSA_ResetDevice function. 
        ///    After you set this attribute, the downconverter is locked to that frequency    until the value is changed    or the attribute is reset. Locking the downconverter to a fixed value allows    frequencies within the    instantaneous bandwidth of the converter to be measured with minimal    overhead, decreasing tuning time. 
        ///    Valid Values: Any supported tuning frequency of the device
        ///    Default Value: The carrier frequency or spectrum center frequency.    NI-RFSA sets this attribute to the default value based on whichever frequency setting is applicable. 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetDownconverterCenterFrequency(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DownconverterCenterFrequency, channel, value);
        }
        /// <summary>
        ///Enables in-band retuning and specifies the current frequency, in hertz (Hz),    of the downconverter.     If you set this attribute, any measurements outside the instantaneous bandwidth    of the device are invalid.    To disable in-band retuning, reset the attribute or call the call the niRFSA_ResetDevice function. 
        ///    After you set this attribute, the downconverter is locked to that frequency    until the value is changed    or the attribute is reset. Locking the downconverter to a fixed value allows    frequencies within the    instantaneous bandwidth of the converter to be measured with minimal    overhead, decreasing tuning time. 
        ///    Valid Values: Any supported tuning frequency of the device
        ///    Default Value: The carrier frequency or spectrum center frequency.    NI-RFSA sets this attribute to the default value based on whichever frequency setting is applicable. 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetDownconverterCenterFrequency(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DownconverterCenterFrequency, channel, out value);
        }

        /// <summary>
        ///Returns the RF downconverter net signal gain at current NI-RFSA settings and    temperature. NI-RFSA takes the    value of this attribute into account when it reads I/Q data and spectrum data. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665      
        /// 
        /// </summary>
        public int SetDownconverterGain(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.DownconverterGain, channel, value);
        }
        /// <summary>
        ///Returns the RF downconverter net signal gain at current NI-RFSA settings and    temperature. NI-RFSA takes the    value of this attribute into account when it reads I/Q data and spectrum data. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665      
        /// 
        /// </summary>
        public int GetDownconverterGain(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.DownconverterGain, channel, out value);
        }

        /// <summary>
        ///Configures the loop bandwidth of the RF downconverter tuning PLLs. To    set this attribute, the NI-RFSA device must be in the Configuration state.
        ///    NI 5600/5661-For signal bandwidths greater than 10 MHz, NIRFSA_VAL_wide is the only    value supported for this attribute.
        ///    NI 5601/5663/5663E- The NI 5601 does not support the NIRFSA_VAL_MEDIUM value.This attribute is not supported if you are using an external LO. 
        ///    Default Values: 
        ///    NI 5600-NIRFSA_VAL_WIDE 
        ///    NI 5601-NIRFSA_VAL_NARROW 
        ///    Supported Devices: NI 5600/5601 (external digitizer mode), NI 5661/5663/5663E        
        /// 
        /// </summary>
        public int SetDownconverterLoopBandwidth(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.DownconverterLoopBandwidth, channel, value);
        }
        /// <summary>
        ///Configures the loop bandwidth of the RF downconverter tuning PLLs. To    set this attribute, the NI-RFSA device must be in the Configuration state.
        ///    NI 5600/5661-For signal bandwidths greater than 10 MHz, NIRFSA_VAL_wide is the only    value supported for this attribute.
        ///    NI 5601/5663/5663E- The NI 5601 does not support the NIRFSA_VAL_MEDIUM value.This attribute is not supported if you are using an external LO. 
        ///    Default Values: 
        ///    NI 5600-NIRFSA_VAL_WIDE 
        ///    NI 5601-NIRFSA_VAL_NARROW 
        ///    Supported Devices: NI 5600/5601 (external digitizer mode), NI 5661/5663/5663E        
        /// 
        /// </summary>
        public int GetDownconverterLoopBandwidth(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.DownconverterLoopBandwidth, channel, out value);
        }
        /// <summary>
        ///The DriverSetup string is used to set the initial values for attributes that    are specific to NI-RFSA. The format of the DriverSetup string is:
        ///    Tag: Value
        ///    Tag is the name of the DriverSetup string attribute. Value is the value set to    the attribute. To set multiple attributes, separate their assignments with a    semicolon.
        ///    The DriverSetup string can include the following tags:
        ///    NI 5661/5663/5663E/5665-Digitizer-Specifies the resource name of the digitizer to use for    this session. If this Driver Setup tag is not specified, the resource name for the    downconverter associated in MAX is used. An example of a Driver Setup string    is DriverSetup=Digitizer:pxi1slot4. If you want to use the NI 5600/5601/5603 with an    external digitizer, use the following Driver Setup tag:    DriverSetup=Digitizer:<external></external>.
        ///    NI 5663/5663E/5665-LO source-Specifies the resource name of the LO source to use for this    session. If you want to use the NI 5601 with an LO other than the NI 5652 or use the    NI 5603 with an LO other than the NI 5653, use the following Driver Setup    tag: DriverSetup=LO:<external></external>.
        ///    Refer to the niRFSA_InitWithOptions function for additional information about the    optionString parameter. Refer to the getting started guide for your device for information    about configuring your device in MAX. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetDriverSetup(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.DriverSetup, channel, out value);
        }

        /// <summary>
        ///Specifies whether fractional resampling is enabled on the digitizer. 
        ///    Dithering adds band-limited noise in the analog signal path to help reduce the    quantization effects of the A/D converter and improve spectral performance.    On the NI PXIe-5622, this out-of-band noise is added at low frequencies up to approximately 12 MHz.
        ///    When you enable dithering, the maximum signal level is reduced by up to 3 dB. This signal level reduction    is accounted for in the nominal input ranges of the NI PXIe-5622. Therefore, you can overrange the input    by up to 3 dB with dither disabled. For example, the +4 dBm input range can handle signal levels up to    +7 dBm with dither disabled. For wider bandwidth acquisitions, such as 40 MHz, dithering should be disabled    to eliminate residual leakage of the dither signal into the lower frequencies of the IF passband, which    starts at 12.5 MHz and ends at 62.5 MHz. This leakage can slightly raise the noise floor in the lower    frequencies, thus degrading the performance in high-sensitivity applications. When taking spectral measurements,    this leakage can appear also as a wide, low-amplitude signal near 12.5 MHz and 62.5 MHz. The width and    amplitude of the signal depends on your resolution bandwidth and the type of time-domain window you apply to your FFT.
        ///    Default Value: VI_TRUE 
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetEnableFractionalResampling(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.EnableFractionalResampling, channel, value);
        }
        /// <summary>
        ///Specifies whether fractional resampling is enabled on the digitizer. 
        ///    Dithering adds band-limited noise in the analog signal path to help reduce the    quantization effects of the A/D converter and improve spectral performance.    On the NI PXIe-5622, this out-of-band noise is added at low frequencies up to approximately 12 MHz.
        ///    When you enable dithering, the maximum signal level is reduced by up to 3 dB. This signal level reduction    is accounted for in the nominal input ranges of the NI PXIe-5622. Therefore, you can overrange the input    by up to 3 dB with dither disabled. For example, the +4 dBm input range can handle signal levels up to    +7 dBm with dither disabled. For wider bandwidth acquisitions, such as 40 MHz, dithering should be disabled    to eliminate residual leakage of the dither signal into the lower frequencies of the IF passband, which    starts at 12.5 MHz and ends at 62.5 MHz. This leakage can slightly raise the noise floor in the lower    frequencies, thus degrading the performance in high-sensitivity applications. When taking spectral measurements,    this leakage can appear also as a wide, low-amplitude signal near 12.5 MHz and 62.5 MHz. The width and    amplitude of the signal depends on your resolution bandwidth and the type of time-domain window you apply to your FFT.
        ///    Default Value: VI_TRUE 
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetEnableFractionalResampling(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.EnableFractionalResampling, channel, out value);
        }

        /// <summary>
        ///Returns the fully qualified signal name as a string. 
        ///    Default Value: /DigitizerName/EndOfRecordEvent, where DigitizerName is the name associated with your digitizer module in MAX.  
        ///    Supported Devices: NI 5663/5663E/5665   	 
        /// 
        /// </summary>
        public int GetEndOfRecordEventTerminalName(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.EndOfRecordEventTerminalName, channel, out value);
        }


        /// <summary>
        ///This attribute is not for customer use. 
        /// 
        /// </summary>
        public int SetReconfigurationTriggerSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ReconfigurationTriggerSource, channel, value);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetReconfigurationTriggerSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ReconfigurationTriggerSource, channel, out value);
        }
        
        /// <summary>
        ///Specifies the destination terminal for the exported Advance trigger. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetExportedAdvanceTriggerOutputTerminal(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ExportedAdvanceTriggerOutputTerminal, channel, value);
        }
        /// <summary>
        ///Specifies the destination terminal for the exported Advance trigger. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetExportedAdvanceTriggerOutputTerminal(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ExportedAdvanceTriggerOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for the Done event. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetExportedDoneEventOutputTerminal(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ExportedDoneEventOutputTerminal, channel, value);
        }
        /// <summary>
        ///Specifies the destination terminal for the Done event. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetExportedDoneEventOutputTerminal(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ExportedDoneEventOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for the End of Record event. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetExportedEndOfRecordEventOutputTerminal(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ExportedEndOfRecordEventOutputTerminal, channel, value);
        }
        /// <summary>
        ///Specifies the destination terminal for the End of Record event. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetExportedEndOfRecordEventOutputTerminal(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ExportedEndOfRecordEventOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for the Ready for Advance event. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetExportedReadyForAdvanceEventOutputTerminal(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ExportedReadyForAdvanceEventOutputTerminal, channel, value);
        }
        /// <summary>
        ///Specifies the destination terminal for the Ready for Advance event. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetExportedReadyForAdvanceEventOutputTerminal(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ExportedReadyForAdvanceEventOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for the Ready for Reference event. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetExportedReadyForRefEventOutputTerminal(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ExportedReadyForRefEventOutputTerminal, channel, value);
        }
        /// <summary>
        ///Specifies the destination terminal for the Ready for Reference event. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetExportedReadyForRefEventOutputTerminal(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ExportedReadyForRefEventOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for the Ready for Start event. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetExportedReadyForStartEventOutputTerminal(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ExportedReadyForStartEventOutputTerminal, channel, value);
        }
        /// <summary>
        ///Specifies the destination terminal for the Ready for Start event. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetExportedReadyForStartEventOutputTerminal(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ExportedReadyForStartEventOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies a comma-separated list of the terminals at which to export the Reference clock. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetExportedRefClockOutputTerminal(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ExportedRefClockOutputTerminal, channel, value);
        }
        /// <summary>
        ///Specifies a comma-separated list of the terminals at which to export the Reference clock. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetExportedRefClockOutputTerminal(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ExportedRefClockOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for the exported Reference trigger. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetExportedRefTriggerOutputTerminal(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ExportedRefTriggerOutputTerminal, channel, value);
        }
        /// <summary>
        ///Specifies the destination terminal for the exported Reference trigger. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetExportedRefTriggerOutputTerminal(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ExportedRefTriggerOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the destination terminal for the exported Start trigger.
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetExportedStartTriggerOutputTerminal(string channel, string value)
        {
            return this.SetString(niRFSAProperties.ExportedStartTriggerOutputTerminal, channel, value);
        }
        /// <summary>
        ///Specifies the destination terminal for the exported Start trigger.
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetExportedStartTriggerOutputTerminal(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ExportedStartTriggerOutputTerminal, channel, out value);
        }

        /// <summary>
        ///Specifies the gain, in dB, of a switch (or cable) connected before the RF IN    connector of an NI-RFSA device. When you set this attribute, and the     NIRFSA_ATTR_ATTENUATION and NIRFSA_ATTR_IF_ATTENUATION values,    NI-RFSA calculates appropriate attenuator settings based on the value of this attribute    and the value of the NIRFSA_ATTR_REFERENCE_LEVEL attribute. In this case, NI-RFSA interprets    the reference level as the maximum expected power level of the signal at the input    of the external gain device. For more information about attenuation, refer to the    Attenuation and Signal Levels topic for your device in    the NI RF Vector Signal Analyzers Help. 
        ///    With this attribute set, NI-RFSA reads the NIRFSA_ATTR_IQ_POWER_EDGE_REF_TRIGGER_LEVEL    attribute value as the power level at the input of the external gain device at    which the NI-RFSA device should trigger.
        ///     Negative values indicate attenuation. The default value is 0. 
        ///    Valid Values: -INF to +INF 
        ///    Units: dB 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetExternalGain(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.ExternalGain, channel, value);
        }
        /// <summary>
        ///Specifies the gain, in dB, of a switch (or cable) connected before the RF IN    connector of an NI-RFSA device. When you set this attribute, and the     NIRFSA_ATTR_ATTENUATION and NIRFSA_ATTR_IF_ATTENUATION values,    NI-RFSA calculates appropriate attenuator settings based on the value of this attribute    and the value of the NIRFSA_ATTR_REFERENCE_LEVEL attribute. In this case, NI-RFSA interprets    the reference level as the maximum expected power level of the signal at the input    of the external gain device. For more information about attenuation, refer to the    Attenuation and Signal Levels topic for your device in    the NI RF Vector Signal Analyzers Help. 
        ///    With this attribute set, NI-RFSA reads the NIRFSA_ATTR_IQ_POWER_EDGE_REF_TRIGGER_LEVEL    attribute value as the power level at the input of the external gain device at    which the NI-RFSA device should trigger.
        ///     Negative values indicate attenuation. The default value is 0. 
        ///    Valid Values: -INF to +INF 
        ///    Units: dB 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetExternalGain(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.ExternalGain, channel, out value);
        }

        /// <summary>
        ///Specifies the offset relative to the position specified by the    NIRFSA_ATTR_FETCH_RELATIVE_TO attribute from which to start fetching data.    Offset can be a positive or negative value. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665         
        /// 
        /// </summary>
        public int SetFetchOffset(string channel, long value)
        {
            return this.SetInt64(niRFSAProperties.FetchOffset, channel, value);
        }
        /// <summary>
        ///Specifies the offset relative to the position specified by the    NIRFSA_ATTR_FETCH_RELATIVE_TO attribute from which to start fetching data.    Offset can be a positive or negative value. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665         
        /// 
        /// </summary>
        public int GetFetchOffset(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.FetchOffset, channel, out value);
        }

        /// <summary>
        ///Specifies the reference location within the acquired record from which to    begin fetching. 
        ///     Default Value: N/A  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetFetchRelativeTo(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.FetchRelativeTo, channel, value);
        }
        /// <summary>
        ///Specifies the reference location within the acquired record from which to    begin fetching. 
        ///     Default Value: N/A  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetFetchRelativeTo(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.FetchRelativeTo, channel, out value);
        }

        /// <summary>
        ///Returns the size of the fast Fourier transform (FFT). 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetFftSize(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.FftSize, channel, out value);
        }

        /// <summary>
        ///Returns the size of the window used in the fast Fourier transform (FFT). 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetFftWindowSize(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.FftWindowSize, channel, out value);
        }

        /// <summary>
        ///Specifies the time-domain window type. 
        ///    Default Value: NIRFSA_VAL_7_TERM_BLACKMAN_HARRIS 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetFftWindowType(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.FftWindowType, channel, value);
        }
        /// <summary>
        ///Specifies the time-domain window type. 
        ///    Default Value: NIRFSA_VAL_7_TERM_BLACKMAN_HARRIS 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetFftWindowType(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.FftWindowType, channel, out value);
        }

        /// <summary>
        ///Specifies the value used for LO frequency settling. The units and interpretation    for this scalar value are specified using the NIRFSA_ATTR_FREQUENCY_SETTLING_UNITS    attribute. This attribute is not supported if you are using an external LO. 
        ///    The valid values for this attribute depend on the NIRFSA_ATTR_FREQUENCY_SETTLING_UNITS attribute. 
        ///    Valid Values:
        ///    NIRFSA_VAL_FSU_TIME_AFTER_LOCK:
        ///    2 microseconds* to 80 milliseconds, resolution of approximately 2 microseconds (NI 5663/5663E)
        ///    4 microseconds to 80 milliseconds, resolution of approximately 4 microseconds (NI 5665) 
        ///    NIRFSA_VAL_FSU_TIME_AFTER_IO:
        ///    0 microseconds to 80 milliseconds**, resolution of 1 microsecond (NI 5663/5663E) 
        ///    0 microseconds to 80 milliseconds**, resolution of 1 microsecond (NI 5665) 
        ///    NIRFSA_VAL_FSU_PPM:
        ///    1.0, 0.1, 0.01(NI 5663/5663E) 
        ///    1.0, 0.1, 0.01 (NI 5665) 
        ///    *If the NIRFSA_ATTR_FREQUENCY_SETTLING_UNITS attribute is set to NIRFSA_VAL_FSU_TIME_AFTER_LOCK and the NIRFSA_ATTR_DOWNCONVERTER_LOOP_BANDWIDTH     attribute is set to NIRFSA_VAL_NARROW, NI recommends a minimum settling time of 128 microseconds to ensure that the PLL lock stabilizes.    If the NIRFSA_ATTR_DOWNCONVERTER_LOOP_BANDWIDTH is set to NIRFSA_VAL_WIDE, NI recommends a minimum settling time of 16 microseconds. 
        ///    **When in RF list mode, the valid values for NIRFSA_VAL_FSU_TIME_AFTER_IO are 0 microseconds to 50 milliseconds. 
        ///    Default Value: 0.1 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetFrequencySettling(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.FrequencySettling, channel, value);
        }
        /// <summary>
        ///Specifies the value used for LO frequency settling. The units and interpretation    for this scalar value are specified using the NIRFSA_ATTR_FREQUENCY_SETTLING_UNITS    attribute. This attribute is not supported if you are using an external LO. 
        ///    The valid values for this attribute depend on the NIRFSA_ATTR_FREQUENCY_SETTLING_UNITS attribute. 
        ///    Valid Values:
        ///    NIRFSA_VAL_FSU_TIME_AFTER_LOCK:
        ///    2 microseconds* to 80 milliseconds, resolution of approximately 2 microseconds (NI 5663/5663E)
        ///    4 microseconds to 80 milliseconds, resolution of approximately 4 microseconds (NI 5665) 
        ///    NIRFSA_VAL_FSU_TIME_AFTER_IO:
        ///    0 microseconds to 80 milliseconds**, resolution of 1 microsecond (NI 5663/5663E) 
        ///    0 microseconds to 80 milliseconds**, resolution of 1 microsecond (NI 5665) 
        ///    NIRFSA_VAL_FSU_PPM:
        ///    1.0, 0.1, 0.01(NI 5663/5663E) 
        ///    1.0, 0.1, 0.01 (NI 5665) 
        ///    *If the NIRFSA_ATTR_FREQUENCY_SETTLING_UNITS attribute is set to NIRFSA_VAL_FSU_TIME_AFTER_LOCK and the NIRFSA_ATTR_DOWNCONVERTER_LOOP_BANDWIDTH     attribute is set to NIRFSA_VAL_NARROW, NI recommends a minimum settling time of 128 microseconds to ensure that the PLL lock stabilizes.    If the NIRFSA_ATTR_DOWNCONVERTER_LOOP_BANDWIDTH is set to NIRFSA_VAL_WIDE, NI recommends a minimum settling time of 16 microseconds. 
        ///    **When in RF list mode, the valid values for NIRFSA_VAL_FSU_TIME_AFTER_IO are 0 microseconds to 50 milliseconds. 
        ///    Default Value: 0.1 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetFrequencySettling(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.FrequencySettling, channel, out value);
        }

        /// <summary>
        ///Specifies the delay duration units and interpretation for LO settling. Specify    the actual settling value using the NIRFSA_ATTR_FREQUENCY_SETTLING attribute.    This attribute is not supported if you are using an external LO. 
        ///    Default Value: NIRFSA_VAL_FSU_PPM 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetFrequencySettlingUnits(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.FrequencySettlingUnits, channel, value);
        }
        /// <summary>
        ///Specifies the delay duration units and interpretation for LO settling. Specify    the actual settling value using the NIRFSA_ATTR_FREQUENCY_SETTLING attribute.    This attribute is not supported if you are using an external LO. 
        ///    Default Value: NIRFSA_VAL_FSU_PPM 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetFrequencySettlingUnits(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.FrequencySettlingUnits, channel, out value);
        }

        /// <summary>
        ///Specifies the IF1 attenuation, in dB. The device IF1 attenuator is set to this nominal value.    Use this attribute, along with the NIRFSA_ATTR_IF2_ATTEN_VALUE attribute, when you    set the NIRFSA_ATTR_IF_FILTER attribute to NIRFSA_VAL_BYPASS. 
        ///    Valid Values: 0 to 15 
        ///    Units: dB 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5663/5663E        
        /// 
        /// </summary>
        public int SetIf1AttenValue(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.If1AttenValue, channel, value);
        }
        /// <summary>
        ///Specifies the IF1 attenuation, in dB. The device IF1 attenuator is set to this nominal value.    Use this attribute, along with the NIRFSA_ATTR_IF2_ATTEN_VALUE attribute, when you    set the NIRFSA_ATTR_IF_FILTER attribute to NIRFSA_VAL_BYPASS. 
        ///    Valid Values: 0 to 15 
        ///    Units: dB 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5663/5663E        
        /// 
        /// </summary>
        public int GetIf1AttenValue(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.If1AttenValue, channel, out value);
        }

        /// <summary>
        ///Specifies the IF2 attenuation, in dB. The device IF2 attenuator is set to this nominal value.   Use this attribute, along with the NIRFSA_ATTR_IF1_ATTEN_VALUE attribute, when you   set the NIRFSA_ATTR_IF_FILTER attribute to NIRFSA_VAL_BYPASS. 
        ///    Valid Values: 0 to 15 
        ///    Units: dB 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5663/5663E        
        /// 
        /// </summary>
        public int SetIf2AttenValue(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.If2AttenValue, channel, value);
        }
        /// <summary>
        ///Specifies the IF2 attenuation, in dB. The device IF2 attenuator is set to this nominal value.   Use this attribute, along with the NIRFSA_ATTR_IF1_ATTEN_VALUE attribute, when you   set the NIRFSA_ATTR_IF_FILTER attribute to NIRFSA_VAL_BYPASS. 
        ///    Valid Values: 0 to 15 
        ///    Units: dB 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5663/5663E        
        /// 
        /// </summary>
        public int GetIf2AttenValue(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.If2AttenValue, channel, out value);
        }

        /// <summary>
        ///Configures the device attenuation to a value that has the actual calibrated IF attenuation    closest to the desired value. 
        ///    Valid Values: 0 to 30 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5663/5663E        
        /// 
        /// </summary>
        public int SetIfAttenuation(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IfAttenuation, channel, value);
        }
        /// <summary>
        ///Configures the device attenuation to a value that has the actual calibrated IF attenuation    closest to the desired value. 
        ///    Valid Values: 0 to 30 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5663/5663E        
        /// 
        /// </summary>
        public int GetIfAttenuation(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IfAttenuation, channel, out value);
        }


        /// <summary>
        ///Specifies the desired IF filter path, regardless of the RF band chosen by NI-RFSA.
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5601        
        /// 
        /// </summary>
        public int SetIfFilter(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.IfFilter, channel, value);
        }
        /// <summary>
        ///Specifies the desired IF filter path, regardless of the RF band chosen by NI-RFSA.
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5601        
        /// 
        /// </summary>
        public int GetIfFilter(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.IfFilter, channel, out value);
        }

        /// <summary>
        ///Returns the center frequency of the IF output that corresponds to    the configured RF center frequency.
        ///    The downconverter translates RF input frequency to the IF output    frequency by mixing it with the LO signal.    The following values are the nominal values for the IF frequency:
        ///    NI 5600 15 MHz
        ///    NI 5601 53 MHz or 187.5 MHz
        ///    NI 5603 187.5 MHz or 199 MHz
        ///    However, the coarse nature of the LO settings can cause the    downconverter to be unable to tune to the exact    LO frequency that would produce the nominal IF output. Any coercion    in the actual LO frequency results in the    IF output frequency being slightly off from the nominal value.
        ///    Additionally, if you use the NIRFSA_ATTR_DOWNCONVERTER_CENTER_FREQUENCY    and NIRFSA_ATTR_LO_FREQUENCY attributes    to program the downconverter, then the IF output frequency could be very    different from the nominal value.    NI-RFSA adjusts the acquired spectrum or I/Q data for the difference between    nominal and actual IF output    frequency. If you use an external digitizer with the NI RF downconverter,    use this attribute to specify the    actual IF output frequency. 
        ///     Default Value: N/A 
        ///    Supported Devices:NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetIfOutputFrequency(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IfOutputFrequency, channel, out value);
        }

        /// <summary>
        ///Specifies the level of the IF signal leaving the downconverter module, in dBm. Use this attribute to    increase or decrease the nominal IF signal output level to achieve better measurement results.    The default is -6dBm. 
        ///    You cannot set the NIRFSA_ATTR_IF_OUTPUT_POWER_LEVEL and    NIRFSA_ATTR_IF_OUTPUT_POWER_LEVEL_OFFSET attributes at the same time. 
        ///    Units: dBm 
        ///    Default Value: -6 dBm 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665       
        /// 
        /// </summary>
        public int SetIfOutputPowerLevel(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IfOutputPowerLevel, channel, value);
        }
        /// <summary>
        ///Specifies the level of the IF signal leaving the downconverter module, in dBm. Use this attribute to    increase or decrease the nominal IF signal output level to achieve better measurement results.    The default is -6dBm. 
        ///    You cannot set the NIRFSA_ATTR_IF_OUTPUT_POWER_LEVEL and    NIRFSA_ATTR_IF_OUTPUT_POWER_LEVEL_OFFSET attributes at the same time. 
        ///    Units: dBm 
        ///    Default Value: -6 dBm 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665       
        /// 
        /// </summary>
        public int GetIfOutputPowerLevel(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IfOutputPowerLevel, channel, out value);
        }

        /// <summary>
        ///Specifies the number of dB by which to adjust the default IF output power level. This    attribute does    not depend on absolute IF output power levels, so you can use it to adjust    the IF output power level    on all NI-RFSA devices without knowing the exact default value. Use this attribute to increase or    decrease the nominal output level to achieve better measurement results. The    default value for the offset    is 0 dB, which results in an IF OUT output power level of -6 dBm. 
        ///    You cannot set the    NIRFSA_ATTR_IF_OUTPUT_POWER_LEVEL and NIRFSA_ATTR_IF_OUTPUT_POWER_LEVEL_OFFSET attributes at    the same time. 
        ///    Units: dB 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665       
        /// 
        /// </summary>
        public int SetIfOutputPowerLevelOffset(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IfOutputPowerLevelOffset, channel, value);
        }
        /// <summary>
        ///Specifies the number of dB by which to adjust the default IF output power level. This    attribute does    not depend on absolute IF output power levels, so you can use it to adjust    the IF output power level    on all NI-RFSA devices without knowing the exact default value. Use this attribute to increase or    decrease the nominal output level to achieve better measurement results. The    default value for the offset    is 0 dB, which results in an IF OUT output power level of -6 dBm. 
        ///    You cannot set the    NIRFSA_ATTR_IF_OUTPUT_POWER_LEVEL and NIRFSA_ATTR_IF_OUTPUT_POWER_LEVEL_OFFSET attributes at    the same time. 
        ///    Units: dB 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665       
        /// 
        /// </summary>
        public int GetIfOutputPowerLevelOffset(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IfOutputPowerLevelOffset, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains the firmware revision information for the    NI-RFSA device you are currently using.
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetInstrumentFirmwareRevision(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.InstrumentFirmwareRevision, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains the name of the manufacturer for the NI-RFSA device you are    currently using.
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetInstrumentManufacturer(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.InstrumentManufacturer, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains the model number or name of the NI-RFSA    device that you are currently using.
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetInstrumentModel(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.InstrumentModel, channel, out value);
        }

        /// <summary>
        ///Specifies whether to perform interchangeability checking and retrieve    interchangeability warnings.
        ///    NOTE: Interchangeability check is unsupported.
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: None         
        /// 
        /// </summary>
        public int SetInterchangeCheck(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.InterchangeCheck, channel, value);
        }
        /// <summary>
        ///Specifies whether to perform interchangeability checking and retrieve    interchangeability warnings.
        ///    NOTE: Interchangeability check is unsupported.
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: None         
        /// 
        /// </summary>
        public int GetInterchangeCheck(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.InterchangeCheck, channel, out value);
        }

        /// <summary>
        ///Indicates the resource name NI-RFSA uses to identify the physical device.    If you initialize NI-RFSA with a logical name, this attribute contains the resource    name that corresponds to the entry in the IVI Configuration Utility. 
        ///    If you initialize NI-RFSA with the resource name, this attribute    contains that value.
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetIoResourceDescriptor(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.IoResourceDescriptor, channel, out value);
        }

        /// <summary>
        ///Specifies the expected carrier frequency of the incoming signal for demodulation. The    RF vector signal analyzer tunes to this frequency. NI-RFSA may coerce this value    based on hardware settings and the RF downconverter specifications. 
        ///    Units: hertz (Hz) 
        ///    Default Value: 100 MHz  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetIqCarrierFrequency(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IqCarrierFrequency, channel, value);
        }
        /// <summary>
        ///Specifies the expected carrier frequency of the incoming signal for demodulation. The    RF vector signal analyzer tunes to this frequency. NI-RFSA may coerce this value    based on hardware settings and the RF downconverter specifications. 
        ///    Units: hertz (Hz) 
        ///    Default Value: 100 MHz  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetIqCarrierFrequency(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IqCarrierFrequency, channel, out value);
        }

        /// <summary>
        ///Specifies the power level, in dBm, at which the device triggers. The device    asserts the trigger when the signal crosses the level specified by the value    of this attribute, taking into consideration the specified slope. If you are    using external gain, refer to the NIRFSA_ATTR_EXTERNAL_GAIN attribute for more information    about how this attribute affects the I/Q power edge trigger level. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetIqPowerEdgeRefTriggerLevel(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IqPowerEdgeRefTriggerLevel, channel, value);
        }
        /// <summary>
        ///Specifies the power level, in dBm, at which the device triggers. The device    asserts the trigger when the signal crosses the level specified by the value    of this attribute, taking into consideration the specified slope. If you are    using external gain, refer to the NIRFSA_ATTR_EXTERNAL_GAIN attribute for more information    about how this attribute affects the I/Q power edge trigger level. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetIqPowerEdgeRefTriggerLevel(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IqPowerEdgeRefTriggerLevel, channel, out value);
        }

        /// <summary>
        ///Specifies whether the device asserts the trigger when the signal power is rising or    falling. When you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to    NIRFSA_VAL_IQ_POWER_EDGE, the device asserts the trigger when the signal power exceeds    the specified level with the slope you specify. 
        ///    Default Value: NIRFSA_VAL_RISING_SLOPE 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetIqPowerEdgeRefTriggerSlope(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.IqPowerEdgeRefTriggerSlope, channel, value);
        }
        /// <summary>
        ///Specifies whether the device asserts the trigger when the signal power is rising or    falling. When you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to    NIRFSA_VAL_IQ_POWER_EDGE, the device asserts the trigger when the signal power exceeds    the specified level with the slope you specify. 
        ///    Default Value: NIRFSA_VAL_RISING_SLOPE 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetIqPowerEdgeRefTriggerSlope(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.IqPowerEdgeRefTriggerSlope, channel, out value);
        }

        /// <summary>
        ///Specifies the channel from which the device monitors the trigger. NI-RFSA    currently supports only 0    as the value of this attribute. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int SetIqPowerEdgeRefTriggerSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.IqPowerEdgeRefTriggerSource, channel, value);
        }
        /// <summary>
        ///Specifies the channel from which the device monitors the trigger. NI-RFSA    currently supports only 0    as the value of this attribute. 
        ///    Default Value: 
        /// 
        /// </summary>
        public int GetIqPowerEdgeRefTriggerSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.IqPowerEdgeRefTriggerSource, channel, out value);
        }

        /// <summary>
        ///Specifies the I/Q rate for the acquisition The value is expressed in samples per second (S/s). 
        ///    Refer to the NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH attribute for more information about device specific instantaneous    bandwidth limits. You can also refer to the NI PXIe-5665 Specifications for more information about instantaneous bandwidth device specifications.
        ///    NOTE: For the NI 5663/5663E/5665, NI-RFSA enables dithering by default. At I/Q rates above 50 MS/s, the dither noise can affect    phase coherency performance and leak into the lower frequencies and the upper frequencies of the IF passband.    Refer to the NIRFSA_ATTR_DIGITIZER_DITHER_ENABLED attribute for more information about dithering. 
        ///    For the NI 5663/5663E/5665, when you set the NIRFSA_ATTR_DIGITIZER_SAMPLE_CLOCK_TIMEBASE_SOURCE attribute    to NIRFSA_VAL_ONBOARD_CLOCK_STR, the downconverter instantaneous bandwidth is greater than or equal to the    coerced I/Q rate times 0.8. For the NI 5665, the actual signal bandwidth is further limited by the combination of the    chosen IF filter and anti-aliasing filter.
        ///    NI 5661-You should not need to configure an I/Q rate higher than 25 megasamples per second (MS/s) because    the NI 5600 RF downconverter bandwidth is 20 MHz. If you configure a higher I/Q rate, you may see aliasing    effects at negative frequencies because the IF frequency of the NI 5600 is 15 MHz.
        ///    NI 5663/5663E-Your maximum allowed instantaneous bandwidth depends on the I/Q carrier frequency you use.    Refer to the NI 5601 RF downconverter overview for more information about instantaneous bandwidth. 
        ///    NI 5665-Your maximum allowed instantaneous bandwidth depends on the downconverter center frequency if you have enabled the preselector (YIG-tuned filter). 
        ///    Units: S/s 
        ///    Default Value: 1 MHz  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetIqRate(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.IqRate, channel, value);
        }
        /// <summary>
        ///Specifies the I/Q rate for the acquisition The value is expressed in samples per second (S/s). 
        ///    Refer to the NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH attribute for more information about device specific instantaneous    bandwidth limits. You can also refer to the NI PXIe-5665 Specifications for more information about instantaneous bandwidth device specifications.
        ///    NOTE: For the NI 5663/5663E/5665, NI-RFSA enables dithering by default. At I/Q rates above 50 MS/s, the dither noise can affect    phase coherency performance and leak into the lower frequencies and the upper frequencies of the IF passband.    Refer to the NIRFSA_ATTR_DIGITIZER_DITHER_ENABLED attribute for more information about dithering. 
        ///    For the NI 5663/5663E/5665, when you set the NIRFSA_ATTR_DIGITIZER_SAMPLE_CLOCK_TIMEBASE_SOURCE attribute    to NIRFSA_VAL_ONBOARD_CLOCK_STR, the downconverter instantaneous bandwidth is greater than or equal to the    coerced I/Q rate times 0.8. For the NI 5665, the actual signal bandwidth is further limited by the combination of the    chosen IF filter and anti-aliasing filter.
        ///    NI 5661-You should not need to configure an I/Q rate higher than 25 megasamples per second (MS/s) because    the NI 5600 RF downconverter bandwidth is 20 MHz. If you configure a higher I/Q rate, you may see aliasing    effects at negative frequencies because the IF frequency of the NI 5600 is 15 MHz.
        ///    NI 5663/5663E-Your maximum allowed instantaneous bandwidth depends on the I/Q carrier frequency you use.    Refer to the NI 5601 RF downconverter overview for more information about instantaneous bandwidth. 
        ///    NI 5665-Your maximum allowed instantaneous bandwidth depends on the downconverter center frequency if you have enabled the preselector (YIG-tuned filter). 
        ///    Units: S/s 
        ///    Default Value: 1 MHz  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetIqRate(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.IqRate, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable the LO OUT terminals on the NI 5603/5605 RF downconverter.
        ///    By default, the LO OUT terminals are not enabled. If you want to daisy-chain multiple    devices together    using the same LO source, set this attribute to VI_TRUE to export the LO input    signals on the LO1, LO2,    and LO3 terminals to LO1 OUT, LO2 OUT, and LO3 OUT, respectively. 
        ///     NOTE: For the NI 5601, the only valid value for this property is VI_TRUE.
        ///    Default Values: 
        ///    NI 5601-VI_TRUE 
        ///    NI 5603/5605-VI_FALSE  
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5665        
        /// 
        /// </summary>
        public int SetLoExportEnabled(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.LoExportEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to enable the LO OUT terminals on the NI 5603/5605 RF downconverter.
        ///    By default, the LO OUT terminals are not enabled. If you want to daisy-chain multiple    devices together    using the same LO source, set this attribute to VI_TRUE to export the LO input    signals on the LO1, LO2,    and LO3 terminals to LO1 OUT, LO2 OUT, and LO3 OUT, respectively. 
        ///     NOTE: For the NI 5601, the only valid value for this property is VI_TRUE.
        ///    Default Values: 
        ///    NI 5601-VI_TRUE 
        ///    NI 5603/5605-VI_FALSE  
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5665        
        /// 
        /// </summary>
        public int GetLoExportEnabled(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.LoExportEnabled, channel, out value);
        }

        /// <summary>
        ///Returns the LO signal frequency for the configured center frequency.
        ///    If you are using the NI RF vector signal analyzer with an external LO, use this    attribute to specify    the LO frequency that the external LO source passes into the LO IN or LO IN1 connector, located    on the RF downconverter front panel. If you are using an external LO, reading the value of this    attribute after configuring the rest of the parameters returns the LO frequency needed    by the device. 
        ///    Set this attribute to the actual LO frequency because NI-RFSA corrects    for any difference between expected and actual LO frequencies. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetLoFrequency(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.LoFrequency, channel, value);
        }
        /// <summary>
        ///Returns the LO signal frequency for the configured center frequency.
        ///    If you are using the NI RF vector signal analyzer with an external LO, use this    attribute to specify    the LO frequency that the external LO source passes into the LO IN or LO IN1 connector, located    on the RF downconverter front panel. If you are using an external LO, reading the value of this    attribute after configuring the rest of the parameters returns the LO frequency needed    by the device. 
        ///    Set this attribute to the actual LO frequency because NI-RFSA corrects    for any difference between expected and actual LO frequencies. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetLoFrequency(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.LoFrequency, channel, out value);
        }

        /// <summary>
        ///Contains the logical name you specified when opening the current IVI session. You may pass    a logical name to the niRFSA_init function or the niRFSA_InitWithOptions function.    The IVI Configuration Utility must contain an entry for the logical name. The logical name    entry refers to a driver session section in the IVI Configuration file. The driver    session section specifies a physical device and initial user options. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetLogicalName(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.LogicalName, channel, out value);
        }

        /// <summary>
        ///Specifies the LO injection side.
        ///    NI 5601/5663/5663E-For frequencies below 517.5 MHz or above 6.4125 GHz, the LO    injection side is fixed and NI-RFSA returns an error if you specify the incorrect value.    If you do not configure this attribute, NI-RFSA selects the default LO injection side    based on the downconverter center frequency. Reset this attribute to    return to automatic behavior. 
        ///    NI 5603/5605/5665 (3.6 GHz)-Setting this attribute to NIRFSA_VAL_LO_INJECTION_LOW_SIDE is not    supported for this device.   NI 5605/5665 (14 GHz)-Setting this attribute to NIRFSA_VAL_LO_INJECTION_LOW_SIDE is supported for this device for frequencies    greater than 4 GHz, but this configuration is not calibrated, and device specifications are not guaranteed. 
        ///    Default Values:
        ///    NI 5601 (external digitizer mode), NI 5663/5663E (frequencies &lt; 3.0 GHz)-NIRFSA_VAL_LO_INJECTION_HIGH_SIDE
        ///    NI 5601 (external digitizer mode), NI 5663/5663E (frequencies &gt;= 3.0 GHz)-NIRFSA_VAL_LO_INJECTION_LOW_SIDE 
        ///    NI 5603/5605 (external digitizer mode), NI 5665-NIRFSA_VAL_LO_INJECTION_HIGH_SIDE  
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetLoInjectionSide(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.LoInjectionSide, channel, value);
        }
        /// <summary>
        ///Specifies the LO injection side.
        ///    NI 5601/5663/5663E-For frequencies below 517.5 MHz or above 6.4125 GHz, the LO    injection side is fixed and NI-RFSA returns an error if you specify the incorrect value.    If you do not configure this attribute, NI-RFSA selects the default LO injection side    based on the downconverter center frequency. Reset this attribute to    return to automatic behavior. 
        ///    NI 5603/5605/5665 (3.6 GHz)-Setting this attribute to NIRFSA_VAL_LO_INJECTION_LOW_SIDE is not    supported for this device.   NI 5605/5665 (14 GHz)-Setting this attribute to NIRFSA_VAL_LO_INJECTION_LOW_SIDE is supported for this device for frequencies    greater than 4 GHz, but this configuration is not calibrated, and device specifications are not guaranteed. 
        ///    Default Values:
        ///    NI 5601 (external digitizer mode), NI 5663/5663E (frequencies &lt; 3.0 GHz)-NIRFSA_VAL_LO_INJECTION_HIGH_SIDE
        ///    NI 5601 (external digitizer mode), NI 5663/5663E (frequencies &gt;= 3.0 GHz)-NIRFSA_VAL_LO_INJECTION_LOW_SIDE 
        ///    NI 5603/5605 (external digitizer mode), NI 5665-NIRFSA_VAL_LO_INJECTION_HIGH_SIDE  
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetLoInjectionSide(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.LoInjectionSide, channel, out value);
        }

        /// <summary>
        ///Returns the current temperature, in degrees Celsius, of the LO module.    This attribute is not supported if    you are using an external LO. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetLoTemperature(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.LoTemperature, channel, out value);
        }

        /// <summary>
        ///Adjusts the dynamics of the current driving the YIG main coil.
        ///    NOTE: Setting this attribute to NIRFSA_VAL_LO_YIG_MAIN_COIL_DRIVE_FAST allows the    frequency to settle significantly faster for some frequency transitions at the    expense of increased phase noise. This attribute is not supported if you are    using an external LO. 
        ///    Default Value: NIRFSA_VAL_LO_YIG_MAIN_COIL_DRIVE_NORMAL  
        ///    Supported Devices: NI 5603/5605 (external digitizer mode), NI 5665        
        /// 
        /// </summary>
        public int SetLoYigMainCoilDrive(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.LoYigMainCoilDrive, channel, value);
        }
        /// <summary>
        ///Adjusts the dynamics of the current driving the YIG main coil.
        ///    NOTE: Setting this attribute to NIRFSA_VAL_LO_YIG_MAIN_COIL_DRIVE_FAST allows the    frequency to settle significantly faster for some frequency transitions at the    expense of increased phase noise. This attribute is not supported if you are    using an external LO. 
        ///    Default Value: NIRFSA_VAL_LO_YIG_MAIN_COIL_DRIVE_NORMAL  
        ///    Supported Devices: NI 5603/5605 (external digitizer mode), NI 5665        
        /// 
        /// </summary>
        public int GetLoYigMainCoilDrive(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.LoYigMainCoilDrive, channel, out value);
        }

        /// <summary>
        ///Specifies the level of mechanical attenuation for the RF path, in dB.
        ///    Units: dB 
        ///    Valid Values:
        ///    NI 5600-0, 10, 20, 30, 40, 50 
        ///    NI 5601-0, 16 
        ///    NI 5603-0, 10, 20, 30 
        ///    NI 5605-0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetMechanicalAttenuation(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.MechanicalAttenuation, channel, value);
        }
        /// <summary>
        ///Specifies the level of mechanical attenuation for the RF path, in dB.
        ///    Units: dB 
        ///    Valid Values:
        ///    NI 5600-0, 10, 20, 30, 40, 50 
        ///    NI 5601-0, 16 
        ///    NI 5603-0, 10, 20, 30 
        ///    NI 5605-0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetMechanicalAttenuation(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.MechanicalAttenuation, channel, out value);
        }

        /// <summary>
        ///Specifies whether the mechanical attenuator is enabled. Set this attribute to NIRFSA_VAL_ENABLED to use the mechanical atteuator.
        ///    Disabling this attenuator can improve device performance. Refer to the NI 5663/5663E    RF Attenuation and Signal Levels for more information about the attenuators. 
        ///    Default Value: NIRFSA_VAL_ENABLED 
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5663/5663E        
        /// 
        /// </summary>
        public int SetMechanicalAttenuatorEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.MechanicalAttenuatorEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether the mechanical attenuator is enabled. Set this attribute to NIRFSA_VAL_ENABLED to use the mechanical atteuator.
        ///    Disabling this attenuator can improve device performance. Refer to the NI 5663/5663E    RF Attenuation and Signal Levels for more information about the attenuators. 
        ///    Default Value: NIRFSA_VAL_ENABLED 
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5663/5663E        
        /// 
        /// </summary>
        public int GetMechanicalAttenuatorEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.MechanicalAttenuatorEnabled, channel, out value);
        }

        /// <summary>
        ///Returns the digitizer onboard memory in bytes. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5661/5663/5663E/5665       
        /// 
        /// </summary>
        public int GetMemorySize(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.MemorySize, channel, out value);
        }

        /// <summary>
        ///Specifies the minimum adjacent channel power ratio (ACPR), in dB, relative to the main channel reference level.    This attribute configures NI-RFSA to optimize downconverter gain to measure a lower power adjacent channel, adding    gain only after filtering the main channel. The gain NI-RFSA applies is always less than or equal to the ACPR value you specify.     NOTE: For the NI 5665 (3.6 GHz), this attribute is supported only if you set the NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH or NIRFSA_ATTR_SPECTRUM_SPAN    attribute to a value less than 300 kHz. For the NI 5665 (14 GHz), this attribute is supported only if you set the NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH    or NIRFSA_ATTR_SPECTRUM_SPAN attribute to a value less than 300 kHz by using the 300 kHz IF filter, or to a value    between 300 kHz and 5 MHz by using the 5 MHz IF filter. 
        ///    NI-RFSA coerces this attribute to zero for the NI 5600/5601. For all other devices, read the coerced value    of this attribute to determine the actual amount of gain applied. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetMinimumAcpr(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.MinimumAcpr, channel, value);
        }
        /// <summary>
        ///Specifies the minimum adjacent channel power ratio (ACPR), in dB, relative to the main channel reference level.    This attribute configures NI-RFSA to optimize downconverter gain to measure a lower power adjacent channel, adding    gain only after filtering the main channel. The gain NI-RFSA applies is always less than or equal to the ACPR value you specify.     NOTE: For the NI 5665 (3.6 GHz), this attribute is supported only if you set the NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH or NIRFSA_ATTR_SPECTRUM_SPAN    attribute to a value less than 300 kHz. For the NI 5665 (14 GHz), this attribute is supported only if you set the NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH    or NIRFSA_ATTR_SPECTRUM_SPAN attribute to a value less than 300 kHz by using the 300 kHz IF filter, or to a value    between 300 kHz and 5 MHz by using the 5 MHz IF filter. 
        ///    NI-RFSA coerces this attribute to zero for the NI 5600/5601. For all other devices, read the coerced value    of this attribute to determine the actual amount of gain applied. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetMinimumAcpr(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.MinimumAcpr, channel, out value);
        }

        /// <summary>
        ///Specifies the mixer level, in dBm. The mixer level represents the attenuation value to apply to    the input RF signal as it reaches the first mixer in the signal chain.    NI-RFSA automatically selects    an optimal mixer level value given the reference level if you do not configure this attribute.    You cannot set the NIRFSA_ATTR_MIXER_LEVEL and NIRFSA_ATTR_MIXER_LEVEL_OFFSET attributes    at the same time. 
        ///     NOTE: This attribute is read-only for the NI 5601/5663/5663E. It is read/write for all other supported devices.   Default Values: 
        ///    NI 5600: -30 
        ///    NI 5601: N/A 
        ///    NI 5603/5605: -10 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetMixerLevel(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.MixerLevel, channel, value);
        }
        /// <summary>
        ///Specifies the mixer level, in dBm. The mixer level represents the attenuation value to apply to    the input RF signal as it reaches the first mixer in the signal chain.    NI-RFSA automatically selects    an optimal mixer level value given the reference level if you do not configure this attribute.    You cannot set the NIRFSA_ATTR_MIXER_LEVEL and NIRFSA_ATTR_MIXER_LEVEL_OFFSET attributes    at the same time. 
        ///     NOTE: This attribute is read-only for the NI 5601/5663/5663E. It is read/write for all other supported devices.   Default Values: 
        ///    NI 5600: -30 
        ///    NI 5601: N/A 
        ///    NI 5603/5605: -10 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetMixerLevel(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.MixerLevel, channel, out value);
        }

        /// <summary>
        ///Specifies the number of dB by which to adjust the device mixer level. The default value    is 0 which specifies device settings that are the best compromise between    distortion and noise.    Specifying a positive value for this attribute configures the device for moderate distortion and    low noise, and specifying a negative value results in low distortion and higher noise. 
        ///     You cannot set the NIRFSA_ATTR_MIXER_LEVEL and NIRFSA_ATTR_MIXER_LEVEL_OFFSET attributes at    the same time. 
        ///    Units: dB    Default Value: 0 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode); NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetMixerLevelOffset(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.MixerLevelOffset, channel, value);
        }
        /// <summary>
        ///Specifies the number of dB by which to adjust the device mixer level. The default value    is 0 which specifies device settings that are the best compromise between    distortion and noise.    Specifying a positive value for this attribute configures the device for moderate distortion and    low noise, and specifying a negative value results in low distortion and higher noise. 
        ///     You cannot set the NIRFSA_ATTR_MIXER_LEVEL and NIRFSA_ATTR_MIXER_LEVEL_OFFSET attributes at    the same time. 
        ///    Units: dB    Default Value: 0 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode); NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetMixerLevelOffset(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.MixerLevelOffset, channel, out value);
        }

        /// <summary>
        ///Returns the revision of the RF downconverter module.
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetModuleRevision(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ModuleRevision, channel, out value);
        }

        /// <summary>
        ///Specifies the number of records to acquire if the    NIRFSA_ATTR_NUM_RECORDS_IS_FINITE attribute is set to VI_TRUE.   Default Value: 1 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetNumberOfRecords(string channel, long value)
        {
            return this.SetInt64(niRFSAProperties.NumberOfRecords, channel, value);
        }
        /// <summary>
        ///Specifies the number of records to acquire if the    NIRFSA_ATTR_NUM_RECORDS_IS_FINITE attribute is set to VI_TRUE.   Default Value: 1 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetNumberOfRecords(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.NumberOfRecords, channel, out value);
        }

        /// <summary>
        ///Configures the device to stop after acquiring the specified number of records    or to acquire records continuously.   Default Value: VI_TRUE 
        ///    Supported Devices: NI 5661/5663/5663E/5665          
        /// 
        /// </summary>
        public int SetNumberOfRecordsIsFinite(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.NumberOfRecordsIsFinite, channel, value);
        }
        /// <summary>
        ///Configures the device to stop after acquiring the specified number of records    or to acquire records continuously.   Default Value: VI_TRUE 
        ///    Supported Devices: NI 5661/5663/5663E/5665          
        /// 
        /// </summary>
        public int GetNumberOfRecordsIsFinite(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.NumberOfRecordsIsFinite, channel, out value);
        }

        /// <summary>
        ///Specifies the number of samples to acquire. This attribute is only valid if the    NIRFSA_ATTR_NUM_SAMPLES_IS_FINITE attribute is set to VI_TRUE.   Default Value: 1,000  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetNumberOfSamples(string channel, long value)
        {
            return this.SetInt64(niRFSAProperties.NumberOfSamples, channel, value);
        }
        /// <summary>
        ///Specifies the number of samples to acquire. This attribute is only valid if the    NIRFSA_ATTR_NUM_SAMPLES_IS_FINITE attribute is set to VI_TRUE.   Default Value: 1,000  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetNumberOfSamples(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.NumberOfSamples, channel, out value);
        }

        /// <summary>
        ///Specifies whether the device acquires a finite number of samples or acquires continuously.   Default Value: VI_TRUE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetNumberOfSamplesIsFinite(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.NumberOfSamplesIsFinite, channel, value);
        }
        /// <summary>
        ///Specifies whether the device acquires a finite number of samples or acquires continuously.   Default Value: VI_TRUE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetNumberOfSamplesIsFinite(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.NumberOfSamplesIsFinite, channel, out value);
        }

        /// <summary>
        ///Specifies the number of spectral lines expected with the current power spectrum configuration.    If you do not configure this attribute, NI-RFSA selects an appropriate value based on    the NIRFSA_ATTR_RESOLUTION_BANDWIDTH attribute. If you configure this attribute,    NI-RFSA coerces the NIRFSA_ATTR_RESOLUTION_BANDWIDTH value based on the number of    spectral lines requested and the value of the NIRFSA_ATTR_SPECTRUM_SPAN attribute. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetNumberOfSpectralLines(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.NumberOfSpectralLines, channel, value);
        }
        /// <summary>
        ///Specifies the number of spectral lines expected with the current power spectrum configuration.    If you do not configure this attribute, NI-RFSA selects an appropriate value based on    the NIRFSA_ATTR_RESOLUTION_BANDWIDTH attribute. If you configure this attribute,    NI-RFSA coerces the NIRFSA_ATTR_RESOLUTION_BANDWIDTH value based on the number of    spectral lines requested and the value of the NIRFSA_ATTR_SPECTRUM_SPAN attribute. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetNumberOfSpectralLinesAttribute(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.NumberOfSpectralLines, channel, out value);
        }

        /// <summary>
        ///Specifies the scaling factor applied to the time-domain voltage data in the IF digitizer. Use this attribute to maximize     the dynamic range of the digitizer by increasing the maximum IF power the ADC can measure without creating OSP overflows.     Because of the device amplitude response, some wide band signals normally attenuated by the signal analyzer go through the    IF digitizer without causing an ADC overflow warning. During IF equalization, these wide band digitizer input signals may become    mathematically amplified. These amplified input signal values overflow the available numeric range used in the signal processing algorithm.     You can use this attribute when OSP calculations would generate an overflow while applying digital filters to the data.    The OSP module in the digitizer multiplies the time-domain signal amplitude, in volts, by the specified attribute value before    further onboard processing. Set this attribute to a value less than 1 to avoid OSP overflow for near full-scale IF signals and to    use the maximum dynamic range of the digitizer. NI-RFSA compensates for the specified OSP data scaling factor to ensure that the    correct scaled data, in absolute levels, is always returned regardless of the value of this attribute. 
        ///    Valid Values: 0.25 to 1.0 
        ///    Default Values:
        ///    NI 5661/5663/5663E/5665 (3.6 GHz): 1.0 
        ///    NI 5665 (14 GHz): 0.8 
        ///    Supported Devices: NI 5661/5663/5663E/5665         
        /// 
        /// </summary>
        public int SetOspDataScalingFactor(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.OspDataScalingFactor, channel, value);
        }
        /// <summary>
        ///Specifies the scaling factor applied to the time-domain voltage data in the IF digitizer. Use this attribute to maximize     the dynamic range of the digitizer by increasing the maximum IF power the ADC can measure without creating OSP overflows.     Because of the device amplitude response, some wide band signals normally attenuated by the signal analyzer go through the    IF digitizer without causing an ADC overflow warning. During IF equalization, these wide band digitizer input signals may become    mathematically amplified. These amplified input signal values overflow the available numeric range used in the signal processing algorithm.     You can use this attribute when OSP calculations would generate an overflow while applying digital filters to the data.    The OSP module in the digitizer multiplies the time-domain signal amplitude, in volts, by the specified attribute value before    further onboard processing. Set this attribute to a value less than 1 to avoid OSP overflow for near full-scale IF signals and to    use the maximum dynamic range of the digitizer. NI-RFSA compensates for the specified OSP data scaling factor to ensure that the    correct scaled data, in absolute levels, is always returned regardless of the value of this attribute. 
        ///    Valid Values: 0.25 to 1.0 
        ///    Default Values:
        ///    NI 5661/5663/5663E/5665 (3.6 GHz): 1.0 
        ///    NI 5665 (14 GHz): 0.8 
        ///    Supported Devices: NI 5661/5663/5663E/5665         
        /// 
        /// </summary>
        public int GetOspDataScalingFactor(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.OspDataScalingFactor, channel, out value);
        }

        /// <summary>
        ///Specifies whether peer-to-peer streaming is enabled for the active stream endpoint.
        ///    This attribute is endpoint based. 
        ///    Default Value: VI_FALSE 
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetP2pEnabled(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.P2pEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether peer-to-peer streaming is enabled for the active stream endpoint.
        ///    This attribute is endpoint based. 
        ///    Default Value: VI_FALSE 
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetP2pEnabled(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.P2pEnabled, channel, out value);
        }

        /// <summary>
        ///Indicates whether the endpoint has overflowed. An overflow condition occurs when data    is written to the endpoint faster than it can be streamed from it. During an overflow,    data in the endpoint begins to be overwritten. Reset the device or close the session to    reset the overflow condition. 
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetP2pEndpointOverflow(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.P2pEndpointOverflow, channel, out value);
        }

        /// <summary>
        ///Returns the size, in samples, of the peer-to-peer endpoint.
        ///     Default Value: 0 
        ///    Supported Devices: NI 5663/5663E/5665         
        /// 
        /// </summary>
        public int GetP2pEndpointSize(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.P2pEndpointSize, channel, out value);
        }

        /// <summary>
        ///Returns the number of peer-to-peer streams supported by the device. 
        ///    Default Value: 0  
        ///    Supported Devices: NI 5663/5663E/5665         
        /// 
        /// </summary>
        public int GetP2pFifoEndpointCount(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.P2pFifoEndpointCount, channel, out value);
        }

        /// <summary>
        ///Returns the largest number of complex samples available in the peer-to-peer endpoint since this    attribute was last read. 
        ///    Default Value: 0  
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetP2pMostSamplesAvailableInEndpoint(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.P2pMostSamplesAvailableInEndpoint, channel, out value);
        }

        /// <summary>
        ///Specifies whether a limit is placed on the number of records and the size of the records by    the size of the device onboard memory. When a peer-to-peer stream is enabled and onboard memory    is disabled, any fetch calls result in an error. 
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int SetP2pOnboardMemoryEnabled(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.P2pOnboardMemoryEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether a limit is placed on the number of records and the size of the records by    the size of the device onboard memory. When a peer-to-peer stream is enabled and onboard memory    is disabled, any fetch calls result in an error. 
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetP2pOnboardMemoryEnabled(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.P2pOnboardMemoryEnabled, channel, out value);
        }

        /// <summary>
        ///Returns the current number of complex samples available in the peer-to-peer endpoint.
        ///    NOTE: The complex samples are composed of two 16-bit words, with the I data as the LSB. 
        ///    Default Value: 0  
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetP2pSamplesAvailableInEndpoint(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.P2pSamplesAvailableInEndpoint, channel, out value);
        }

        /// <summary>
        ///Returns the number of complex samples transferred through the peer-to-peer stream endpoint    since the endpoint was last reset. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5663/5663E/5665        
        /// 
        /// </summary>
        public int GetP2pSamplesTransferred(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.P2pSamplesTransferred, channel, out value);
        }

        /// <summary>
        ///Specifies the offset to apply to the initial I and Q phases.
        ///    Valid Values: -180 to 180 
        ///    Default Value: 0  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetPhaseOffset(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.PhaseOffset, channel, value);
        }
        /// <summary>
        ///Specifies the offset to apply to the initial I and Q phases.
        ///    Valid Values: -180 to 180 
        ///    Default Value: 0  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetPhaseOffset(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.PhaseOffset, channel, out value);
        }

        /// <summary>
        ///Specifies the units of the power spectrum. 
        ///    Default Value: NIRFSA_VAL_DBM  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetPowerSpectrumUnits(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.PowerSpectrumUnits, channel, value);
        }
        /// <summary>
        ///Specifies the units of the power spectrum. 
        ///    Default Value: NIRFSA_VAL_DBM  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetPowerSpectrumUnits(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.PowerSpectrumUnits, channel, out value);
        }

        /// <summary>
        ///Specifies whether the preselector is enabled on the downconverter. 
        ///    NOTE: All devices support setting this attribute to NIRFSA_VAL_PRESELECTOR_DISABLED. Only devices with a preselector support setting this attribute to NIRFSA_VAL_PRESLECTOR_ENABLED or NIRFSA_VAL_PRESELECTOR_ENABLED_WHEN_IN_SIGNAL_PATH. 
        ///    Default Value: NIRFSA_VAL_PRESELECTOR_DISABLED if the device has no preselector. 
        ///    NIRFSA_VAL_PRESELECTOR_ENABLED_WHEN_IN_SIGNAL_PATH if the device has a preselector.  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        [Obsolete("use DownconvertorPreselectorEnabled instead")]
        public int SetPreselectorEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.PreselectorEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether the preselector is enabled on the downconverter. 
        ///    NOTE: All devices support setting this attribute to NIRFSA_VAL_PRESELECTOR_DISABLED. Only devices with a preselector support setting this attribute to NIRFSA_VAL_PRESLECTOR_ENABLED or NIRFSA_VAL_PRESELECTOR_ENABLED_WHEN_IN_SIGNAL_PATH. 
        ///    Default Value: NIRFSA_VAL_PRESELECTOR_DISABLED if the device has no preselector. 
        ///    NIRFSA_VAL_PRESELECTOR_ENABLED_WHEN_IN_SIGNAL_PATH if the device has a preselector.  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        [Obsolete("use DownconvertorPreselectorEnabled instead")]
        public int GetPreselectorEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.PreselectorEnabled, channel, out value);
        }



        /// <summary>
        ///Returns whether a preselector is available on the RF downconverter module. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetPreselectorPresent(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.PreselectorPresent, channel, out value);
        }

        /// <summary>
        ///Specifies the signal to drive the 10 MHz Reference clock on the PXI    backplane. This option can be configured only when the NI 5600 is installed in    Slot 2 of the PXI chassis. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600 (external digitizer mode), NI 5661        
        /// 
        /// </summary>
        public int SetPxiChassisClk10Source(string channel, string value)
        {
            return this.SetString(niRFSAProperties.PxiChassisClk10Source, channel, value);
        }
        /// <summary>
        ///Specifies the signal to drive the 10 MHz Reference clock on the PXI    backplane. This option can be configured only when the NI 5600 is installed in    Slot 2 of the PXI chassis. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600 (external digitizer mode), NI 5661        
        /// 
        /// </summary>
        public int GetPxiChassisClk10Source(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.PxiChassisClk10Source, channel, out value);
        }

        /// <summary>
        ///Specifies whether NI-RFSA queries the NI-RFSA device status after each operation. Querying    the device status is useful for debugging. After you validate your program, you can set    this attribute to VI_FALSE to disable status checking and maximize performance. 
        ///    NI-RFSA can choose to ignore status checking for    particular attributes, regardless of the setting of this attribute.
        ///    NOTE: Use niRFSA_InitWithOptions function to override this value.
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetQueryInstrumentStatus(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.QueryInstrumentStatus, channel, value);
        }
        /// <summary>
        ///Specifies whether NI-RFSA queries the NI-RFSA device status after each operation. Querying    the device status is useful for debugging. After you validate your program, you can set    this attribute to VI_FALSE to disable status checking and maximize performance. 
        ///    NI-RFSA can choose to ignore status checking for    particular attributes, regardless of the setting of this attribute.
        ///    NOTE: Use niRFSA_InitWithOptions function to override this value.
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetQueryInstrumentStatus(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.QueryInstrumentStatus, channel, out value);
        }

        /// <summary>
        ///Specifies whether to validate attribute values and function parameters.    If enabled, NI-RFSA validates the parameter values that you    pass to NI-RFSA functions. Range checking parameters is very useful for    debugging. After you validate your program, you can set this attribute to    VI_FALSE to disable range checking and maximize performance.
        ///    NOTE: Use niRFSA_InitWithOptions function to override this value.
        ///    Default Value: VI_TRUE 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetRangeCheck(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.RangeCheck, channel, value);
        }
        /// <summary>
        ///Specifies whether to validate attribute values and function parameters.    If enabled, NI-RFSA validates the parameter values that you    pass to NI-RFSA functions. Range checking parameters is very useful for    debugging. After you validate your program, you can set this attribute to    VI_FALSE to disable range checking and maximize performance.
        ///    NOTE: Use niRFSA_InitWithOptions function to override this value.
        ///    Default Value: VI_TRUE 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetRangeCheck(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.RangeCheck, channel, out value);
        }

        /// <summary>
        ///Returns the fully qualified signal name as a string. 
        ///    Default Value: /DigitizerName/ReadyForAdvanceEvent, where DigitizerName is the name associated with your digitizer module in MAX. 
        ///    Supported Devices: NI 5663/5663E/5665    	 
        /// 
        /// </summary>
        public int GetReadyForAdvanceEventTerminalName(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ReadyForAdvanceEventTerminalName, channel, out value);
        }

        /// <summary>
        ///Returns the fully qualified signal name as a string. 
        ///    Default Value: /DigitizerName/ReadyForReferenceEvent, where DigitizerName is the name associated with your digitizer module in MAX. 
        ///    Supported Devices: NI 5663/5663E/5665   	 
        /// 
        /// </summary>
        public int GetReadyForRefEventTerminalName(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ReadyForRefEventTerminalName, channel, out value);
        }

        /// <summary>
        ///Returns the fully qualified signal name as a string. 
        ///    Default Value: /DigitizerName/ReadyForStartEvent, where DigitizerName is the name associated with your digitizer module in MAX. 
        ///    Supported Devices: NI 5663/5663E/5665    	 
        /// 
        /// </summary>
        public int GetReadyForStartEventTerminalName(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.ReadyForStartEventTerminalName, channel, out value);
        }

        /// <summary>
        ///Specifies whether the IVI engine keeps a list of the value coercions it    makes for integer and real type attributes.
        ///    NOTE: This attribute is currently not supported.
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: None        
        /// 
        /// </summary>
        public int SetRecordCoercions(string channel, bool value)
        {
            return this.SetBoolean(niRFSAProperties.RecordCoercions, channel, value);
        }
        /// <summary>
        ///Specifies whether the IVI engine keeps a list of the value coercions it    makes for integer and real type attributes.
        ///    NOTE: This attribute is currently not supported.
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: None        
        /// 
        /// </summary>
        public int GetRecordCoercions(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.RecordCoercions, channel, out value);
        }

        /// <summary>
        ///Returns the number of records the RF vector signal analyzer has acquired. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetRecordsDone(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.RecordsDone, channel, out value);
        }

        /// <summary>
        ///Specifies the Reference clock rate, in hertz (Hz). 
        ///    Valid Values: 
        ///    NI 5601/5663/5663E- 10 MHz 
        ///    NI 5603/5605/5665- 5 MHz to 100 MHz, in increments of 1 MHz 
        ///    Default Value: 10 MHz  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetRefClockRate(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.RefClockRate, channel, value);
        }
        /// <summary>
        ///Specifies the Reference clock rate, in hertz (Hz). 
        ///    Valid Values: 
        ///    NI 5601/5663/5663E- 10 MHz 
        ///    NI 5603/5605/5665- 5 MHz to 100 MHz, in increments of 1 MHz 
        ///    Default Value: 10 MHz  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetRefClockRate(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.RefClockRate, channel, out value);
        }

        /// <summary>
        ///Specifies the Reference clock source. 
        ///    Default Value: NIRFSA_VAL_ONBOARD_CLOCK_STR  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665         
        /// 
        /// </summary>
        public int SetRefClockSource(string channel, string value)
        {
            return this.SetString(niRFSAProperties.RefClockSource, channel, value);
        }
        /// <summary>
        ///Specifies the Reference clock source. 
        ///    Default Value: NIRFSA_VAL_ONBOARD_CLOCK_STR  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665         
        /// 
        /// </summary>
        public int GetRefClockSource(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.RefClockSource, channel, out value);
        }

        /// <summary>
        ///Specifies the reference level, in dBm. The reference level represents    the maximum expected power of an input RF signal. Refer to the    NIRFSA_ATTR_EXTERNAL_GAIN attribute for more information about how configuring    an external gain and a reference level affect attenuation. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetReferenceLevel(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.ReferenceLevel, channel, value);
        }
        /// <summary>
        ///Specifies the reference level, in dBm. The reference level represents    the maximum expected power of an input RF signal. Refer to the    NIRFSA_ATTR_EXTERNAL_GAIN attribute for more information about how configuring    an external gain and a reference level affect attenuation. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetReferenceLevel(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.ReferenceLevel, channel, out value);
        }

        /// <summary>
        ///Specifies the minimum time, in seconds, that must elapse between Reference triggers of    two records. The device does not recognize the Reference trigger of the next record    before this minimum time elapses. 
        ///    Units: seconds 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetRefToRefTriggerHoldoff(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.RefToRefTriggerHoldoff, channel, value);
        }
        /// <summary>
        ///Specifies the minimum time, in seconds, that must elapse between Reference triggers of    two records. The device does not recognize the Reference trigger of the next record    before this minimum time elapses. 
        ///    Units: seconds 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetRefToRefTriggerHoldoff(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.RefToRefTriggerHoldoff, channel, out value);
        }

        /// <summary>
        ///Specifies the trigger delay time, in seconds. The trigger delay time is the    length of time the IF digitizer waits after it receives the trigger    before it asserts the Reference event. 
        ///    Units: seconds 
        ///    Default Value: 0  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetRefTriggerDelay(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.RefTriggerDelay, channel, value);
        }
        /// <summary>
        ///Specifies the trigger delay time, in seconds. The trigger delay time is the    length of time the IF digitizer waits after it receives the trigger    before it asserts the Reference event. 
        ///    Units: seconds 
        ///    Default Value: 0  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetRefTriggerDelay(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.RefTriggerDelay, channel, out value);
        }

        /// <summary>
        ///Specifies a time duration, in seconds, for which the signal must be quiet    before the device arms the trigger. The signal is quiet when it is below the    trigger level if the trigger slope, specified by the    NIRFSA_ATTR_IQ_POWER_EDGE_REF_TRIGGER_SLOPE attribute, is set to    NIRFSA_VAL_RISING_SLOPE or above the trigger level if the trigger slope is    set to NIRFSA_VAL_FALLING_SLOPE.
        ///    By default this value is set to 0, which means the device does not wait for a    quiet time before arming the trigger. This attribute is useful to trigger the    acquisition on signals containing repeated bursts, but for which each burst    may have large changes in signal power within itself. By configuring the    minimum quiet time to the time between bursts, you can ensure that the trigger    occurs at the beginning of a burst rather than at the  signal power change within    a burst.
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetRefTriggerMinimumQuietTime(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.RefTriggerMinimumQuietTime, channel, value);
        }
        /// <summary>
        ///Specifies a time duration, in seconds, for which the signal must be quiet    before the device arms the trigger. The signal is quiet when it is below the    trigger level if the trigger slope, specified by the    NIRFSA_ATTR_IQ_POWER_EDGE_REF_TRIGGER_SLOPE attribute, is set to    NIRFSA_VAL_RISING_SLOPE or above the trigger level if the trigger slope is    set to NIRFSA_VAL_FALLING_SLOPE.
        ///    By default this value is set to 0, which means the device does not wait for a    quiet time before arming the trigger. This attribute is useful to trigger the    acquisition on signals containing repeated bursts, but for which each burst    may have large changes in signal power within itself. By configuring the    minimum quiet time to the time between bursts, you can ensure that the trigger    occurs at the beginning of a burst rather than at the  signal power change within    a burst.
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetRefTriggerMinimumQuietTime(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.RefTriggerMinimumQuietTime, channel, out value);
        }

        /// <summary>
        ///Specifies the number of pretrigger samples--the samples acquired before the    Reference trigger is received--to be acquired per record. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetRefTriggerPretriggerSamples(string channel, long value)
        {
            return this.SetInt64(niRFSAProperties.RefTriggerPretriggerSamples, channel, value);
        }
        /// <summary>
        ///Specifies the number of pretrigger samples--the samples acquired before the    Reference trigger is received--to be acquired per record. 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetRefTriggerPretriggerSamples(string channel, out long value)
        {
            return this.GetInt64(niRFSAProperties.RefTriggerPretriggerSamples, channel, out value);
        }

        /// <summary>
        ///Returns the fully qualified signal name as a string. 
        ///    Default Value: /DigitizerName/RefTrigger, where DigitizerName is the name associated with your digitizer module in MAX. 
        ///    Supported Devices: NI 5663/5663E/5665   	 
        /// 
        /// </summary>
        public int GetRefTriggerTerminalName(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.RefTriggerTerminalName, channel, out value);
        }

        /// <summary>
        ///Specifies whether you want the Reference trigger to be a digital edge, IQ    power edge, or software trigger. 
        ///    Default Value: NIRFSA_VAL_NONE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetRefTriggerType(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.RefTriggerType, channel, value);
        }
        /// <summary>
        ///Specifies whether you want the Reference trigger to be a digital edge, IQ    power edge, or software trigger. 
        ///    Default Value: NIRFSA_VAL_NONE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetRefTriggerType(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.RefTriggerType, channel, out value);
        }

        /// <summary>
        ///Specifies the resolution along the x-axis of the spectrum.    NI-RFSA uses the resolution bandwidth value to determine the acquisition size. If the    NIRFSA_ATTR_NUMBER_OF_SPECTRAL_LINES attribute is specified, that value overrides    this value. 
        ///    Units: hertz (Hz) 
        ///    Default Value: 100 kHz  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetResolutionBandwidth(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.ResolutionBandwidth, channel, value);
        }
        /// <summary>
        ///Specifies the resolution along the x-axis of the spectrum.    NI-RFSA uses the resolution bandwidth value to determine the acquisition size. If the    NIRFSA_ATTR_NUMBER_OF_SPECTRAL_LINES attribute is specified, that value overrides    this value. 
        ///    Units: hertz (Hz) 
        ///    Default Value: 100 kHz  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetResolutionBandwidth(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.ResolutionBandwidth, channel, out value);
        }

        /// <summary>
        ///Specifies how the NIRFSA_ATTR_RESOLUTION_BANDWIDTH attribute is expressed. 
        ///    Default Value: NIRFSA_VAL_RBW_3DB 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetResolutionBandwidthType(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.ResolutionBandwidthType, channel, value);
        }
        /// <summary>
        ///Specifies how the NIRFSA_ATTR_RESOLUTION_BANDWIDTH attribute is expressed. 
        ///    Default Value: NIRFSA_VAL_RBW_3DB 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetResolutionBandwidthType(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.ResolutionBandwidthType, channel, out value);
        }

        /// <summary>
        ///Specifies the attenuator setting to use from the RF attenuator table, which is    specified by the NIRFSA_ATTR_RF_ATTENUATION_TABLE attribute.
        ///    Valid Values: 0 to 65 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5603/5663/5663E        
        /// 
        /// </summary>
        public int SetRfAttenuationIndex(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.RfAttenuationIndex, channel, value);
        }
        /// <summary>
        ///Specifies the attenuator setting to use from the RF attenuator table, which is    specified by the NIRFSA_ATTR_RF_ATTENUATION_TABLE attribute.
        ///    Valid Values: 0 to 65 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5603/5663/5663E        
        /// 
        /// </summary>
        public int GetRfAttenuationIndex(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.RfAttenuationIndex, channel, out value);
        }

        /// <summary>
        ///Specifies the step size for the RF attenuation level. The actual RF attenuation is coerced up to the    next highest multiple of this step size.    You can also set this value to change the step size for the device within the supported device precision and configuration. 
        ///    NI 5600-The device configuration supports only the following attenuation step size values: 10, 20, 30, 40, and 50. 
        ///    NI 5601-The attenuation is calculated based on the actual calibrated value closest to the    desired value, so the step size varies as the actual gain values vary between consecutive attenuation settings.
        ///    NI 5603-The device configuration supports attenuation changes in 1 dB steps.
        ///    NI 5605-The available attenuation step size depends on the specified center frequency. In    the high band signal path (input frequencies greater than 3.6 GHz), the only available attenuation is the step attenuator    that you can change in 5 dB steps. In the low band signal path (input frequencies less than or     equal to 3.6 GHz), an additional 31 dB of solid-state attenuation is available in 1 dB steps.    The 5 dB default value indicates that, even when in the low band signal path, NI-RFSA changes the    attenuation in 5 dB steps using only the mechanical attenuator. You can use this property to affect     when the device changes the attenuation settings. To use the solid-state attenuation in the low band    signal path, change the step size to a value other than a multiple of 5 (for example, a step size of 1 dB).    If you use a value other than a multiple of 5 while in the high band of the NI 5605, NI-RFSA returns an error.
        ///    Valid Values: 
        ///    NI 5600:10, 20, 30, 40, and 50 
        ///    NI 5601:0.0 to 93.0, continuous 
        ///    NI 5603:1.0 to 74.0, in 1 dB steps 
        ///    NI 5605 (low band): 1.0 to 106.0, in 1 dB steps 
        ///    NI 5605 (high band): 5.0 to 75.0, in 5 dB steps 
        ///    Default Value: 
        ///    NI 5600: 10.0 
        ///    NI 5601: 0.0 
        ///    NI 5603: 1.0 
        ///    NI 5605: 5.0 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetRfAttenuationStepSize(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.RfAttenuationStepSize, channel, value);
        }
        /// <summary>
        ///Specifies the step size for the RF attenuation level. The actual RF attenuation is coerced up to the    next highest multiple of this step size.    You can also set this value to change the step size for the device within the supported device precision and configuration. 
        ///    NI 5600-The device configuration supports only the following attenuation step size values: 10, 20, 30, 40, and 50. 
        ///    NI 5601-The attenuation is calculated based on the actual calibrated value closest to the    desired value, so the step size varies as the actual gain values vary between consecutive attenuation settings.
        ///    NI 5603-The device configuration supports attenuation changes in 1 dB steps.
        ///    NI 5605-The available attenuation step size depends on the specified center frequency. In    the high band signal path (input frequencies greater than 3.6 GHz), the only available attenuation is the step attenuator    that you can change in 5 dB steps. In the low band signal path (input frequencies less than or     equal to 3.6 GHz), an additional 31 dB of solid-state attenuation is available in 1 dB steps.    The 5 dB default value indicates that, even when in the low band signal path, NI-RFSA changes the    attenuation in 5 dB steps using only the mechanical attenuator. You can use this property to affect     when the device changes the attenuation settings. To use the solid-state attenuation in the low band    signal path, change the step size to a value other than a multiple of 5 (for example, a step size of 1 dB).    If you use a value other than a multiple of 5 while in the high band of the NI 5605, NI-RFSA returns an error.
        ///    Valid Values: 
        ///    NI 5600:10, 20, 30, 40, and 50 
        ///    NI 5601:0.0 to 93.0, continuous 
        ///    NI 5603:1.0 to 74.0, in 1 dB steps 
        ///    NI 5605 (low band): 1.0 to 106.0, in 1 dB steps 
        ///    NI 5605 (high band): 5.0 to 75.0, in 5 dB steps 
        ///    Default Value: 
        ///    NI 5600: 10.0 
        ///    NI 5601: 0.0 
        ///    NI 5603: 1.0 
        ///    NI 5605: 5.0 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetRfAttenuationStepSize(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.RfAttenuationStepSize, channel, out value);
        }

        /// <summary>
        ///Specifies which RF attenuator table to use.
        ///    Valid Values: 0 to 1 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5663/5663E        
        /// 
        /// </summary>
        public int SetRfAttenuationTable(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.RfAttenuationTable, channel, value);
        }
        /// <summary>
        ///Specifies which RF attenuator table to use.
        ///    Valid Values: 0 to 1 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5601 (external digitizer mode), NI 5663/5663E        
        /// 
        /// </summary>
        public int GetRfAttenuationTable(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.RfAttenuationTable, channel, out value);
        }

        /// <summary>
        ///Specifies whether the RF Preamplifier is enabled on the downconverter. 
        ///    NOTE: All devices support setting this attribute to NIRFSA_VAL_RF_PREAMP_DISABLED.    Only devices with an RF preamplifier support setting this attribute    to NIRFSA_VAL_RF_PREAMP_ENABLED_WHEN_IN_SIGNAL_PATH or NIRFSA_VAL_RF_PREAMP_ENABLED. 
        ///    Default Value: NIRFSA_VAL_RF_PREAMP_DISABLED  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665          
        /// 
        /// </summary>
        public int SetRfPreampEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.RfPreampEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether the RF Preamplifier is enabled on the downconverter. 
        ///    NOTE: All devices support setting this attribute to NIRFSA_VAL_RF_PREAMP_DISABLED.    Only devices with an RF preamplifier support setting this attribute    to NIRFSA_VAL_RF_PREAMP_ENABLED_WHEN_IN_SIGNAL_PATH or NIRFSA_VAL_RF_PREAMP_ENABLED. 
        ///    Default Value: NIRFSA_VAL_RF_PREAMP_DISABLED  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665          
        /// 
        /// </summary>
        public int GetRfPreampEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.RfPreampEnabled, channel, out value);
        }

        /// <summary>
        ///Returns whether an RF preamplifier is available on the downconverter module.
        ///     Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetRfPreampPresent(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.RfPreampPresent, channel, out value);
        }

        /// <summary>
        ///Returns the serial number of the RF downconverter module. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetSerialNumber(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.SerialNumber, channel, out value);
        }

        /// <summary>
        ///Specifies whether or not to simulate NI-RFSA I/O operations. This attribute is    useful for debugging applications without using hardware. After a session    is opened, you cannot change the simulation state. Use the niRFSA_InitWithOptions    function to enable simulation.
        ///    NOTE: NI 5600/5661 support setting this attribute to VI_FALSE only. 
        ///    Default Value: VI_FALSE  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode); NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetSimulate(string channel, out bool value)
        {
            return this.GetBoolean(niRFSAProperties.Simulate, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains a brief description of NI-RFSA. This attribute returns    RF Signal Analyzer Instrument Driver. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetSpecificDriverDescription(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.SpecificDriverDescription, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains the prefix for NI-RFSA. The name of each user-callable    function in NI-RFSA starts with this prefix. This attribute returns niRFSA. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665         
        /// 
        /// </summary>
        public int GetSpecificDriverPrefix(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.SpecificDriverPrefix, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains additional version information about NI-RFSA.    For example, NI-RFSA can return Driver: NI-RFSA 2.5, Compiler: MSVC 7.10,    Components: IVI Engine 4.00, VISA-Spec 4.00 as the value of this attribute. 
        ///    Default Value: N/A  
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetSpecificDriverRevision(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.SpecificDriverRevision, channel, out value);
        }

        /// <summary>
        ///Returns a string that contains the name of the vendor that supplies NI-RFSA.    This attribute returns National Instruments. 
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetSpecificDriverVendor(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.SpecificDriverVendor, channel, out value);
        }

        /// <summary>
        ///Specifies the averaging mode for the spectrum acquisition. 
        ///    Default Value: NIRFSA_VAL_NO_AVERAGING  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetSpectrumAveragingMode(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.SpectrumAveragingMode, channel, value);
        }
        /// <summary>
        ///Specifies the averaging mode for the spectrum acquisition. 
        ///    Default Value: NIRFSA_VAL_NO_AVERAGING  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetSpectrumAveragingMode(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.SpectrumAveragingMode, channel, out value);
        }

        /// <summary>
        ///Specifies the center frequency in a spectrum acquisition.    An acquisition consists of a span of data surrounding    the center frequency.  The value is expressed in hertz (Hz).
        ///     NOTE: Use this attribute to tune the downconverter when using external digitizer mode. 
        ///    Units: hertz (Hz) 
        ///    Default Value: 1 GHz 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        [Obsolete("Use SetCenterFrequency()")]
        public int SetSpectrumCenterFrequency(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.SpectrumCenterFrequency, channel, value);
        }
        /// <summary>
        ///Specifies the center frequency in a spectrum acquisition.    An acquisition consists of a span of data surrounding    the center frequency.  The value is expressed in hertz (Hz).
        ///     NOTE: Use this attribute to tune the downconverter when using external digitizer mode. 
        ///    Units: hertz (Hz) 
        ///    Default Value: 1 GHz 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        [Obsolete("Use GetCenterFrequency()")]
        public int GetSpectrumCenterFrequency(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.SpectrumCenterFrequency, channel, out value);
        }



        /// <summary>
        ///Specifies the number of acquisitions to average.    The averaging process returns the final result after the number    of averages is complete.
        ///    Default Value: 10  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetSpectrumNumberOfAverages(string channel, int value)
        {
            return this.SetInt32( niRFSAProperties.SpectrumNumberOfAverages, channel,value);
        }
        /// <summary>
        ///Specifies the number of acquisitions to average.    The averaging process returns the final result after the number    of averages is complete.
        ///    Default Value: 10  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetSpectrumNumberOfAverages(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.SpectrumNumberOfAverages, channel, out value);
        }

        /// <summary>
        ///Specifies the oversampling ratio used by the the digitizer onboard signal processing (OSP)    when you are in spectrum acquisition mode. This attribute allows you to acquire a larger    bandwidth in hardware and reduce that bandwidth in software, decreasing the possibility of hardware data path overflows. 
        ///    Default Value: 1.0 
        ///    Supported Devices: NI 5661/5663/5663E/5665          
        /// 
        /// </summary>
        public int SetSpectrumOspSamplingRatio(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.SpectrumOspSamplingRatio, channel, value);
        }
        /// <summary>
        ///Specifies the oversampling ratio used by the the digitizer onboard signal processing (OSP)    when you are in spectrum acquisition mode. This attribute allows you to acquire a larger    bandwidth in hardware and reduce that bandwidth in software, decreasing the possibility of hardware data path overflows. 
        ///    Default Value: 1.0 
        ///    Supported Devices: NI 5661/5663/5663E/5665          
        /// 
        /// </summary>
        public int GetSpectrumOspSamplingRatio(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.SpectrumOspSamplingRatio, channel, out value);
        }

        /// <summary>
        ///Specifies the frequency range of the computed spectrum, in hertz (Hz).    For example, if you specify a center frequency of 1 GHz and a span of 100 MHz,    the spectrum ranges from 950 MHz to 1,050 MHz after zoom processing. This value    may be coerced based on hardware settings and RF downconverter specifications. 
        ///    NOTE: If you configure the spectrum span to a value larger than the hardware    instantaneous bandwidth, NI-RFSA performs multiple acquisitions and combines    them into a spectrum of the size you requested. 
        ///    NOTE: For the NI 5663/5663E, NI-RFSA does not support multispan acquisitions from frequency    ranges that correspond with different instantaneous bandwidths. For example, you cannot configure    a multispan acquisition that acquires one span from 110 MHz to 120 MHz and a    second from 120 MHz to    130 MHz because the bandwidths that correspond with each span is    different (10 MHz and 20 MHz, respectively).
        ///    NOTE: For the NI 5663/5663E/5665, NI-RFSA enables dithering by default.    At spans wider than 40 MHz,    the dither noise can leak into the lower frequencies and the upper frequencies    of the IF pass band.    The amount of leakage depends on the resolution bandwidth, resolution bandwidth type,    and FFT window    you select. Refer to the NIRFSA_ATTR_DIGITIZER_DITHER_ENABLED attribute for more    information about dithering. 
        ///    Default Value: 10 MHz  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetSpectrumSpan(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.SpectrumSpan, channel, value);
        }
        /// <summary>
        ///Specifies the frequency range of the computed spectrum, in hertz (Hz).    For example, if you specify a center frequency of 1 GHz and a span of 100 MHz,    the spectrum ranges from 950 MHz to 1,050 MHz after zoom processing. This value    may be coerced based on hardware settings and RF downconverter specifications. 
        ///    NOTE: If you configure the spectrum span to a value larger than the hardware    instantaneous bandwidth, NI-RFSA performs multiple acquisitions and combines    them into a spectrum of the size you requested. 
        ///    NOTE: For the NI 5663/5663E, NI-RFSA does not support multispan acquisitions from frequency    ranges that correspond with different instantaneous bandwidths. For example, you cannot configure    a multispan acquisition that acquires one span from 110 MHz to 120 MHz and a    second from 120 MHz to    130 MHz because the bandwidths that correspond with each span is    different (10 MHz and 20 MHz, respectively).
        ///    NOTE: For the NI 5663/5663E/5665, NI-RFSA enables dithering by default.    At spans wider than 40 MHz,    the dither noise can leak into the lower frequencies and the upper frequencies    of the IF pass band.    The amount of leakage depends on the resolution bandwidth, resolution bandwidth type,    and FFT window    you select. Refer to the NIRFSA_ATTR_DIGITIZER_DITHER_ENABLED attribute for more    information about dithering. 
        ///    Default Value: 10 MHz  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetSpectrumSpan(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.SpectrumSpan, channel, out value);
        }

        /// <summary>
        ///Specifies the minimum time, in seconds, that must elapse after the Start trigger is    received before the device recognizes a Reference trigger. 
        ///    Units: seconds 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetStartToRefTriggerHoldoff(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.StartToRefTriggerHoldoff, channel, value);
        }
        /// <summary>
        ///Specifies the minimum time, in seconds, that must elapse after the Start trigger is    received before the device recognizes a Reference trigger. 
        ///    Units: seconds 
        ///    Default Value: 0 
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetStartToRefTriggerHoldoff(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.StartToRefTriggerHoldoff, channel, out value);
        }

        /// <summary>
        ///Returns the fully qualified signal name as a string. 
        ///    Default Value: /DigitizerName/StartTrigger, where DigitizerName is the name associated with your digitizer module in MAX.  
        ///    Supported Devices: NI 5663/5663E/5665   	 
        /// 
        /// </summary>
        public int GetStartTriggerTerminalName(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.StartTriggerTerminalName, channel, out value);
        }

        /// <summary>
        ///Specifies whether you want the Start trigger to be a digital edge or    software trigger.
        ///    Default Value: NIRFSA_VAL_NONE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetStartTriggerType(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.StartTriggerType, channel, value);
        }
        /// <summary>
        ///Specifies whether you want the Start trigger to be a digital edge or    software trigger.
        ///    Default Value: NIRFSA_VAL_NONE  
        ///    Supported Devices: NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetStartTriggerType(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.StartTriggerType, channel, out value);
        }

        /// <summary>
        ///Returns a comma-separated list of supported devices.
        ///    Default Value: N/A 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetSupportedInstrumentModels(string channel, out string value)
        {
            return this.GetString(niRFSAProperties.SupportedInstrumentModels, channel, out value);
        }

        /// <summary>
        ///Indicates the minimum time between temperature sensor readings. When you    call the niRFSA_ReadPowerSpectrum function, the niRFSA_ReadIQSingleRecordComplexF64 function,    or the niRFSA_Initiate function, NI-RFSA checks whether at least the amount of    time specified by this attribute has elapsed before reading the hardware temperature. 
        ///    NOTE: NI-RFSA ignores this attribute if you called the niRFSA_PerformThermalCorrection    function or the NIRFSA_ATTR_DOWNCONVERTER_GAIN attribute. 
        ///    Default Value: 30 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int SetTemperatureReadInterval(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.TemperatureReadInterval, channel, value);
        }
        /// <summary>
        ///Indicates the minimum time between temperature sensor readings. When you    call the niRFSA_ReadPowerSpectrum function, the niRFSA_ReadIQSingleRecordComplexF64 function,    or the niRFSA_Initiate function, NI-RFSA checks whether at least the amount of    time specified by this attribute has elapsed before reading the hardware temperature. 
        ///    NOTE: NI-RFSA ignores this attribute if you called the niRFSA_PerformThermalCorrection    function or the NIRFSA_ATTR_DOWNCONVERTER_GAIN attribute. 
        ///    Default Value: 30 
        ///    Supported Devices: NI 5600/5601/5603/5605 (external digitizer mode), NI 5661/5663/5663E/5665        
        /// 
        /// </summary>
        public int GetTemperatureReadInterval(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.TemperatureReadInterval, channel, out value);
        }

        /// <summary>
        ///Specifies the time, in seconds, that the timer waits before sending a Timer event. 
        ///    After the timer reaches zero, it automatically restarts. 
        ///    Default Value: 0.01  
        ///    Supported Devices: NI 5663E/5665       
        /// 
        /// </summary>
        public int SetTimerEventInterval(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.TimerEventInterval, channel, value);
        }
        /// <summary>
        ///Specifies the time, in seconds, that the timer waits before sending a Timer event. 
        ///    After the timer reaches zero, it automatically restarts. 
        ///    Default Value: 0.01  
        ///    Supported Devices: NI 5663E/5665       
        /// 
        /// </summary>
        public int GetTimerEventInterval(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.TimerEventInterval, channel, out value);
        }

        /// <summary>
        ///Specifies the FFT width of the device. The FFT width is the effective bandwidth of the signal
        ///    path during each signal acquisition.
        ///    Default Value: N/A
        ///    Supported Devices: NI 5663/5663E/5665
        /// 
        /// </summary>
        public int SetFftWidth(string channel, double value)
        {
            return this.SetDouble(niRFSAProperties.FftWidth, channel, value);
        }
        
        /// <summary>
        ///Specifies the FFT width of the device. The FFT width is the effective bandwidth of the signal
        ///    path during each signal acquisition.
        ///    Default Value: N/A
        ///    Supported Devices: NI 5663/5663E/5665
        /// 
        /// </summary>
        public int GetFftWidth(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.FftWidth, channel, out value);
        }

        /// <summary>
        ///Specifies whether input isolation is enabled.
        ///    Enabling this attribute isolates the input signal at the RF IN connector on the RF downconverter
        ///    from the rest of the RF downconverter signal path. Disabling this attribute reintegrates the
        ///    input signal into the RF downconverter signal path.
        ///    NOTE: If you enable input isolation for your device, the device impedance is changed from the
        ///    characteristic 50 Ohm impedance. A change in the device impedance may also cause a VSWR value
        ///    higher than the device specifications.
        ///    Default Values: NIRFSA_VAL_ENABLED
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665
        /// </summary>
        public int SetInputIsolationEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.InputIsolationEnabled, channel, value);
        }
        
        /// <summary>
        ///Specifies whether input isolation is enabled.
        ///    Enabling this attribute isolates the input signal at the RF IN connector on the RF downconverter
        ///    from the rest of the RF downconverter signal path. Disabling this attribute reintegrates the
        ///    input signal into the RF downconverter signal path.
        ///    NOTE: If you enable input isolation for your device, the device impedance is changed from the
        ///    characteristic 50 Ohm impedance. A change in the device impedance may also cause a VSWR value
        ///    higher than the device specifications.
        ///    Default Values: NIRFSA_VAL_ENABLED
        ///    Supported Devices: NI 5601/5603/5605 (external digitizer mode), NI 5663/5663E/5665
        /// </summary>
        public int GetInputIsolationEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.InputIsolationEnabled, channel, out value);
        }


        
        /// <summary>
        ///Specifies whether the digitizer OSP block delays Reference triggers, along with the data
        ///    samples, moving through the OSP block or if the Reference triggers bypass the OSP block 
        ///    and are processed immediately.
        ///    Enabling this attribute requires the following equipment configurations:
        ///    All digitizers being used must be the same model and hardware revision.
        ///    All digitizers must use the same firmware.
        ///    All digitizers must be configured with the same I/Q rate. 
        ///    All devices must use the same signal path. 
        ///    NI 5661The IF filters for the NI 5661 are determined by the incoming frequency.
        ///    NI 5663/5663ERead the value of the NIRFSA_ATTR_IF_FILTER attribute to determine the 
        ///    IF filters used by the NI 5663/5663E.
        ///    NI 5665Refer to the device-specific information in the
        ///    NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH attribute to determine the IF filters used by 
        ///    the NI 5665. If you set the NIRFSA_ATTR_FFT_WIDTH attribute, refer to the device-specific
        ///    information for this attribute and the NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH attribute
        ///    to determine the IF filters used. For frequencies less than 3.6 GHz, set the
        ///    NIRFSA_ATTR_RF_PREAMP_ENABLED to the same value for all devices.
        ///    NI 5665 14 GHzSet the NIRFSA_ATTR_PRESELECTOR_ENABLED to the same value for all devices.
        ///    If the I/Q rate is set programmatically for I/Q acquisitions, the following attributes 
        ///    should be identical for the best device synchronization:
        ///    NIRFSA_ATTR_DIGITAL_IF_EQUALIZATION_ENABLED 
        ///    NIRFSA_ATTR_SPECTRUM_OSP_SAMPLING_RATIO 
        ///    For spectrum acquisitions, the following attributes should be identical for the 
        ///    best device synchronization:
        ///    NIRFSA_ATTR_SPECTRUM_SPAN 
        ///    NIRFSA_ATTR_RESOLUTION_BANDWIDTH_TYPE 
        ///    NIRFSA_ATTR_DIGITAL_IF_EQUALIZATION_ENABLED
        ///    NIRFSA_ATTR_SPECTRUM_OSP_SAMPLING_RATIO 
        ///    Default Value: NIRFSA_VAL_ENABLED 
        ///    Supported Devices: NI 5661/5663/5663E/5665
        /// </summary>
        public int SetRefTriggerOspDelayEnabled(string channel, int value)
        {
            return this.SetInt32(niRFSAProperties.RefTriggerOspDelayEnabled, channel, value);
        }
        
        /// <summary>
        ///Specifies whether the digitizer OSP block delays Reference triggers, along with the data
        ///    samples, moving through the OSP block or if the Reference triggers bypass the OSP block 
        ///    and are processed immediately.
        ///    Enabling this attribute requires the following equipment configurations:
        ///    All digitizers being used must be the same model and hardware revision.
        ///    All digitizers must use the same firmware.
        ///    All digitizers must be configured with the same I/Q rate. 
        ///    All devices must use the same signal path. 
        ///    NI 5661The IF filters for the NI 5661 are determined by the incoming frequency.
        ///    NI 5663/5663ERead the value of the NIRFSA_ATTR_IF_FILTER attribute to determine the 
        ///    IF filters used by the NI 5663/5663E.
        ///    NI 5665Refer to the device-specific information in the
        ///    NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH attribute to determine the IF filters used by 
        ///    the NI 5665. If you set the NIRFSA_ATTR_FFT_WIDTH attribute, refer to the device-specific
        ///    information for this attribute and the NIRFSA_ATTR_DEVICE_INSTANTANEOUS_BANDWIDTH attribute
        ///    to determine the IF filters used. For frequencies less than 3.6 GHz, set the
        ///    NIRFSA_ATTR_RF_PREAMP_ENABLED to the same value for all devices.
        ///    NI 5665 14 GHzSet the NIRFSA_ATTR_PRESELECTOR_ENABLED to the same value for all devices.
        ///    If the I/Q rate is set programmatically for I/Q acquisitions, the following attributes 
        ///    should be identical for the best device synchronization:
        ///    NIRFSA_ATTR_DIGITAL_IF_EQUALIZATION_ENABLED 
        ///    NIRFSA_ATTR_SPECTRUM_OSP_SAMPLING_RATIO 
        ///    For spectrum acquisitions, the following attributes should be identical for the 
        ///    best device synchronization:
        ///    NIRFSA_ATTR_SPECTRUM_SPAN 
        ///    NIRFSA_ATTR_RESOLUTION_BANDWIDTH_TYPE 
        ///    NIRFSA_ATTR_DIGITAL_IF_EQUALIZATION_ENABLED
        ///    NIRFSA_ATTR_SPECTRUM_OSP_SAMPLING_RATIO 
        ///    Default Value: NIRFSA_VAL_ENABLED 
        ///    Supported Devices: NI 5661/5663/5663E/5665
        /// </summary>
        public int GetRefTriggerOspDelayEnabled(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.RefTriggerOspDelayEnabled, channel, out value);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetChannelCount(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.ChannelCount, channel, out value);
        }
	/// <summary>
	/// 
	/// </summary>
	/// <param name="channel"></param>
	/// <param name="value"></param>
	/// <returns></returns>
        public int GetGroupCapabilities(string channel, out double value)
        {
            return this.GetDouble(niRFSAProperties.GroupCapabilities, channel, out value);
        }
	/// <summary>
	/// 
	/// </summary>
	/// <param name="channel"></param>
	/// <param name="value"></param>
	/// <returns></returns>
        public int GetSpecificDriverClassSpecMajorVersion(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.SpecificDriverClassSpecMajorVersion, channel, out value);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpecificDriverClassSpecMinorVersion(string channel, out int value)
        {
            return this.GetInt32(niRFSAProperties.SpecificDriverClassSpecMinorVersion, channel, out value);
        }

        #endregion GetSetMethodsForAttributes

        #region PInvoke
        private class PInvoke
        {
            private const string rfsaModuleName32 = "niRFSA.dll";
            private const string rfsaModuleName64 = "niRFSA_64.dll";

            // Define the readonly field to check for process' bitness.
            private static readonly bool Is64BitProcess = (IntPtr.Size == 8);

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_init", CallingConvention = CallingConvention.StdCall)]
            public static extern int init32(string Resource_Name, ushort ID_Query, ushort Reset, out System.IntPtr instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_init", CallingConvention = CallingConvention.StdCall)]
            public static extern int init64(string Resource_Name, ushort ID_Query, ushort Reset, out System.IntPtr instrumentHandle);

            public static int init(string Resource_Name, ushort ID_Query, ushort Reset, out System.IntPtr instrumentHandle)
            {
                if (Is64BitProcess)
                    return init64(Resource_Name, ID_Query, Reset, out instrumentHandle);
                else
                    return init32(Resource_Name, ID_Query, Reset, out instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_InitWithOptions", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitWithOptions32(string Resource_Name, ushort ID_Query, ushort Reset, string Option_String, out System.IntPtr instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_InitWithOptions", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitWithOptions64(string Resource_Name, ushort ID_Query, ushort Reset, string Option_String, out System.IntPtr instrumentHandle);

            public static int InitWithOptions(string Resource_Name, ushort ID_Query, ushort Reset, string Option_String, out System.IntPtr instrumentHandle)
            {
                if (Is64BitProcess)
                    return InitWithOptions64(Resource_Name, ID_Query, Reset, Option_String, out instrumentHandle);
                else
                    return InitWithOptions32(Resource_Name, ID_Query, Reset, Option_String, out instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureAcquisitionType", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureAcquisitionType32(HandleRef instrumentHandle, int Acquisition_Type);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureAcquisitionType", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureAcquisitionType64(HandleRef instrumentHandle, int Acquisition_Type);

            public static int ConfigureAcquisitionType(HandleRef instrumentHandle, int Acquisition_Type)
            {
                if (Is64BitProcess)
                    return ConfigureAcquisitionType64(instrumentHandle, Acquisition_Type);
                else
                    return ConfigureAcquisitionType32(instrumentHandle, Acquisition_Type);
            }
            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_EnableSessionAccess", CallingConvention = CallingConvention.StdCall)]
            public static extern int EnableSessionAccess32(HandleRef instrumentHandle, bool enable);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_EnableSessionAccess", CallingConvention = CallingConvention.StdCall)]
            public static extern int EnableSessionAccess64(HandleRef instrumentHandle, bool enable);

            public static int EnableSessionAccess(HandleRef instrumentHandle, bool enable)
            {
                if (Is64BitProcess)
                    return EnableSessionAccess64(instrumentHandle, enable);
                else
                    return EnableSessionAccess32(instrumentHandle, enable);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureReferenceLevel", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureReferenceLevel32(HandleRef instrumentHandle, string Channel_List, double Reference_Level);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureReferenceLevel", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureReferenceLevel64(HandleRef instrumentHandle, string Channel_List, double Reference_Level);

            public static int ConfigureReferenceLevel(HandleRef instrumentHandle, string Channel_List, double Reference_Level)
            {
                if (Is64BitProcess)
                    return ConfigureReferenceLevel64(instrumentHandle, Channel_List, Reference_Level);
                else
                    return ConfigureReferenceLevel32(instrumentHandle, Channel_List, Reference_Level);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureIQCarrierFrequency", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureIQCarrierFrequency32(HandleRef instrumentHandle, string Channel_List, double Carrier_Frequency);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureIQCarrierFrequency", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureIQCarrierFrequency64(HandleRef instrumentHandle, string Channel_List, double Carrier_Frequency);

            public static int ConfigureIQCarrierFrequency(HandleRef instrumentHandle, string Channel_List, double Carrier_Frequency)
            {
                if (Is64BitProcess)
                    return ConfigureIQCarrierFrequency64(instrumentHandle, Channel_List, Carrier_Frequency);
                else
                    return ConfigureIQCarrierFrequency32(instrumentHandle, Channel_List, Carrier_Frequency);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CalAdjustCalTonePower", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustCalTonePower32(HandleRef instrumentHandle, string Channel_List, double Measurement);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CalAdjustCalTonePower", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustCalTonePower64(HandleRef instrumentHandle, string Channel_List, double Measurement);

            public static int CalAdjustCalTonePower(HandleRef instrumentHandle, string Channel_List, double Measurement)
            {
                if (Is64BitProcess)
                    return CalAdjustCalTonePower64(instrumentHandle, Channel_List, Measurement);
                else
                    return CalAdjustCalTonePower32(instrumentHandle, Channel_List, Measurement);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CalAdjustDeviceGain", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustDeviceGain32(HandleRef instrumentHandle, string Channel_List, double Frequency, double Gain);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CalAdjustDeviceGain", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustDeviceGain64(HandleRef instrumentHandle, string Channel_List, double Frequency, double Gain);

            public static int CalAdjustDeviceGain(HandleRef instrumentHandle, string Channel_List, double Frequency, double Gain)
            {
                if (Is64BitProcess)
                    return CalAdjustDeviceGain64(instrumentHandle, Channel_List, Frequency, Gain);
                else
                    return CalAdjustDeviceGain32(instrumentHandle, Channel_List, Frequency, Gain);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SelfCalibrateRange", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelfCalibrateRange32(HandleRef instrumentHandle, long stepsToOmit, double minFrequency, double maxFrequency, double minReferenceLevel, double maxReferenceLevel);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SelfCalibrateRange", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelfCalibrateRange64(HandleRef instrumentHandle, long stepsToOmit, double minFrequency, double maxFrequency, double minReferenceLevel, double maxReferenceLevel);


            public static int SelfCalibrateRange(HandleRef instrumentHandle, long stepsToOmit,double minFrequency,double maxFrequency,double minReferenceLevel,double maxReferenceLevel)
            {
                if (Is64BitProcess)
                    return SelfCalibrateRange64(instrumentHandle, stepsToOmit, minFrequency, maxFrequency, minReferenceLevel, maxReferenceLevel);
                else
                    return SelfCalibrateRange32(instrumentHandle, stepsToOmit, minFrequency, maxFrequency, minReferenceLevel, maxReferenceLevel);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureIQRate", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureIQRate32(HandleRef instrumentHandle, string Channel_List, double IQ_Rate);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureIQRate", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureIQRate64(HandleRef instrumentHandle, string Channel_List, double IQ_Rate);

            public static int ConfigureIQRate(HandleRef instrumentHandle, string Channel_List, double IQ_Rate)
            {
                if (Is64BitProcess)
                    return ConfigureIQRate64(instrumentHandle, Channel_List, IQ_Rate);
                else
                    return ConfigureIQRate32(instrumentHandle, Channel_List, IQ_Rate);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureNumberOfSamples", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureNumberOfSamples32(HandleRef instrumentHandle, string Channel_List, ushort Number_of_Samples_Is_Finite, Int64 Samples_Per_Record);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureNumberOfSamples", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureNumberOfSamples64(HandleRef instrumentHandle, string Channel_List, ushort Number_of_Samples_Is_Finite, Int64 Samples_Per_Record);

            public static int ConfigureNumberOfSamples(HandleRef instrumentHandle, string Channel_List, ushort Number_of_Samples_Is_Finite, Int64 Samples_Per_Record)
            {
                if (Is64BitProcess)
                    return ConfigureNumberOfSamples64(instrumentHandle, Channel_List, Number_of_Samples_Is_Finite, Samples_Per_Record);
                else
                    return ConfigureNumberOfSamples32(instrumentHandle, Channel_List, Number_of_Samples_Is_Finite, Samples_Per_Record);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureNumberOfRecords", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureNumberOfRecords32(HandleRef instrumentHandle, string Channel_List, ushort Number_of_Records_Is_Finite, Int64 Number_of_Records);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureNumberOfRecords", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureNumberOfRecords64(HandleRef instrumentHandle, string Channel_List, ushort Number_of_Records_Is_Finite, Int64 Number_of_Records);

            public static int ConfigureNumberOfRecords(HandleRef instrumentHandle, string Channel_List, ushort Number_of_Records_Is_Finite, Int64 Number_of_Records)
            {
                if (Is64BitProcess)
                    return ConfigureNumberOfRecords64(instrumentHandle, Channel_List, Number_of_Records_Is_Finite, Number_of_Records);
                else
                    return ConfigureNumberOfRecords32(instrumentHandle, Channel_List, Number_of_Records_Is_Finite, Number_of_Records);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureSpectrumFrequencyCenterSpan", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSpectrumFrequencyCenterSpan32(HandleRef instrumentHandle, string Channel_List, double Center_Frequency, double Span);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureSpectrumFrequencyCenterSpan", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSpectrumFrequencyCenterSpan64(HandleRef instrumentHandle, string Channel_List, double Center_Frequency, double Span);

            public static int ConfigureSpectrumFrequencyCenterSpan(HandleRef instrumentHandle, string Channel_List, double Center_Frequency, double Span)
            {
                if (Is64BitProcess)
                    return ConfigureSpectrumFrequencyCenterSpan64(instrumentHandle, Channel_List, Center_Frequency, Span);
                else
                    return ConfigureSpectrumFrequencyCenterSpan32(instrumentHandle, Channel_List, Center_Frequency, Span);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureSpectrumFrequencyStartStop", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSpectrumFrequencyStartStop32(HandleRef instrumentHandle, string Channel_List, double Start_Frequency, double Stop_Frequency);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureSpectrumFrequencyStartStop", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSpectrumFrequencyStartStop64(HandleRef instrumentHandle, string Channel_List, double Start_Frequency, double Stop_Frequency);

            public static int ConfigureSpectrumFrequencyStartStop(HandleRef instrumentHandle, string Channel_List, double Start_Frequency, double Stop_Frequency)
            {
                if (Is64BitProcess)
                    return ConfigureSpectrumFrequencyStartStop64(instrumentHandle, Channel_List, Start_Frequency, Stop_Frequency);
                else
                    return ConfigureSpectrumFrequencyStartStop32(instrumentHandle, Channel_List, Start_Frequency, Stop_Frequency);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureResolutionBandwidth", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureResolutionBandwidth32(HandleRef instrumentHandle, string Channel_List, double Resolution_Bandwidth);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureResolutionBandwidth", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureResolutionBandwidth64(HandleRef instrumentHandle, string Channel_List, double Resolution_Bandwidth);

            public static int ConfigureResolutionBandwidth(HandleRef instrumentHandle, string Channel_List, double Resolution_Bandwidth)
            {
                if (Is64BitProcess)
                    return ConfigureResolutionBandwidth64(instrumentHandle, Channel_List, Resolution_Bandwidth);
                else
                    return ConfigureResolutionBandwidth32(instrumentHandle, Channel_List, Resolution_Bandwidth);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureDigitalEdgeStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeStartTrigger32(HandleRef instrumentHandle, string Source, int Edge);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureDigitalEdgeStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeStartTrigger64(HandleRef instrumentHandle, string Source, int Edge);

            public static int ConfigureDigitalEdgeStartTrigger(HandleRef instrumentHandle, string Source, int Edge)
            {
                if (Is64BitProcess)
                    return ConfigureDigitalEdgeStartTrigger64(instrumentHandle, Source, Edge);
                else
                    return ConfigureDigitalEdgeStartTrigger32(instrumentHandle, Source, Edge);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureSoftwareEdgeStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSoftwareEdgeStartTrigger32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureSoftwareEdgeStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSoftwareEdgeStartTrigger64(HandleRef instrumentHandle);

            public static int ConfigureSoftwareEdgeStartTrigger(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return ConfigureSoftwareEdgeStartTrigger64(instrumentHandle);
                else
                    return ConfigureSoftwareEdgeStartTrigger32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_DisableStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableStartTrigger32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_DisableStartTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableStartTrigger64(HandleRef instrumentHandle);

            public static int DisableStartTrigger(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return DisableStartTrigger64(instrumentHandle);
                else
                    return DisableStartTrigger32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_InvalidateAllAttributes", CallingConvention = CallingConvention.StdCall)]
            public static extern int InvalidateAllAttributes32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_InvalidateAllAttributes", CallingConvention = CallingConvention.StdCall)]
            public static extern int InvalidateAllAttributes64(HandleRef instrumentHandle);

            public static int InvalidateAllAttributes(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return InvalidateAllAttributes64(instrumentHandle);
                else
                    return InvalidateAllAttributes32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ResetWithDefaults", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetWithDefaults32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ResetWithDefaults", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetWithDefaults64(HandleRef instrumentHandle);

            public static int ResetWithDefaults(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return ResetWithDefaults64(instrumentHandle);
                else
                    return ResetWithDefaults32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_Disable", CallingConvention = CallingConvention.StdCall)]
            public static extern int Disable32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_Disable", CallingConvention = CallingConvention.StdCall)]
            public static extern int Disable64(HandleRef instrumentHandle);

            public static int Disable(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return Disable64(instrumentHandle);
                else
                    return Disable32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureDigitalEdgeRefTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeRefTrigger32(HandleRef instrumentHandle, string Source, int Edge, Int64 Pretrigger_Samples);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureDigitalEdgeRefTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeRefTrigger64(HandleRef instrumentHandle, string Source, int Edge, Int64 Pretrigger_Samples);

            public static int ConfigureDigitalEdgeRefTrigger(HandleRef instrumentHandle, string Source, int Edge, Int64 Pretrigger_Samples)
            {
                if (Is64BitProcess)
                    return ConfigureDigitalEdgeRefTrigger64(instrumentHandle, Source, Edge, Pretrigger_Samples);
                else
                    return ConfigureDigitalEdgeRefTrigger32(instrumentHandle, Source, Edge, Pretrigger_Samples);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureIQPowerEdgeRefTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureIQPowerEdgeRefTrigger32(HandleRef instrumentHandle, string Source, double Level, int Slope, Int64 Pretrigger_Samples);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureIQPowerEdgeRefTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureIQPowerEdgeRefTrigger64(HandleRef instrumentHandle, string Source, double Level, int Slope, Int64 Pretrigger_Samples);

            public static int ConfigureIQPowerEdgeRefTrigger(HandleRef instrumentHandle, string Source, double Level, int Slope, Int64 Pretrigger_Samples)
            {
                if (Is64BitProcess)
                    return ConfigureIQPowerEdgeRefTrigger64(instrumentHandle, Source, Level, Slope, Pretrigger_Samples);
                else
                    return ConfigureIQPowerEdgeRefTrigger32(instrumentHandle, Source, Level, Slope, Pretrigger_Samples);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureSoftwareEdgeRefTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSoftwareEdgeRefTrigger32(HandleRef instrumentHandle, Int64 Pretrigger_Samples);


            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureSoftwareEdgeRefTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSoftwareEdgeRefTrigger64(HandleRef instrumentHandle, Int64 Pretrigger_Samples);

            public static int ConfigureSoftwareEdgeRefTrigger(HandleRef instrumentHandle, Int64 Pretrigger_Samples)
            {
                if (Is64BitProcess)
                    return ConfigureSoftwareEdgeRefTrigger64(instrumentHandle, Pretrigger_Samples);
                else
                    return ConfigureSoftwareEdgeRefTrigger32(instrumentHandle, Pretrigger_Samples);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_DisableRefTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableRefTrigger32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_DisableRefTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableRefTrigger64(HandleRef instrumentHandle);

            public static int DisableRefTrigger(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return DisableRefTrigger64(instrumentHandle);
                else
                    return DisableRefTrigger32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureDigitalEdgeAdvanceTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeAdvanceTrigger32(HandleRef instrumentHandle, string Source, int Edge);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureDigitalEdgeAdvanceTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureDigitalEdgeAdvanceTrigger64(HandleRef instrumentHandle, string Source, int Edge);

            public static int ConfigureDigitalEdgeAdvanceTrigger(HandleRef instrumentHandle, string Source, int Edge)
            {
                if (Is64BitProcess)
                    return ConfigureDigitalEdgeAdvanceTrigger64(instrumentHandle, Source, Edge);
                else
                    return ConfigureDigitalEdgeAdvanceTrigger32(instrumentHandle, Source, Edge);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureSoftwareEdgeAdvanceTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSoftwareEdgeAdvanceTrigger32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureSoftwareEdgeAdvanceTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureSoftwareEdgeAdvanceTrigger64(HandleRef instrumentHandle);

            public static int ConfigureSoftwareEdgeAdvanceTrigger(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return ConfigureSoftwareEdgeAdvanceTrigger64(instrumentHandle);
                else
                    return ConfigureSoftwareEdgeAdvanceTrigger32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_DisableAdvanceTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableAdvanceTrigger32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_DisableAdvanceTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int DisableAdvanceTrigger64(HandleRef instrumentHandle);

            public static int DisableAdvanceTrigger(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return DisableAdvanceTrigger64(instrumentHandle);
                else
                    return DisableAdvanceTrigger32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SendSoftwareEdgeTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int SendSoftwareEdgeTrigger32(HandleRef instrumentHandle, int Trigger, string Trigger_Identifier);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SendSoftwareEdgeTrigger", CallingConvention = CallingConvention.StdCall)]
            public static extern int SendSoftwareEdgeTrigger64(HandleRef instrumentHandle, int Trigger, string Trigger_Identifier);

            public static int SendSoftwareEdgeTrigger(HandleRef instrumentHandle, int Trigger, string Trigger_Identifier)
            {
                if (Is64BitProcess)
                    return SendSoftwareEdgeTrigger64(instrumentHandle, Trigger, Trigger_Identifier);
                else
                    return SendSoftwareEdgeTrigger32(instrumentHandle, Trigger, Trigger_Identifier);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ExportSignal", CallingConvention = CallingConvention.StdCall)]
            public static extern int ExportSignal32(HandleRef instrumentHandle, int Signal, string Signal_Identifier, string Output_Terminal);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ExportSignal", CallingConvention = CallingConvention.StdCall)]
            public static extern int ExportSignal64(HandleRef instrumentHandle, int Signal, string Signal_Identifier, string Output_Terminal);

            public static int ExportSignal(HandleRef instrumentHandle, int Signal, string Signal_Identifier, string Output_Terminal)
            {
                if (Is64BitProcess)
                    return ExportSignal64(instrumentHandle, Signal, Signal_Identifier, Output_Terminal);
                else
                    return ExportSignal32(instrumentHandle, Signal, Signal_Identifier, Output_Terminal);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigureRefClock", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureRefClock32(HandleRef instrumentHandle, string Ref_Clock_Source, double Ref_Clock_Rate);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigureRefClock", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigureRefClock64(HandleRef instrumentHandle, string Ref_Clock_Source, double Ref_Clock_Rate);

            public static int ConfigureRefClock(HandleRef instrumentHandle, string Ref_Clock_Source, double Ref_Clock_Rate)
            {
                if (Is64BitProcess)
                    return ConfigureRefClock64(instrumentHandle, Ref_Clock_Source, Ref_Clock_Rate);
                else
                    return ConfigureRefClock32(instrumentHandle, Ref_Clock_Source, Ref_Clock_Rate);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ConfigurePXIChassisClk10", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigurePXIChassisClk10_32(HandleRef instrumentHandle, string PXI_Clk_10_Source);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ConfigurePXIChassisClk10", CallingConvention = CallingConvention.StdCall)]
            public static extern int ConfigurePXIChassisClk10_64(HandleRef instrumentHandle, string PXI_Clk_10_Source);

            public static int ConfigurePXIChassisClk10(HandleRef instrumentHandle, string PXI_Clk_10_Source)
            {
                if (Is64BitProcess)
                    return ConfigurePXIChassisClk10_64(instrumentHandle, PXI_Clk_10_Source);
                else
                    return ConfigurePXIChassisClk10_32(instrumentHandle, PXI_Clk_10_Source);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ResetAttribute", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetAttribute32(HandleRef instrumentHandle, string Channel_Name, int Attribute_ID);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ResetAttribute", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetAttribute64(HandleRef instrumentHandle, string Channel_Name, int Attribute_ID);

            public static int ResetAttribute(HandleRef instrumentHandle, string Channel_Name, int Attribute_ID)
            {
                if (Is64BitProcess)
                    return ResetAttribute64(instrumentHandle, Channel_Name, Attribute_ID);
                else
                    return ResetAttribute32(instrumentHandle, Channel_Name, Attribute_ID);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_Initiate", CallingConvention = CallingConvention.StdCall)]
            public static extern int Initiate32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_Initiate", CallingConvention = CallingConvention.StdCall)]
            public static extern int Initiate64(HandleRef instrumentHandle);

            public static int Initiate(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return Initiate64(instrumentHandle);
                else
                    return Initiate32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_FetchIQSingleRecordComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQSingleRecordComplexI16_32(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, [Out] short[] Data, out niRFSA_wfmInfo Waveform_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_FetchIQSingleRecordComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQSingleRecordComplexI16_64(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, [Out] short[] Data, out niRFSA_wfmInfo Waveform_Info);

            public static int FetchIQSingleRecordComplexI16(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, [Out] short[] Data, out niRFSA_wfmInfo Waveform_Info)
            {
                if (Is64BitProcess)
                    return FetchIQSingleRecordComplexI16_64(instrumentHandle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
                else
                    return FetchIQSingleRecordComplexI16_32(instrumentHandle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
            }
            
            [Obsolete]
            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_FetchIQSingleRecordComplexF32", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQSingleRecordComplexF32_32(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, niComplexF32[] Data, out niRFSA_wfmInfo Waveform_Info);

            [Obsolete]
            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_FetchIQSingleRecordComplexF32", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQSingleRecordComplexF32_64(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, niComplexF32[] Data, out niRFSA_wfmInfo Waveform_Info);

            [Obsolete]
            public static int FetchIQSingleRecordComplexF32(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, niComplexF32[] Data, out niRFSA_wfmInfo Waveform_Info)
            {
                if (Is64BitProcess)
                    return FetchIQSingleRecordComplexF32_64(instrumentHandle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
                else
                    return FetchIQSingleRecordComplexF32_32(instrumentHandle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_FetchIQSingleRecordComplexF32", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQSingleRecordComplexF32_32(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, niComplexNumberF32[] Data, out niRFSA_wfmInfo Waveform_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_FetchIQSingleRecordComplexF32", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQSingleRecordComplexF32_64(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, niComplexNumberF32[] Data, out niRFSA_wfmInfo Waveform_Info);

            public static int FetchIQSingleRecordComplexF32(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, niComplexNumberF32[] Data, out niRFSA_wfmInfo Waveform_Info)
            {
                if (Is64BitProcess)
                    return FetchIQSingleRecordComplexF32_64(instrumentHandle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
                else
                    return FetchIQSingleRecordComplexF32_32(instrumentHandle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
            }

            [Obsolete]
            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_FetchIQMultiRecordComplexF32", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQMultiRecordComplexF32_32(HandleRef instrumentHandle, string Channel_List, Int64 StartingRecord, Int64 NumberOfRecords, Int64 Number_of_Samples, double Timeout, niComplexF32[] Data, out niRFSA_wfmInfo Waveform_Info);

            [Obsolete]
            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_FetchIQMultiRecordComplexF32", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQMultiRecordComplexF32_64(HandleRef instrumentHandle, string Channel_List, Int64 StartingRecord, Int64 NumberOfRecords, Int64 Number_of_Samples, double Timeout, niComplexF32[] Data, out niRFSA_wfmInfo Waveform_Info);
            
            [Obsolete]
            public static int FetchIQMultiRecordComplexF32(HandleRef instrumentHandle, string Channel_List, Int64 StartingRecord, Int64 NumberOfRecords, Int64 Number_of_Samples, double Timeout, niComplexF32[] Data, out niRFSA_wfmInfo Waveform_Info)
            {
                if (Is64BitProcess)
                    return FetchIQMultiRecordComplexF32_64(instrumentHandle, Channel_List, StartingRecord, NumberOfRecords, Number_of_Samples, Timeout, Data, out Waveform_Info);
                else
                    return FetchIQMultiRecordComplexF32_32(instrumentHandle, Channel_List, StartingRecord, NumberOfRecords, Number_of_Samples, Timeout, Data, out Waveform_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_FetchIQMultiRecordComplexF32", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQMultiRecordComplexF32_32(HandleRef instrumentHandle, string Channel_List, Int64 StartingRecord, Int64 NumberOfRecords, Int64 Number_of_Samples, double Timeout, niComplexNumberF32[] Data, out niRFSA_wfmInfo Waveform_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_FetchIQMultiRecordComplexF32", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQMultiRecordComplexF32_64(HandleRef instrumentHandle, string Channel_List, Int64 StartingRecord, Int64 NumberOfRecords, Int64 Number_of_Samples, double Timeout, niComplexNumberF32[] Data, out niRFSA_wfmInfo Waveform_Info);

            public static int FetchIQMultiRecordComplexF32(HandleRef instrumentHandle, string Channel_List, Int64 StartingRecord, Int64 NumberOfRecords, Int64 Number_of_Samples, double Timeout, niComplexNumberF32[] Data, out niRFSA_wfmInfo Waveform_Info)
            {
                if (Is64BitProcess)
                    return FetchIQMultiRecordComplexF32_64(instrumentHandle, Channel_List, StartingRecord, NumberOfRecords, Number_of_Samples, Timeout, Data, out Waveform_Info);
                else
                    return FetchIQMultiRecordComplexF32_32(instrumentHandle, Channel_List, StartingRecord, NumberOfRecords, Number_of_Samples, Timeout, Data, out Waveform_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_FetchIQSingleRecordComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQSingleRecordComplexF64_32(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, [Out] niComplexNumber[] Data, out niRFSA_wfmInfo Waveform_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_FetchIQSingleRecordComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQSingleRecordComplexF64_64(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, [Out] niComplexNumber[] Data, out niRFSA_wfmInfo Waveform_Info);

            public static int FetchIQSingleRecordComplexF64(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, [Out] niComplexNumber[] Data, out niRFSA_wfmInfo Waveform_Info)
            {
                if (Is64BitProcess)
                    return FetchIQSingleRecordComplexF64_64(instrumentHandle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
                else
                    return FetchIQSingleRecordComplexF64_32(instrumentHandle, Channel_List, Record_Number, Number_of_Samples, Timeout, Data, out Waveform_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ReadIQSingleRecordComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int ReadIQSingleRecordComplexF64_32(HandleRef instrumentHandle, string Channel_List, double Timeout, [Out] niComplexNumber[] Data, Int64 Data_Array_Size, out niRFSA_wfmInfo Waveform_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ReadIQSingleRecordComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int ReadIQSingleRecordComplexF64_64(HandleRef instrumentHandle, string Channel_List, double Timeout, [Out] niComplexNumber[] Data, Int64 Data_Array_Size, out niRFSA_wfmInfo Waveform_Info);

            public static int ReadIQSingleRecordComplexF64(HandleRef instrumentHandle, string Channel_List, double Timeout, [Out] niComplexNumber[] Data, Int64 Data_Array_Size, out niRFSA_wfmInfo Waveform_Info)
            {
                if (Is64BitProcess)
                    return ReadIQSingleRecordComplexF64_64(instrumentHandle, Channel_List, Timeout, Data, Data_Array_Size, out Waveform_Info);
                else
                    return ReadIQSingleRecordComplexF64_32(instrumentHandle, Channel_List, Timeout, Data, Data_Array_Size, out Waveform_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_FetchIQMultiRecordComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQMultiRecordComplexI16_32(HandleRef instrumentHandle, string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, [Out] short[] Data, [Out] niRFSA_wfmInfo[] Waveform_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_FetchIQMultiRecordComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQMultiRecordComplexI16_64(HandleRef instrumentHandle, string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, [Out] short[] Data, [Out] niRFSA_wfmInfo[] Waveform_Info);

            public static int FetchIQMultiRecordComplexI16(HandleRef instrumentHandle, string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, [Out] short[] Data, [Out] niRFSA_wfmInfo[] Waveform_Info)
            {
                if (Is64BitProcess)
                    return FetchIQMultiRecordComplexI16_64(instrumentHandle, Channel_List, Starting_Record, Number_of_Records, Number_of_Samples, Timeout, Data, Waveform_Info);
                else
                    return FetchIQMultiRecordComplexI16_32(instrumentHandle, Channel_List, Starting_Record, Number_of_Records, Number_of_Samples, Timeout, Data, Waveform_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_FetchIQMultiRecordComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQMultiRecordComplexF64_32(HandleRef instrumentHandle, string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, [Out] niComplexNumber[] Data, [Out] niRFSA_wfmInfo[] Waveform_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_FetchIQMultiRecordComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQMultiRecordComplexF64_64(HandleRef instrumentHandle, string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, [Out] niComplexNumber[] Data, [Out] niRFSA_wfmInfo[] Waveform_Info);

            public static int FetchIQMultiRecordComplexF64(HandleRef instrumentHandle, string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, [Out] niComplexNumber[] Data, [Out] niRFSA_wfmInfo[] Waveform_Info)
            {
                if (Is64BitProcess)
                    return FetchIQMultiRecordComplexF64_64(instrumentHandle, Channel_List, Starting_Record, Number_of_Records, Number_of_Samples, Timeout, Data, Waveform_Info);
                else
                    return FetchIQMultiRecordComplexF64_32(instrumentHandle, Channel_List, Starting_Record, Number_of_Records, Number_of_Samples, Timeout, Data, Waveform_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_Abort", CallingConvention = CallingConvention.StdCall)]
            public static extern int Abort32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_Abort", CallingConvention = CallingConvention.StdCall)]
            public static extern int Abort64(HandleRef instrumentHandle);

            public static int Abort(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return Abort64(instrumentHandle);
                else
                    return Abort32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ReadPowerSpectrumF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int ReadPowerSpectrumF64_32(HandleRef instrumentHandle, string Channel_List, double Timeout, [In, Out] double[] Power_Spectrum_Data, int Data_Array_Size, out niRFSA_spectrumInfo Spectrum_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ReadPowerSpectrumF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int ReadPowerSpectrumF64_64(HandleRef instrumentHandle, string Channel_List, double Timeout, [In, Out] double[] Power_Spectrum_Data, int Data_Array_Size, out niRFSA_spectrumInfo Spectrum_Info);

            public static int ReadPowerSpectrumF64(HandleRef instrumentHandle, string Channel_List, double Timeout, [In, Out] double[] Power_Spectrum_Data, int Data_Array_Size, out niRFSA_spectrumInfo Spectrum_Info)
            {
                if (Is64BitProcess)
                    return ReadPowerSpectrumF64_64(instrumentHandle, Channel_List, Timeout, Power_Spectrum_Data, Data_Array_Size, out Spectrum_Info);
                else
                    return ReadPowerSpectrumF64_32(instrumentHandle, Channel_List, Timeout, Power_Spectrum_Data, Data_Array_Size, out Spectrum_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetNumberOfSpectralLines", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetNumberOfSpectralLines32(HandleRef instrumentHandle, string Channel_List, out int Number_of_Spectral_Lines);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetNumberOfSpectralLines", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetNumberOfSpectralLines64(HandleRef instrumentHandle, string Channel_List, out int Number_of_Spectral_Lines);

            public static int GetNumberOfSpectralLines(HandleRef instrumentHandle, string Channel_List, out int Number_of_Spectral_Lines)
            {
                if (Is64BitProcess)
                    return GetNumberOfSpectralLines64(instrumentHandle, Channel_List, out Number_of_Spectral_Lines);
                else
                    return GetNumberOfSpectralLines32(instrumentHandle, Channel_List, out Number_of_Spectral_Lines);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CheckAcquisitionStatus", CallingConvention = CallingConvention.StdCall)]
            public static extern int CheckAcquisitionStatus32(HandleRef instrumentHandle, out ushort Is_Done);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CheckAcquisitionStatus", CallingConvention = CallingConvention.StdCall)]
            public static extern int CheckAcquisitionStatus64(HandleRef instrumentHandle, out ushort Is_Done);

            public static int CheckAcquisitionStatus(HandleRef instrumentHandle, out ushort Is_Done)
            {
                if (Is64BitProcess)
                    return CheckAcquisitionStatus64(instrumentHandle, out Is_Done);
                else
                    return CheckAcquisitionStatus32(instrumentHandle, out Is_Done);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_reset", CallingConvention = CallingConvention.StdCall)]
            public static extern int reset32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_reset", CallingConvention = CallingConvention.StdCall)]
            public static extern int reset64(HandleRef instrumentHandle);

            public static int reset(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return reset64(instrumentHandle);
                else
                    return reset32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_Commit", CallingConvention = CallingConvention.StdCall)]
            public static extern int Commit32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_Commit", CallingConvention = CallingConvention.StdCall)]
            public static extern int Commit64(HandleRef instrumentHandle);

            public static int Commit(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return Commit64(instrumentHandle);
                else
                    return Commit32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_self_test", CallingConvention = CallingConvention.StdCall)]
            public static extern int self_test32(HandleRef instrumentHandle, out short testResult, System.Text.StringBuilder testMessage);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_self_test", CallingConvention = CallingConvention.StdCall)]
            public static extern int self_test64(HandleRef instrumentHandle, out short testResult, System.Text.StringBuilder testMessage);

            public static int self_test(HandleRef instrumentHandle, out short testResult, System.Text.StringBuilder testMessage)
            {
                if (Is64BitProcess)
                    return self_test64(instrumentHandle, out testResult, testMessage);
                else
                    return self_test32(instrumentHandle, out testResult, testMessage);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SelfCal", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelfCal32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SelfCal", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelfCal64(HandleRef instrumentHandle);

            public static int SelfCal(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return SelfCal64(instrumentHandle);
                else
                    return SelfCal32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_PerformThermalCorrection", CallingConvention = CallingConvention.StdCall)]
            public static extern int PerformThermalCorrection32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_PerformThermalCorrection", CallingConvention = CallingConvention.StdCall)]
            public static extern int PerformThermalCorrection64(HandleRef instrumentHandle);

            public static int PerformThermalCorrection(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return PerformThermalCorrection64(instrumentHandle);
                else
                    return PerformThermalCorrection32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetFetchBacklog", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetFetchBacklog32(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, out Int64 Backlog);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetFetchBacklog", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetFetchBacklog64(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, out Int64 Backlog);

            public static int GetFetchBacklog(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, out Int64 Backlog)
            {
                if (Is64BitProcess)
                    return GetFetchBacklog64(instrumentHandle, Channel_List, Record_Number, out Backlog);
                else
                    return GetFetchBacklog32(instrumentHandle, Channel_List, Record_Number, out Backlog);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_revision_query", CallingConvention = CallingConvention.StdCall)]
            public static extern int revision_query32(HandleRef instrumentHandle, System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_revision_query", CallingConvention = CallingConvention.StdCall)]
            public static extern int revision_query64(HandleRef instrumentHandle, System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision);

            public static int revision_query(HandleRef instrumentHandle, System.Text.StringBuilder Instrument_Driver_Revision, System.Text.StringBuilder Firmware_Revision)
            {
                if (Is64BitProcess)
                    return revision_query64(instrumentHandle, Instrument_Driver_Revision, Firmware_Revision);
                else
                    return revision_query32(instrumentHandle, Instrument_Driver_Revision, Firmware_Revision);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetSpectralInfoForSMT", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetSpectralInfoForSMT32(HandleRef instrumentHandle, out SmtSpectrumInfo Spectrum_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetSpectralInfoForSMT", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetSpectralInfoForSMT64(HandleRef instrumentHandle, out SmtSpectrumInfo Spectrum_Info);

            public static int GetSpectralInfoForSMT(HandleRef instrumentHandle, out SmtSpectrumInfo Spectrum_Info)
            {
                if (Is64BitProcess)
                    return GetSpectralInfoForSMT64(instrumentHandle, out Spectrum_Info);
                else
                    return GetSpectralInfoForSMT32(instrumentHandle, out Spectrum_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetFrequencyResponse", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetFrequencyResponse32(HandleRef instrumentHandle, string Channel_List, int Buffer_Size, [In, Out] double[] Frequencies, [In, Out] double[] Magnitude_Response, [In, Out] double[] Phase_Response, out int Number_of_Frequencies);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetFrequencyResponse", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetFrequencyResponse64(HandleRef instrumentHandle, string Channel_List, int Buffer_Size, [In, Out] double[] Frequencies, [In, Out] double[] Magnitude_Response, [In, Out] double[] Phase_Response, out int Number_of_Frequencies);

            public static int GetFrequencyResponse(HandleRef instrumentHandle, string Channel_List, int Buffer_Size, [In, Out] double[] Frequencies, [In, Out] double[] Magnitude_Response, [In, Out] double[] Phase_Response, out int Number_of_Frequencies)
            {
                if (Is64BitProcess)
                    return GetFrequencyResponse64(instrumentHandle, Channel_List, Buffer_Size, Frequencies, Magnitude_Response, Phase_Response, out Number_of_Frequencies);
                else
                    return GetFrequencyResponse32(instrumentHandle, Channel_List, Buffer_Size, Frequencies, Magnitude_Response, Phase_Response, out Number_of_Frequencies);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_close", CallingConvention = CallingConvention.StdCall)]
            public static extern int close32(HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_close", CallingConvention = CallingConvention.StdCall)]
            public static extern int close64(HandleRef instrumentHandle);

            public static int close(HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return close64(instrumentHandle);
                else
                    return close32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_error_message", CallingConvention = CallingConvention.StdCall)]
            public static extern int error_message32(HandleRef instrumentHandle, int Error_Code, System.Text.StringBuilder Error_Message_2);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_error_message", CallingConvention = CallingConvention.StdCall)]
            public static extern int error_message64(HandleRef instrumentHandle, int Error_Code, System.Text.StringBuilder Error_Message_2);

            public static int error_message(HandleRef instrumentHandle, int Error_Code, System.Text.StringBuilder Error_Message_2)
            {
                if (Is64BitProcess)
                    return error_message64(instrumentHandle, Error_Code, Error_Message_2);
                else
                    return error_message32(instrumentHandle, Error_Code, Error_Message_2);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViInt32_32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out int Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViInt32_64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out int Attribute_Value);

            public static int GetAttributeViInt32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out int Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViInt32_64(instrumentHandle, Channel_Name, Attribute_ID, out Attribute_Value);
                else
                    return GetAttributeViInt32_32(instrumentHandle, Channel_Name, Attribute_ID, out Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetAttributeViInt64", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViInt64_32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out Int64 Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetAttributeViInt64", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViInt64_64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out Int64 Attribute_Value);

            public static int GetAttributeViInt64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out Int64 Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViInt64_64(instrumentHandle, Channel_Name, Attribute_ID, out Attribute_Value);
                else
                    return GetAttributeViInt64_32(instrumentHandle, Channel_Name, Attribute_ID, out Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViReal64_32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out double Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViReal64_64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out double Attribute_Value);

            public static int GetAttributeViReal64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out double Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViReal64_64(instrumentHandle, Channel_Name, Attribute_ID, out Attribute_Value);
                else
                    return GetAttributeViReal64_32(instrumentHandle, Channel_Name, Attribute_ID, out Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViString32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, int Buffer_Size, System.Text.StringBuilder Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViString64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, int Buffer_Size, System.Text.StringBuilder Attribute_Value);

            public static int GetAttributeViString(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, int Buffer_Size, System.Text.StringBuilder Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViString64(instrumentHandle, Channel_Name, Attribute_ID, Buffer_Size, Attribute_Value);
                else
                    return GetAttributeViString32(instrumentHandle, Channel_Name, Attribute_ID, Buffer_Size, Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViBoolean32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out ushort Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViBoolean64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out ushort Attribute_Value);

            public static int GetAttributeViBoolean(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out ushort Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViBoolean64(instrumentHandle, Channel_Name, Attribute_ID, out Attribute_Value);
                else
                    return GetAttributeViBoolean32(instrumentHandle, Channel_Name, Attribute_ID, out Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViSession32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out System.IntPtr Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetAttributeViSession64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out System.IntPtr Attribute_Value);

            public static int GetAttributeViSession(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, out System.IntPtr Attribute_Value)
            {
                if (Is64BitProcess)
                    return GetAttributeViSession64(instrumentHandle, Channel_Name, Attribute_ID, out Attribute_Value);
                else
                    return GetAttributeViSession32(instrumentHandle, Channel_Name, Attribute_ID, out Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViInt32_32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, int Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SetAttributeViInt32", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViInt32_64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, int Attribute_Value);

            public static int SetAttributeViInt32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, int Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViInt32_64(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViInt32_32(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SetAttributeViInt64", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViInt64_32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, long Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SetAttributeViInt64", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViInt64_64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, long Attribute_Value);

            public static int SetAttributeViInt64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, long Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViInt64_64(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViInt64_32(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViReal64_32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, double Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SetAttributeViReal64", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViReal64_64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, double Attribute_Value);

            public static int SetAttributeViReal64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, double Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViReal64_64(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViReal64_32(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViString32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, string Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SetAttributeViString", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViString64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, string Attribute_Value);

            public static int SetAttributeViString(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, string Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViString64(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViString32(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViBoolean32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, ushort Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SetAttributeViBoolean", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViBoolean64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, ushort Attribute_Value);

            public static int SetAttributeViBoolean(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, ushort Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViBoolean64(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViBoolean32(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViSession32(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, System.IntPtr Attribute_Value);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SetAttributeViSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetAttributeViSession64(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, System.IntPtr Attribute_Value);

            public static int SetAttributeViSession(HandleRef instrumentHandle, string Channel_Name, niRFSAProperties Attribute_ID, System.IntPtr Attribute_Value)
            {
                if (Is64BitProcess)
                    return SetAttributeViSession64(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
                else
                    return SetAttributeViSession32(instrumentHandle, Channel_Name, Attribute_ID, Attribute_Value);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetError", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetError32(HandleRef instrumentHandle, out int errorCode, int BufferSize, System.Text.StringBuilder Description);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetError", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetError64(HandleRef instrumentHandle, out int errorCode, int BufferSize, System.Text.StringBuilder Description);

            public static int GetError(HandleRef instrumentHandle, out int errorCode, int BufferSize, System.Text.StringBuilder Description)
            {
                if (Is64BitProcess)
                    return GetError64(instrumentHandle, out errorCode, BufferSize, Description);
                else
                    return GetError32(instrumentHandle, out errorCode, BufferSize, Description);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CalAdjustIFAttenuationCalibration", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustIFAttenuationCalibration32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int iFFilter, int numberofAttenuators, double[] attenuatorSettings, double measurement);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CalAdjustIFAttenuationCalibration", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustIFAttenuationCalibration64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int iFFilter, int numberofAttenuators, double[] attenuatorSettings, double measurement);

            public static int CalAdjustIFAttenuationCalibration(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int iFFilter, int numberofAttenuators, double[] attenuatorSettings, double measurement)
            {
                if (Is64BitProcess)
                    return CalAdjustIFAttenuationCalibration64(instrumentHandle, channelList, iFFilter, numberofAttenuators, attenuatorSettings, measurement);
                else
                    return CalAdjustIFAttenuationCalibration32(instrumentHandle, channelList, iFFilter, numberofAttenuators, attenuatorSettings, measurement);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CalAdjustIFResponseCalibration", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustIFResponseCalibration32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int iFFilter, double rFFrequency, double bandwidth, int numberofMeasurements, double[] measurements);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CalAdjustIFResponseCalibration", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustIFResponseCalibration64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int iFFilter, double rFFrequency, double bandwidth, int numberofMeasurements, double[] measurements);

            public static int CalAdjustIFResponseCalibration(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int iFFilter, double rFFrequency, double bandwidth, int numberofMeasurements, double[] measurements)
            {
                if (Is64BitProcess)
                    return CalAdjustIFResponseCalibration64(instrumentHandle, channelList, iFFilter, rFFrequency, bandwidth, numberofMeasurements, measurements);
                else
                    return CalAdjustIFResponseCalibration32(instrumentHandle, channelList, iFFilter, rFFrequency, bandwidth, numberofMeasurements, measurements);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CalAdjustRefLevelCalibration", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustRefLevelCalibration32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int referenceLevelCalDataType, int rFBand, int attenuatorTableNumber, double frequency, double measurement);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CalAdjustRefLevelCalibration", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustRefLevelCalibration64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int referenceLevelCalDataType, int rFBand, int attenuatorTableNumber, double frequency, double measurement);

            public static int CalAdjustRefLevelCalibration(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int referenceLevelCalDataType, int rFBand, int attenuatorTableNumber, double frequency, double measurement)
            {
                if (Is64BitProcess)
                    return CalAdjustRefLevelCalibration64(instrumentHandle, channelList, referenceLevelCalDataType, rFBand, attenuatorTableNumber, frequency, measurement);
                else
                    return CalAdjustRefLevelCalibration32(instrumentHandle, channelList, referenceLevelCalDataType, rFBand, attenuatorTableNumber, frequency, measurement);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CalSetTemperature", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalSetTemperature32(System.Runtime.InteropServices.HandleRef instrumentHandle, double temperaturedegreesC);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CalSetTemperature", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalSetTemperature64(System.Runtime.InteropServices.HandleRef instrumentHandle, double temperaturedegreesC);

            public static int CalSetTemperature(System.Runtime.InteropServices.HandleRef instrumentHandle, double temperaturedegreesC)
            {
                if (Is64BitProcess)
                    return CalSetTemperature64(instrumentHandle, temperaturedegreesC);
                else
                    return CalSetTemperature32(instrumentHandle, temperaturedegreesC);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ChangeExtCalPassword", CallingConvention = CallingConvention.StdCall)]
            public static extern int ChangeExtCalPassword32(System.Runtime.InteropServices.HandleRef instrumentHandle, string oldpassword, string newpassword);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ChangeExtCalPassword", CallingConvention = CallingConvention.StdCall)]
            public static extern int ChangeExtCalPassword64(System.Runtime.InteropServices.HandleRef instrumentHandle, string oldpassword, string newpassword);

            public static int ChangeExtCalPassword(System.Runtime.InteropServices.HandleRef instrumentHandle, string oldpassword, string newpassword)
            {
                if (Is64BitProcess)
                    return ChangeExtCalPassword64(instrumentHandle, oldpassword, newpassword);
                else
                    return ChangeExtCalPassword32(instrumentHandle, oldpassword, newpassword);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CloseCalibrationStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int CloseCalibrationStep32(System.Runtime.InteropServices.HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CloseCalibrationStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int CloseCalibrationStep64(System.Runtime.InteropServices.HandleRef instrumentHandle);

            public static int CloseCalibrationStep(System.Runtime.InteropServices.HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return CloseCalibrationStep64(instrumentHandle);
                else
                    return CloseCalibrationStep32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CloseExtCal", CallingConvention = CallingConvention.StdCall)]
            public static extern int CloseExtCal32(System.Runtime.InteropServices.HandleRef instrumentHandle, int action);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CloseExtCal", CallingConvention = CallingConvention.StdCall)]
            public static extern int CloseExtCal64(System.Runtime.InteropServices.HandleRef instrumentHandle, int action);

            public static int CloseExtCal(System.Runtime.InteropServices.HandleRef instrumentHandle, int action)
            {
                if (Is64BitProcess)
                    return CloseExtCal64(instrumentHandle, action);
                else
                    return CloseExtCal32(instrumentHandle, action);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CreateConfigurationList", CallingConvention = CallingConvention.StdCall)]
            public static extern int CreateConfigurationList32(System.Runtime.InteropServices.HandleRef instrumentHandle, string listName, int numberOfListAttributes, niRFSAProperties[] listAttributeIDs, bool setAsActiveList);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CreateConfigurationList", CallingConvention = CallingConvention.StdCall)]
            public static extern int CreateConfigurationList64(System.Runtime.InteropServices.HandleRef instrumentHandle, string listName, int numberOfListAttributes, niRFSAProperties[] listAttributeIDs, bool setAsActiveList);

            public static int CreateConfigurationList(System.Runtime.InteropServices.HandleRef instrumentHandle, string listName, int numberOfListAttributes, niRFSAProperties[] listAttributeIDs, bool setAsActiveList)
            {
                if (Is64BitProcess)
                    return CreateConfigurationList64(instrumentHandle, listName, numberOfListAttributes, listAttributeIDs, setAsActiveList);
                else
                    return CreateConfigurationList32(instrumentHandle, listName, numberOfListAttributes, listAttributeIDs, setAsActiveList);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CreateConfigurationListStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int CreateConfigurationListStep32(System.Runtime.InteropServices.HandleRef instrumentHandle, bool setAsActiveStep);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CreateConfigurationListStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int CreateConfigurationListStep64(System.Runtime.InteropServices.HandleRef instrumentHandle, bool setAsActiveStep);

            public static int CreateConfigurationListStep(System.Runtime.InteropServices.HandleRef instrumentHandle, bool setAsActiveStep)
            {
                if (Is64BitProcess)
                    return CreateConfigurationListStep64(instrumentHandle, setAsActiveStep);
                else
                    return CreateConfigurationListStep32(instrumentHandle, setAsActiveStep);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_DeleteConfigurationList", CallingConvention = CallingConvention.StdCall)]
            public static extern int DeleteConfigurationList32(System.Runtime.InteropServices.HandleRef instrumentHandle, string listName);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_DeleteConfigurationList", CallingConvention = CallingConvention.StdCall)]
            public static extern int DeleteConfigurationList64(System.Runtime.InteropServices.HandleRef instrumentHandle, string listName);

            public static int DeleteConfigurationList(System.Runtime.InteropServices.HandleRef instrumentHandle, string listName)
            {
                if (Is64BitProcess)
                    return DeleteConfigurationList64(instrumentHandle, listName);
                else
                    return DeleteConfigurationList32(instrumentHandle, listName);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetCalUserDefinedInfo", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetCalUserDefinedInfo32(System.Runtime.InteropServices.HandleRef instrumentHandle, StringBuilder userdefinedinfo);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetCalUserDefinedInfo", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetCalUserDefinedInfo64(System.Runtime.InteropServices.HandleRef instrumentHandle, StringBuilder userdefinedinfo);

            public static int GetCalUserDefinedInfo(System.Runtime.InteropServices.HandleRef instrumentHandle, StringBuilder userdefinedinfo)
            {
                if (Is64BitProcess)
                    return GetCalUserDefinedInfo64(instrumentHandle, userdefinedinfo);
                else
                    return GetCalUserDefinedInfo32(instrumentHandle, userdefinedinfo);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetCalUserDefinedInfoMaxSize", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetCalUserDefinedInfoMaxSize32(System.Runtime.InteropServices.HandleRef instrumentHandle, out int infoSize);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetCalUserDefinedInfoMaxSize", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetCalUserDefinedInfoMaxSize64(System.Runtime.InteropServices.HandleRef instrumentHandle, out int infoSize);

            public static int GetCalUserDefinedInfoMaxSize(System.Runtime.InteropServices.HandleRef instrumentHandle, out int infoSize)
            {
                if (Is64BitProcess)
                    return GetCalUserDefinedInfoMaxSize64(instrumentHandle, out infoSize);
                else
                    return GetCalUserDefinedInfoMaxSize32(instrumentHandle, out infoSize);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetExtCalLastDateAndTime", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetExtCalLastDateAndTime32(System.Runtime.InteropServices.HandleRef instrumentHandle, out int year, out int month, out int day, out int hour, out int minute);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetExtCalLastDateAndTime", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetExtCalLastDateAndTime64(System.Runtime.InteropServices.HandleRef instrumentHandle, out int year, out int month, out int day, out int hour, out int minute);

            public static int GetExtCalLastDateAndTime(System.Runtime.InteropServices.HandleRef instrumentHandle, out int year, out int month, out int day, out int hour, out int minute)
            {
                if (Is64BitProcess)
                    return GetExtCalLastDateAndTime64(instrumentHandle, out year, out month, out day, out hour, out minute);
                else
                    return GetExtCalLastDateAndTime32(instrumentHandle, out year, out month, out day, out hour, out minute);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetExtCalLastTemp", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetExtCalLastTemp32(System.Runtime.InteropServices.HandleRef instrumentHandle, out double temperature);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetExtCalLastTemp", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetExtCalLastTemp64(System.Runtime.InteropServices.HandleRef instrumentHandle, out double temperature);

            public static int GetExtCalLastTemp(System.Runtime.InteropServices.HandleRef instrumentHandle, out double temperature)
            {
                if (Is64BitProcess)
                    return GetExtCalLastTemp64(instrumentHandle, out temperature);
                else
                    return GetExtCalLastTemp32(instrumentHandle, out temperature);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetExtCalRecommendedInterval", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetExtCalRecommendedInterval32(System.Runtime.InteropServices.HandleRef instrumentHandle, out int months);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetExtCalRecommendedInterval", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetExtCalRecommendedInterval64(System.Runtime.InteropServices.HandleRef instrumentHandle, out int months);

            public static int GetExtCalRecommendedInterval(System.Runtime.InteropServices.HandleRef instrumentHandle, out int months)
            {
                if (Is64BitProcess)
                    return GetExtCalRecommendedInterval64(instrumentHandle, out months);
                else
                    return GetExtCalRecommendedInterval32(instrumentHandle, out months);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetNormalizationCoefficients", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetNormalizationCoefficients32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int bufferSize, out niRFSA_coefficientInfo coefficientInfo, out int numberofCoefficientSets);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetNormalizationCoefficients", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetNormalizationCoefficients64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int bufferSize, out niRFSA_coefficientInfo coefficientInfo, out int numberofCoefficientSets);

            public static int GetNormalizationCoefficients(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int bufferSize, out niRFSA_coefficientInfo coefficientInfo, out int numberofCoefficientSets)
            {
                if (Is64BitProcess)
                    return GetNormalizationCoefficients64(instrumentHandle, channelList, bufferSize, out coefficientInfo, out numberofCoefficientSets);
                else
                    return GetNormalizationCoefficients32(instrumentHandle, channelList, bufferSize, out coefficientInfo, out numberofCoefficientSets);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetScalingCoefficients", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetScalingCoefficients32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int arraySize, out niRFSA_coefficientInfo coefficientInfo, out int numberOfCoefficientSets);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetScalingCoefficients", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetScalingCoefficients64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int arraySize, out niRFSA_coefficientInfo coefficientInfo, out int numberOfCoefficientSets);

            public static int GetScalingCoefficients(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int arraySize, out niRFSA_coefficientInfo coefficientInfo, out int numberOfCoefficientSets)
            {
                if (Is64BitProcess)
                    return GetScalingCoefficients64(instrumentHandle, channelList, arraySize, out coefficientInfo, out numberOfCoefficientSets);
                else
                    return GetScalingCoefficients32(instrumentHandle, channelList, arraySize, out coefficientInfo, out numberOfCoefficientSets);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetStreamEndpointHandle", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetStreamEndpointHandle32(System.Runtime.InteropServices.HandleRef instrumentHandle, string streamEndpoint, out uint writerHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetStreamEndpointHandle", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetStreamEndpointHandle64(System.Runtime.InteropServices.HandleRef instrumentHandle, string streamEndpoint, out uint writerHandle);

            public static int GetStreamEndpointHandle(System.Runtime.InteropServices.HandleRef instrumentHandle, string streamEndpoint, out uint writerHandle)
            {
                if (Is64BitProcess)
                    return GetStreamEndpointHandle64(instrumentHandle, streamEndpoint, out writerHandle);
                else
                    return GetStreamEndpointHandle32(instrumentHandle, streamEndpoint, out writerHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_InitExtCal", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitExtCal32(string resourceName, string password, string optionstring, out System.IntPtr instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_InitExtCal", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitExtCal64(string resourceName, string password, string optionstring, out System.IntPtr instrumentHandle);

            public static int InitExtCal(string resourceName, string password, string optionstring, out System.IntPtr instrumentHandle)
            {
                if (Is64BitProcess)
                    return InitExtCal64(resourceName, password, optionstring, out instrumentHandle);
                else
                    return InitExtCal32(resourceName, password, optionstring, out instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_InitializeCalibrationStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitializeCalibrationStep32(System.Runtime.InteropServices.HandleRef instrumentHandle, int calibrationstep);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_InitializeCalibrationStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitializeCalibrationStep64(System.Runtime.InteropServices.HandleRef instrumentHandle, int calibrationstep);

            public static int InitializeCalibrationStep(System.Runtime.InteropServices.HandleRef instrumentHandle, int calibrationstep)
            {
                if (Is64BitProcess)
                    return InitializeCalibrationStep64(instrumentHandle, calibrationstep);
                else
                    return InitializeCalibrationStep32(instrumentHandle, calibrationstep);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ResetDevice", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetDevice32(System.Runtime.InteropServices.HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ResetDevice", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetDevice64(System.Runtime.InteropServices.HandleRef instrumentHandle);

            public static int ResetDevice(System.Runtime.InteropServices.HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return ResetDevice64(instrumentHandle);
                else
                    return ResetDevice32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SetCalUserDefinedInfo", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetCalUserDefinedInfo32(System.Runtime.InteropServices.HandleRef instrumentHandle, string userdefinedinfo);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SetCalUserDefinedInfo", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetCalUserDefinedInfo64(System.Runtime.InteropServices.HandleRef instrumentHandle, string userdefinedinfo);

            public static int SetCalUserDefinedInfo(System.Runtime.InteropServices.HandleRef instrumentHandle, string userdefinedinfo)
            {
                if (Is64BitProcess)
                    return SetCalUserDefinedInfo64(instrumentHandle, userdefinedinfo);
                else
                    return SetCalUserDefinedInfo32(instrumentHandle, userdefinedinfo);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_FetchIQSingleRecordComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQSingleRecordComplexI16_32(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, [Out] niComplexI16[] data, out niRFSA_wfmInfo Waveform_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_FetchIQSingleRecordComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQSingleRecordComplexI16_64(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, [Out] niComplexI16[] data, out niRFSA_wfmInfo Waveform_Info);

            public static int FetchIQSingleRecordComplexI16(HandleRef instrumentHandle, string Channel_List, Int64 Record_Number, Int64 Number_of_Samples, double Timeout, ref niComplexI16[] data, out niRFSA_wfmInfo Waveform_Info)
            {
                if (Is64BitProcess)
                    return FetchIQSingleRecordComplexI16_64(instrumentHandle, Channel_List, Record_Number, Number_of_Samples, Timeout, data, out Waveform_Info);
                else
                    return FetchIQSingleRecordComplexI16_32(instrumentHandle, Channel_List, Record_Number, Number_of_Samples, Timeout, data, out Waveform_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_FetchIQMultiRecordComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQMultiRecordComplexI16_32(HandleRef instrumentHandle, string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, [Out] niComplexI16[] data, [Out] niRFSA_wfmInfo[] Waveform_Info);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_FetchIQMultiRecordComplexI16", CallingConvention = CallingConvention.StdCall)]
            public static extern int FetchIQMultiRecordComplexI16_64(HandleRef instrumentHandle, string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, [Out] niComplexI16[] data, [Out] niRFSA_wfmInfo[] Waveform_Info);

            public static int FetchIQMultiRecordComplexI16(HandleRef instrumentHandle, string Channel_List, Int64 Starting_Record, Int64 Number_of_Records, Int64 Number_of_Samples, double Timeout, ref niComplexI16[] data, [Out] niRFSA_wfmInfo[] Waveform_Info)
            {
                if (Is64BitProcess)
                    return FetchIQMultiRecordComplexI16_64(instrumentHandle, Channel_List, Starting_Record, Number_of_Records, Number_of_Samples, Timeout, data, Waveform_Info);
                else
                    return FetchIQMultiRecordComplexI16_32(instrumentHandle, Channel_List, Starting_Record, Number_of_Records, Number_of_Samples, Timeout, data, Waveform_Info);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CalAdjustDownconverterGain", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustDownconverterGain32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, double frequency, double gain);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CalAdjustDownconverterGain", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustDownconverterGain64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, double frequency, double gain);

            public static int CalAdjustDownconverterGain(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, double frequency, double gain)
            {
                if (Is64BitProcess)
                    return CalAdjustDownconverterGain64(instrumentHandle, channelList, frequency, gain);
                else
                    return CalAdjustDownconverterGain32(instrumentHandle, channelList, frequency, gain);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CloseExternalAlignment", CallingConvention = CallingConvention.StdCall)]
            public static extern int CloseExternalAlignment32(System.Runtime.InteropServices.HandleRef instrumentHandle, Int32 action);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CloseExternalAlignment", CallingConvention = CallingConvention.StdCall)]
            public static extern int CloseExternalAlignment64(System.Runtime.InteropServices.HandleRef instrumentHandle, Int32 action);

            public static int CloseExternalAlignment(System.Runtime.InteropServices.HandleRef instrumentHandle, Int32 action)
            {
                if (Is64BitProcess)
                    return CloseExternalAlignment64(instrumentHandle, action);
                else
                    return CloseExternalAlignment32(instrumentHandle, action);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CloseExternalAlignmentStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int CloseExternalAlignmentStep32(System.Runtime.InteropServices.HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CloseExternalAlignmentStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int CloseExternalAlignmentStep64(System.Runtime.InteropServices.HandleRef instrumentHandle);

            public static int CloseExternalAlignmentStep(System.Runtime.InteropServices.HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return CloseExternalAlignmentStep64(instrumentHandle);
                else
                    return CloseExternalAlignmentStep32(instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ExtCalStoreBaselineForSelfCalibration", CallingConvention = CallingConvention.StdCall)]
            public static extern int ExtCalStoreBaselineForSelfCalibration32(System.Runtime.InteropServices.HandleRef instrumentHandle, string password, long stepToRun);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ExtCalStoreBaselineForSelfCalibration", CallingConvention = CallingConvention.StdCall)]
            public static extern int ExtCalStoreBaselineForSelfCalibration64(System.Runtime.InteropServices.HandleRef instrumentHandle, string password, long stepToRun);

            public static int ExtCalStoreBaselineForSelfCalibration(System.Runtime.InteropServices.HandleRef instrumentHandle, string password, long stepToRun)
            {
                if (Is64BitProcess)
                    return ExtCalStoreBaselineForSelfCalibration64(instrumentHandle, password, stepToRun);
                else
                    return ExtCalStoreBaselineForSelfCalibration32(instrumentHandle, password, stepToRun);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ExternalAlignmentAdjustPreselector", CallingConvention = CallingConvention.StdCall)]
            public static extern int ExternalAlignmentAdjustPreselector32(System.Runtime.InteropServices.HandleRef instrumentHandle, Int32 numberOfCoefficients, double[] coefficients);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ExternalAlignmentAdjustPreselector", CallingConvention = CallingConvention.StdCall)]
            public static extern int ExternalAlignmentAdjustPreselector64(System.Runtime.InteropServices.HandleRef instrumentHandle, Int32 numberOfCoefficients, double[] coefficients);

            public static int ExternalAlignmentAdjustPreselector(System.Runtime.InteropServices.HandleRef instrumentHandle, Int32 numberOfCoefficients, double[] coefficients)
            {
                if (Is64BitProcess)
                    return ExternalAlignmentAdjustPreselector64(instrumentHandle, numberOfCoefficients, coefficients);
                else
                    return ExternalAlignmentAdjustPreselector32(instrumentHandle, numberOfCoefficients, coefficients);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetDeviceResponse", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetDeviceResponse32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int responseType, int bufferSize, [In, Out] double[] frequencies, [In, Out] double[] magnitudeResponse, [In, Out] double[] phaseResponse, out int numberofFrequencies);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetDeviceResponse", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetDeviceResponse64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int responseType, int bufferSize, [In, Out] double[] frequencies, [In, Out] double[] magnitudeResponse, [In, Out] double[] phaseResponse, out int numberofFrequencies);

            public static int GetDeviceResponse(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int responseType, int bufferSize, [In, Out] double[] frequencies, [In, Out] double[] magnitudeResponse, [In, Out] double[] phaseResponse, out int numberofFrequencies)
            {
                if (Is64BitProcess)
                    return GetDeviceResponse64(instrumentHandle, channelList, responseType, bufferSize, frequencies, magnitudeResponse, phaseResponse, out numberofFrequencies);
                else
                    return GetDeviceResponse32(instrumentHandle, channelList, responseType, bufferSize, frequencies, magnitudeResponse, phaseResponse, out numberofFrequencies);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SetUserData", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetUserData32(System.Runtime.InteropServices.HandleRef instrumentHandle, string identifier, int bufferSize, byte[] data);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SetUserData", CallingConvention = CallingConvention.StdCall)]
            public static extern int SetUserData64(System.Runtime.InteropServices.HandleRef instrumentHandle, string identifier, int bufferSize, byte[] data);

            public static int SetUserData(System.Runtime.InteropServices.HandleRef instrumentHandle, string identifier, int bufferSize, byte[] data)
            {
                if (Is64BitProcess)
                    return SetUserData64(instrumentHandle, identifier, bufferSize, data);
                else
                    return SetUserData32(instrumentHandle, identifier, bufferSize, data);
            }

            
            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetUserData", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetUserData32(System.Runtime.InteropServices.HandleRef instrumentHandle, string identifier, int bufferSize, byte[] data, ref int actualDataSize);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetUserData", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetUserData64(System.Runtime.InteropServices.HandleRef instrumentHandle, string identifier, int bufferSize, byte[] data, ref int actualDataSize);

            public static int GetUserData(System.Runtime.InteropServices.HandleRef instrumentHandle, string identifier, int bufferSize, byte[] data, ref int actualDataSize)
            {
                if (Is64BitProcess)
                    return GetUserData64(instrumentHandle, identifier, bufferSize, data,  ref actualDataSize);
                else
                    return GetUserData32(instrumentHandle, identifier, bufferSize, data,  ref actualDataSize);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_EnableSessionAccess", CallingConvention = CallingConvention.StdCall)]
            public static extern int EnableSessionAccess32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, bool enable);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_EnableSessionAccess", CallingConvention = CallingConvention.StdCall)]
            public static extern int EnableSessionAccess64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, bool enable);

            public static int EnableSessionAccess(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, bool enable)
            {
                if (Is64BitProcess)
                    return EnableSessionAccess64(instrumentHandle, channelList, enable);
                else
                    return EnableSessionAccess32(instrumentHandle, channelList, enable);
            }


            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetGainReferenceCalBaseline", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetGainReferenceCalBaseline32(System.Runtime.InteropServices.HandleRef instrumentHandle, int bufferSize, [In, Out] double[] gainReferenceCalConstants, out int numberofRefCalConstants);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetGainReferenceCalBaseline", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetGainReferenceCalBaseline64(System.Runtime.InteropServices.HandleRef instrumentHandle, int bufferSize, [In, Out] double[] gainReferenceCalConstants, out int numberofRefCalConstants);

            public static int GetGainReferenceCalBaseline(System.Runtime.InteropServices.HandleRef instrumentHandle, int bufferSize, [In, Out] double[] gainReferenceCalConstants, out int numberofRefCalConstants)
            {
                if (Is64BitProcess)
                    return GetGainReferenceCalBaseline64(instrumentHandle, bufferSize, gainReferenceCalConstants, out numberofRefCalConstants);
                else
                    return GetGainReferenceCalBaseline32(instrumentHandle, bufferSize, gainReferenceCalConstants, out numberofRefCalConstants);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetRelayName", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetRelayName32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int indexofRelay, StringBuilder name, out int bufferSize);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetRelayName", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetRelayName64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int indexofRelay, StringBuilder name, out int bufferSize);

            public static int GetRelayName(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int indexofRelay, StringBuilder name, out int bufferSize)
            {
                if (Is64BitProcess)
                    return GetRelayName64(instrumentHandle, channelList, indexofRelay, name, out bufferSize);
                else
                    return GetRelayName32(instrumentHandle, channelList, indexofRelay, name, out bufferSize);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetRelayOperationsCount", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetRelayOperationsCount32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, [In, Out] int[] operationsCountArray, out int bufferSize);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetRelayOperationsCount", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetRelayOperationsCount64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, [In, Out] int[] operationsCountArray, out int bufferSize);

            public static int GetRelayOperationsCount(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, [In, Out] int[] operationsCountArray, out int bufferSize)
            {
                if (Is64BitProcess)
                    return GetRelayOperationsCount64(instrumentHandle, channelList, operationsCountArray, out bufferSize);
                else
                    return GetRelayOperationsCount32(instrumentHandle, channelList, operationsCountArray, out bufferSize);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetSelfCalLastDateAndTime", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetSelfCalLastDateAndTime32(System.Runtime.InteropServices.HandleRef instrumentHandle, long selfCalibrationStep, out int year, out int month, out int day, out int hour, out int minute);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetSelfCalLastDateAndTime", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetSelfCalLastDateAndTime64(System.Runtime.InteropServices.HandleRef instrumentHandle, long selfCalibrationStep, out int year, out int month, out int day, out int hour, out int minute);

            public static int GetSelfCalLastDateAndTime(System.Runtime.InteropServices.HandleRef instrumentHandle, long selfCalibrationStep, out int year, out int month, out int day, out int hour, out int minute)
            {
                if (Is64BitProcess)
                    return GetSelfCalLastDateAndTime64(instrumentHandle, selfCalibrationStep, out year, out month, out day, out hour, out minute);
                else
                    return GetSelfCalLastDateAndTime32(instrumentHandle, selfCalibrationStep, out year, out month, out day, out hour, out minute);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetSelfCalLastTemp", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetSelfCalLastTemp32(System.Runtime.InteropServices.HandleRef instrumentHandle, long selfCalibrationStep, out double temperature);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetSelfCalLastTemp", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetSelfCalLastTemp64(System.Runtime.InteropServices.HandleRef instrumentHandle, long selfCalibrationStep, out double temperature);

            public static int GetSelfCalLastTemp(System.Runtime.InteropServices.HandleRef instrumentHandle, long selfCalibrationStep, out double temperature)
            {
                if (Is64BitProcess)
                    return GetSelfCalLastTemp64(instrumentHandle, selfCalibrationStep, out temperature);
                else
                    return GetSelfCalLastTemp32(instrumentHandle, selfCalibrationStep, out temperature);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_InitializeExternalAlignment", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitializeExternalAlignment32(string Resource_Name, string Option_String, out System.Runtime.InteropServices.HandleRef instrumentHandle);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_InitializeExternalAlignment", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitializeExternalAlignment64(string Resource_Name, string Option_String, out System.Runtime.InteropServices.HandleRef instrumentHandle);

            public static int InitializeExternalAlignment(string Resource_Name, string Option_String, out System.Runtime.InteropServices.HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return InitializeExternalAlignment64(Resource_Name, Option_String, out instrumentHandle);
                else
                    return InitializeExternalAlignment32(Resource_Name, Option_String, out instrumentHandle);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_InitializeExternalAlignmentStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitializeExternalAlignmentStep32(System.Runtime.InteropServices.HandleRef instrumentHandle, Double externalAlignmentStep);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_InitializeExternalAlignmentStep", CallingConvention = CallingConvention.StdCall)]
            public static extern int InitializeExternalAlignmentStep64(System.Runtime.InteropServices.HandleRef instrumentHandle, Double externalAlignmentStep);

            public static int InitializeExternalAlignmentStep(System.Runtime.InteropServices.HandleRef instrumentHandle, Double externalAlignmentStep)
            {
                if (Is64BitProcess)
                    return InitializeExternalAlignmentStep64(instrumentHandle, externalAlignmentStep);
                else
                    return InitializeExternalAlignmentStep32(instrumentHandle, externalAlignmentStep);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_IsSelfCalValid", CallingConvention = CallingConvention.StdCall)]
            public static extern int IsSelfCalValid32(System.Runtime.InteropServices.HandleRef instrumentHandle, out bool selfCalValid, out long validSteps);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_IsSelfCalValid", CallingConvention = CallingConvention.StdCall)]
            public static extern int IsSelfCalValid64(System.Runtime.InteropServices.HandleRef instrumentHandle, out bool selfCalValid, out long validSteps);

            public static int IsSelfCalValid(System.Runtime.InteropServices.HandleRef instrumentHandle, out bool selfCalValid, out long validSteps)
            {
                if (Is64BitProcess)
                    return IsSelfCalValid64(instrumentHandle, out selfCalValid, out validSteps);
                else
                    return IsSelfCalValid32(instrumentHandle, out selfCalValid, out validSteps);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_CalAdjustLOExportCalibration", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustLOExportCalibration32(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int loNumber, int numberOfFrequencyPoints, double[] frequencies, double[] LOAttenuations);
            
            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_CalAdjustLOExportCalibration", CallingConvention = CallingConvention.StdCall)]
            public static extern int CalAdjustLOExportCalibration64(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int loNumber, int numberOfFrequencyPoints, double[] frequencies, double[] LOAttenuations);
            
            public static int CalAdjustLOExportCalibration(System.Runtime.InteropServices.HandleRef instrumentHandle, string channelList, int loNumber, int numberOfFrequencyPoints, double[] frequencies, double[] LOAttenuations)
            {
                if (Is64BitProcess)
                    return CalAdjustLOExportCalibration64(instrumentHandle, channelList, loNumber, numberOfFrequencyPoints, frequencies, LOAttenuations);
                else
                    return CalAdjustLOExportCalibration32(instrumentHandle, channelList, loNumber, numberOfFrequencyPoints, frequencies, LOAttenuations);
            }
            
            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ClearError", CallingConvention = CallingConvention.StdCall)]
            public static extern int ClearError32(System.Runtime.InteropServices.HandleRef instrumentHandle);
            
            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ClearError", CallingConvention = CallingConvention.StdCall)]
            public static extern int ClearError64(System.Runtime.InteropServices.HandleRef instrumentHandle);
            
            public static int ClearError(System.Runtime.InteropServices.HandleRef instrumentHandle)
            {
                if (Is64BitProcess)
                    return ClearError64(instrumentHandle);
                else
                    return ClearError32(instrumentHandle);
            }
            
            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_GetTerminalName", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetTerminalName32(System.Runtime.InteropServices.HandleRef instrumentHandle, int signal, string signalIdentifier, int bufferSize, StringBuilder terminalName);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_GetTerminalName", CallingConvention = CallingConvention.StdCall)]
            public static extern int GetTerminalName64(System.Runtime.InteropServices.HandleRef instrumentHandle, int signal, string signalIdentifier, int bufferSize, StringBuilder terminalName);

            public static int GetTerminalName(System.Runtime.InteropServices.HandleRef instrumentHandle, int signal, string signalIdentifier, int bufferSize, StringBuilder terminalName)
            {
                if (Is64BitProcess)
                    return GetTerminalName32(instrumentHandle, signal, signalIdentifier, bufferSize, terminalName);
                else
                    return GetTerminalName64(instrumentHandle, signal, signalIdentifier, bufferSize, terminalName);
            }
            
            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_LockSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int LockSession32(HandleRef instrumentHandle, ref ushort callerHasLock);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_LockSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int LockSession64(HandleRef instrumentHandle, ref ushort callerHasLock);

            public static int LockSession(HandleRef instrumentHandle, ref ushort callerHasLock)
            {
                if (Is64BitProcess)
                    return LockSession64(instrumentHandle, ref callerHasLock);
                else
                    return LockSession32(instrumentHandle, ref callerHasLock);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_UnlockSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int UnlockSession32(HandleRef instrumentHandle, ref ushort callerHasLock);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_UnlockSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int UnlockSession64(HandleRef instrumentHandle, ref ushort callerHasLock);

            public static int UnlockSession(HandleRef instrumentHandle, ref ushort callerHasLock)
            {
                if (Is64BitProcess)
                    return UnlockSession64(instrumentHandle, ref callerHasLock);
                else
                    return UnlockSession32(instrumentHandle, ref callerHasLock);
            }

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_SelfCalibrate", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelfCalibrate32(System.Runtime.InteropServices.HandleRef instrumentHandle, long stepsToOmit);
            
            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_SelfCalibrate", CallingConvention = CallingConvention.StdCall)]
            public static extern int SelfCalibrate64(System.Runtime.InteropServices.HandleRef instrumentHandle, long stepsToOmit);
            
            public static int SelfCalibrate(System.Runtime.InteropServices.HandleRef instrumentHandle, long stepsToOmit)
            {
                if (Is64BitProcess)
                    return SelfCalibrate64(instrumentHandle, stepsToOmit);
                else
                    return SelfCalibrate32(instrumentHandle, stepsToOmit);
            }

            // Added in 15.0

            [DllImport(rfsaModuleName32, EntryPoint = "niRFSA_ResetWithOptions", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetWithOptions32(System.Runtime.InteropServices.HandleRef instrumentHandle, ulong stepsToOmit);

            [DllImport(rfsaModuleName64, EntryPoint = "niRFSA_ResetWithOptions", CallingConvention = CallingConvention.StdCall)]
            public static extern int ResetWithOptions64(System.Runtime.InteropServices.HandleRef instrumentHandle, ulong stepsToOmit);

            public static int ResetWithOptions(System.Runtime.InteropServices.HandleRef instrumentHandle, ulong stepsToOmit)
            {
                if (Is64BitProcess)
                    return ResetWithOptions64(instrumentHandle, stepsToOmit);
                else
                    return ResetWithOptions32(instrumentHandle, stepsToOmit);
            }
        }
        #endregion PInvoke
    }
    
    
    #region Constants
    /// <summary>
    /// 
    /// </summary>
    public class niRFSAConstants
    {
        /// <summary>
        /// 
        /// </summary>
        public const int RfIn = 2000;
        /// <summary>
        /// 
        /// </summary>
        public const int IqIn = 2001;
        /// <summary>
        /// 
        /// </summary>
        public const int CalIn = 2002;
        /// <summary>
        /// 
        /// </summary>
        public const int IOnly = 2003;
        /// <summary>
        /// 
        /// </summary>
        public const int Differential = 2100;
        /// <summary>
        /// 
        /// </summary>
        public const int SingleEnded = 2101;
        /// <summary>
        /// 
        /// </summary>
        public const int IqAnalogEdge = 605;
        /// <summary>
        /// 
        /// </summary>
        public const int Iq = 100;
        /// <summary>
        /// 
        /// </summary>
        public const int Spectrum = 101;
        /// <summary>
        /// 
        /// </summary>
        public const string Pfi0Str = "PFI0";
        /// <summary>
        /// 
        /// </summary>
        public const string Pfi1Str = "PFI1";
        /// <summary>
        /// 
        /// </summary>
        public const string Rtsi0Str = "PXI_Trig0";
        /// <summary>
        /// 
        /// </summary>
        public const string Rtsi1Str = "PXI_Trig1";
        /// <summary>
        /// 
        /// </summary>
        public const string Rtsi2Str = "PXI_Trig2";
        /// <summary>
        /// 
        /// </summary>
        public const string Rtsi3Str = "PXI_Trig3";
        /// <summary>
        /// 
        /// </summary>
        public const string Rtsi4Str = "PXI_Trig4";
        /// <summary>
        /// 
        /// </summary>
        public const string Rtsi5Str = "PXI_Trig5";
        /// <summary>
        /// 
        /// </summary>
        public const string Rtsi6Str = "PXI_Trig6";
        /// <summary>
        /// 
        /// </summary>
        public const string Rtsi7Str = "PXI_Trig7";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiStarStr = "PXI_STAR";
        /// <summary>
        /// 
        /// </summary>
        public const int RisingEdge = 900;
        /// <summary>
        /// 
        /// </summary>
        public const int FallingEdge = 901;
        /// <summary>
        /// 
        /// </summary>
        public const int RisingSlope = 1000;
        /// <summary>
        /// 
        /// </summary>
        public const int FallingSlope = 1001;
        /// <summary>
        /// 
        /// </summary>
        public const int StartTrigger = 1100;
        /// <summary>
        /// 
        /// </summary>
        public const int RefTrigger = 702;
        /// <summary>
        /// 
        /// </summary>
        public const int AdvanceTrigger = 1102;
        /// <summary>
        /// 
        /// </summary>
        public const int ArmRefTrigger = 1103;
        /// <summary>
        /// 
        /// </summary>
        public const int ReadyForStartEvent = 1200;
        /// <summary>
        /// 
        /// </summary>
        public const int ReadyForAdvanceEvent = 1202;
        /// <summary>
        /// 
        /// </summary>
        public const int ReadyForRefEvent = 1201;
        /// <summary>
        /// 
        /// </summary>
        public const int EndOfRecordEvent = 1203;
        /// <summary>
        /// 
        /// </summary>
        public const int DoneEvent = 1204;
        /// <summary>
        /// 
        /// </summary>
        public const int RefClock = 1205;
        /// <summary>
        /// 
        /// </summary>
        public const string DoNotExportStr = "";
        /// <summary>
        /// 
        /// </summary>
        public const string ClkOutStr = "ClkOut";
        /// <summary>
        /// 
        /// </summary>
        public const string RefOutStr = "RefOut";
        /// <summary>
        /// 
        /// </summary>
        public const string LoInStr = "LO_In";
        /// <summary>
        /// 
        /// </summary>
        public const string OnBoardStr = "Onboard";
        /// <summary>
        /// 
        /// </summary>
        public const string IfCondOutStr = "IFCondRefOut";
        /// <summary>
        /// 
        /// </summary>
        public const string LoRefClkStr = "LORefClk";
        /// <summary>
        /// 
        /// </summary>
        public const string EndOfRecordEventStr = "EndOfRecordEvent";
        /// <summary>
        /// 
        /// </summary>
        public const string EndOrRecordEventStr = EndOfRecordEventStr;
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig0Str = "PXI_Trig0";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig1Str = "PXI_Trig1";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig2Str = "PXI_Trig2";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig3Str = "PXI_Trig3";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig4Str = "PXI_Trig4";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig5Str = "PXI_Trig5";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig6Str = "PXI_Trig6";
        /// <summary>
        /// 
        /// </summary>
        public const int Dbm = 200;
        /// <summary>
        /// 
        /// </summary>
        public const int VoltsSquared = 201;
        /// <summary>
        /// 
        /// </summary>
        public const int Dbmv = 202;
        /// <summary>
        /// 
        /// </summary>
        public const int Dbuv = 203;
        /// <summary>
        /// 
        /// </summary>
        public const int Volts = 204;
        /// <summary>
        /// 
        /// </summary>
        public const int Watts = 205;
        /// <summary>
        /// 
        /// </summary>
        public const int Rbw3db = 300;
        /// <summary>
        /// 
        /// </summary>
        public const int Rbw6db = 301;
        /// <summary>
        /// 
        /// </summary>
        public const int RbwBinWidth = 302;
        /// <summary>
        /// 
        /// </summary>
        public const int RbwEnbw = 303;
        /// <summary>
        /// 
        /// </summary>
        public const int NoAveraging = 400;
        /// <summary>
        /// 
        /// </summary>
        public const int RmsAveraging = 401;
        /// <summary>
        /// 
        /// </summary>
        public const int VectorAveraging = 402;
        /// <summary>
        /// 
        /// </summary>
        public const int PeakHoldAveraging = 403;
        /// <summary>
        /// 
        /// </summary>
        public const int Uniform = 500;
        /// <summary>
        /// 
        /// </summary>
        public const int Hanning = 501;
        /// <summary>
        /// 
        /// </summary>
        public const int Hamming = 502;
        /// <summary>
        /// 
        /// </summary>
        public const int BlackmanHarris = 503;
        /// <summary>
        /// 
        /// </summary>
        public const int ExactBlackman = 504;
        /// <summary>
        /// 
        /// </summary>
        public const int Blackman = 505;
        /// <summary>
        /// 
        /// </summary>
        public const int FlatTop = 506;
        /// <summary>
        /// 
        /// </summary>
        public const int _4TermBlackmanHarris = 507;
        /// <summary>
        /// 
        /// </summary>
        public const int _7TermBlackmanHarris = 508;
        /// <summary>
        /// 
        /// </summary>
        public const int LowSideLobe = 509;
        /// <summary>
        /// 
        /// </summary>
        public const int MostRecentSample = 700;
        /// <summary>
        /// 
        /// </summary>
        public const int FirstSample = 701;
        /// <summary>
        /// 
        /// </summary>
        public const int FirstPretriggerSample = 703;
        /// <summary>
        /// 
        /// </summary>
        public const int CurrentReadPosition = 704;
        /// <summary>
        /// 
        /// </summary>
        public const string OnboardClockStr = "OnboardClock";
        /// <summary>
        /// 
        /// </summary>
        public const string RefInStr = "RefIn";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiClkStr = "PXI_Clk";
        /// <summary>
        /// 
        /// </summary>
        public const string PxiClk10Str = "PXI_Clk10";
        /// <summary>
        /// 
        /// </summary>
        public const string ClkInStr = "ClkIn";
        /// <summary>
        /// 
        /// </summary>
        public const string RefOut2Str = "RefOut2";
        /// <summary>
        /// 
        /// </summary>
        public const string NoneStr = "None";
        /// <summary>
        /// 
        /// </summary>
        public const int None = 600;
        /// <summary>
        /// 
        /// </summary>
        public const int DigitalEdge = 601;
        /// <summary>
        /// 
        /// </summary>
        public const int SoftwareEdge = 604;
        /// <summary>
        /// 
        /// </summary>
        public const string PxiTrig7Str = "PXI_Trig7";
        /// <summary>
        /// 
        /// </summary>
        public const string TimerEventStr = "TimerEvent";
        /// <summary>
        /// 
        /// </summary>
        public const int IqPowerEdge = 603;
        /// <summary>
        /// 
        /// </summary>
        public const int Low = 800;
        /// <summary>
        /// 
        /// </summary>
        public const int Medium = 801;
        /// <summary>
        /// 
        /// </summary>
        public const int High = 802;
        /// <summary>
        /// 
        /// </summary>
        public const int LoInjectionHighSide = 1300;
        /// <summary>
        /// 
        /// </summary>
        public const int LoInjectionLowSide = 1301;
        /// <summary>
        /// 
        /// </summary>
        public const int Narrow = 800;
        /// <summary>
        /// 
        /// </summary>
        public const int Wide = 802;
        /// <summary>
        /// 
        /// </summary>
        public const int Disabled = 1900;
        /// <summary>
        /// 
        /// </summary>
        public const int Enabled = 1901;
        /// <summary>
        /// 
        /// </summary>
        public const int _1875MhzWide = 1400;
        /// <summary>
        /// 
        /// </summary>
        public const int _1875MhzNarrow = 1401;
        /// <summary>
        /// 
        /// </summary>
        public const int _53Mhz = 1402;
        /// <summary>
        /// 
        /// </summary>
        public const int Bypass = 1403;
        /// <summary>
        /// 
        /// </summary>
        public const int FsuPpm = 2000;
        /// <summary>
        /// 
        /// </summary>
        public const int FsuSecondsAfterLock = 2001;
        /// <summary>
        /// 
        /// </summary>
        public const int FsuSecondsAfterIo = 2002;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalRfBand1 = 1700;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalRfBand2 = 1701;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalRfBand3 = 1702;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalRfBand4 = 1703;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfFilterPath1 = 2100;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfFilterPath2 = 2101;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfFilterPath3 = 2102;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfFilterPath4 = 2103;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfFilterPath5 = 2104;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfFilterPath6 = 2105;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfFilterPath7 = 2106;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfFilterPath8 = 2107;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalLoPath1 = 2300;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalLoPath2 = 2301;
        /// <summary>
        /// 
        /// </summary>
        public const int RFPreampDisabled = 2500;
        /// <summary>
        /// 
        /// </summary>
        public const int RFPreampEnabledWhenInSignalPath = 2501;
        /// <summary>
        /// 
        /// </summary>
        public const int RFPreampEnabled = 2502;
        /// <summary>
        /// 
        /// </summary>
        public const int RFPreampAutomatic = 2503;
        /// <summary>
        /// 
        /// </summary>
        public const int PreselectorDisabled = 2600;
        /// <summary>
        /// 
        /// </summary>
        public const int PreselectorEnabledWhenInSignalPath = 2601;
        /// <summary>
        /// 
        /// </summary>
        public const int PreselectorEnabled = 2602;
        /// <summary>
        /// 
        /// </summary>
        public const int LOYigMainCoilDriveNormal = 2400;
        /// <summary>
        /// 
        /// </summary>
        public const int LOYigMainCoilDriveFast = 2401;
        /// <summary>
        /// 
        /// </summary>
        public const int CalToneDisabled = 2700;
        /// <summary>
        /// 
        /// </summary>
        public const int CalToneLowbandRf = 2701;
        /// <summary>
        /// 
        /// </summary>
        public const int CalToneHighbandRf = 2702;
        /// <summary>
        /// 
        /// </summary>
        public const int CalToneHighbandIf = 2703;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfAttenuationTableStandard = 2900;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfAttenuationTableAcpr = 2901;
        /// <summary>
        /// 
        /// </summary>
        public const int AC = 3001;
        /// <summary>
        /// 
        /// </summary>
        public const int DC = 3002;
        /// <summary>
        /// 
        /// </summary>
        public const int DownconverterCombinedResponse = 2802;
        /// <summary>
        /// 
        /// </summary>
        public const int DownconverterIfResponse = 2800;
        /// <summary>
        /// 
        /// </summary>
        public const int DownconverterRfResponse = 2801;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtAlignmentAbort = 3100;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtAlignmentCommit = 3101;


        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalAbort = 1500;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalCommit = 1501;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalDefault = 1800;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfAttenuationCalibration = 1600;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalIfResponseCalibration = 1601;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalLo1 = 2200;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalLo2 = 2201;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalLo3 = 2202;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalLoExportCalibration = 1603;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalMechanicalAttenuatorDisabled = 1801;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalRefLevelCalibration = 1602;
        /// <summary>
        /// 
        /// </summary>
        public const int ExtCalGainReferenceCalibration = 1604;
        /// <summary>
        /// 
        /// </summary>
        public const string ReferenceTriggerStr = "ReferenceTrigger";
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalDigitizerSelfCal = 0x0000000000000008;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalOmitNone = 0x0000000000000000;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalPreselectorAllignment = 0x0000000000000001;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalGainReference = 0x0000000000000002;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalIfFlatness = 0x0000000000000004;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalLoSelfCal = 0x0000000000000010;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalPreselectorAlignment = 0x0000000000000001;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalAmplitudeAccuracy = 0x0000000000000020;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalResidualLoPower = 0x0000000000000040;
        /// <summary>
        /// 
        /// </summary>
        public const int SelfCalImageSuppresion = 0x0000000000000080;
        /// <summary>
        /// 
        /// </summary>
        public const string StartTriggerStr = "StartTrigger";
        /// <summary>
        /// 
        /// </summary>
        public const string SyncStartTriggerStr = "Sync_Start";
        /// <summary>
        /// 
        /// </summary>
        public const string SyncRefTriggerStr = "Sync_Ref";
        /// <summary>
        /// 
        /// </summary>
        public const string SyncAdvanceTriggerStr = "Sync_Advance";
        /// <summary>
        /// 
        /// </summary>
        public const int VsaCombinedResponse = 2804;
        /// <summary>
        /// 
        /// </summary>
        public const int VsaIfResponse = 2803;

        // These are added to avoid breaking old code
        /// <summary>
        /// 
        /// </summary>
        [Obsolete("This constant is obsolete; use constant ExtCalIfAttenuationTableStandard instead")]
        public const int NiextCalIfAttenuationTableStandard = ExtCalIfAttenuationTableStandard;

        /// <summary>
        /// 
        /// </summary>
        [Obsolete("This constant is obsolete; use constant ExtCalIfAttenuationTableAcpr instead")]
        public const int NiextCalIfAttenuationTableAcpr = ExtCalIfAttenuationTableAcpr;

        /// <summary>
        /// 
        /// </summary>
        [Obsolete("This constant is obsolete; use constant ClkOutStr instead")]
        public const string CalClkOutStr = ClkOutStr;

        #region Constants added between 2.5.2 and 2.9
        /// <summary>
        /// 
        /// </summary>
        public const int ExtAllignmentPreselector = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPathNone = 3300;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath1 = 3301;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath2 = 3302;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath3 = 3303;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath4 = 3304;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath5 = 3305;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath6 = 3306;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath7 = 3307;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath8 = 3308;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath9 = 3309;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath10 = 3310;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath11 = 3311;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath12 = 3312;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath13 = 3313;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath14 = 3314;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath15 = 3315;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPath16 = 3316;
        /// <summary>
        /// 
        /// </summary>
        public const int RfPreselectorPathExternalFilter = 3317;
        /// <summary>
        /// 
        /// </summary>
        public const int StepGainDisabled = 3200;
        /// <summary>
        /// 
        /// </summary>
        public const int StepGainEnabled = 3201;
        /// <summary>
        /// 
        /// </summary>
        public const int NotchFilterDisabled = 3400;
        /// <summary>
        /// 
        /// </summary>
        public const int NotchFilterEnabledWhenInSignal = 3401;
        /// <summary>
        /// 
        /// </summary>
        public const int NotchFilterEnabled = 3402;
        /// <summary>
        /// 
        /// </summary>
        public const int SignalCondioningEnabled = 3600;
        /// <summary>
        /// 
        /// </summary>
        public const int SignalCondioningBypassed = 3601;

        #endregion


        #region Constants added between 2.9 and 14.1
		/// <summary>
		/// 
		/// </summary>
		public const int MinHoldAveraging = 404;
        /// <summary>
        /// 
        /// </summary>
		public const int ScalarAveraging = 405;
        /// <summary>
        /// 
        /// </summary>
		public const int LogAveraging = 406 ;
        /// <summary>
        /// 
        /// </summary>
		public const int Gaussian = 510 ;
        /// <summary>
        /// 
        /// </summary>
		public const int KaiserBessel = 511 ;
        /// <summary>
        /// 
        /// </summary>
		public const int User = 1206;
        /// <summary>
        /// 
        /// </summary>
		public const string DownconverterLo2OutStr = "downconverterlo2out";
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalIfFilterPath9 = 2108 ;
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalIfFilterPath10 = 2109 ;
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalIfFilterPath11 = 2110 ;
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalLoPath3 = 2302 ;
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalLoPath4 = 2303 ;
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalLoPath5 = 2304 ;
        /// <summary>
        /// 
        /// </summary>
		public const int CalToneLowbandRfWithoutAlc = 2704 ;
        /// <summary>
        /// 
        /// </summary>
		public const int CalToneCombGenerator = 2705 ;
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalRfLowbandSignalConditioningPath1 = 3700 ;
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalRfLowbandSignalConditioningPath2 = 3701 ;
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalRfLowbandSignalConditioningPath3 = 3702 ;
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalRfLowbandSignalConditioningPath4 = 3703 ;
        /// <summary>
        /// 
        /// </summary>
		public const int ExtCalRfLowbandSignalConditioningPath5 = 3704 ;
        /// <summary>
        /// 
        /// </summary>
        public const int DigitalLevel = 602;
        #endregion


    }
    #endregion Constants

    #region Structs
    /// <summary>
    /// 
    /// </summary>
    [StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 8)]
    public struct niRFSA_wfmInfo
    {
        /// <summary>
        /// 
        /// </summary>
        public Double absoluteInitialX;
        /// <summary>
        /// 
        /// </summary>
        public Double relativeInitialX;
        /// <summary>
        /// 
        /// </summary>
        public Double xIncrement;
        /// <summary>
        /// 
        /// </summary>
        public Int64 actualSamples;
        /// <summary>
        /// 
        /// </summary>
        public Double offset;
        /// <summary>
        /// 
        /// </summary>
        public Double gain;
        /// <summary>
        /// 
        /// </summary>
        public Double reserved1;
        /// <summary>
        /// 
        /// </summary>
        public Double reserved2;

    }
    /// <summary>
    /// 
    /// </summary>
    [StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 8)]
    public struct niRFSA_spectrumInfo
    {
        /// <summary>
        /// 
        /// </summary>
        public Double initialFrequency;
        /// <summary>
        /// 
        /// </summary>
        public Double frequencyIncrement;
        /// <summary>
        /// 
        /// </summary>
        public Int32 numberOfSpectralLines;
        /// <summary>
        /// 
        /// </summary>
        public Double reserved1;
        /// <summary>
        /// 
        /// </summary>
        public Double reserved2;
        /// <summary>
        /// 
        /// </summary>
        public Double reserved3;
        /// <summary>
        /// 
        /// </summary>
        public Double reserved4;
        /// <summary>
        /// 
        /// </summary>
        public Double reserved5;

    }
    /// <summary>
    /// 
    /// </summary>
    [StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 1)]
    public struct SmtSpectrumInfo
    {
        /// <summary>
        /// 
        /// </summary>
        public ushort spectrumType;
        /// <summary>
        /// 
        /// </summary>
        public ushort linearDB;
        /// <summary>
        /// 
        /// </summary>
        public ushort window;
        /// <summary>
        /// 
        /// </summary>
        public int windowSize;
        /// <summary>
        /// 
        /// </summary>
        public int FFTSize;

    }
    /// <summary>
    /// 
    /// </summary>
    [StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 1)]
    public struct niRFSA_coefficientInfo
    {
        /// <summary>
        /// 
        /// </summary>
        public Double offset;
        /// <summary>
        /// 
        /// </summary>
        public Double gain;
        /// <summary>
        /// 
        /// </summary>
        public Double reserved1;
        /// <summary>
        /// 
        /// </summary>
        public Double reserved2;

    }
    #endregion Structs

    #region Attributes
    /// <summary>
    /// 
    /// </summary>
    public enum niRFSAProperties
    {

        /// <summary>
        /// System.Int32
        /// </summary>
        AcquisitionType = 1150001,

        /// <summary>
        /// System.Double
        /// </summary>
        ReferenceLevel = 1150004,

        /// <summary>
        /// System.Double
        /// </summary>
        Attenuation = 1150005,

        /// <summary>
        /// System.Double
        /// </summary>
        MixerLevel = 1150006,

        /// <summary>
        /// System.Double
        /// </summary>
        IqCarrierFrequency = 1150059,

        /// <summary>
        /// System.Double
        /// </summary>
        IqRate = 1150007,

        /// <summary>
        /// System.Boolean
        /// </summary>
        NumberOfSamplesIsFinite = 1150008,

        /// <summary>
        /// System.Int64
        /// </summary>
        NumberOfSamples = 1150009,

        /// <summary>
        /// System.Boolean
        /// </summary>
        NumberOfRecordsIsFinite = 1150010,

        /// <summary>
        /// System.Int64
        /// </summary>
        NumberOfRecords = 1150011,

        /// <summary>
        /// System.Double
        /// </summary>
        [Obsolete("Use CenterFrequency")]
        SpectrumCenterFrequency = 1150002,
        /// <summary>
        /// 
        /// </summary>
        CenterFrequency = 1150002,

        /// <summary>
        /// System.Double
        /// </summary>
        SpectrumSpan = 1150003,

        /// <summary>
        /// System.Int32
        /// </summary>
        PowerSpectrumUnits = 1150012,

        /// <summary>
        /// System.Double
        /// </summary>
        ResolutionBandwidth = 1150013,

        /// <summary>
        /// System.Int32
        /// </summary>
        ResolutionBandwidthType = 1150014,

        /// <summary>
        /// System.Int32
        /// </summary>
        NumberOfSpectralLines = 1150018,

        /// <summary>
        /// System.Int32
        /// </summary>
        SpectrumAveragingMode = 1150016,

        /// <summary>
        /// System.Int32
        /// </summary>
        SpectrumNumberOfAverages = 1150015,

        /// <summary>
        /// System.Int32
        /// </summary>
        FftWindowType = 1150017,

        /// <summary>
        /// System.Int32
        /// </summary>
        FftWindowSize = 1150049,

        /// <summary>
        /// System.Int32
        /// </summary>
        FftSize = 1150050,

        /// <summary>
        /// System.Int32
        /// </summary>
        FetchRelativeTo = 1150045,

        /// <summary>
        /// System.Int32
        /// </summary>
        FetchOffset = 1150046,

        /// <summary>
        /// System.Int32
        /// </summary>
        RecordsDone = 1150047,

        /// <summary>
        /// System.String
        /// </summary>
        RefClockSource = 1150019,

        /// <summary>
        /// System.Double
        /// </summary>
        RefClockRate = 1150020,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedRefClockOutputTerminal = 1150072,

        /// <summary>
        /// System.String
        /// </summary>
        DigitizerSampleClockTimebaseSource = 1150021,

        /// <summary>
        /// System.Double
        /// </summary>
        DigitizerSampleClockTimebaseRate = 1150022,

        /// <summary>
        /// System.String
        /// </summary>
        PxiChassisClk10Source = 1150023,

        /// <summary>
        /// System.Int32
        /// </summary>
        StartTriggerType = 1150024,

        /// <summary>
        /// System.String
        /// </summary>
        DigitalEdgeStartTriggerSource = 1150025,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalEdgeStartTriggerEdge = 1150026,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedStartTriggerOutputTerminal = 1150027,

        /// <summary>
        /// System.Int32
        /// </summary>
        RefTriggerType = 1150028,

        /// <summary>
        /// System.Int32
        /// </summary>
        RefTriggerPretriggerSamples = 1150035,

        /// <summary>
        /// System.String
        /// </summary>
        DigitalEdgeRefTriggerSource = 1150029,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitalEdgeRefTriggerEdge = 1150030,

        /// <summary>
        /// System.String
        /// </summary>
        IqPowerEdgeRefTriggerSource = 1150055,

        /// <summary>
        /// System.Double
        /// </summary>
        IqPowerEdgeRefTriggerLevel = 1150056,

        /// <summary>
        /// System.Int32
        /// </summary>
        IqPowerEdgeRefTriggerSlope = 1150057,

        /// <summary>
        /// System.Double
        /// </summary>
        RefTriggerMinimumQuietTime = 1150058,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedRefTriggerOutputTerminal = 1150032,

        /// <summary>
        /// System.Double
        /// </summary>
        RefTriggerDelay = 1150060,

        /// <summary>
        /// System.Double
        /// </summary>
        StartToRefTriggerHoldoff = 1150033,

        /// <summary>
        /// System.Double
        /// </summary>
        RefToRefTriggerHoldoff = 1150034,

        /// <summary>
        /// System.Int32
        /// </summary>
        AdvanceTriggerType = 1150036,

        /// <summary>
        /// System.String
        /// </summary>
        DigitalEdgeAdvanceTriggerSource = 1150037,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedAdvanceTriggerOutputTerminal = 1150038,

        /// <summary>
        /// System.Int32
        /// </summary>
        ArmRefTriggerType = 1150039,

        /// <summary>
        /// System.String
        /// </summary>
        DigitalEdgeArmRefTriggerSource = 1150040,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedReadyForStartEventOutputTerminal = 1150041,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedReadyForAdvanceEventOutputTerminal = 1150042,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedReadyForRefEventOutputTerminal = 1150043,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedEndOfRecordEventOutputTerminal = 1150044,

        /// <summary>
        /// System.String
        /// </summary>
        ExportedDoneEventOutputTerminal = 1150054,

        /// <summary>
        /// System.Double
        /// </summary>
        LoFrequency = 1150068,

        /// <summary>
        /// System.Int32
        /// </summary>
        DownconverterLoopBandwidth = 1150067,

        /// <summary>
        /// System.Boolean
        /// </summary>
        DigitalIfEqualizationEnabled = 1150048,

        /// <summary>
        /// System.Double
        /// </summary>
        DownconverterGain = 1150065,

        /// <summary>
        /// System.Int32
        /// </summary>
        LoInjectionSide = 1150069,

        /// <summary>
        /// System.Double
        /// </summary>
        DigitizerVerticalRange = 1150070,

        /// <summary>
        /// System.Boolean
        /// </summary>
        EnableFractionalResampling = 1150071,

        /// <summary>
        /// System.String
        /// </summary>
        SerialNumber = 1150053,

        /// <summary>
        /// System.Double
        /// </summary>
        DeviceTemperature = 1150051,

        /// <summary>
        /// System.Double
        /// </summary>
        TemperatureReadInterval = 1150061,

        /// <summary>
        /// System.Boolean
        /// </summary>
        Cache = 1050004,

        /// <summary>
        /// System.Boolean
        /// </summary>
        InterchangeCheck = 1050021,

        /// <summary>
        /// System.String
        /// </summary>
        DriverSetup = 1050007,

        /// <summary>
        /// System.Boolean
        /// </summary>
        QueryInstrumentStatus = 1050003,

        /// <summary>
        /// System.Boolean
        /// </summary>
        RangeCheck = 1050002,

        /// <summary>
        /// System.Boolean
        /// </summary>
        RecordCoercions = 1050006,

        /// <summary>
        /// System.Boolean
        /// </summary>
        Simulate = 1050005,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverDescription = 1050514,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverPrefix = 1050302,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverVendor = 1050513,

        /// <summary>
        /// System.String
        /// </summary>
        SpecificDriverRevision = 1050551,

        /// <summary>
        /// System.String
        /// </summary>
        SupportedInstrumentModels = 1050327,

        /// <summary>
        /// System.String
        /// </summary>
        InstrumentManufacturer = 1050511,

        /// <summary>
        /// System.String
        /// </summary>
        InstrumentModel = 1050512,

        /// <summary>
        /// System.String
        /// </summary>
        InstrumentFirmwareRevision = 1050510,

        /// <summary>
        /// System.String
        /// </summary>
        LogicalName = 1050305,

        /// <summary>
        /// System.String
        /// </summary>
        IoResourceDescriptor = 1050304,

        /// <summary>
        /// string
        /// </summary>
        ActiveConfigurationList = 1150092,

        /// <summary>
        /// long
        /// </summary>
        ActiveConfigurationListStep = 1150093,

        /// <summary>
        /// System.Int32
        /// </summary>
        CalRfPathSelection = 1150083,

        /// <summary>
        /// int
        /// </summary>
        DataTransferBlockSize = 1150105,

        /// <summary>
        /// double
        /// </summary>
        DataTransferMaximumBandwidth = 1150104,

        /// <summary>
        /// System.Int32
        /// </summary>
        DigitizerDitherEnabled = 1150080,

        /// <summary>
        /// double
        /// </summary>
        DigitizerTemperature = 1150090,

        /// <summary>
        /// double
        /// </summary>
        DownconverterCenterFrequency = 1150082,

        /// <summary>
        /// double
        /// </summary>
        ExternalGain = 1150094,

        /// <summary>
        /// double
        /// </summary>
        FrequencySettling = 1150088,

        /// <summary>
        /// System.Int32
        /// </summary>
        FrequencySettlingUnits = 1150087,

        /// <summary>
        /// double
        /// </summary>
        If1AttenValue = 1150078,

        /// <summary>
        /// double
        /// </summary>
        If2AttenValue = 1150079,

        /// <summary>
        /// double
        /// </summary>
        IfAttenuation = 1150074,

        /// <summary>
        /// System.Int32
        /// </summary>
        IfFilter = 1150075,

        /// <summary>
        /// double
        /// </summary>
        IfOutputFrequency = 1150086,

        /// <summary>
        /// double
        /// </summary>
        LoTemperature = 1150089,

        /// <summary>
        /// System.Int32
        /// </summary>
        MechanicalAttenuatorEnabled = 1150081,

        /// <summary>
        /// long
        /// </summary>
        MemorySize = 1150085,

        /// <summary>
        /// string
        /// </summary>
        ModuleRevision = 1150091,

        /// <summary>
        /// bool
        /// </summary>
        P2pEnabled = 1150097,

        /// <summary>
        /// bool
        /// </summary>
        P2pEndpointOverflow = 1150103,

        /// <summary>
        /// long
        /// </summary>
        P2pEndpointSize = 1150102,

        /// <summary>
        /// long
        /// </summary>
        P2pFifoEndpointCount = 1150098,

        /// <summary>
        /// long
        /// </summary>
        P2pMostSamplesAvailableInEndpoint = 1150101,

        /// <summary>
        /// bool
        /// </summary>
        P2pOnboardMemoryEnabled = 1150107,

        /// <summary>
        /// long
        /// </summary>
        P2pSamplesAvailableInEndpoint = 1150100,

        /// <summary>
        /// long
        /// </summary>
        P2pSamplesTransferred = 1150099,

        /// <summary>
        /// double
        /// </summary>
        PhaseOffset = 1150106,

        /// <summary>
        /// int
        /// </summary>
        RfAttenuationIndex = 1150076,

        /// <summary>
        /// int
        /// </summary>
        RfAttenuationTable = 1150077,

        /// <summary>
        /// double
        /// </summary>
        TimerEventInterval = 1150096,

        /// <summary>
        /// int
        /// </summary>
        CalIfAttenuationIndex = 1150109,

        /// <summary>
        /// int
        /// </summary>
        CalRfElectronicAttenuationIndex = 1150110,

        /// <summary>
        /// int
        /// </summary>
        CalRfMechanicalAttenuationIndex = 1150111,

        /// <summary>
        /// int
        /// </summary>
        CalIfFilterSelection = 1150112,

        /// <summary>
        /// int
        /// </summary>
        CalLoPathSelection = 1150113,

        /// <summary>
        /// double
        /// </summary>
        CalLo1Attenuation = 1150114,

        /// <summary>
        /// double
        /// </summary>
        CalLo2Attenuation = 1150115,

        /// <summary>
        /// double
        /// </summary>
        CalLo3Attenuation = 1150116,

        /// <summary>
        /// System.String
        /// </summary>
        ReadyForStartEventTerminalName = 1150117,

        /// <summary>
        /// System.String
        /// </summary>
        ReadyForAdvanceEventTerminalName = 1150118,

        /// <summary>
        /// System.String
        /// </summary>
        ReadyForRefEventTerminalName = 1150119,

        /// <summary>
        /// System.String
        /// </summary>
        EndOfRecordEventTerminalName = 1150120,

        /// <summary>
        /// System.String
        /// </summary>
        DoneEventTerminalName = 1150121,

        /// <summary>
        /// System.String
        /// </summary>
        StartTriggerTerminalName = 1150122,

        /// <summary>
        /// System.String
        /// </summary>
        RefTriggerTerminalName = 1150123,

        /// <summary>
        /// System.String
        /// </summary>
        AdvanceTriggerTerminalName = 1150124,

        /// <summary>
        /// double  
        /// </summary>
        DeviceInstantaneousBandwidth = 1150125,

        /// <summary>
        /// long
        /// </summary>
        ConfigurationListStepInProgress = 1150126,

        /// <summary>
        /// double
        /// </summary>
        MixerLevelOffset = 1150127,

        /// <summary>
        /// double
        /// </summary>
        MechanicalAttenuation = 1150128,

        /// <summary>
        /// int
        /// </summary>
        RfPreampEnabled = 1150129,

        /// <summary>
        /// double
        /// </summary>
        IfOutputPowerLevel = 1150130,

        /// <summary>
        /// double
        /// </summary>
        IfOutputPowerLevelOffset = 1150131,

        /// <summary>
        /// int
        /// </summary>
        DownconvertorPreselectorEnabled = 1150132,

        /// <summary>
        /// int
        /// </summary>
        [Obsolete("use DownconvertorPreselectorEnabled instead")]
        PreselectorEnabled = DownconvertorPreselectorEnabled,

        /// <summary>
        /// bool
        /// </summary>
        LoExportEnabled = 1150134,

        /// <summary>
        /// int
        /// </summary>
        LoYigMainCoilDrive = 1150135,

        /// <summary>
        /// bool
        /// </summary>
        PreselectorPresent = 1150136,

        /// <summary>
        /// bool
        /// </summary>
        RfPreampPresent = 1150137,
        
        /// <summary>
        /// int
        /// </summary>
        DownconvertorCalToneMode = 1150139,

        /// <summary>
        /// int
        /// </summary>
        [Obsolete(" Use DownconvertorCalToneMode instead")]
        CalToneMode = DownconvertorCalToneMode,

        /// <summary>
        /// double
        /// </summary>
        DownconvertorCalToneFrequency = 1150140,

        /// <summary>
        /// double
        /// </summary>
        [Obsolete("Use DownconvertorCalToneFrequency instead")]
        CalToneFrequency= DownconvertorCalToneFrequency,

        /// <summary>
        /// int
        /// </summary>
        CalIfAttenuationTableSelection = 1150141,

        /// <summary>
        /// double
        /// </summary>
        MinimumAcpr = 1150142,

        /// <summary>
        /// 
        /// </summary>
        SpectrumOspSamplingRatio = 1150144,

        /// <summary>
        /// double
        /// </summary>
        CalibrationCorrectionThroughFilter = 1150146,

        /// <summary>
        /// double
        /// </summary>
        CalibrationCorrection300KhzFilter = 1150147,

        /// <summary>
        /// double
        /// </summary>
        CalibrationCorrection5MhzFilter = 1150148,

        /// <summary>
        /// int
        /// </summary>
        ChannelCoupling = 1150149,

        /// <summary>
        /// double
        /// </summary>
        OspDataScalingFactor = 1150151,

        /// <summary>
        /// bool
        /// </summary>
        AllowMoreRecordsThanMemory = 1150154,

        /// <summary>
        /// double
        /// </summary>
        RfAttenuationStepSize = 1150155,
        #region Properties added between 2.5 and 2.9

        /// <summary>
        /// int
        /// </summary>
        StepGainEnabled = 1150157,


        /// <summary>
        /// int
        /// </summary>
        SignalConditioningEnabled = 1150160,

        /// <summary>
        /// int
        /// </summary>
        IfConditioningDownConversionEnabled = 1150161,

        /// <summary>
        /// int
        /// </summary>
        RfPreselectorFilter = 1150166,

        /// <summary>
        /// int
        /// </summary>
        NotchFilterEnabled = 1150167,


        /// <summary>
        /// Double
        /// </summary>
        IfFilterBandwidth = 1150205,

        /// <summary>
        /// Int
        /// </summary>
        LowFrequencyByPassEnabled = 1150207,


        /// <summary>
        /// String
        /// </summary>
        FpgaBitFilePath = 1150221,

        /// <summary>
        /// Int
        /// </summary>
        SmoothSpectrumEnabled = 1150219,


        /// <summary>
        /// Double
        /// </summary>
        RfConditioningTemperature = 1150211, //ReadOnly

        /// <summary>
        /// Double
        /// </summary>
        IfConditioningTemperature = 1150210, //ReadOnly
        
        /// <summary>
        /// Double
        /// </summary>
        FftWindowShapeFactor = 1150206, //ReadOnly


        /// <summary>
        /// string
        /// </summary>
        LoSource = 1150162,


        /// <summary>
        /// bool
        /// </summary>
        DdcRefTriggerOverride = 1150164,

        /// <summary>
        /// System.Double
        /// </summary>
        MinimumReconfigTime = 1150165,

        /// <summary>
        /// string
        /// </summary>
        [Obsolete(" Use ReconfigurationTriggerSource instead")]
        ConfigurationListStepTriggerSource = ReconfigurationTriggerSource,

        /// <summary>
        /// string
        /// </summary>
        ReconfigurationTriggerSource = 1150095,

        /// <summary>
        /// System.Int32
        /// </summary>
        ContiguousMultiRecord = 1150172,

        /// <summary>
        /// string
        /// </summary>
        TimerStartSource = 1150173,

        /// <summary>
        /// Int
        /// </summary>
        RfPreselectorCalToneMode = 1150208,

        /// <summary>
        /// Double
        /// </summary>
        RfPreselectorCalToneFrequency = 1150209,


        /// <summary>
        /// System.Double
        /// </summary>
        CalToneStepAttenuation = 1150168,

        /// <summary>
        /// System.Double
        /// </summary>
        CalTonePowerReferredToRfIn = 1150174,

        /// <summary>
        /// System.Double
        /// </summary>
        IqInPortCarrierrFrequency = 1150181,

        /// <summary>
        /// System.Int32
        /// </summary>
        IqInportTerminalConfiguration = 1150182,

        /// <summary>
        /// System.Double
        /// </summary>
        IqInPortVerticalRange = 1150183,

        /// <summary>
        /// bool
        /// </summary>
        SyncAdvanceTriggerMaster = 1150184,

        /// <summary>
        /// string
        /// </summary>
        SyncAdvanceTriggerDistLine = 1150185,

        /// <summary>
        /// System.Double
        /// </summary>
        IqInPortTemperature = 1150204,


        /// <summary>
        /// System.Int32
        /// </summary>
        InputPort = 1150180,


        /// <summary>
        /// System.Double
        /// </summary>
        LoInPower = 1150186,

        /// <summary>
        /// System.Int32
        /// </summary>
        LoPllFractionalModeEnabled = 1150187,

        /// <summary>
        /// System.Double
        /// </summary>
        LoFrequencyStepSize = 1150188,

        /// <summary>
        /// bool
        /// </summary>
        SyncStartTriggerMaster = 1150176,

        /// <summary>
        /// string
        /// </summary>
        SyncStartTriggerDistLine = 1150177,

        /// <summary>
        /// bool
        /// </summary>
        SyncRefTriggerMaster = 1150178,

        /// <summary>
        /// string
        /// </summary>
        SyncRefTriggerDistLine = 1150179,


        /// <summary>
        /// System.Int32
        /// </summary>
        SyncRefTriggerDelayEnabled = 1150189,

        /// <summary>
        /// bool
        /// </summary>
        SyncSampleClockMaster = 1150217,

        /// <summary>
        /// String
        /// </summary>
        SyncSampleClockDistLine = 1150218,



        /// <summary>
        /// System.Double
        /// </summary>
        DecimationDelay = 1150191,

        /// <summary>
        /// System.Int32
        /// </summary>
        IqAnalogEdgeRefTriggerSource = 1150192,

        /// <summary>
        /// RfsaIqAnalogEdgeRefTriggerSlope
        /// </summary>
        IqAnalogEdgeRefTriggerSlope = 1150193,

        /// <summary>
        /// System.Double
        /// </summary>
        IqAnalogEdgeRefTriggerLevel = 1150194,

        /// <summary>
        /// System.Double
        /// </summary>
        IqAnalogEdgeRefTriggerHysteresis = 1150195,


        /// <summary>
        /// Double
        /// </summary>
        DownconvertorFrequencyOffset = 1150203,


        #endregion

        #region attributes added between 2.9 and 14.1
        /// <summary>
        /// Double
        /// </summary>
        DigitizerSampleClockRate = 1150228,

        /// <summary>
        /// string
        /// </summary>
        ExportedDigitizerSampleClockOutputTerminal = 1150229,
		
		/// <summary>
        /// bool
        /// </summary>
		Lo2ExportEnabled = 1150235,

		/// <summary>
        /// Double
        /// </summary>
		CalibrationCorrection100mhzFilter = 1150223,
		
		/// <summary>
        /// Double
        /// </summary>
		CalibrationCorrection320mhzFilter = 1150224,
		
		/// <summary>
        /// Double
        /// </summary>
		CalibrationCorrection765mhzFilter = 1150225,
		
		/// <summary>
        /// string
        /// </summary>
		CalDigitizerId = 1150226,
		
		/// <summary>
        /// int
        /// </summary>
		CalRfLowbandSignalConditioningPathSelection = 1150215,
		
		/// <summary>
        /// Double
        /// </summary>
		RfHighPassFiltering = 1150220,
		
		/// <summary>
        /// int
        /// </summary>
		CalIfAttenuationTableSize = 1150216,
		
		/// <summary>
        /// Double
        /// </summary>
		MaxDeviceInstantaneousBandwidth = 1150236,
		
		/// <summary>
        /// Double
        /// </summary>
		MaxIQRate = 1150237,
		
		
		/// <summary>
        /// int
        /// </summary>
		NoiseSourcePowerEnabled = 1150222,
		
		/// <summary>
        /// string
        /// </summary>
		FpgaTargetName = 1150233,
		
		
		/// <summary>
        /// Double
        /// </summary>
		SubspanOverlap = 1150234,
		
        #endregion


        /// <summary>
        /// int
        /// </summary>
        PreselectorTuningDacValue5665 = 1150158,

        /// <summary>
        /// double
        /// </summary>
        DeviceConfigurationTemperature = 1150159,


        /// <summary>
        /// System.Double
        /// </summary>
        FftWidth = 1150169,

        /// <summary>
        /// System.Int32
        /// </summary>
        InputIsolationEnabled = 1150170,


        /// <summary>
        /// System.Double
        /// </summary>
        StartTriggerDelay = 1150175,


        /// <summary>
        /// string
        /// </summary>
        IqAnalogEdgeRefTrigger = 1150092,
        
        /// <summary>
        /// System.Int32
        /// </summary>
        RefTriggerOspDelayEnabled = 1150196,


        /// <summary>
        /// System.Int32
        /// </summary>
        ChannelCount = 1050203,
        
        /// <summary>
        /// System.String
        /// </summary>
        GroupCapabilities = 1050401,
        
        /// <summary>
        /// System.Int32
        /// </summary>
        SpecificDriverClassSpecMajorVersion = 1050515,
        
        /// <summary>
        /// System.Int32
        /// </summary>
        SpecificDriverClassSpecMinorVersion = 1050516,

    }
    #endregion Attributes
}
