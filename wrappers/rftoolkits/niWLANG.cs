//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Measurement Studio for NI WLAN Generation 15.5.
//     
//     Documentation is available at Start»All Programs»National Instruments»NI WLAN Generation Toolkit»WLAN Generation Toolkit Documentation>>NI WLAN Generation Toolkit Help.
//      
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Text;
using NationalInstruments.ModularInstruments.Interop;

namespace NationalInstruments.RFToolkits.Interop
{
    /// <summary>
    /// 
    /// </summary>
    public class niWLANG : IDisposable
    {
        private System.Runtime.InteropServices.HandleRef _handle;

        private bool _isNamedSession;

        /// <summary>
        /// Looks up an existing niWLAN generation session and returns the refnum that you can pass to subsequent niWLAN generation functions. If the lookup fails, the niWLANG_OpenSession function creates a new niWLAN generation session and returns a new refnum.
        /// 
        /// </summary>
        ///<param>
        /// toolkitCompatibilityVersion
        /// int32
        /// Specifies the version of the toolkit in use. If the behavior of the toolkit changes in a new version, use this parameter to specify that you want to continue using the behavior of the previous release.
        ///    niWLANG_VAL_TOOLKIT_COMPATIBILITY_VERSION_100 (100)
        ///   Specifies that the toolkit version is 1.0.0.
        ///</param>
        public niWLANG(int toolkitCompatibilityVersion)
        {
            IntPtr handle;
            int isNewSession;
            int pInvokeResult = PInvoke.niWLANG_OpenSession(null, toolkitCompatibilityVersion, out handle, out isNewSession);
            TestForError(pInvokeResult);
            _handle = new HandleRef(this, handle);
            _isNamedSession = false;
        }

        /// <summary>
        /// Looks up an existing niWLAN generation session and returns the refnum that you can pass to subsequent niWLAN generation functions. If the lookup fails, the niWLANG_OpenSession function creates a new niWLAN generation session and returns a new refnum.
        /// Make sure you call Close for the named session. Dispose does not close named session.
        /// </summary>
        ///<param>
        /// sessionName
        /// char[]
        /// Specifies the name of the session that you are looking up or creating. If a session with the same name already exists, this function returns a reference to that session. To get the reference to an existing open session, call the niWLANG_OpenSession function and specify the same name as an existing open session function in the sessionName parameter.
        ///  You can obtain the reference to an existing session multiple times if you have not called the niWLANG_CloseSession function in that session. You do not need to close the session multiple times. To create an unnamed session, pass an empty string to the sessionName parameter. 
        /// Tip  National Instruments recommends that you call the niWLANG_CloseSession function for each uniquely-named instance of the niWLANG_OpenSession function or each instance of the niWLANG_OpenSession function with an unnamed session.
        ///</param>
        ///<param>
        /// toolkitCompatibilityVersion
        /// int32
        /// Specifies the version of the toolkit in use. If the behavior of the toolkit changes in a new version, use this parameter to specify that you want to continue using the behavior of the previous release.
        ///    niWLANG_VAL_TOOLKIT_COMPATIBILITY_VERSION_100 (100)
        ///   Specifies that the toolkit version is 1.0.0.
        ///</param>
        ///<param>
        /// isNewSession
        /// int32*
        /// Returns TRUE if the function creates a new session. This parameter returns FALSE if the function returns a reference to an existing session.
        ///</param>
        ///<param>
        /// session
        /// niWLANGSession*
        /// Returns the niWLAN generation session.
        ///</param>
        public niWLANG(string sessionName, int toolkitCompatibilityVersion, out int isNewSession)
        {
            IntPtr handle;
            int pInvokeResult = PInvoke.niWLANG_OpenSession(sessionName, toolkitCompatibilityVersion, out handle, out isNewSession);
            TestForError(pInvokeResult);
            _handle = new HandleRef(this, handle);
            if (String.IsNullOrEmpty(sessionName))
                _isNamedSession = false;
            else
                _isNamedSession = true;
        }
        /// <summary>
        /// 
        /// </summary>
        ~niWLANG()
        {
            Dispose(false);
        }
        /// <summary>
        /// 
        /// </summary>
        public HandleRef Handle
        {
            get
            {
                return _handle;
            }
        }
        /// <summary>
        /// Closes the niWLAN generation session and releases resources associated with that session.
        /// 
        /// </summary>
        public void Close()
        {
            if (!_isNamedSession)
            {
                Dispose();
            }
            else
            {
                if (!Handle.Handle.Equals(IntPtr.Zero))
                    PInvoke.niWLANG_CloseSession(Handle);
            }
        }
        /// <summary>
        /// Creates WLAN I/Q data for multiple channels and returns the data as an array of complex waveforms. This function returns one frame, including the idle interval, at a time. For multiframe generation, set the reset parameter to NIWLANG_VAL_FALSE and run the function in a loop for the specified number of times or until the done parameter is NIWLANG_VAL_TRUE.
        /// Note&#160;&#160; Use this function if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// 
        /// </summary>
        ///<param name = "reset">
        /// Specifies whether to reset the internal states in the created waveform. Set this parameter to NIWLANG_VAL_TRUE for the first frame of the generation or if you want to reset the pseudonoise (PN) seed.  
        /// 
        ///</param>
        ///<param name = "t0">
        /// Returns the starting time The size of this array must be at least equal to value of the numberOfTxChains parameter. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "dt">
        /// Returns the time interval between baseband I/Q samples. The size array must be at least equal to value of the   numberOfTxChains parameter. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "waveforms">
        /// Returns the WLAN I/Q data. The waveforms are written sequentially in the array. Allocate an array at least as large as numberOfTxChains times individualWaveformSize for this parameter.
        /// 
        ///</param>
        ///<param name = "numberOfTxChains">
        /// Specifies the number of Transmit chains. The value of this parameter should be product of the values configured using the?NIWLANG_NUMBER_OF_TRANSMIT_CHANNELS?and NIWLANG_NUMBER_OF_SEGMENTS attributes.
        /// 
        ///</param>
        ///<param name = "individualWaveformSize">
        /// Specifies the size of the waveform per WLAN channel. The size of the waveform is given by the NIWLANG_IQ_WAVEFORM_SIZE attribute. 
        /// 
        ///</param>
        ///<param name = "actualNumSamplesinEachWfm">
        /// Returns the actual number of samples for each WLAN channel waveform. If the array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<param name = "done">
        /// Indicates whether the function has generated all data. If you generate multiple frames, you can include this function in a while loop and use the done parameter as the terminating condition.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_CreateMIMOWaveformsComplexF64
        /// int32 __stdcall niWLANG_CreateMIMOWaveformsComplexF64 (niWLANGenerationSession session,
        ///     int32 reset,
        ///     int32 numberOfTxChains,
        ///     int32 individualWaveformSize,
        ///     float64 t0[],
        ///     float64 dt[],
        ///     NIComplexNumber *waveforms,
        ///     int32* actualNumSamplesInEachWfm,
        ///     int32* done);
        /// Purpose
        /// Creates WLAN I/Q data for multiple channels and returns the data as an array of complex waveforms. This function returns one frame, including the idle interval, at a time. For multiframe generation, set the reset parameter to NIWLANG_VAL_FALSE and run the function in a loop for the specified number of times or until the done parameter is NIWLANG_VAL_TRUE.
        /// Note&#160;&#160; Use this function if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// 
        ///</returns>
        public int CreateMIMOWaveformsComplexF64(int reset, double[] t0, double[] dt, niComplexNumber[] waveforms, int numberOfTxChains, int individualWaveformSize, out int actualNumSamplesinEachWfm, out int done)
        {
            int pInvokeResult = PInvoke.niWLANG_CreateMIMOWaveformsComplexF64(Handle, reset, t0, dt, waveforms, numberOfTxChains, individualWaveformSize, out actualNumSamplesinEachWfm, out done);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Creates WLAN I/Q data and returns the data as a complex waveform. This function returns one frame, including the idle interval, at a time. For multi-frame generation, set the reset parameter to NIWLANG_VAL_FALSE and run the function in a loop for the specified number of times or until the done parameter is NIWLANG_VAL_TRUE.
        /// Note&#160;&#160; Use this function if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM, NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211BG_DSSS, or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM.
        /// 
        /// </summary>
        ///<param name = "reset">
        /// Specifies whether to reset the internal states in the created waveform. Set this parameter to NIWLANG_VAL_TRUE for the first frame of the generation or if you want to reset the pseudonoise (PN) seed. 
        /// 
        ///</param>
        ///<param name = "t0">
        /// Returns the starting time. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "dt">
        /// Returns the time interval between baseband I/Q samples. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "waveform">
        /// Returns the WLAN I/Q data. This parameter must be at least the size of the waveformSize parameter.
        /// 
        ///</param>
        ///<param name = "waveformSize">
        /// Specifies the waveform size in samples. The size of the waveform is given by the NIWLANG_IQ_WAVEFORM_SIZE attribute.
        /// 
        ///</param>
        ///<param name = "actualNumWaveformSamples">
        /// Returns the actual number of samples populated in the waveform array. If the array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<param name = "done">
        /// Indicates whether the function has generated all the data. If you generate multiple frames, you can include this function in a while loop and use the done parameter as the terminating condition.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_CreateWaveformComplexF64
        /// int32 __stdcall niWLANG_CreateWaveformComplexF64 (niWLANGenerationSession session,
        ///     int32 reset,
        ///     int32 waveformSize,
        ///     float64* t0,
        ///     float64* dt,
        ///     NIComplexNumber waveform[],
        ///     int32* actualNumWaveformSamples,
        ///     int32* done);
        /// Purpose
        /// Creates WLAN I/Q data and returns the data as a complex waveform. This function returns one frame, including the idle interval, at a time. For multi-frame generation, set the reset parameter to NIWLANG_VAL_FALSE and run the function in a loop for the specified number of times or until the done parameter is NIWLANG_VAL_TRUE.
        /// Note&#160;&#160; Use this function if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM, NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211BG_DSSS, or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM.
        /// 
        ///</returns>
        public int CreateWaveformComplexF64(int reset, out double t0, out double dt, niComplexNumber[] waveform, int waveformSize, out int actualNumWaveformSamples, out int done)
        {
            int pInvokeResult = PInvoke.niWLANG_CreateWaveformComplexF64(Handle, reset, out t0, out dt, waveform, waveformSize, out actualNumWaveformSamples, out done);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the matrix used or mapping space-time streams to the transmit channels as defined in section 20.3.11.10.1 of IEEE Standard 802.11n-2009.
        /// The dimensions of the matrix must be NTx * (NSTS + NESS) if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM. The dimensions of the matrix must be NTx * NSTS if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// where &#160;&#160;NTx is the number of transmit channels
        /// &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NSTS is the number of space-time streams. If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,  NSTS determined by the MCS index and the STBC index
        /// &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NESS is the number of extension spatial streams 
        /// Note&#160;&#160; For 802.11n signals, N_STS is determined by the MCS Index and the STBC Index. For 802.11ac signals, N_STS is determined by the NIWLANG_MCS_INDEX
        /// and NIWLANG_STBC_INDEX attributes. 
        /// For one-to-one mapping (direct mapping), NTx = NSTS and NESS = 0. For one-to-many mapping (spatial expansion), NTx     &#8805; (NSTS + NESS).
        /// Valid values are any matrix of size NTx * (NSTS + NESS).
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "mappingMatrix">
        /// Returns the matrix for mapping spatial streams to transmit channels.
        /// 
        ///</param>
        ///<param name = "numMappingMatrixRows">
        /// Specifies the number of mapping matrix rows.
        /// 
        ///</param>
        ///<param name = "numMappingMatrixColumns">
        /// Specifies the number of mapping matrix columns.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_GetMappingMatrix
        /// int32 __stdcall niWLANG_GetMappingMatrix (niWLANGenerationSession session,
        ///     char channelString[],
        ///     NIComplexNumber* mappingMatrix,
        ///     int32 numMappingMatrixRows,
        ///     int32 numMappingMatrixColumns);
        /// Purpose
        /// Returns the matrix used or mapping space-time streams to the transmit channels as defined in section 20.3.11.10.1 of IEEE Standard 802.11n-2009.
        /// The dimensions of the matrix must be NTx * (NSTS + NESS) if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM. The dimensions of the matrix must be NTx * NSTS if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// where &#160;&#160;NTx is the number of transmit channels
        /// &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NSTS is the number of space-time streams. If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,  NSTS determined by the MCS index and the STBC index
        /// &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NESS is the number of extension spatial streams 
        /// Note&#160;&#160; For 802.11n signals, N_STS is determined by the MCS Index and the STBC Index. For 802.11ac signals, N_STS is determined by the NIWLANG_MCS_INDEX
        /// and NIWLANG_STBC_INDEX attributes. 
        /// For one-to-one mapping (direct mapping), NTx = NSTS and NESS = 0. For one-to-many mapping (spatial expansion), NTx     &#8805; (NSTS + NESS).
        /// Valid values are any matrix of size NTx * (NSTS + NESS).
        /// 
        ///</returns>
        public int GetMappingMatrix(string channelString, niComplexNumber[] mappingMatrix, int numMappingMatrixRows, int numMappingMatrixColumns)
        {
            int pInvokeResult = PInvoke.niWLANG_GetMappingMatrix(Handle, channelString, mappingMatrix, numMappingMatrixRows, numMappingMatrixColumns);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Resets all the attributes of the session to their default values. 
        /// 
        /// </summary>
        ///<returns>
        /// 
        ///niWLANG_ResetSession
        /// int32 __stdcall niWLANG_ResetSession (niWLANGenerationSession session);
        /// Purpose
        /// Resets all the attributes of the session to their default values. 
        /// 
        ///</returns>
        public int ResetSession()
        {
            int pInvokeResult = PInvoke.niWLANG_ResetSession(Handle);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Configures the NI PXIe-5673 or NI PXIe-5673E for WLAN 2.0 signal generation. This function sets the RF frequency to a user-specified value and the RF power level to a value that is equal to the sum of the maximum expected peak to average power ratio and the user-specified average power level. 
        /// Note&#160;&#160;Call this function after you call the niWLANG_RFSGConfigureWaveform and niWLANG_CreateWaveformComplexF64 functions.
        /// Note&#160;&#160;For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, or IEEE Standard 802.11g-2003, if the compatibilityVersion parameter of the niWLANG_OpenSession function is set to NIWLANG_VAL_COMPATIBILITY_VERSION_010000, the toolkit supports NI PXI-5671, NI PXIe-5672, NI PXIe-5673, and NI PXIe-5673E. For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, IEEE Standard 802.11g-2003, or IEEE Standard 802.11n-2009, if the compatibilityVersion parameter is set to NIWLANG_VAL_COMPATIBILITY_VERSION_020000, the toolkit supports NI PXIe-5673 and NI PXIe-5673E.
        /// This function also sets the following NI-RFSG attributes:       
        /// NIRFSG_ATTR_UPCONVERTER_CENTER_FREQUENCY attribute is set to 25 MHz below the RF Carrier Frequency..        
        /// NIRFSG_ATTR_POWER_LEVEL_TYPE attribute is set to NIRFSG_VAL_PEAK_POWER.        
        /// NIRFSG_ATTR_GENERATION_MODE attribute is set to NIRFSG_VAL_ARB_WAVEFORM.                    
        /// 
        /// </summary>
        ///<param name = "wLANChannelString">
        /// wlanChannelString
        /// char[]
        /// Specifies the WLAN channel to be used for configuration.
        ///</param>
        ///<param name = "rFSGSession">
        /// rfsgSession
        /// ViSession
        /// Specifies a reference to an NI-RFSG instrument session. This parameter is obtained from the niRFSG_init or niRFSG_InitWithOptions function and identifies a particular instrument session.
        ///</param>
        ///<param name = "hardwareChannelString">
        /// hwChannelString
        /// char[]
        /// Identifies the RFSG device channel. Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public int RFSGConfigure(string wLANChannelString, HandleRef rFSGSession, string hardwareChannelString)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGConfigure(Handle, wLANChannelString, rFSGSession, hardwareChannelString);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }


        /// <summary>
        /// Configures the WLAN I/Q rate and actual waveform size according to user-specified parameters and hardware capabilities.
        /// Note&#160;&#160;Use this function before calling the niWLANG_CreateWaveformComplexF64 and niWLANG_CreateMIMOWaveformsComplexF64 functions.
        /// Note&#160;&#160;For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, or IEEE Standard 802.11g-2003, if the compatibilityVersion parameter of the niWLANG_OpenSession function is set to NIWLANG_VAL_COMPATIBILITY_VERSION_010000, the toolkit supports NI PXI-5671, NI PXIe-5672, NI PXIe-5673, and NI PXIe-5673E. For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, IEEE Standard 802.11g-2003, or IEEE Standard 802.11n-2009, if the compatibilityVersion parameter is set to NIWLANG_VAL_COMPATIBILITY_VERSION_020000, the toolkit supports NI PXIe-5673 and NI PXIe-5673E.
        /// 
        /// </summary>
        ///<param name = "wLANChannelString">
        /// wlanChannelString
        /// char[]
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "rFSGSession">
        /// rfsgSession
        /// ViSession
        /// Specifies a reference to an NI-RFSG instrument session. This parameter is obtained from the niRFSG_init or niRFSG_InitWithOptions function and identifies a particular instrument session.
        ///</param>
        ///<param name = "hardwareChannelString">
        /// hwChannelString
        /// char[]
        /// Identifies the RFSG device channel. Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "resetHardware">
        /// resetHardware
        /// int32
        /// Specifies whether to reset the NI RF signal generator. Set this parameter to NIWLANG_VAL_TRUE to reset the hardware.
        ///</param>
        ///<param name = "waveformSize">
        /// waveformSize
        /// int32*
        /// Returns the number of samples in each frame, including the interframe spacing.
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public int RFSGConfigureWaveform(string wLANChannelString, HandleRef rFSGSession, string hardwareChannelString, int resetHardware, out int waveformSize)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGConfigureWaveform(Handle, wLANChannelString, rFSGSession, hardwareChannelString, resetHardware, out waveformSize);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }


        /// <summary>
        /// Stores the headroom, or peak-to-average power ratio (PAPR), specified in the PAPR parameter in the RFSG database.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        /// 
        ///</param>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the waveform for which you want to store the maximum expected PAPR. 
        /// 
        ///</param>
        ///<param name = "pAPR">
        /// Specifies the headroom (or PAPR) to store in the RFSG database.  This value is expressed in dB.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_RFSGStorePAPR
        /// int32 __stdcall niWLANG_RFSGStorePAPR (ViSession RFSGSession, 
        ///     char channelString[],
        ///     char waveformName[], 
        ///     float64 PAPR);
        /// Purpose
        /// Stores the headroom, or peak-to-average power ratio (PAPR), specified in the PAPR parameter in the RFSG database.
        /// 
        ///</returns>
        [Obsolete("Use WLANG_RFSGStorePAPR() static method")]
        public int RFSGStorePAPR(HandleRef rFSGSession, string channelString, string waveformName, double pAPR)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGStorePAPR(rFSGSession, channelString, waveformName, pAPR);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }


        /// <summary>
        /// Stores the maximum expected PAPR in the RFSG waveform database.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        /// 
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to store the headroom. 
        /// 
        ///</param>
        ///<param name = "pAPR">
        /// Specifies the PAPR to store in the RFSG database. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public static int WLANG_RFSGStorePAPR(HandleRef rFSGSession, string channelString, string waveformName, double pAPR)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGStorePAPR(rFSGSession, channelString, waveformName, pAPR);
            TestForErrorForNullHandle(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Stores the I/Q rate in the RFSG waveform database.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        /// 
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to store the I/Q rate.  
        /// 
        ///</param>
        ///<param name = "iQRate">
        /// Specifies the I/Q rate to store in the RFSG database. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        [Obsolete("Use WLANG_RFSGStoreIQRate() static method")]
        public int RFSGStoreIQRate(HandleRef rFSGSession, string channelString, string waveformName, double iQRate)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGStoreIQRate(rFSGSession, channelString, waveformName, iQRate);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Stores the I/Q rate in the RFSG waveform database.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        /// 
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to store the I/Q rate.  
        /// 
        ///</param>
        ///<param name = "iQRate">
        /// Specifies the I/Q rate to store in the RFSG database. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public static int WLANG_RFSGStoreIQRate(HandleRef rFSGSession, string channelString, string waveformName, double iQRate)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGStoreIQRate(rFSGSession, channelString, waveformName, iQRate);
            TestForErrorForNullHandle(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the maximum expected PAPR stored in the RFSG database. 
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to retrieve the maximum expected PAPR.
        /// 
        ///</param>
        ///<param name = "pAPR">
        /// Returns the maximum expected PAPR stored in the RFSG database.  
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        [Obsolete("Use WLANG_RFSGRetrievePAPR() static method")]
        public int RFSGRetrievePAPR(HandleRef rFSGSession, string channelString, string waveformName, out double pAPR)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrievePAPR(rFSGSession, channelString, waveformName, out pAPR);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the maximum expected PAPR stored in the RFSG database. 
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to retrieve the maximum expected PAPR.
        /// 
        ///</param>
        ///<param name = "pAPR">
        /// Returns the maximum expected PAPR stored in the RFSG database.  
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public static int WLANG_RFSGRetrievePAPR(HandleRef rFSGSession, string channelString, string waveformName, out double pAPR)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrievePAPR(rFSGSession, channelString, waveformName, out pAPR);
            TestForErrorForNullHandle(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the I/Q rate stored in the RFSG waveform database. 
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to retrieve the I/Q rate.  
        /// 
        ///</param>
        ///<param name = "iQRate">
        /// Returns the I/Q rate stored in the RFSG waveform database for the waveform that you specify in the waveformName parameter. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        [Obsolete("Use WLANG_RFSGRetrieveIQRate() static method")]
        public int RFSGRetrieveIQRate(HandleRef rFSGSession, string channelString, string waveformName, out double iQRate)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrieveIQRate(rFSGSession, channelString, waveformName, out iQRate);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the I/Q rate stored in the RFSG waveform database. 
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to retrieve the I/Q rate.  
        /// 
        ///</param>
        ///<param name = "iQRate">
        /// Returns the I/Q rate stored in the RFSG waveform database for the waveform that you specify in the waveformName parameter. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public static int WLANG_RFSGRetrieveIQRate(HandleRef rFSGSession, string channelString, string waveformName, out double iQRate)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrieveIQRate(rFSGSession, channelString, waveformName, out iQRate);
            TestForErrorForNullHandle(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the minimum of the maximum expected PAPR of all the waveforms in the script that you specify in the script parameter.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "script">
        /// Specifies the RFSG script used to generate the signal. The function looks up the PAPR of all the waveforms contained in the script and returns the minimum of all these PAPR, in dB.
        /// 
        ///</param>
        ///<param name = "pAPR">
        /// Returns the minimum of all the maximum expected PAPR stored in the RFSG database. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        [Obsolete("Use WLANGRetrieveMinimumPAPRAllWaveforms() static method")]
        public int RFSGRetrieveMinimumPAPRAllWaveforms(HandleRef rFSGSession, string channelString, string script, out double pAPR)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrieveMinimumPAPRAllWaveforms(rFSGSession, channelString, script, out pAPR);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the minimum of the maximum expected PAPR of all the waveforms in the script that you specify in the script parameter.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "script">
        /// Specifies the RFSG script used to generate the signal. The function looks up the PAPR of all the waveforms contained in the script and returns the minimum of all these PAPR, in dB.
        /// 
        ///</param>
        ///<param name = "pAPR">
        /// Returns the minimum of all the maximum expected PAPR stored in the RFSG database. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public static int WLANG_RFSGRetrieveMinimumPAPRAllWaveforms(HandleRef rFSGSession, string channelString, string script, out double pAPR)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrieveMinimumPAPRAllWaveforms(rFSGSession, channelString, script, out pAPR);
            TestForErrorForNullHandle(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Checks the I/Q rate of all the waveforms in the script that you specify in the script parameter. This function returns the I/Q rate if the I/Q rates are the same for all the waveforms. If the I/Q rates are different, the function returns an error. 
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "script">
        /// Specifies the RFSG script used to generate the signal. The function looks up the I/Q rate of all the waveforms contained in the script and returns the returns the I/Q rate if the I/Q rates are the same for all the waveforms. If the I/Q rates are different, the function returns an error.
        /// 
        ///</param>
        ///<param name = "iQRate">
        /// Returns the I/Q rate stored in the RFSG waveform database. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        [Obsolete("Use WLANG_RFSGRetrieveIQRateAllWaveforms() static method")]
        public int RFSGRetrieveIQRateAllWaveforms(HandleRef rFSGSession, string channelString, string script, out double iQRate)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrieveIQRateAllWaveforms(rFSGSession, channelString, script, out iQRate);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Checks the I/Q rate of all the waveforms in the script that you specify in the script parameter. This function returns the I/Q rate if the I/Q rates are the same for all the waveforms. If the I/Q rates are different, the function returns an error. 
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "script">
        /// Specifies the RFSG script used to generate the signal. The function looks up the I/Q rate of all the waveforms contained in the script and returns the returns the I/Q rate if the I/Q rates are the same for all the waveforms. If the I/Q rates are different, the function returns an error.
        /// 
        ///</param>
        ///<param name = "iQRate">
        /// Returns the I/Q rate stored in the RFSG waveform database. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public static int WLANG_RFSGRetrieveIQRateAllWaveforms(HandleRef rFSGSession, string channelString, string script, out double iQRate)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrieveIQRateAllWaveforms(rFSGSession, channelString, script, out iQRate);
            TestForErrorForNullHandle(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Creates a single channel waveform, writes it into the RFSG memory, and stores the I/Q rate, the burst start locations, the burst stop locations, the waveform size, and the actual headroom of the waveform in the RFSG database. Use this instance if the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM, NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211BG_DSSS, or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM.
        /// Inside the niWLANG_CreateAndDownloadWaveform function, all the following operations that involve NI-RFSG are performed on the device. The niWLANG_CreateAndDownloadWaveform function completes the following operations: 
        /// Sets the NIWLANG_MAXIMUM_HARDWARE_IQ_RATE attribute according to the device model. You must set the value of the NIWLANG_MAXIMUM_HARDWARE_IQ_RATE attribute to 1250 MS/s if you are using the NI PXIe-5840, 250 MS/s if you are using the NI PXIe-5646R, 120 Ms/s if you are using the NI PXIe-5644R/5645R, and 200 MS/s if you are using the NI PXIe-5673/5673E.
        /// Reads the NIWLANG_IQ_RATE attribute, and sets the NIRFSG_ATTR_IQ_RATE attribute to the value specified in the NIWLANG_IQ_RATE attribute. The value is stored in the RFSG database for the waveform and device.
        /// Sets the NIRFSG_ATTR_RF_BLANKING_SOURCE attribute to NIRFSG_VAL_MARKER0 (if it is not set already), if the NIWLANG_RF_BLANKING_ENABLED attribute is set to NIWLANG_VAL_TRUE and the device model is the NI PXIe-5644R, NI PXIe-5645R, NI PXIe-5646R, or NI PXIe-5840.
        /// Reads and stores the NIWLANG_BURST_START_LOCATIONS attribute, NIWLANG_BURST_STOP_LOCATIONS attribute and the waveform size in the RFSG database.
        /// Creates the WLAN waveform and downloads it to device.
        /// Stores the NIWLANG_ACTUAL_HEADROOM
        ///  attribute to the RFSG database.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        /// 
        ///</param>
        ///<param name = "hardwareChannelString">
        /// Specifies the RF vector signal generator channel. Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name used to write the waveform to NI-RFSG device memory and store its attributes to RFSG database. This string is case-insensitive, alphanumeric, and does not use reserved words.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_RFSGCreateAndDownloadWaveform
        /// int32 __stdcall niWLANG_RFSGCreateAndDownloadWaveform (niWLANGenerationSession session, ViSession rfsgSession, char hwChannelString[], char waveformName[]);
        /// Purpose
        /// Creates a single channel waveform, writes it into the RFSG memory, and stores the I/Q rate, the burst start locations, the burst stop locations, the waveform size, and the actual headroom of the waveform in the RFSG database. Use this instance if the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM, NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211BG_DSSS, or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM.
        /// Inside the niWLANG_CreateAndDownloadWaveform function, all the following operations that involve NI-RFSG are performed on the device. The niWLANG_CreateAndDownloadWaveform function completes the following operations: 
        /// Sets the NIWLANG_MAXIMUM_HARDWARE_IQ_RATE attribute according to the device model. You must set the value of the NIWLANG_MAXIMUM_HARDWARE_IQ_RATE attribute to 1250 MS/s if you are using the NI PXIe-5840, 250 MS/s if you are using the NI PXIe-5646R, 120 Ms/s if you are using the NI PXIe-5644R/5645R, and 200 MS/s if you are using the NI PXIe-5673/5673E.
        /// Reads the NIWLANG_IQ_RATE attribute, and sets the NIRFSG_ATTR_IQ_RATE attribute to the value specified in the NIWLANG_IQ_RATE attribute. The value is stored in the RFSG database for the waveform and device.
        /// Sets the NIRFSG_ATTR_RF_BLANKING_SOURCE attribute to NIRFSG_VAL_MARKER0 (if it is not set already), if the NIWLANG_RF_BLANKING_ENABLED attribute is set to NIWLANG_VAL_TRUE and the device model is the NI PXIe-5644R, NI PXIe-5645R, NI PXIe-5646R, or NI PXIe-5840.
        /// Reads and stores the NIWLANG_BURST_START_LOCATIONS attribute, NIWLANG_BURST_STOP_LOCATIONS attribute and the waveform size in the RFSG database.
        /// Creates the WLAN waveform and downloads it to device.
        /// Stores the NIWLANG_ACTUAL_HEADROOM
        ///  attribute to the RFSG database.
        /// 
        ///</returns>
        public int RFSGCreateAndDownloadWaveform(HandleRef rFSGSession, string hardwareChannelString, string waveformName)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGCreateAndDownloadWaveform(Handle, rFSGSession, hardwareChannelString, waveformName);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Creates multiple channel waveforms, writes each waveform into the respective RFSG memory, and stores the I/Q rate, burst start locations, burst stop locations, waveform size  and the actual headroom for each channel of the waveform in the respective RFSG database, if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMOOFDM.The function creates a single channel waveform and writes the same waveform to RFSG memory of all devices, and stores the I/Q rate, burst start locations, burst stop locations, the waveform size and the actual headroom of the waveform in all RFSG databases, if you set the?NIWLANG_STANDARD?attribute to?NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM, NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211BG_DSSS, or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM. 
        /// Inside the niWLANG_CreateAndDownloadMIMOWaveforms function, all the following operations that involve NI-RFSG are performed on the device. The niWLANG_CreateAndDownloadWaveform function completes the following operations: 
        /// Sets the NIWLANG_MAXIMUM_HARDWARE_IQ_RATE attribute according to the device model. You must set the value of the NIWLANG_MAXIMUM_HARDWARE_IQ_RATE attribute to 1250 MS/s if you are using the NI PXIe-5840, 250 MS/s if you are using the NI PXIe-5646R, 120 Ms/s if you are using the NI PXIe-5644R/5645R, and 200 MS/s if you are using the NI PXIe-5673/5673E.
        /// Reads the NIWLANG_IQ_RATE attribute, and sets the NIRFSG_ATTR_IQ_RATE attribute to the value specified in the NIWLANG_IQ_RATE attribute. The value is stored in the RFSG database for the waveform and device.
        /// Sets the NIRFSG_ATTR_RF_BLANKING_SOURCE attribute to NIRFSG_VAL_MARKER0 (if it is not set already), if the NIWLANG_RF_BLANKING_ENABLED attribute is set to NIWLANG_VAL_TRUE and the device model is the NI PXIe-5644R, NI PXIe-5645R, NI PXIe-5646R, or NI PXIe-5840.
        /// Reads and stores the NIWLANG_BURST_START_LOCATIONS attribute, NIWLANG_BURST_STOP_LOCATIONS attribute and the waveform size in the RFSG database.
        /// Creates the WLAN waveform and downloads it to device.
        /// Stores the NIWLANG_ACTUAL_HEADROOM
        ///  attribute to the RFSG database.
        /// 
        /// </summary>
        ///<param name = "rFSGSessions">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        /// 
        ///</param>
        ///<param name = "hardwareChannelStrings">
        /// Specifies the RFSG device channel. Set this parameter to NULL.
        /// 
        ///</param>
        ///<param name = "numberOfTxChains">
        /// Specifies the number of Transmit chains. The value of this parameter should be product of the values configured using the?NIWLANG_NUMBER_OF_TRANSMIT_CHANNELS?and NIWLANG_NUMBER_OF_SEGMENTS attributes.
        /// 
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name used to store the waveform. This string is case-insensitive, alphanumeric, and does not use reserved words. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_RFSGCreateAndDownloadMIMOWaveforms
        /// int32 __stdcall niWLANG_RFSGCreateAndDownloadMIMOWaveforms (niWLANGenerationSession session, ViSession rfsgSessions[], char *hwChannelStrings[], int32 numberOfTxChains, char waveformName[]);
        /// Purpose
        /// Creates multiple channel waveforms, writes each waveform into the respective RFSG memory, and stores the I/Q rate, burst start locations, burst stop locations, waveform size  and the actual headroom for each channel of the waveform in the respective RFSG database, if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMOOFDM.The function creates a single channel waveform and writes the same waveform to RFSG memory of all devices, and stores the I/Q rate, burst start locations, burst stop locations, the waveform size and the actual headroom of the waveform in all RFSG databases, if you set the?NIWLANG_STANDARD?attribute to?NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM, NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211BG_DSSS, or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM. 
        /// Inside the niWLANG_CreateAndDownloadMIMOWaveforms function, all the following operations that involve NI-RFSG are performed on the device. The niWLANG_CreateAndDownloadWaveform function completes the following operations: 
        /// Sets the NIWLANG_MAXIMUM_HARDWARE_IQ_RATE attribute according to the device model. You must set the value of the NIWLANG_MAXIMUM_HARDWARE_IQ_RATE attribute to 1250 MS/s if you are using the NI PXIe-5840, 250 MS/s if you are using the NI PXIe-5646R, 120 Ms/s if you are using the NI PXIe-5644R/5645R, and 200 MS/s if you are using the NI PXIe-5673/5673E.
        /// Reads the NIWLANG_IQ_RATE attribute, and sets the NIRFSG_ATTR_IQ_RATE attribute to the value specified in the NIWLANG_IQ_RATE attribute. The value is stored in the RFSG database for the waveform and device.
        /// Sets the NIRFSG_ATTR_RF_BLANKING_SOURCE attribute to NIRFSG_VAL_MARKER0 (if it is not set already), if the NIWLANG_RF_BLANKING_ENABLED attribute is set to NIWLANG_VAL_TRUE and the device model is the NI PXIe-5644R, NI PXIe-5645R, NI PXIe-5646R, or NI PXIe-5840.
        /// Reads and stores the NIWLANG_BURST_START_LOCATIONS attribute, NIWLANG_BURST_STOP_LOCATIONS attribute and the waveform size in the RFSG database.
        /// Creates the WLAN waveform and downloads it to device.
        /// Stores the NIWLANG_ACTUAL_HEADROOM
        ///  attribute to the RFSG database.
        /// 
        ///</returns>
        public int RFSGCreateAndDownloadMIMOWaveforms(HandleRef[] rFSGSessions, string[] hardwareChannelStrings, int numberOfTxChains, string waveformName)
        {
            Int32[] rfsgIntPtrHandles = new Int32[rFSGSessions.Length];
            for (int i = 0; i < rFSGSessions.Length; i++)
            {
                rfsgIntPtrHandles[i] = rFSGSessions[i].Handle.ToInt32();
            }
            int pInvokeResult = PInvoke.niWLANG_RFSGCreateAndDownloadMIMOWaveforms(Handle, rfsgIntPtrHandles, hardwareChannelStrings, numberOfTxChains, waveformName);
            TestForError(pInvokeResult, rFSGSessions);
            return pInvokeResult;
        }

        /// <summary>
        /// Writes a script to the device to control waveform generation in script mode. Configures the I/Q rate and power level of the waveforms that you specify in the script parameter. This function sets the NIRFSG_ATTR_IQ_RATE attribute to the I/Q rate in the RFSG waveform database if the I/Q rates are the same for all the waveforms. The function calculates the sum of the power level, in dBm, and the minimum maximum expected PAPR of all the waveforms and sets the NIRFSG_ATTR_POWER_LEVEL attribute to the sum. 
        /// Note&#160;&#160;For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, or IEEE Standard 802.11g-2003, if the toolkit compatibility version parameter of the  niWLANG_OpenSession function is set to 1.0.0, the toolkit supports NI PXI-5671, NI PXIe-5672, NI PXIe-5673, and NI PXIe 5673E. For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, IEEE Standard 802.11g-2003, or IEEE Standard 802.11n-2009, if the toolkit compatibility version parameter is set to 2.0.0, the toolkit supports NI PXIe-5673 and NI PXIe-5673E.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "script">
        /// Specifies the RFSG script used to generate the waveform. 
        /// 
        ///</param>
        ///<param name = "powerLevel">
        /// Specifies the power level, in dBm. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        [Obsolete("Use WLANG_RFSGConfigureScript() static method")]
        public int RFSGConfigureScript(HandleRef rFSGSession, string channelString, string script, double powerLevel)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGConfigureScript(rFSGSession, channelString, script, powerLevel);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Writes a script to the device to control waveform generation in script mode. Configures the I/Q rate and power level of the waveforms that you specify in the script parameter. This function sets the NIRFSG_ATTR_IQ_RATE attribute to the I/Q rate in the RFSG waveform database if the I/Q rates are the same for all the waveforms. The function calculates the sum of the power level, in dBm, and the minimum maximum expected PAPR of all the waveforms and sets the NIRFSG_ATTR_POWER_LEVEL attribute to the sum. 
        /// Note&#160;&#160;For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, or IEEE Standard 802.11g-2003, if the toolkit compatibility version parameter of the  niWLANG_OpenSession function is set to 1.0.0, the toolkit supports NI PXI-5671, NI PXIe-5672, NI PXIe-5673, and NI PXIe 5673E. For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, IEEE Standard 802.11g-2003, or IEEE Standard 802.11n-2009, if the toolkit compatibility version parameter is set to 2.0.0, the toolkit supports NI PXIe-5673 and NI PXIe-5673E.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "script">
        /// Specifies the RFSG script used to generate the waveform. 
        /// 
        ///</param>
        ///<param name = "powerLevel">
        /// Specifies the power level, in dBm. 
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public static int WLANG_RFSGConfigureScript(HandleRef rFSGSession, string channelString, string script, double powerLevel)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGConfigureScript(rFSGSession, channelString, script, powerLevel);
            TestForErrorForNullHandle(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Looks up the waveforms in the script, retrieves the minimum maximum expected PAPR of the waveforms in the script, adds this value to the power level parameter, and sets the result to the NIRFSG_ATTR_POWER_LEVEL attribute. Set the NIRFSG_ATTR_POWER_LEVEL_TYPE attribute to peak power before calling this function.  
        /// Note&#160;&#160;For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, or IEEE Standard 802.11g-2003, if the toolkit compatibility version parameter of the  niWLANG_OpenSession function is set to 1.0.0, the toolkit supports NI PXI-5671, NI PXIe-5672, NI PXIe-5673, and NI PXIe 5673E. For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, IEEE Standard 802.11g-2003, or IEEE Standard 802.11n-2009, if the toolkit compatibility version parameter is set to 2.0.0, the toolkit supports NI PXIe-5673 and NI PXIe-5673E.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "script">
        /// Specifies the RFSG script used to generate the signal. 
        /// 
        ///</param>
        ///<param name = "powerLevel">
        /// Specifies the power level, in dBm.  
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        [Obsolete("Use WLANG_RFSGConfigurePowerLevel() static method")]
        public int RFSGConfigurePowerLevel(HandleRef rFSGSession, string channelString, string script, double powerLevel)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGConfigurePowerLevel(rFSGSession, channelString, script, powerLevel);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Looks up the waveforms in the script, retrieves the minimum maximum expected PAPR of the waveforms in the script, adds this value to the power level parameter, and sets the result to the NIRFSG_ATTR_POWER_LEVEL attribute. Set the NIRFSG_ATTR_POWER_LEVEL_TYPE attribute to peak power before calling this function.  
        /// Note&#160;&#160;For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, or IEEE Standard 802.11g-2003, if the toolkit compatibility version parameter of the  niWLANG_OpenSession function is set to 1.0.0, the toolkit supports NI PXI-5671, NI PXIe-5672, NI PXIe-5673, and NI PXIe 5673E. For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, IEEE Standard 802.11g-2003, or IEEE Standard 802.11n-2009, if the toolkit compatibility version parameter is set to 2.0.0, the toolkit supports NI PXIe-5673 and NI PXIe-5673E.
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "script">
        /// Specifies the RFSG script used to generate the signal. 
        /// 
        ///</param>
        ///<param name = "powerLevel">
        /// Specifies the power level, in dBm.  
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public static int WLANG_RFSGConfigurePowerLevel(HandleRef rFSGSession, string channelString, string script, double powerLevel)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGConfigurePowerLevel(rFSGSession, channelString, script, powerLevel);
            TestForErrorForNullHandle(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Clears the attributes stored in the RFSG database and clears the waveforms from the RFSG memory. 
        /// This function clears the waveforms and the properties of the waveforms that you specify in the waveformName parameter. If you set the waveformName parameter as empty, this VI clears all the waveforms and their properties. 
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the waveforms to clear. If you set this parameter as empty, the function clears all the waveforms and their properties. 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        [Obsolete("Use WLANG_RFSGClearDatabase() static method")]
        public int RFSGClearDatabase(HandleRef rFSGSession, string channelString, string waveformName)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGClearDatabase(rFSGSession, channelString, waveformName);
            TestForError(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }

        /// <summary>
        /// Clears the attributes stored in the RFSG database and clears the waveforms from the RFSG memory. 
        /// This function clears the waveforms and the properties of the waveforms that you specify in the waveformName parameter. If you set the waveformName parameter as empty, this VI clears all the waveforms and their properties. 
        /// 
        /// </summary>
        ///<param name = "rFSGSession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        ///</param>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the waveforms to clear. If you set this parameter as empty, the function clears all the waveforms and their properties. 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. 
        /// Examine the status code from each call to an niWLAN generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function. 
        /// The general meaning of the status code is as follows:
        /// Value Meaning 
        /// 0 Success 
        /// Positive Values Warnings 
        /// Negative Values Exception 
        /// 
        ///</returns>
        public static int WLANG_RFSGClearDatabase(HandleRef rFSGSession, string channelString, string waveformName)
        {
            int pInvokeResult = PInvoke.niWLANG_RFSGClearDatabase(rFSGSession, channelString, waveformName);
            TestForErrorForNullHandle(pInvokeResult, rFSGSession);
            return pInvokeResult;
        }


        /// <summary>
        /// Configures multiple NI RF vector signal generators for sharing local oscillator (LO), configures reference clock settings, and synchronizes multiple devices. 
        /// For NI 5673/5673E RF vector signal generators, this VI configures LO sharing and clock settings in daisy-chained manner.
        /// For NI 5644R, NI 5645R and NI 5646R RF vector signal transceiver (VST) devices, this VI configures daisy-chained LO sharing and low-level properties for multiple device synchronization. VSTs do not support daisy-chained reference clocks for synchronization. You must set the master reference clock source to PXI_CLK for these devices. For additional information, refer to Synchronization Using NI-RFSA and NI-RFSG topic appropriate to your device in the NI RF Signal Generators Help.
        /// This VI assumes that the devices are interconnected in the order of elements of instrument handles array. The first device is assumed to be the master device. The remaining devices are assumed to be slave devices. To interconnect multiple devices, refer to the following topics appropriate to your device in the NI RF Signal Generators Help:
        /// Interconnecting Multiple NI 5673/5673E Modules 
        /// Interconnecting Multiple NI 5644R RF Channels (Homogeneous Channel Types) 
        /// Interconnecting Multiple NI 5645R RF Channels (Homogeneous Channel Types) 
        /// Interconnecting Multiple NI 5646R RF Channels (Homogeneous Channel Types) 
        /// </summary>
        /// <param name="rfsgHandles"> identifies instruments for multiple RFSG sessions.</param>
        /// <param name="numofChannels">specifies number of Channels.</param>
        /// <param name="masterReferenceClockSource">specifies the device reference clock to configure on the master NI RF vector signal generator. </param>
        /// <param name="triggerLines">specifies trigger lines used for distribution of synchronized trigger signals. </param>
        /// <param name="numofTriggerLines">specifies number of Trigger Lines</param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int ConfigureMultipleDeviceSynchronization(HandleRef[] rfsgHandles, int numofChannels, string masterReferenceClockSource, int[] triggerLines, int numofTriggerLines)
        {

            Int32[] rfsgPtrs = new Int32[rfsgHandles.Length];
            rfsgPtrs = Array.ConvertAll<HandleRef, Int32>(rfsgHandles, x => x.Handle.ToInt32());
            int pInvokeResult = PInvoke.niWLANG_RFSGConfigureMultipleDeviceSynchronization(Handle, rfsgPtrs, numofChannels, masterReferenceClockSource, triggerLines, numofTriggerLines);
            TestForError(pInvokeResult, rfsgHandles);
            return pInvokeResult;
        }


        /// <summary>
        /// Reads the waveforms stored in a TDMS file, writes them to the memory of the respective NI RF vector signal generator, and stores the I/Q rate, actual headroom and RF blanking marker positions of the waveforms in the RFSG database.
        /// </summary>
        /// <param name="rfsgSessions">identifies instruments for multiple RFSG sessions.</param>
        /// <param name="numberOfChannels">specifies number of Channels</param>
        /// <param name="waveformName">specifies the names of the waveforms to clear.</param>
        /// <param name="filePath">specifies the absolute path to the TDMS file from which the toolkit reads the waveform. </param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public static int WLANG_RFSGReadAndDownloadWaveformsFromFile(HandleRef[] rfsgSessions, int numberOfChannels, string waveformName, string filePath)
        {
            Int32[] sessions = new Int32[rfsgSessions.Length];
            for (int i = 0; i < rfsgSessions.Length; i++)
            {
                sessions[i] = rfsgSessions[i].Handle.ToInt32();
            }
            int pInvokeResult = PInvoke.niWLANG_RFSGReadAndDownloadWaveformsFromFile(sessions, numberOfChannels, waveformName, filePath);
            TestForErrorForNullHandle(pInvokeResult, rfsgSessions);
            return pInvokeResult;
        }


        /// <summary>
        /// Specifies the matrix for mapping space-time streams to the transmit channels as specified in section 20.3.11.10.1 of IEEE Standard 802.11n-2009.
        /// If the mappingMatrixType parameter is not set to NIWLANG_VAL_MAPPING_MATRIX_TYPE_USER_DEFINED, the toolkit ignores the niWLANG_SetMappingMatrix function. 
        /// The dimensions of the matrix must be NTx * (NSTS + NESS) if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM. The dimensions of the matrix must be NTx * NSTS if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// where &#160;&#160;NTx is the number of transmit channels
        /// &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NSTS is the number of space-time streams. If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,  NSTS determined by the MCS index and the STBC index
        /// &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NESS is the number of extension spatial streams 
        /// Note&#160;&#160; For 802.11n signals, N_STS is determined by the MCS Index and the STBC Index. For 802.11ac signals, N_STS is determined by the NIWLANG_MCS_INDEX
        /// and NIWLANG_STBC_INDEX attributes. 
        /// For one-to-one mapping (direct mapping), NTx = NSTS and NESS = 0. For one-to-many mapping (spatial expansion), NTx     &#8805; (NSTS + NESS).
        /// Valid values are any matrix of size NTx * (NSTS + NESS).
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "mappingMatrix">
        /// Specifies the matrix for mapping spatial streams to the transmit channels.
        /// 
        ///</param>
        ///<param name = "numMappingMatrixRows">
        /// Specifies the number of mapping matrix rows.
        /// 
        ///</param>
        ///<param name = "numMappingMatrixColumns">
        /// Specifies the number of mapping matrix columns.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetMappingMatrix
        /// int32 __stdcall niWLANG_SetMappingMatrix (niWLANGenerationSession session,
        ///     char channelString[],
        ///     NIComplexNumber* mappingMatrix,
        ///     int32 numMappingMatrixRows,
        ///     int32 numMappingMatrixColumns);
        /// Purpose
        /// Specifies the matrix for mapping space-time streams to the transmit channels as specified in section 20.3.11.10.1 of IEEE Standard 802.11n-2009.
        /// If the mappingMatrixType parameter is not set to NIWLANG_VAL_MAPPING_MATRIX_TYPE_USER_DEFINED, the toolkit ignores the niWLANG_SetMappingMatrix function. 
        /// The dimensions of the matrix must be NTx * (NSTS + NESS) if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM. The dimensions of the matrix must be NTx * NSTS if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// where &#160;&#160;NTx is the number of transmit channels
        /// &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NSTS is the number of space-time streams. If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,  NSTS determined by the MCS index and the STBC index
        /// &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NESS is the number of extension spatial streams 
        /// Note&#160;&#160; For 802.11n signals, N_STS is determined by the MCS Index and the STBC Index. For 802.11ac signals, N_STS is determined by the NIWLANG_MCS_INDEX
        /// and NIWLANG_STBC_INDEX attributes. 
        /// For one-to-one mapping (direct mapping), NTx = NSTS and NESS = 0. For one-to-many mapping (spatial expansion), NTx     &#8805; (NSTS + NESS).
        /// Valid values are any matrix of size NTx * (NSTS + NESS).
        /// 
        ///</returns>
        public int SetMappingMatrix(string channelString, niComplexNumber[] mappingMatrix, int numMappingMatrixRows, int numMappingMatrixColumns)
        {
            int pInvokeResult = PInvoke.niWLANG_SetMappingMatrix(Handle, channelString, mappingMatrix, numMappingMatrixRows, numMappingMatrixColumns);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Specifies the difference between the number of space-time streams and the number of spatial streams, as defined in section 20.3.9.4.3 of IEEE Standard 802.11n-2009. The toolkit derives the number of spatial streams from the specified value of the NIWLANG_MCS_INDEX attribute. Different space-time coding schemes are defined in section 20.3.11.8.1 of IEEE Standard 802.11n-2009.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "sTBCIndex">
        /// Specifies the value of the space-time block coding (STBC) index.
        ///  The default value is 0. Valid values are 0 to 2, inclusive.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLAN_SetSTBCIndex
        /// int32 __stdcall niWLANG_SetSTBCIndex (niWLANGenerationSession session,
        ///     char channelString[],
        ///     int32 STBCIndex);
        /// Purpose
        /// Specifies the difference between the number of space-time streams and the number of spatial streams, as defined in section 20.3.9.4.3 of IEEE Standard 802.11n-2009. The toolkit derives the number of spatial streams from the specified value of the NIWLANG_MCS_INDEX attribute. Different space-time coding schemes are defined in section 20.3.11.8.1 of IEEE Standard 802.11n-2009.
        /// 
        ///</returns>
        public int SetSTBCIndex(string channelString, int sTBCIndex)
        {
            return SetInt32(niWLANGProperties.StbcIndex, channelString, sTBCIndex);
       }


        /// <summary>
        /// Saves all attributes of the session to a file located at a specified path. Use this file to save the current state of the toolkit.
        /// 
        /// </summary>
        ///<param name = "filePath">
        /// Specifies the complete path to the TDMS file to which the toolkit saves the configuration.
        /// 
        ///</param>
        ///<param name = "operation">
        /// Specifies the operation to perform on the file. The default value is NIWLANG_VAL_FILE_OPERATION_MODE_CREATE_OR_REPLACE.
        /// NIWLANG_VAL_FILE_OPERATION_MODE_OPEN(0)
        /// Opens an existing file to write the niWLANG settings.
        /// NIWLANG_VAL_FILE_OPERATION_MODE_OPEN_OR_CREATE(1)
        /// Opens an existing file or creates a new file if the file does not exist.
        /// NIWLANG_VAL_FILE_OPERATION_MODE_CREATE_OR_REPLACE(2)
        /// Creates a new file or replaces an existing file.
        /// NIWLANG_VAL_FILE_OPERATION_MODE_CREATE(3)
        /// Creates a new file.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SaveConfigurationToFile
        /// int32 __stdcall niWLANG_SaveConfigurationToFile (niWLANGenerationSession session, char filePath[], int32 operation);
        /// Purpose
        /// Saves all attributes of the session to a file located at a specified path. Use this file to save the current state of the toolkit.
        /// 
        ///</returns>
        public int SaveConfigurationToFile(string filePath, int operation)
        {
            int pInvokeResult = PInvoke.niWLANG_SaveConfigurationToFile(Handle, filePath, operation);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Loads the attributes of a session saved in a file.
        /// 
        /// </summary>
        ///<param name = "filePath">
        /// Specifies the complete path to the file from which the toolkit loads the configuration.
        /// 
        ///</param>
        ///<param name = "reset">
        /// Specifies whether to reset all the attributes of the session before loading the settings from a file. The default value is NIWLANG_VAL_TRUE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_LoadConfigurationFromFile
        /// int32 __stdcall niWLANG_LoadConfigurationFromFile (niWLANGenerationSession session, char filePath[], int32 reset);
        /// Purpose
        /// Loads the attributes of a session saved in a file.
        /// 
        ///</returns>
        public int LoadConfigurationFromFile(string filePath, int reset)
        {
            int pInvokeResult = PInvoke.niWLANG_LoadConfigurationFromFile(Handle, filePath, reset);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Creates waveforms according to the properties configured in an niWLAN generation session and saves the waveforms to a file. In addition to creating the waveform, this function also saves the NIWLANG_HEADROOM and NIWLANG_IQ_RATE attributes for each waveform. The function reads the NIWLANG_RF_BLANKING_MARKER_POSITIONS attribute and saves the value to the file. The NIWLANG_RF_BLANKING_MARKER_POSITIONS attribute stored in the file is applicable to all waveforms stored in the file.
        /// 
        /// </summary>
        ///<param name = "filePath">
        /// Specifies the absolute path to the TDMS file to which the toolkit writes the waveforms. 
        /// 
        ///</param>
        ///<param name = "operation">
        /// Specifies the operation to perform on the file. The default value is NIWLANG_VAL_FILE_OPERATION_MODE_CREATE_OR_REPLACE.
        /// NIWLANG_VAL_FILE_OPERATION_MODE_OPEN(0)
        /// Opens an existing file to write the niWLANG settings.
        /// NIWLANG_VAL_FILE_OPERATION_MODE_OPEN_OR_CREATE(1)
        /// Opens an existing file or creates a new file if the file does not exist.
        /// NIWLANG_VAL_FILE_OPERATION_MODE_CREATE_OR_REPLACE(2)
        /// Creates a new file or replaces a file if it exists.
        /// NIWLANG_VAL_FILE_OPERATION_MODE_CREATE(3)
        /// Creates a new file.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_CreateAndWriteWaveformsToFile
        /// int32 __stdcall niWLANG_CreateAndWriteWaveformsToFile (niWLANGenerationSession session, char filePath[], int32 operation);
        /// Purpose
        /// Creates waveforms according to the properties configured in an niWLAN generation session and saves the waveforms to a file. In addition to creating the waveform, this function also saves the NIWLANG_HEADROOM and NIWLANG_IQ_RATE attributes for each waveform. The function reads the NIWLANG_RF_BLANKING_MARKER_POSITIONS attribute and saves the value to the file. The NIWLANG_RF_BLANKING_MARKER_POSITIONS attribute stored in the file is applicable to all waveforms stored in the file.
        /// 
        ///</returns>
        public int CreateAndWriteWaveformsToFile(string filePath, int operation)
        {
            int pInvokeResult = PInvoke.niWLANG_CreateAndWriteWaveformsToFile(Handle, filePath, operation);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Reads a waveform from a TDMS file.  You can save this file using the NI WLAN Generation Soft Front Panel. This function returns headroom and I/Q rate waveform data that you can subsequently download to an NI RF vector signal generator.
        /// Use the following active channel string formats to query this function.
        ///                                     NIWLANG_STANDARD attribute
        ///                     Active Channel String Format
        ///                     Comments
        ///                                     NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM, NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211BG_DSSS, or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "" (empty string) 
        ///                     "" for all waveforms
        ///                                     NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx" 
        ///                     channel1 for a waveform of channel with index 1
        ///                                         NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     "[segmentz/channelx 
        ///                     "segment1/channel0" for a waveform of channel with index 0 of segment with index 1. "segment0/" is optional if the segment index is 1.
        /// 
        /// </summary>
        ///<param name = "filePath">
        /// Specifies the absolute path to the TDMS file from which the toolkit saves the waveform. 
        /// 
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform to read from the file. For example, use the channel0 string as a waveform name to read the waveform for channel 0. 
        /// 
        ///</param>
        ///<param name = "offset">
        /// Specifies the number of waveform samples at which the function begins reading the I/Q data. 
        /// The default value is 0. If you set count to 1,000 and offset to 2, the function returns 1,000 samples, starting from index 2 and ending at index 1,002.
        /// 
        ///</param>
        ///<param name = "count">
        /// Specifies the maximum number of samples of the I/Q complex waveform to read from the file. 
        /// The default value is ?1, which returns all samples. If you set count to 1,000 and offset to 2, the function returns 1,000 samples, starting from index 2 and ending at index 1,002.
        /// 
        ///</param>
        ///<param name = "t0">
        /// Returns the start time. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "dt">
        /// Returns the time interval between baseband I/Q samples. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "waveform">
        /// Returns the baseband time-domain waveform. This parameter must be at least the size of the waveformSize parameter.
        /// 
        ///</param>
        ///<param name = "waveformSize">
        /// Specifies the waveform size in samples.
        /// 
        ///</param>
        ///<param name = "actualSize">
        /// Returns the size of the data array. You can pass NULL to the waveform parameter to obtain the size of the waveform.
        /// 
        ///</param>
        ///<param name = "iQRate">
        /// Returns the I/Q rate of the waveform. This value is expressed in samples per seconds (S/s).
        /// 
        ///</param>
        ///<param name = "headroom">
        /// Returns the headroom of waveform. This value is expressed in dB.
        /// 
        ///</param>
        ///<param name = "eOF">
        /// Indicates whether the end of file has been reached with this read. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_ReadWaveformFromFile
        /// int32 __stdcall niWLANG_ReadWaveformFromFile (char filePath[], char waveformName[], int64 offset, int64 count, float64 *t0, float64 *dt, NIComplexNumber waveform[], int32 waveformSize, int32 *actualNumWaveformSamples, float64 *IQRate, float64 *headroom, int32 *eof);
        /// Purpose
        /// Reads a waveform from a TDMS file.  You can save this file using the NI WLAN Generation Soft Front Panel. This function returns headroom and I/Q rate waveform data that you can subsequently download to an NI RF vector signal generator.
        /// Use the following active channel string formats to query this function.
        ///                                     NIWLANG_STANDARD attribute
        ///                     Active Channel String Format
        ///                     Comments
        ///                                     NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM, NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211BG_DSSS, or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "" (empty string) 
        ///                     "" for all waveforms
        ///                                     NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx" 
        ///                     channel1 for a waveform of channel with index 1
        ///                                         NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     "[segmentz/channelx 
        ///                     "segment1/channel0" for a waveform of channel with index 0 of segment with index 1. "segment0/" is optional if the segment index is 1.
        /// 
        ///</returns>
        public int ReadWaveformFromFile(string filePath, string waveformName, long offset, long count, out double t0, out double dt, niComplexNumber[] waveform, int waveformSize, out int actualSize, out double iQRate, out double headroom, out int eOF)
        {
            int pInvokeResult = PInvoke.niWLANG_ReadWaveformFromFile(filePath, waveformName, offset, count, out t0, out dt, waveform, waveformSize, out actualSize, out iQRate, out headroom, out eOF);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Sets the value of an niWLAN generation 64-bit integer (int64) scalar attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of a int64 niWLAN generation scalar attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Specifies the value to which you want to set the attribute.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetScalarAttributeI64
        /// int32 __stdcall  niWLANG_SetScalarAttributeI64 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID,
        ///     int64 attributeValue);
        /// Purpose
        /// Sets the value of an niWLAN generation 64-bit integer (int64) scalar attribute.
        /// 
        ///</returns>
        [Obsolete]
        public int SetScalarAttributeI64(string channelString, niWLANGProperties attributeID, int attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANG_SetScalarAttributeI64(Handle, channelString, attributeID, attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Sets the value of an niWLAN generation 64-bit integer (int64) scalar attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of a int64 niWLAN generation scalar attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Specifies the value to which you want to set the attribute.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetScalarAttributeI64
        /// int32 __stdcall  niWLANG_SetScalarAttributeI64 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID,
        ///     int64 attributeValue);
        /// Purpose
        /// Sets the value of an niWLAN generation 64-bit integer (int64) scalar attribute.
        /// 
        ///</returns>
       public int SetScalarAttributeI64(string channelString, niWLANGProperties attributeID, long attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANG_SetScalarAttributeI64(Handle, channelString, attributeID, attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }



        /// <summary>
        /// Queries the value of an niWLAN Generation 64-bit integer (int64) scalar attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of a int64 niWLAN generation scalar attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Returns the value to which you want to set the attribute.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_GetScalarAttributeI64
        /// int32 __stdcall  niWLANG_GetScalarAttributeI64 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID, 
        ///     int64* attributeValue);
        /// Purpose
        /// Queries the value of an niWLAN Generation 64-bit integer (int64) scalar attribute.
        /// 
        ///</returns>
        [Obsolete]
        public int GetScalarAttributeI64(string channelString, niWLANGProperties attributeID, out int attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANG_GetScalarAttributeI64(Handle, channelString, attributeID, out attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Queries the value of an niWLAN Generation 64-bit integer (int64) scalar attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of a int64 niWLAN generation scalar attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Returns the value to which you want to set the attribute.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_GetScalarAttributeI64
        /// int32 __stdcall  niWLANG_GetScalarAttributeI64 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID, 
        ///     int64* attributeValue);
        /// Purpose
        /// Queries the value of an niWLAN Generation 64-bit integer (int64) scalar attribute.
        /// 
        ///</returns>
        public int GetScalarAttributeI64(string channelString, niWLANGProperties attributeID, out long attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANG_GetScalarAttributeI64(Handle, channelString, attributeID, out attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Queries the value of an niWLAN generation 64-bit floating point number (float64) scalar attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of a float64 niWLAN generation scalar attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Returns the value to which you want to set the attribute.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_GetScalarAttributeF64
        /// int32 __stdcall  niWLANG_GetScalarAttributeF64 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID,
        ///     float64* attributeValue);
        /// Purpose
        /// Queries the value of an niWLAN generation 64-bit floating point number (float64) scalar attribute.
        /// 
        ///</returns>
        public int GetScalarAttributeF64(string channelString, niWLANGProperties attributeID, out double attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANG_GetScalarAttributeF64(Handle, channelString, attributeID, out attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        /// Queries the value of an niWLAN generation 32-bit integer (int32) scalar attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of an int32 niWLAN generation scalar attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Returns the value of the attribute that you specify using the  attributeID  parameter.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_GetScalarAttributeI32
        /// int32 __stdcall  niWLANG_GetScalarAttributeI32 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID, 
        ///     int32* attributeValue);
        /// Purpose
        /// Queries the value of an niWLAN generation 32-bit integer (int32) scalar attribute.
        /// 
        ///</returns>
        public int GetScalarAttributeI32(string channelString, niWLANGProperties attributeID, out int attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANG_GetScalarAttributeI32(Handle, channelString, attributeID, out attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        /// Queries the value of an niWLAN generation 64-bit floating point number (float64) array attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of a float64 niWLAN generation vector attribute.
        /// 
        ///</param>
        ///<param name = "data">
        /// Returns the current value of a float64 vector attribute. The
        /// array must have at least as many elements as are indicated in the dataArraySize parameter.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the data array.
        /// 
        ///</param>
        ///<param name = "actualNumDataElements">
        /// Returns the actual number of elements populated in the data array parameter. If the array is not large enough to hold all the samples, the function returns an error and actualNumDataArrayElements parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_GetVectorAttributeF64
        /// int32 __stdcall niWLANG_GetVectorAttributeF64 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID,
        ///     float64 data[],
        ///     int32 dataArraySize,
        ///     int32* actualNumDataArrayElements);
        /// Purpose
        /// Queries the value of an niWLAN generation 64-bit floating point number (float64) array attribute.
        /// 
        ///</returns>
        public int GetVectorAttributeF64(string channelString, niWLANGProperties attributeID, double[] data, int dataArraySize, out int actualNumDataElements)
        {
            int pInvokeResult = PInvoke.niWLANG_GetVectorAttributeF64(Handle, channelString, attributeID, data, dataArraySize, out actualNumDataElements);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        /// Queries the value of an niWLAN generation 32-bit integer (int32) vector attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of an int32 niWLAN generation vector attribute.
        /// 
        ///</param>
        ///<param name = "data">
        /// Returns the current values of an int32 vector attribute. The
        /// array must have at least as many elements as are indicated in the dataArraySize parameter.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the data array.
        /// 
        ///</param>
        ///<param name = "actualNumDataElements">
        /// Returns the number of elements populated in the data array attribute. If the array is not large enough to hold all the samples, the function returns an error and actualNumDataArrayElements parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_GetVectorAttributeI32
        /// int32 __stdcall niWLANG_GetVectorAttributeI32 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID,   
        ///     int32 data[],
        ///     int32 dataArraySize, 
        ///     int32* actualNumDataArrayElements);
        /// Purpose
        /// Queries the value of an niWLAN generation 32-bit integer (int32) vector attribute.
        /// 
        ///</returns>
        public int GetVectorAttributeI32(string channelString, niWLANGProperties attributeID, int[] data, int dataArraySize, out int actualNumDataElements)
        {
            int pInvokeResult = PInvoke.niWLANG_GetVectorAttributeI32(Handle, channelString, attributeID, data, dataArraySize, out actualNumDataElements);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Specifies the format of the physical layer convergence protocol (PLCP) frame structure. The frame structure determines the arrangement of preambles, header (SIGNAL field), and payload in a frame as defined in section 20.3.2 of IEEE Standard 802.11n-2009.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "frameFormat">
        /// Specifies the PLCP frame structure to use. The default value is NIWLANG_VAL_80211N_PLCP_FRAME_FORMAT_MIXED.
        /// NIWLANG_VAL_80211N_PLCP_FRAME_FORMAT_MIXED (0)
        /// Specifies that the PLCP frame structure consists of non-HT preamble and header (Signal field) followed by high throughput (HT) header, preambles, and payload as specified in IEEE Standard 802.11n-2009.
        /// NIWLANG_VAL_80211N_PLCP_FRAME_FORMAT_GREENFIELD (1)
        /// Specifies that the PLCP frame structure does not support non-HT, and starts with HT preamble, followed by HT SIGnal field, and payload.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_Set80211nPLCPFrameFormat
        /// int32 __stdcall niWLANG_Set80211nPLCPFrameFormat (niWLANGenerationSession session,
        ///     char channelString[],
        ///     int32 frameFormat);
        /// Purpose
        /// Specifies the format of the physical layer convergence protocol (PLCP) frame structure. The frame structure determines the arrangement of preambles, header (SIGNAL field), and payload in a frame as defined in section 20.3.2 of IEEE Standard 802.11n-2009.
        /// 
        ///</returns>
        public int Set80211nPLCPFrameFormat(string channelString, int frameFormat)
        {
            return SetInt32(niWLANGProperties._80211nPlcpFrameFormat, channelString, frameFormat);
        }

        /// <summary>
        /// Specifies the data rate for the direct sequence spread spectrum (DSSS) payload, as defined in IEEE Standard 802.11b-1999 and the extended rate physical layer-packet binary convolutional coding (ERP-PBCC) mode in IEEE Standard 802.11g-2003.
        /// Note&#160;&#160;Configure this function only if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211BG_DSSS.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "dSSSDataRate">
        /// Specifies the data rate for the DSSS payload. The default value is NIWLANG_VAL_DSSS_DATA_RATE_1.
        /// NIWLANG_VAL_DSSS_DATA_RATE_1 (0)
        /// Specifies a data rate of 1, as defined in sections 18.4.6.3 and 18.4.6.4 of IEEE Standard 802.11b-1999. 
        /// NIWLANG_VAL_DSSS_DATA_RATE_2 (1)
        /// Specifies a data rate of 2, as defined in sections 18.4.6.3 and 18.4.6.4 of IEEE Standard 802.11b-1999.
        /// NIWLANG_VAL_DSSS_DATA_RATE_5p5_CCK (2)
        /// Specifies a data rate of 5.5 complementary code keying (CCK), as defined in section 18.4.6.5 of IEEE Standard 802.11b-1999.
        /// NIWLANG_VAL_DSSS_DATA_RATE_5p5_PBCC (3)
        /// Specifies a data rate of 5.5 PBCC, as defined in section 18.4.6.6 of IEEE Standard 802.11b-1999.
        /// NIWLANG_VAL_DSSS_DATA_RATE_11_CCK (4)
        /// Specifies a data rate of 11 CCK, as defined in section 18.4.6.5 of IEEE Standard 802.11b-1999.
        /// NIWLANG_VAL_DSSS_DATA_RATE_11_PBCC (5)
        /// Specifies a data rate of 11 PBCC, as defined in section 18.4.6.6 of IEEE Standard 802.11b-1999.
        /// NIWLANG_VAL_DSSS_DATA_RATE_22 (6)
        /// Specifies a data rate of 22, as defined in section 19.3.3.2 of IEEE Standard 802.11g-2003.
        /// NIWLANG_VAL_DSSS_DATA_RATE_33 (7)
        /// Specifies a data rate of 33, as defined in section 19.3.3.2 of IEEE Standard 802.11g-2003.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetDSSSDataRate
        /// int32 __stdcall niWLANG_SetDSSSDataRate (niWLANGenerationSession session,
        ///     char channelString[],
        ///     int32 dsssDataRate);
        /// Purpose
        /// Specifies the data rate for the direct sequence spread spectrum (DSSS) payload, as defined in IEEE Standard 802.11b-1999 and the extended rate physical layer-packet binary convolutional coding (ERP-PBCC) mode in IEEE Standard 802.11g-2003.
        /// Note&#160;&#160;Configure this function only if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211BG_DSSS.
        /// 
        ///</returns>
        public int SetDSSSDataRate(string channelString, int dSSSDataRate)
        {
            return SetInt32(niWLANGProperties.DsssDataRate, channelString, dSSSDataRate);
        }

        /// <summary>
        /// Specifies whether to use a long or short preamble for direct sequence spread spectrum (DSSS) and DSSS-OFDM packets as defined in IEEE Standard 802.11b-1999.
        /// Note&#160;&#160; Configure this function only if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211BG_DSSS or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "preambleType">
        /// Specifies whether to use a long or short preamble for DSSS and DSSS-OFDM packets. The default value is NIWLANG_VAL_PREAMBLE_TYPE_LONG_PREAMBLE.
        /// NIWLANG_VAL_PREAMBLE_TYPE_LONG_PREAMBLE (0)
        /// Uses a long preamble, as defined in section 18.2.2.1 of IEEE Standard 802.11b-1999.
        /// NIWLANG_VAL_PREAMBLE_TYPE_SHORT_PREAMBLE (1)
        /// Uses a short preamble, as defined in section 18.2.2.2 of IEEE Standard 802.11b-1999. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetDSSSPreambleType
        /// int32 __stdcall niWLANG_SetDSSSPreambleType (niWLANGenerationSession session,
        ///     char channelString[],
        ///     int32 preambleFormat);
        /// Purpose
        /// Specifies whether to use a long or short preamble for direct sequence spread spectrum (DSSS) and DSSS-OFDM packets as defined in IEEE Standard 802.11b-1999.
        /// Note&#160;&#160; Configure this function only if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211BG_DSSS or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM.
        /// 
        ///</returns>
        public int SetDSSSPreambleType(string channelString, int preambleType)
        {
            return SetInt32(niWLANGProperties.DsssPreambleType, channelString, preambleType);
        }


        /// <summary>
        /// Specifies the value of the modulation and coding scheme (MCS) index. The MCS index is a compact representation that determines the modulation scheme, coding rate, and number of spatial streams as specified in section 20.3.5 of IEEE Standard 802.11n-2009, section 22.5 of IEEE Standard 802.11ac-2013, section 24.5 of IEEE Standard P802.11ah/D1.3, section 23.5 of IEEE Standard 802.11af-2013, and section 28.5 of IEEE P802.11ax/D1.2. 
        /// To understand which active channel strings are required to configure this function, refer to the NIWLANG_MCS_INDEX attribute. 
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "mCSIndex">
        /// Specifies the value of the MCS index. The default value is 0. If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM and NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, the valid values are 0 to 11, inclusive. If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, the valid values are 0 to 32, inclusive. If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, the valid values are 0 to 10, inclusive. If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM, the valid values are 0 to 9, inclusive.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetMCSIndex
        /// int32 __stdcall niWLANG_SetMCSIndex (niWLANGenerationSession session,
        ///     char channelString[],
        ///     int32 MCSIndex);
        /// Purpose
        /// Specifies the value of the modulation and coding scheme (MCS) index. The MCS index is a compact representation that determines the modulation scheme, coding rate, and number of spatial streams as specified in section 20.3.5 of IEEE Standard 802.11n-2009, section 22.5 of IEEE Standard 802.11ac-2013, section 24.5 of IEEE Standard P802.11ah/D1.3, section 23.5 of IEEE Standard 802.11af-2013, and section 28.5 of IEEE P802.11ax/D1.2. 
        /// To understand which active channel strings are required to configure this function, refer to the NIWLANG_MCS_INDEX attribute. 
        /// 
        ///</returns>
        public int SetMCSIndex(string channelString, int mCSIndex)
        {
            return SetInt32(niWLANGProperties.McsIndex, channelString, mCSIndex);
        }

        /// <summary>
        /// Specifies the data rate for the OFDM payload, as defined in section 17.3.2.2 of IEEE Standard 802.11a-1999. This value is expressed is Mbps.
        /// Note&#160;&#160;Configure this function only when you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM, NIWLANG_VAL_STANDARD_80211P_OFDM or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "oFDMDataRate">
        /// Specifies the data rate for the OFDM payload. This value is expressed in Mbps. The default value is NIWLANG_VAL_OFDM_DATA_RATE_6.
        /// NIWLANG_VAL_OFDM_DATA_RATE_6 (0)
        /// Specifies a data rate of 1.5 Mbps, 3 Mbps, and 6 Mbps for respective channel bandwidths of 5 MHz, 10 MHz, and 20 MHz. 
        /// NIWLANG_VAL_OFDM_DATA_RATE_9 (1)
        /// Specifies a data rate of 2.25 Mbps, 4.5 Mbps, and 9 Mbps for respective channel bandwidths of 5 MHz, 10 MHz, and 20 MHz.
        /// NIWLANG_VAL_OFDM_DATA_RATE_12 (2)
        /// Specifies a data rate of 3 Mbps, 6 Mbps, and 12 Mbps for respective channel bandwidths of 5 MHz, 10 MHz, and 20 MHz.
        /// NIWLANG_VAL_OFDM_DATA_RATE_18 (3)
        /// Specifies a data rate of 4.5 Mbps, 9 Mbps, and 18 Mbps for respective channel bandwidths of 5 MHz, 10 MHz, and 20 MHz.
        /// NIWLANG_VAL_OFDM_DATA_RATE_24 (4)
        /// Specifies a data rate of 6 Mbps, 12 Mbps, and 24 Mbps for respective channel bandwidths of 5 MHz, 10 MHz, and 20 MHz. 
        /// NIWLANG_VAL_OFDM_DATA_RATE_36 (5)
        /// Specifies a data rate of 9 Mbps, 18 Mbps, and 36 Mbps for respective channel bandwidths of 5 MHz, 10 MHz, and 20 MHz.
        /// NIWLANG_VAL_OFDM_DATA_RATE_48 (6)
        /// Specifies a data rate of 12 Mbps, 24 Mbps, and 48 Mbps for respective channel bandwidths of 5 MHz, 10 MHz, and 20 MHz. 
        /// NIWLANG_VAL_OFDM_DATA_RATE_54 (7)
        /// Specifies a data rate of 13.5 Mbps, 27 Mbps, and 54 Mbps for respective channel bandwidths of 5 MHz, 10 MHz, and 20 MHz. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetOFDMDataRate
        /// int32 __stdcall niWLANG_SetOFDMDataRate (niWLANGenerationSession session,
        ///     char channelString[],
        ///     int32 ofdmDataRate);
        /// Purpose
        /// Specifies the data rate for the OFDM payload, as defined in section 17.3.2.2 of IEEE Standard 802.11a-1999. This value is expressed is Mbps.
        /// Note&#160;&#160;Configure this function only when you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM, NIWLANG_VAL_STANDARD_80211P_OFDM or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM.
        /// 
        ///</returns>
        public int SetOFDMDataRate(string channelString, int oFDMDataRate)
        {
            return SetInt32(niWLANGProperties.OfdmDataRate, channelString, oFDMDataRate);
        }

        /// <summary>
        /// Sets the value of an niWLAN generation 64-bit floating point number (float64) scalar attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of a float64 niWLAN generation scalar attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Specifies the value to which you want to set the attribute.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetScalarAttributeF64
        /// int32 __stdcall  niWLANG_SetScalarAttributeF64 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID,
        ///     float64 attributeValue);
        /// Purpose
        /// Sets the value of an niWLAN generation 64-bit floating point number (float64) scalar attribute.
        /// 
        ///</returns>
        public int SetScalarAttributeF64(string channelString, niWLANGProperties attributeID, double attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANG_SetScalarAttributeF64(Handle, channelString, attributeID, attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        /// Sets the value of an niWLAN generation 32-bit integer (int32) scalar attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of an int32 niWLAN generation scalar attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// Specifies the value to which you want to set the attribute.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetScalarAttributeI32
        /// int32 __stdcall  niWLANG_SetScalarAttributeI32 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID,
        ///     int32 attributeValue);
        /// Purpose
        /// Sets the value of an niWLAN generation 32-bit integer (int32) scalar attribute.
        /// 
        ///</returns>
        public int SetScalarAttributeI32(string channelString, niWLANGProperties attributeID, int attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANG_SetScalarAttributeI32(Handle, channelString, attributeID, attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Sets the value of an niWLAN generation 64-bit floating point number (float64) vector attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of a float64 niWLAN generation vector attribute.
        /// 
        ///</param>
        ///<param name = "data">
        /// Specifies the float64 array to which you want to set the attribute.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the data array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetVectorAttributeF64
        /// int32 __stdcall niWLANG_SetVectorAttributeF64 (niWLANGenerationSession session,
        ///     char channelString[], 
        ///     niWLANG_Attr attributeID,
        ///     float64 data[],
        ///     int32 dataArraySize);
        /// Purpose
        /// Sets the value of an niWLAN generation 64-bit floating point number (float64) vector attribute.
        /// 
        ///</returns>
        public int SetVectorAttributeF64(string channelString, niWLANGProperties attributeID, double[] data, int dataArraySize)
        {
            int pInvokeResult = PInvoke.niWLANG_SetVectorAttributeF64(Handle, channelString, attributeID, data, dataArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        /// Sets the value of an niWLAN generation 32-bit integer (int32) vector attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of an int32 niWLAN generation vector attribute.
        /// 
        ///</param>
        ///<param name = "data">
        /// Specifies the int32 array to which you want to set the attribute.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the int32 array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetVectorAttributeI32
        /// int32 __stdcall niWLANG_SetVectorAttributeI32 (niWLANGenerationSession session,
        ///     char channelString[],
        ///     niWLANG_Attr attributeID,
        ///     int32 data[],
        ///     int32 dataArraySize);
        /// Purpose
        /// Sets the value of an niWLAN generation 32-bit integer (int32) vector attribute.
        /// 
        ///</returns>
        public int SetVectorAttributeI32(string channelString, niWLANGProperties attributeID, int[] data, int dataArraySize)
        {
            int pInvokeResult = PInvoke.niWLANG_SetVectorAttributeI32(Handle, channelString, attributeID, data, dataArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Calculates the frequency according to the numbering scheme by converting a set of input parameters into the carrier frequency as specified in sections 18.4.6 and 17.3.8.3 of IEEE Standard 802.11-2007, and sections 20.3.15.1 and 20.3.15.2  of IEEE Standard 802.11-2009.
        /// 
        /// </summary>
        ///<param name = "frequencyBand">
        /// Specifies whether to use the 2.4 GHz or the 5 GHz band.
        /// NIWLANG_VAL_FREQUENCY_BAND_2p4GHZ (0)
        /// Specifies a frequency band of 2.4 GHz.
        /// NIWLANG_VAL_FREQUENCY_BAND_5GHZ (1)
        /// Specifies a frequency band of 5 GHz.
        /// 
        ///</param>
        ///<param name = "channelBandwidth">
        /// Specifies whether to choose a 5 MHz, 10 MHz, 20 MHz, or 40 MHz channel.
        /// 
        ///</param>
        ///<param name = "channelNumber">
        /// Specifies the offset of the center frequency, in increments of 5 MHz, above the starting frequency of the channel.
        /// When the channelBandwidth parameter is set to 40 MHz, the channelNumber parameter is the primary channel number and the corresponding channel center frequency is the primary channel center frequency. Channel
        /// center frequency is calculated using the following formula:
        /// <p class="body">channel center frequency (Hz) = channel starting frequency (Hz) + (channel&#160;number&#160;*&#160;5&#160;MHz)</p>
        /// 
        ///</param>
        ///<param name = "secondaryFactor">
        /// Specifies whether the secondary channel is above or below the primary channel when the
        /// channelBandwidth parameter is set to 40 MHz.
        /// A 40 MHz channel is created by combining the primary channel and the secondary channel, each of bandwidth
        /// 20MHz.
        /// The secondary channel number is given by the following formula:
        /// secondary channel number = primary channel number + (4&#160;*&#160;secondary factor)
        /// The secondary channel center frequency is given by the following formula:
        /// secondary channel center frequency (Hz) = channel starting frequency (Hz) + (secondary channel number * 5&#160;MHz)
        /// <p class="body">The valid values are &#8211;1 and +1.</p>
        /// 
        ///</param>
        ///<param name = "chStartingFactor">
        /// Specifies the value used to define the baseline frequency.
        /// The channel starting frequency is given by the following formula:
        /// channel starting frequency (Hz) = (channel starting factor * 500 kHz)
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Returns the carrier frequency, in hertz (Hz).
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_ChannelNumberToCarrierFrequency
        /// int32 __stdcall niWLANG_ChannelNumberToCarrierFrequency (uInt16 frequencyBand,
        ///     float64 channelBandwidth,
        ///     int32 channelNumber,
        ///     int32 secondaryFactor, 
        ///     float64 channelStartingFactor,
        ///     float64 *carrierFrequency);
        /// Purpose
        /// Calculates the frequency according to the numbering scheme by converting a set of input parameters into the carrier frequency as specified in sections 18.4.6 and 17.3.8.3 of IEEE Standard 802.11-2007, and sections 20.3.15.1 and 20.3.15.2  of IEEE Standard 802.11-2009.
        /// 
        ///</returns>        
        [Obsolete("Use Standard Specific Functions")]
        public int ChannelNumberToCarrierFrequency(int frequencyBand, double channelBandwidth, int channelNumber, int secondaryFactor, double chStartingFactor, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANG_ChannelNumberToCarrierFrequency(frequencyBand, channelBandwidth, channelNumber, secondaryFactor, chStartingFactor, out carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Calculates the carrier frequency of 802.11a/b/g/j/p/n channels according to sections 16.4.6, 17.4.6, 18.3.8.4, and 20.3.15 of IEEE Standard 802.11-2012.
        /// 
        /// </summary>
        ///<param name = "channelStartingFrequency">
        /// Specifies the starting frequency of the frequency band. 
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelBandwidth">
        /// Specifies the channel bandwidth You can choose a 5 MHz, 10 MHz, 20 MHz, or 40 MHz channel.
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelNumber">
        /// Specifies the offset of the center frequency, in increments of 5 MHz, above the starting frequency of the channel.
        /// 
        ///</param>
        ///<param name = "secondaryFactor">
        /// Specifies whether the secondary channel is above or below the primary channel when you set the
        /// channelBandwidth parameter to 40 MHz.
        /// The toolkit creates a 40 MHz channel by combining the primary channel and the secondary channel, each with a 20 MHz bandwidth.
        /// The value of -1 indicates that the secondary channel is below the primary channel whereas the value of +1 indicates that the secondary channel is above the primary channel. Valid values are -1 and +1.
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Returns the carrier frequency. This value is expressed in Hz. The function calculates the carrier frequency using the following equation:
        /// Carrier frequency (Hz) = channel starting frequency (Hz) + (channel number * 5 MHz)
        /// When you set the channelBandwidth parameter to 40 MHz, the channelNumber parameter is the primary channel number. The function calculates the carrier frequency using the following equation:
        /// carrier frequency (Hz) = channel starting frequency (Hz) + (channel number * 5 MHz)+ (Secondary factor * 20 MHz)
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_ChannelNumberToCarrierFrequency80211abgjpn
        /// int32 __stdcall niWLANG_ChannelNumberToCarrierFrequency80211abgjpn (float64 channelStartingFrequency, 
        ///     float64 channelBandwidth, 
        ///     int32 channelNumber, 
        ///     int32 secondaryFactor, 
        ///     float64 *carrierFrequency);
        /// Purpose
        /// Calculates the carrier frequency of 802.11a/b/g/j/p/n channels according to sections 16.4.6, 17.4.6, 18.3.8.4, and 20.3.15 of IEEE Standard 802.11-2012.
        /// 
        ///</returns>
        public int ChannelNumberToCarrierFrequency80211abgjpn(double channelStartingFrequency, double channelBandwidth, int channelNumber, int secondaryFactor, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANG_ChannelNumberToCarrierFrequency80211abgjpn(channelStartingFrequency, channelBandwidth, channelNumber, secondaryFactor, out  carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Calculates carrier frequency of 802.11ac channels according to section 22.3.14 of IEEE Standard 802.11ac-2013. 
        /// 
        /// </summary>
        ///<param name = "channelStartingFrequencyHz">
        /// Specifies the start frequency of the frequency band. 
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelNumber">
        /// Specifies the offset of the center frequency above the starting frequency of the channel.
        ///  This value is expressed in increments of 5 MHz.
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Returns the carrier frequency. This value is expressed in Hz. The function calculates the carrier frequency using the following equation:
        /// Carrier frequency (Hz) = channel starting frequency (Hz) + (channel number * 5 MHz)
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_ChannelNumberToCarrierFrequency80211ac
        /// int32 __stdcall niWLANG_ChannelNumberToCarrierFrequency80211ac (float64 channelStartingFrequency, 
        ///     int32 channelNumber, 
        ///     float64 *carrierFrequency);
        /// Purpose
        /// Calculates carrier frequency of 802.11ac channels according to section 22.3.14 of IEEE Standard 802.11ac-2013. 
        /// 
        ///</returns>
        public int ChannelNumberToCarrierFrequency80211ac(double channelStartingFrequencyHz, int channelNumber, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANG_ChannelNumberToCarrierFrequency80211ac(channelStartingFrequencyHz, channelNumber, out  carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Calculates the carrier frequency of 802.11ah channels according to section 22.3.13 of IEEE P802.11ah/D1.3.
        /// 
        /// </summary>
        ///<param name = "channelStartingFrequencyHz">
        /// Specifies the start frequency of the frequency band. 
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelNumber">
        /// Specifies the offset of the center frequency above the starting frequency of the channel.
        ///  This value is expressed in increments of 5 MHz.
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Returns the carrier frequency. This value is expressed in Hz.  The function calculates the carrier frequency using the following formula:
        /// carrier frequency (Hz) = channel starting frequency (Hz) + (channel number * 0.5 MHz)
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_ChannelNumberToCarrierFrequency80211ah
        /// int32 __stdcall niWLANG_ChannelNumberToCarrierFrequency80211ah (float64 channelStartingFrequency, 
        ///     int32 channelNumber, 
        ///     float64 *carrierFrequency);
        /// Purpose
        /// Calculates the carrier frequency of 802.11ah channels according to section 22.3.13 of IEEE P802.11ah/D1.3.
        /// 
        ///</returns>
        public int ChannelNumberToCarrierFrequency80211ah(double channelStartingFrequencyHz, int channelNumber, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANG_ChannelNumberToCarrierFrequency80211ah(channelStartingFrequencyHz, channelNumber, out  carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        #region Missing Functions

        /// <summary>
        ///Specifies the number of medium access control (MAC) protocol data units (MPDUs) to combine into one aggregate-MPDU (A-MPDU).
        ///       If you set the NIWLANG_STANDARD attribute to    NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM,    use an empty string active channel string format to configure this attribute. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, use    an empty string as the active channel string format, if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, or use 'userx' as    the active channel string format if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_MU_PPDU to configure this attribute. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, use    an empty string as the active channel string format, if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, or    NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, or use  'userx' as the active channel string    format if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU to    configure this attribute. 
        ///     Note: The toolkit ignores this attribute if you set the NIWLANG_AMPDU_ENABLED attribute to NIWLANG_VAL_FALSE or if you set the    NIWLANG_STANDARD attribute to a value other than NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM; or if you set    the NIWLANG_NON_HT_MODULATION_MODE attribute to NIWLANG_VAL_NON_HT_MODULATION_MODE_ON.
        ///    The default value is 1.
        ///    Set Function: niWLANG_SetNumberOfMPDUs
        ///    Get Function: niWLANG_GetNumberOfMPDUs
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetNumberOfMPDUs(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.PayloadNumberOfMpdus, channelString, value);
        }
        /// <summary>
        ///Specifies the number of medium access control (MAC) protocol data units (MPDUs) to combine into one aggregate-MPDU (A-MPDU).
        ///       If you set the NIWLANG_STANDARD attribute to    NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM,    use an empty string active channel string format to configure this attribute. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, use    an empty string as the active channel string format, if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, or use 'userx' as    the active channel string format if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_MU_PPDU to configure this attribute. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, use    an empty string as the active channel string format, if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, or    NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, or use  'userx' as the active channel string    format if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU to    configure this attribute. 
        ///     Note: The toolkit ignores this attribute if you set the NIWLANG_AMPDU_ENABLED attribute to NIWLANG_VAL_FALSE or if you set the    NIWLANG_STANDARD attribute to a value other than NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM; or if you set    the NIWLANG_NON_HT_MODULATION_MODE attribute to NIWLANG_VAL_NON_HT_MODULATION_MODE_ON.
        ///    The default value is 1.
        ///    Set Function: niWLANG_SetNumberOfMPDUs
        ///    Get Function: niWLANG_GetNumberOfMPDUs
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetNumberOfMPDUs(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadNumberOfMpdus, channelString,out value);
        }

        /// <summary>
        /// Specifies the method of applying window to the baseband signal, if you set the NIWLANG_STANDARD attribute to    NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM,    NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM,    or NIWLANG_VAL_STANDARD_80211AX_MIMOOFDM. This attribute is ignored if you set the NIWLANG_STANDARD    attribute to NIWLANG_VAL_STANDARD_80211BG_DSSS.
        ///    Refer to the Windowing topic for more information about windowing for OFDM signals. 
        ///    The default value is NIWLANG_VAL_WIN_METHOD_CENTERED_AT_SYMBOL_BOUNDARY.
        ///    Set Function: niWLANG_SetWindowingMethod
        ///    Get Function: niWLANG_GetWindowingMethod
        ///</summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetWindowingMethod(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.WindowingMethod, channelString, value);
        }

        ///<summary>
        ///Specifies the method of applying window to the baseband signal, if you set the NIWLANG_STANDARD attribute to    NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM,    NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM,    or NIWLANG_VAL_STANDARD_80211AX_MIMOOFDM. This attribute is ignored if you set the NIWLANG_STANDARD    attribute to NIWLANG_VAL_STANDARD_80211BG_DSSS.
        ///    Refer to the Windowing topic for more information about windowing for OFDM signals. 
        ///    The default value is NIWLANG_VAL_WIN_METHOD_CENTERED_AT_SYMBOL_BOUNDARY.
        ///    Set Function: niWLANG_SetWindowingMethod
        ///    Get Function: niWLANG_GetWindowingMethod
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetWindowingMethod(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.WindowingMethod, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetMACCurrentSequenceControl(string channelString, int value)
        {
            int pInvokeResult = PInvoke.niWLANG_SetMACCurrentSequenceControl(Handle, channelString, value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetMACCurrentSequenceControl(string channelString, out int value)
        {
            int pInvokeResult = PInvoke.niWLANG_GetMACCurrentSequenceControl(Handle, channelString, out value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Indicates the compatibilityVersion parameter of the niWLANG_OpenSession function.
        ///    Get Function: niWLANG_GetToolkitCompatibilityVersion
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetToolkitCompatibilityVersion(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.CompatibilityVersion, channelString,out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetMACOverheadLength(string channelString, out int value)
        {
            int pInvokeResult = PInvoke.niWLANG_GetMACOverheadLength(Handle, channelString, out value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        #endregion

        #region Version 4.0

        //NIWLANG_PAYLOAD_NUMBER_OF_MPDUS 0x68
        /// <summary>
        ///Specifies the number of medium access control (MAC) protocol data units (MPDUs) to combine into one aggregate-MPDU (A-MPDU).
        ///       If you set the NIWLANG_STANDARD attribute to    NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM,    use an empty string active channel string format to configure this attribute. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, use    an empty string as the active channel string format, if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, or use 'userx' as    the active channel string format if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_MU_PPDU to configure this attribute. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, use    an empty string as the active channel string format, if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, or    NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, or use  'userx' as the active channel string    format if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU to    configure this attribute. 
        ///     Note: The toolkit ignores this attribute if you set the NIWLANG_AMPDU_ENABLED attribute to NIWLANG_VAL_FALSE or if you set the    NIWLANG_STANDARD attribute to a value other than NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM; or if you set    the NIWLANG_NON_HT_MODULATION_MODE attribute to NIWLANG_VAL_NON_HT_MODULATION_MODE_ON.
        ///    The default value is 1.
        ///    Set Function: niWLANG_SetNumberOfMPDUs
        ///    Get Function: niWLANG_GetNumberOfMPDUs
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetPayloadNumberOfMpdus(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PayloadNumberOfMpdus, channel, value);
        }

        /// <summary>
        ///Specifies the number of medium access control (MAC) protocol data units (MPDUs) to combine into one aggregate-MPDU (A-MPDU).
        ///       If you set the NIWLANG_STANDARD attribute to    NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM,    use an empty string active channel string format to configure this attribute. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, use    an empty string as the active channel string format, if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, or use 'userx' as    the active channel string format if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_MU_PPDU to configure this attribute. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, use    an empty string as the active channel string format, if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, or    NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, or use  'userx' as the active channel string    format if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU to    configure this attribute. 
        ///     Note: The toolkit ignores this attribute if you set the NIWLANG_AMPDU_ENABLED attribute to NIWLANG_VAL_FALSE or if you set the    NIWLANG_STANDARD attribute to a value other than NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM; or if you set    the NIWLANG_NON_HT_MODULATION_MODE attribute to NIWLANG_VAL_NON_HT_MODULATION_MODE_ON.
        ///    The default value is 1.
        ///    Set Function: niWLANG_SetNumberOfMPDUs
        ///    Get Function: niWLANG_GetNumberOfMPDUs
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetPayloadNumberOfMpdus(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadNumberOfMpdus, channel, out value);
        }

        // NIWLANG_AMPDU_ENABLED                             	0x67	/*int32*/
        /// <summary>
        ///Specifies whether all medium access control (MAC) protocol data units (MPDUs) are transmitted as aggregate-MPDU (A-MPDU).
        ///    Note: This attribute is applicable only if you set the NIWLANG_STANDARD attribute to    NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_NON_HT_MODULATION_MODE attribute to NIWLANG_VAL_NON_HT_MODULATION_MODE_OFF.
        ///     The default value is NIWLANG_VAL_FALSE, if you set the NIWLANG_STANDARD attribute    to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM.    The default value is NIWLANG_VAL_TRUE, if you set the NIWLANG_STANDARD attribute    to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.
        ///     Set Function: niWLANG_SetAMPDUEnabled
        ///    Get Function: niWLANG_GetAMPDUEnabled
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetAmpduEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.AmpduEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether all medium access control (MAC) protocol data units (MPDUs) are transmitted as aggregate-MPDU (A-MPDU).
        ///    Note: This attribute is applicable only if you set the NIWLANG_STANDARD attribute to    NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_NON_HT_MODULATION_MODE attribute to NIWLANG_VAL_NON_HT_MODULATION_MODE_OFF.
        ///     The default value is NIWLANG_VAL_FALSE, if you set the NIWLANG_STANDARD attribute    to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM.    The default value is NIWLANG_VAL_TRUE, if you set the NIWLANG_STANDARD attribute    to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM, or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.
        ///     Set Function: niWLANG_SetAMPDUEnabled
        ///    Get Function: niWLANG_GetAMPDUEnabled
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetAmpduEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.AmpduEnabled, channel, out value);
        }

        // #define NIWLANG_TIMING_SKEW									0x4F	/*float64*/
        /// <summary>
        ///Specifies the difference between the sampling instants of I and Q streams. This value is expressed in seconds.
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM,    NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANG_VAL_STANDARD_80211BG_DSSS, or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM    the active channel string syntax is an empty string.
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, the active channel string    syntax is 'channelx'.
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM, the    active channel string syntax is 'segmentx/channely'. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, the active    channel string format is 'segmentx/channely' if you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, or NIWLANG_VAL_PPDU_TYPE_MU_PPDU. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, the active    channel string format is '[userx/]segmenty/channelz' if you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU (userx is optional if you want to apply to all the users). 
        ///     Refer to the Configuring Active Channels (LabWindows/CVI) help topic for more information about configuring active channels.
        ///    The default value is 0. Valid values are -1 microsecond to 1 microsecond, inclusive.
        ///    Set Function: niWLANG_SetTimingSkew
        ///    Get Function: niWLANG_GetTimingSkew
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetTimingSkew(string channel, double value)
        {
            return SetDouble(niWLANGProperties.TimingSkew, channel, value);
        }

        /// <summary>
        ///Specifies the difference between the sampling instants of I and Q streams. This value is expressed in seconds.
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211J_OFDM,    NIWLANG_VAL_STANDARD_80211P_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANG_VAL_STANDARD_80211BG_DSSS, or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM    the active channel string syntax is an empty string.
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, the active channel string    syntax is 'channelx'.
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AF_MIMOOFDM, the    active channel string syntax is 'segmentx/channely'. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, the active    channel string format is 'segmentx/channely' if you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, or NIWLANG_VAL_PPDU_TYPE_MU_PPDU. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, the active    channel string format is '[userx/]segmenty/channelz' if you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU (userx is optional if you want to apply to all the users). 
        ///     Refer to the Configuring Active Channels (LabWindows/CVI) help topic for more information about configuring active channels.
        ///    The default value is 0. Valid values are -1 microsecond to 1 microsecond, inclusive.
        ///    Set Function: niWLANG_SetTimingSkew
        ///    Get Function: niWLANG_GetTimingSkew
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetTimingSkew(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.TimingSkew, channel, out value);
        }

        //#define NIWLANG_MAXIMUM_HARDWARE_IQ_RATE					0x66	/*float64*/
        /// <summary>
        ///Specifies the maximum I/Q rate that the NI RF vector signal generator supports.
        ///    This attribute is set according to the device model in the niWLANG_RFSGCreateandDownloadWaveform function. 
        ///    Valid values are 1250 MS/s if you are using NI PXIe-5840, 250 MS/s if you are using the NI PXIe-5646R, 120 MS/s if you are    using the NI PXIe-5644R/NI PXIe-5645R, or 200 MS/s if you are using the NI PXIe-5673/5673E.
        ///    Set Function: niWLANG_SetMaximumHardwareIQRate
        ///    Get Function: niWLANG_GetMaximumHardwareIQRate
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetMaximumHardwareIqRate(string channel, double value)
        {
            return SetDouble(niWLANGProperties.MaximumHardwareIqRate, channel, value);
        }

        /// <summary>
        ///Specifies the maximum I/Q rate that the NI RF vector signal generator supports.
        ///    This attribute is set according to the device model in the niWLANG_RFSGCreateandDownloadWaveform function. 
        ///    Valid values are 1250 MS/s if you are using NI PXIe-5840, 250 MS/s if you are using the NI PXIe-5646R, 120 MS/s if you are    using the NI PXIe-5644R/NI PXIe-5645R, or 200 MS/s if you are using the NI PXIe-5673/5673E.
        ///    Set Function: niWLANG_SetMaximumHardwareIQRate
        ///    Get Function: niWLANG_GetMaximumHardwareIQRate
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetMaximumHardwareIqRate(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.MaximumHardwareIqRate, channel, out value);
        }

        //define NIWLANG_NUMBER_OF_SEGMENTS							0x4B	/*int32*/
        /// <summary>
        ///Specifies the number of frequency segments for 802.11ac or 802.11ax signals.
        ///    For 80 MHz + 80 MHz transmission of 802.11ac or 802.11ax signals, set this attribute to 2 and the    NIWLANG_CHANNEL_BANDWIDTH attribute to 80 MHz.
        ///    The default value is 1.
        ///    Set Function: niWLANG_SetNumberOfSegments
        ///    Get Function: niWLANG_GetNumberOfSegments
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetNumberOfSegments(string channel, int value)
        {
            return SetInt32(niWLANGProperties.NumberOfSegments, channel, value);
        }

        /// <summary>
        ///Specifies the number of frequency segments for 802.11ac or 802.11ax signals.
        ///    For 80 MHz + 80 MHz transmission of 802.11ac or 802.11ax signals, set this attribute to 2 and the    NIWLANG_CHANNEL_BANDWIDTH attribute to 80 MHz.
        ///    The default value is 1.
        ///    Set Function: niWLANG_SetNumberOfSegments
        ///    Get Function: niWLANG_GetNumberOfSegments
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetNumberOfSegments(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.NumberOfSegments, channel, out value);
        }

        //#define NIWLANG_NUMBER_OF_SPACE_TIME_STREAMS				0x4C	/*int32*/
        /// <summary>
        ///Specifies the number of space-time streams into which the data is divided.
        ///       If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_SU_PPDU   , use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute to   NIWLANG_VAL_PPDU_TYPE_MU_PPDU, use 'userx' as the active channel string syntax to set this attribute. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_SU_PPDU or NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, use     an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, use     'userx' as the active channel string format to set this attribute. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, or    NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDMthe active string syntax is an empty string. 
        ///    The default value is 1. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, the    valid values are 1 to 4, inclusive. If you set the NIWLANG_STANDARD attribute    to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANG_OFDM_PPDU_TYPE attribute    to NIWLANG_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, the valid values are 1 to 8, inclusive. If    you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_OFDM_PPDU_TYPE attribute to NIWLANG_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, the    valid values are 1 to 4, inclusive. If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_OFDM_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the valid values are 1 to 2, inclusive. If you    set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_OFDM_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the    valid values are 1 to 4, inclusive.
        ///    Set Function: niWLANG_SetNumberOfSpaceTimeStreams
        ///    Get Function: niWLANG_GetNumberOfSpaceTimeStreams
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetNumberOfSpaceTimeStreams(string channel, int value)
        {
            return SetInt32(niWLANGProperties.NumberOfSpaceTimeStreams, channel, value);
        }

        /// <summary>
        ///Specifies the number of space-time streams into which the data is divided.
        ///       If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_SU_PPDU   , use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute to   NIWLANG_VAL_PPDU_TYPE_MU_PPDU, use 'userx' as the active channel string syntax to set this attribute. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_SU_PPDU or NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, use     an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, use     'userx' as the active channel string format to set this attribute. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, or    NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDMthe active string syntax is an empty string. 
        ///    The default value is 1. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, the    valid values are 1 to 4, inclusive. If you set the NIWLANG_STANDARD attribute    to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANG_OFDM_PPDU_TYPE attribute    to NIWLANG_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, the valid values are 1 to 8, inclusive. If    you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_OFDM_PPDU_TYPE attribute to NIWLANG_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, the    valid values are 1 to 4, inclusive. If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_OFDM_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the valid values are 1 to 2, inclusive. If you    set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_OFDM_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the    valid values are 1 to 4, inclusive.
        ///    Set Function: niWLANG_SetNumberOfSpaceTimeStreams
        ///    Get Function: niWLANG_GetNumberOfSpaceTimeStreams
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetNumberOfSpaceTimeStreams(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.NumberOfSpaceTimeStreams, channel, out value);
        }

        //#define NIWLANG_STBC_ALL_STREAMS_ENABLED					0x4D	/*int32*/
        /// <summary>
        ///Specifies whether space-time block coding (STBC) is performed at the transmitter when the NIWLANG_STANDARD   attribute is set to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.    Whenever STBC is performed, the number of space-time streams is equal to two times the number of spatial streams.
        ///    The default value is NIWLANG_VAL_FALSE. 
        ///    Set Function: niWLANG_SetSTBCAllStreamsEnabled
        ///    Get Function: niWLANG_GetSTBCAllStreamsEnabled
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetStbcAllStreamsEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.StbcAllStreamsEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether space-time block coding (STBC) is performed at the transmitter when the NIWLANG_STANDARD   attribute is set to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.    Whenever STBC is performed, the number of space-time streams is equal to two times the number of spatial streams.
        ///    The default value is NIWLANG_VAL_FALSE. 
        ///    Set Function: niWLANG_SetSTBCAllStreamsEnabled
        ///    Get Function: niWLANG_GetSTBCAllStreamsEnabled
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetStbcAllStreamsEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.StbcAllStreamsEnabled, channel, out value);
        }

        //define NIWLANG_SWAP_I_AND_Q_ENABLED						0x4E	/*int32*/
        /// <summary>
        ///Specifies whether to swap the data in the I and Q streams. 
        ///    The default value is NIWLANG_VAL_FALSE. 
        ///    Set Function: niWLANG_SetSwapIAndQEnabled
        ///    Get Function: niWLANG_GetSwapIAndQEnabled
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetSwapIAndQEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.SwapIAndQEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to swap the data in the I and Q streams. 
        ///    The default value is NIWLANG_VAL_FALSE. 
        ///    Set Function: niWLANG_SetSwapIAndQEnabled
        ///    Get Function: niWLANG_GetSwapIAndQEnabled
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetSwapIAndQEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.SwapIAndQEnabled, channel, out value);
        }

        //#define NIWLANG_SAMPLE_CLOCK_RATE_FACTOR					0x6B	/*float64*/
        /// <summary>
        ///Specifies the factor by which the Sample Clock rate is multiplied to generate a signal that is compressed in the    frequency domain and expanded in the time domain.
        ///    For example, a 40 MHz 802.11n signal can be compressed in the frequency domain to 20 MHz, if the Sample Clock rate is reduced to half.   In this case, you must set this attribute to 0.5 to generate the signal.
        ///    The default value is 1. Valid values are 0.001 to 1, inclusive.
        ///    Set Function: niWLANG_SetSampleClockRateFactor
        ///    Get Function: niWLANG_GetSampleClockRateFactor
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetSampleClockRateFactor(string channel, double value)
        {
            return SetDouble(niWLANGProperties.SampleClockRateFactor, channel, value);
        }

        /// <summary>
        ///Specifies the factor by which the Sample Clock rate is multiplied to generate a signal that is compressed in the    frequency domain and expanded in the time domain.
        ///    For example, a 40 MHz 802.11n signal can be compressed in the frequency domain to 20 MHz, if the Sample Clock rate is reduced to half.   In this case, you must set this attribute to 0.5 to generate the signal.
        ///    The default value is 1. Valid values are 0.001 to 1, inclusive.
        ///    Set Function: niWLANG_SetSampleClockRateFactor
        ///    Get Function: niWLANG_GetSampleClockRateFactor
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetSampleClockRateFactor(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.SampleClockRateFactor, channel, out value);
        }

        //#define NIWLANG_OFDM_LEGACY_SCALING_ENABLED					0x65	/*int32*/
        /// <summary>
        ///Specifies whether to enable standard-defined transmit chain scaling of the legacy part of the high throughput (HT) and very high throughput (VHT) frames.
        ///    Note: Configure this attribute only when you set  the NIWLANG_STANDARD attribute to  NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM.
        ///    Note: The toolkit ignores the NIWLANG_OFDM_LEGACY_SCALING_ENABLED attribute for all other standards.
        ///    Note: This attribute is available only when you set the toolkit compatibility version parameter    of the niWLANG_OpenSession function to NIWLANG_VAL_COMPATIBILITY_VERSION_020000 or NIWLANG_VAL_COMPATIBILITY_VERSION_030000. 
        ///    The default value is NIWLANG_VAL_TRUE.
        ///    Set Function: niWLANG_SetOFDMLegacyScalingEnabled
        ///    Get Function: niWLANG_GetOFDMLegacyScalingEnabled
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        [Obsolete]
        public int SetOfdmLegacyScalingEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.OfdmLegacyScalingEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable standard-defined transmit chain scaling of the legacy part of the high throughput (HT) and very high throughput (VHT) frames.
        ///    Note: Configure this attribute only when you set  the NIWLANG_STANDARD attribute to  NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM.
        ///    Note: The toolkit ignores the NIWLANG_OFDM_LEGACY_SCALING_ENABLED attribute for all other standards.
        ///    Note: This attribute is available only when you set the toolkit compatibility version parameter    of the niWLANG_OpenSession function to NIWLANG_VAL_COMPATIBILITY_VERSION_020000 or NIWLANG_VAL_COMPATIBILITY_VERSION_030000. 
        ///    The default value is NIWLANG_VAL_TRUE.
        ///    Set Function: niWLANG_SetOFDMLegacyScalingEnabled
        ///    Get Function: niWLANG_GetOFDMLegacyScalingEnabled
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        [Obsolete]
        public int GetOfdmLegacyScalingEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.OfdmLegacyScalingEnabled, channel, out value);
        }


        #endregion

        #region Version 4.1

        /// <summary>
        ///Specifies the type of physical layer convergence procedure (PLCP) protocol data    unit (PPDU), if the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.   The default value is NIWLANG_VAL_PPDU_TYPE_SU_PPDU. 
        ///    Set Function: niWLANG_SetPPDUType
        ///    Get Function: niWLANG_GetPPDUType
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetPPDUType(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.PpduType, channelString, value);
        }

        /// <summary>
        ///Specifies the type of physical layer convergence procedure (PLCP) protocol data    unit (PPDU), if the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM.   The default value is NIWLANG_VAL_PPDU_TYPE_SU_PPDU. 
        ///    Set Function: niWLANG_SetPPDUType
        ///    Get Function: niWLANG_GetPPDUType
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetPPDUType(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.PpduType, channelString,out value);
        }

        /// <summary>
        ///Specifies the number of users in a multi-user (MU) physical layer convergence procedure (PLCP) protocol data unit (PPDU).     The default value is 1. 
        ///    You can set this attribute only when you set the NIWLANG_STANDARD attribute    to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU, or when you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU.
        ///    Get Function: niWLANG_GetNumberOfUsers
        ///     Set Function: niWLANG_SetNumberOfUsers
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="mappingMatrixType"></param>
        /// <returns></returns>
        public int SetNumberOfUsers(string channelString, int mappingMatrixType)
        {
            return SetInt32(niWLANGProperties.NumberOfUsers, channelString, mappingMatrixType);
        }

        /// <summary>
        ///Specifies the number of users in a multi-user (MU) physical layer convergence procedure (PLCP) protocol data unit (PPDU).     The default value is 1. 
        ///    You can set this attribute only when you set the NIWLANG_STANDARD attribute    to NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU, or when you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU.
        ///    Get Function: niWLANG_GetNumberOfUsers
        ///     Set Function: niWLANG_SetNumberOfUsers
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNumberOfUsers(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.NumberOfUsers, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to enable RF blanking. 
        ///    Set this attribute to NIWLANG_VAL_TRUE, if you want to attenuate the RF OUT signal during the idle interval.    This behavior prevents any DC leakage from the local oscillator of the signal generator from appearing at the RF OUT signal. 
        ///    RF blanking attenuates the RF OUT signal of signal generators quickly. 
        ///    For more details about RF blanking, refer to    the NIWLANG_BURST_START_LOCATIONS attribute, the NIWLANG_BURST_STOP_LOCATIONS attribute, the niWLANG_RFSGCreateAndDownloadWaveform function,    and the niWLANG_RFSGConfigureScript function. 
        ///    The default value is NIWLANG_VAL_FALSE. 
        ///    Set Function: niWLANG_SetRFBlankingEnabled
        ///    Get Function: niWLANG_GetRFBlankingEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetRFBlankingEnabled(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.RfBlankingEnabled, channelString,value);
        }

        /// <summary>
        ///Specifies whether to enable RF blanking. 
        ///    Set this attribute to NIWLANG_VAL_TRUE, if you want to attenuate the RF OUT signal during the idle interval.    This behavior prevents any DC leakage from the local oscillator of the signal generator from appearing at the RF OUT signal. 
        ///    RF blanking attenuates the RF OUT signal of signal generators quickly. 
        ///    For more details about RF blanking, refer to    the NIWLANG_BURST_START_LOCATIONS attribute, the NIWLANG_BURST_STOP_LOCATIONS attribute, the niWLANG_RFSGCreateAndDownloadWaveform function,    and the niWLANG_RFSGConfigureScript function. 
        ///    The default value is NIWLANG_VAL_FALSE. 
        ///    Set Function: niWLANG_SetRFBlankingEnabled
        ///    Get Function: niWLANG_GetRFBlankingEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRFBlankingEnabled(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.RfBlankingEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to enable configuration for sharing of local oscillator (LO) signal for multiple NI RF vector    signal generators and NI RF vector signal transceivers, or both. This attribute is queried as    part of the niWLANG_RFSGConfigureMultipleDeviceSynchronization function.
        ///    The default value is NIWLANG_VAL_FALSE. 
        ///    Set Function: niWLANG_SetLOSharingEnabled
        ///    Get Function: niWLANG_GetLOSharingEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetLOSharingEnabled(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.LoSharingEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether to enable configuration for sharing of local oscillator (LO) signal for multiple NI RF vector    signal generators and NI RF vector signal transceivers, or both. This attribute is queried as    part of the niWLANG_RFSGConfigureMultipleDeviceSynchronization function.
        ///    The default value is NIWLANG_VAL_FALSE. 
        ///    Set Function: niWLANG_SetLOSharingEnabled
        ///    Get Function: niWLANG_GetLOSharingEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetLOSharingEnabled(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.LoSharingEnabled, channelString,out value);
        }

        /// <summary>
        ///Returns the array of sample positions of marker events, which are used to toggle the state of RF blanking, within the waveform.    The marker positions are such that RF blanking is enabled during the idle interval. This attribute is applicable only if the NIWLANG_RF_BLANKING_ENABLED    attribute is set to NIWLANG_VAL_TRUE. This attribute is read by the niWLANG_RFSGCreateandDownloadWaveform function to store RF blanking    marker positions in the RFSG database.
        ///    Get Function: niWLANG_GetRFBlankingMarkerPositions
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetRFBlankingMarkerPositions(string channelString, int[] dataArray, int dataArraySize, out  int actualNumDataArrayElements)
        {
            return GetVectorAttributeI32(channelString, niWLANGProperties.RfBlankingMarkerPositions, dataArray, dataArraySize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the number of symbols in the data portion of the generated WLAN frame. Symbol refers    to the chip if the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211BG_DSSS, and the    symbol refers to the OFDM symbol for other values of the NIWLANG_STANDARD attribute.
        ///    Set Function: niWLANG_SetNumberOfDataSymbols
        ///    Get Function: niWLANG_GetNumberOfDataSymbols
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNumberOfDataSymbols(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.NumberOfDataSymbols, channelString, value);
        }

        /// <summary>
        ///Returns the number of symbols in the data portion of the generated WLAN frame. Symbol refers    to the chip if the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211BG_DSSS, and the    symbol refers to the OFDM symbol for other values of the NIWLANG_STANDARD attribute.
        ///    Set Function: niWLANG_SetNumberOfDataSymbols
        ///    Get Function: niWLANG_GetNumberOfDataSymbols
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNumberOfDataSymbols(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.NumberOfDataSymbols, channelString,out value);
        }

        #endregion

        /// <summary>
        /// Specifies the physical layer convergence protocol (PLCP) frame structure to use.     The frame structure determines the arrangement of preambles, header (SIGnal field),     and payload in a frame as defined in section 20.3.2 of IEEE Standard 802.11n-2009.
        ///      Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE 802.11a/b/g/n     license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is NIWLANG_VAL_80211N_PLCP_FRAME_FORMAT_MIXED.    
        /// 
        /// </summary>
        public int Set_80211nPlcpFrameFormat(string channel, int value)
        {
            return SetInt32(niWLANGProperties._80211nPlcpFrameFormat, channel, value);
        }

        /// <summary>
        /// Specifies the physical layer convergence protocol (PLCP) frame structure to use.     The frame structure determines the arrangement of preambles, header (SIGnal field),     and payload in a frame as defined in section 20.3.2 of IEEE Standard 802.11n-2009.
        ///      Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE 802.11a/b/g/n     license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is NIWLANG_VAL_80211N_PLCP_FRAME_FORMAT_MIXED.    
        /// 
        /// </summary>
        public int Get_80211nPlcpFrameFormat(string channel, out int value)
        {
            return GetInt32(niWLANGProperties._80211nPlcpFrameFormat, channel, out value);
        }
        /// <summary>
        /// Specifies the carrier frequency, in hertz (Hz), for signal generation.
        ///    The default value is 2.412G.        
        /// 
        /// </summary>
        public int SetCarrierFrequency(string channel, double value)
        {
            return SetDouble(niWLANGProperties.CarrierFrequency, channel, value);
        }
        /// <summary>
        /// Specifies the carrier frequency, in hertz (Hz), for signal generation.
        ///    The default value is 2.412G.        
        /// 
        /// </summary>
        public int GetCarrierFrequency(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.CarrierFrequency, channel, out value);
        }
        /// <summary>
        /// Specifies the offset, in hertz (Hz), from the value you    specify in the NIWLANG_CARRIER_FREQUENCY attribute.
        ///    The default value is 0.        
        /// 
        /// </summary>
        public int SetCarrierFrequencyOffset(string channel, double value)
        {
            return SetDouble(niWLANGProperties.CarrierFrequencyOffset, channel, value);
        }
        /// <summary>
        /// Specifies the offset, in hertz (Hz), from the value you    specify in the NIWLANG_CARRIER_FREQUENCY attribute.
        ///    The default value is 0.        
        /// 
        /// </summary>
        public int GetCarrierFrequencyOffset(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.CarrierFrequencyOffset, channel, out value);
        }
        /// <summary>
        /// Specifies the channel width, in hertz (Hz), used for transmitting the signal as defined in section 20.2.3 of    IEEE Standard 802.11n-2009. For orthogonal frequency division multiplexing (OFDM) signals, channel bandwidth determines    the number of pilot and data subcarriers used.
        ///     Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE 802.11a/b/g/n     license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 20M. Valid values are 20M and 40M.   
        /// 
        /// </summary>
        public int SetChannelBandwidth(string channel, double value)
        {
            return SetDouble(niWLANGProperties.ChannelBandwidth, channel, value);
        }
        /// <summary>
        /// Specifies the channel width, in hertz (Hz), used for transmitting the signal as defined in section 20.2.3 of    IEEE Standard 802.11n-2009. For orthogonal frequency division multiplexing (OFDM) signals, channel bandwidth determines    the number of pilot and data subcarriers used.
        ///     Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE 802.11a/b/g/n     license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 20M. Valid values are 20M and 40M.   
        /// 
        /// </summary>
        public int GetChannelBandwidth(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.ChannelBandwidth, channel, out value);
        }
        /// <summary>
        /// Returns the WLAN Generation Toolkit version in use.  
        /// 
        /// </summary>
        public int GetCompatibilityVersion(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.CompatibilityVersion, channel, out value);
        }
        /// <summary>
        /// Specifies the data rate, in Mbps, for the direct sequence spread spectrum (DSSS) payload, as defined in    IEEE Standard 802.11b-1999 and the extended rate physical layer-packet binary convolutional coding (ERP -PBCC) mode in IEEE Standard    802.11g-2003.
        ///     This attribute is not applicable when the standard parameter of the niWLANG_SetStandard function is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///    The default value is NIWLANG_VAL_DSSS_DATA_RATE_1.   
        /// 
        /// </summary>
        public int SetDsssDataRate(string channel, int value)
        {
            return SetInt32(niWLANGProperties.DsssDataRate, channel, value);
        }
        /// <summary>
        /// Specifies the data rate, in Mbps, for the direct sequence spread spectrum (DSSS) payload, as defined in    IEEE Standard 802.11b-1999 and the extended rate physical layer-packet binary convolutional coding (ERP -PBCC) mode in IEEE Standard    802.11g-2003.
        ///     This attribute is not applicable when the standard parameter of the niWLANG_SetStandard function is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///    The default value is NIWLANG_VAL_DSSS_DATA_RATE_1.   
        /// 
        /// </summary>
        public int GetDsssDataRate(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.DsssDataRate, channel, out value);
        }
        /// <summary>
        /// Specifies whether to use a long or short preamble for    direct sequence spread spectrum (DSSS) and DSSS-orthogonal frequency division multiplexing (DSSS-OFDM) packets as defined in IEEE Standard 802.11b-1999.
        ///     This attribute is not applicable when the standard parameter of the niWLANG_SetStandard function is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is NIWLANG_VAL_PREAMBLE_TYPE_LONG_PREAMBLE.    
        /// 
        /// </summary>
        public int SetDsssPreambleType(string channel, int value)
        {
            return SetInt32(niWLANGProperties.DsssPreambleType, channel, value);
        }
        /// <summary>
        /// Specifies whether to use a long or short preamble for    direct sequence spread spectrum (DSSS) and DSSS-orthogonal frequency division multiplexing (DSSS-OFDM) packets as defined in IEEE Standard 802.11b-1999.
        ///     This attribute is not applicable when the standard parameter of the niWLANG_SetStandard function is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is NIWLANG_VAL_PREAMBLE_TYPE_LONG_PREAMBLE.    
        /// 
        /// </summary>
        public int GetDsssPreambleType(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.DsssPreambleType, channel, out value);
        }
        /// <summary>
        /// Specifies the length of the cyclic prefix (CP), in seconds, of an orthogonal frequency division     multiplexing (OFDM) symbol as specified in section 20.1.1 of IEEE Standard 802.11n-2009.
        ///     The guard interval can be 800 nanoseconds (long) or 400 nanoseconds (short).
        ///     Note: The toolkit does not support Short guard interval if the modulation and coding scheme (MCS)     index is 0-7 and the physical layer convergence protocol (PLCP)frame format is Greenfield format.
        ///     Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE     802.11a/b/g/n license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 800n. Valid values are 400n and 800n.     
        /// 
        /// </summary>
        [Obsolete("Use SetOfdmGuardIntervalType()")]
        public int SetGuardInterval(string channel, double value)
        {
            return SetDouble(niWLANGProperties.GuardInterval, channel, value);
        }
        /// <summary>
        /// Specifies the length of the cyclic prefix (CP), in seconds, of an orthogonal frequency division     multiplexing (OFDM) symbol as specified in section 20.1.1 of IEEE Standard 802.11n-2009.
        ///     The guard interval can be 800 nanoseconds (long) or 400 nanoseconds (short).
        ///     Note: The toolkit does not support Short guard interval if the modulation and coding scheme (MCS)     index is 0-7 and the physical layer convergence protocol (PLCP)frame format is Greenfield format.
        ///     Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE     802.11a/b/g/n license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 800n. Valid values are 400n and 800n.     
        /// 
        /// </summary>
        [Obsolete("Use GetOfdmGuardIntervalType()")]
        public int GetGuardInterval(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.GuardInterval, channel, out value);
        }
        /// <summary>
        /// Specifies whether to enable convolutional encoding of the orthogonal frequency division multiplexing (OFDM) SIGNAL field,    as defined in section 17.3.5.5 of IEEE Standard 802.11a-1999.
        ///     Note: The toolkit ignores this property if the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211BG_DSSS.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    the toolkit always sets the NIWLANG_HEADER_ENCODER_ENABLED attribute to NIWLANG_VAL_TRUE. 
        ///     The default value is NIWLANG_VAL_TRUE.        
        /// 
        /// </summary>
        public int SetHeaderEncoderEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.HeaderEncoderEnabled, channel, value);
        }
        /// <summary>
        /// Specifies whether to enable convolutional encoding of the orthogonal frequency division multiplexing (OFDM) SIGNAL field,    as defined in section 17.3.5.5 of IEEE Standard 802.11a-1999.
        ///     Note: The toolkit ignores this property if the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211BG_DSSS.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    the toolkit always sets the NIWLANG_HEADER_ENCODER_ENABLED attribute to NIWLANG_VAL_TRUE. 
        ///     The default value is NIWLANG_VAL_TRUE.        
        /// 
        /// </summary>
        public int GetHeaderEncoderEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.HeaderEncoderEnabled, channel, out value);
        }
        /// <summary>
        /// Specifies whether to enable interleaving for the orthogonal frequency division multiplexing (OFDM) SIGNAL field, as    defined in section 17.3.5.6 of IEEE Standard 802.11a-1999.
        /// 
        /// </summary>
        public int SetHeaderInterleaverEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.HeaderInterleaverEnabled, channel, value);
        }
        /// <summary>
        /// Specifies whether to enable interleaving for the orthogonal frequency division multiplexing (OFDM) SIGNAL field, as    defined in section 17.3.5.6 of IEEE Standard 802.11a-1999.
        /// 
        /// </summary>
        public int GetHeaderInterleaverEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.HeaderInterleaverEnabled, channel, out value);
        }
        /// <summary>
        /// Specifies the value of the DC offset in the in-phase (I) channel as    a percentage of the root mean square (RMS) magnitude of the unaltered I channel.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,     you must use an active channel string to configure the NIWLANG_I_DC_OFFSET attribute.
        ///    The default value is 0. Valid values are -100 to +100, inclusive.        
        /// 
        /// </summary>
        public int SetIDcOffset(string channel, double value)
        {
            return SetDouble(niWLANGProperties.IDcOffset, channel, value);
        }
        /// <summary>
        /// Specifies the value of the DC offset in the in-phase (I) channel as    a percentage of the root mean square (RMS) magnitude of the unaltered I channel.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,     you must use an active channel string to configure the NIWLANG_I_DC_OFFSET attribute.
        ///    The default value is 0. Valid values are -100 to +100, inclusive.        
        /// 
        /// </summary>
        public int GetIDcOffset(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.IDcOffset, channel, out value);
        }
        /// <summary>
        /// Specifies the interframe spacing, in seconds, for signal generation.    In the generated waveform, the toolkit places half of the interframe spacing on    either side of the burst. The waveform contains zeros for    the duration of the interframe spacing.
        ///    The default value is 100&#181;. Valid values are 0 to 1, inclusive.
        ///     Note: For higher value of idle interval, LabVIEW may run out of memory.        
        /// 
        /// </summary>
        public int SetIdleInterval(string channel, double value)
        {
            return SetDouble(niWLANGProperties.IdleInterval, channel, value);
        }
        /// <summary>
        /// Specifies the interframe spacing, in seconds, for signal generation.    In the generated waveform, the toolkit places half of the interframe spacing on    either side of the burst. The waveform contains zeros for    the duration of the interframe spacing.
        ///    The default value is 100&#181;. Valid values are 0 to 1, inclusive.
        ///     Note: For higher value of idle interval, LabVIEW may run out of memory.        
        /// 
        /// </summary>
        public int GetIdleInterval(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.IdleInterval, channel, out value);
        }
        /// <summary>
        /// Specifies the ratio, in dB, of the mean amplitude of the in-phase (I)    channel to the mean amplitude of the quadrature-phase (Q) channel.
        ///     Note: If this attribute is set to a large value, there may be loss of dynamic range at the D/A converter (DAC).
        ///     I/Q gain imbalance follows the definition
        ///     Real(output) = Real(input) - Gs * Imag(input)
        ///     Imag(output) = Gc * Imag(input)
        ///     where
        ///     Gs = G * sin(Q) and
        ///     Gc = G * cos(Q) 
        ///     where G is the I/Q gain imbalance and Q is the quadrature skew.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,     you must use an active channel string to configure the NIWLANG_IQ_GAIN_IMBALANCE attribute.
        ///     The default value is 0. Valid values are -6 to +6, inclusive.        
        /// 
        /// </summary>
        public int SetIqGainImbalance(string channel, double value)
        {
            return SetDouble(niWLANGProperties.IqGainImbalance, channel, value);
        }
        /// <summary>
        /// Specifies the ratio, in dB, of the mean amplitude of the in-phase (I)    channel to the mean amplitude of the quadrature-phase (Q) channel.
        ///     Note: If this attribute is set to a large value, there may be loss of dynamic range at the D/A converter (DAC).
        ///     I/Q gain imbalance follows the definition
        ///     Real(output) = Real(input) - Gs * Imag(input)
        ///     Imag(output) = Gc * Imag(input)
        ///     where
        ///     Gs = G * sin(Q) and
        ///     Gc = G * cos(Q) 
        ///     where G is the I/Q gain imbalance and Q is the quadrature skew.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,     you must use an active channel string to configure the NIWLANG_IQ_GAIN_IMBALANCE attribute.
        ///     The default value is 0. Valid values are -6 to +6, inclusive.        
        /// 
        /// </summary>
        public int GetIqGainImbalance(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.IqGainImbalance, channel, out value);
        }
        /// <summary>
        /// Returns the number of samples in each frame, including the interframe spacing.    
        /// 
        /// </summary>
        public int GetIqWaveformSize(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.IqWaveformSize, channel, out value);
        }
        /// <summary>
        /// Specifies whether to enable the locked clock bit flag for the direct sequence spread spectrum (DSSS) header, as    defined in sections 18.2.3.4 and 18.2.3.11 of IEEE Standard 802.11b-1999.
        ///     Note: You must set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211BG_DSSS     or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM to use this attribute.
        ///     The default value is NIWLANG_VAL_FALSE.   
        /// 
        /// </summary>
        public int SetLockedClockBitEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.LockedClockBitEnabled, channel, value);
        }
        /// <summary>
        /// Specifies whether to enable the locked clock bit flag for the direct sequence spread spectrum (DSSS) header, as    defined in sections 18.2.3.4 and 18.2.3.11 of IEEE Standard 802.11b-1999.
        ///     Note: You must set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211BG_DSSS     or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM to use this attribute.
        ///     The default value is NIWLANG_VAL_FALSE.   
        /// 
        /// </summary>
        public int GetLockedClockBitEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.LockedClockBitEnabled, channel, out value);
        }
        /// <summary>
        /// Specifies whether to enable the medium access control (MAC) header,     as defined in section 7.1.2 of IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999,    and IEEE Standard 802.11g-2003. If the header is enabled, only the frame checksum (FCS) is computed, as described in the    NIWLANG_PAYLOAD_DATA_LENGTH attribute. Other fields are always set to 0.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    the toolkit always sets the NIWLANG_MAC_HEADER_ENABLED attribute to NIWLANG_VAL_TRUE. 
        ///     The default value is NIWLANG_VAL_TRUE.  
        /// 
        /// </summary>
        public int SetMacHeaderEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacHeaderEnabled, channel, value);
        }
        /// <summary>
        /// Specifies whether to enable the medium access control (MAC) header,     as defined in section 7.1.2 of IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999,    and IEEE Standard 802.11g-2003. If the header is enabled, only the frame checksum (FCS) is computed, as described in the    NIWLANG_PAYLOAD_DATA_LENGTH attribute. Other fields are always set to 0.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    the toolkit always sets the NIWLANG_MAC_HEADER_ENABLED attribute to NIWLANG_VAL_TRUE. 
        ///     The default value is NIWLANG_VAL_TRUE.  
        /// 
        /// </summary>
        public int GetMacHeaderEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacHeaderEnabled, channel, out value);
        }
        /// <summary>
        /// Specifies the mapping matrix type for mapping spatial streams to transmit channels as specified in section 20.3.11.10.1 of IEEE Standard 802.11n-2009.
        ///      Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE 802.11a/b/g/n     license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///    The default value is NIWLANG_VAL_MAPPING_MATRIX_TYPE_DIRECT.  
        /// 
        /// </summary>
        public int SetMappingMatrixType(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MappingMatrixType, channel, value);
        }
        /// <summary>
        /// Specifies the mapping matrix type for mapping spatial streams to transmit channels as specified in section 20.3.11.10.1 of IEEE Standard 802.11n-2009.
        ///      Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE 802.11a/b/g/n     license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///    The default value is NIWLANG_VAL_MAPPING_MATRIX_TYPE_DIRECT.  
        /// 
        /// </summary>
        public int GetMappingMatrixType(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MappingMatrixType, channel, out value);
        }
        /// <summary>
        /// Specifies the maximum peak-to-average power ratio (PAPR), in dB, allowed in the signal to be generated.     The toolkit clips any portion of the signal that exceeds the peak power corresponding to this value.     The toolkit uses this value to configure the peak power of the generation hardware.
        ///     Note: If you specify a value that is more than the actual peak-to-average power ratio of the signal, there is loss of     dynamic range of the D/A converter (DAC). If you specify a value that is less than the actual peak-to-average     power ratio of the signal, the toolkit clips the generated signal.
        ///     Note: The toolkit uses the Maximum Expected PAPR property to compute the peak power.     In version 1.0, the toolkit internally computes the PAPR, which was a read-only property.     The change ensures that the average power level of the burst is steady across the frames.
        ///     If you set the standard parameter of the niWLANG_SetStandard function to     NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, you must use an active channel string to    configure this attribute.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211BG_DSSS, the default value is 5. Otherwise, the default value is 12. 
        /// 
        /// </summary>
        [Obsolete]
        public int SetMaxExpectedPapr(string channel, double value)
        {
            return SetDouble(niWLANGProperties.MaxExpectedPapr, channel, value);
        }
        /// <summary>
        /// Specifies the maximum peak-to-average power ratio (PAPR), in dB, allowed in the signal to be generated.     The toolkit clips any portion of the signal that exceeds the peak power corresponding to this value.     The toolkit uses this value to configure the peak power of the generation hardware.
        ///     Note: If you specify a value that is more than the actual peak-to-average power ratio of the signal, there is loss of     dynamic range of the D/A converter (DAC). If you specify a value that is less than the actual peak-to-average     power ratio of the signal, the toolkit clips the generated signal.
        ///     Note: The toolkit uses the Maximum Expected PAPR property to compute the peak power.     In version 1.0, the toolkit internally computes the PAPR, which was a read-only property.     The change ensures that the average power level of the burst is steady across the frames.
        ///     If you set the standard parameter of the niWLANG_SetStandard function to     NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, you must use an active channel string to    configure this attribute.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211BG_DSSS, the default value is 5. Otherwise, the default value is 12. 
        /// 
        /// </summary>
        [Obsolete]
        public int GetMaxExpectedPapr(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.MaxExpectedPapr, channel, out value);
        }
        /// <summary>
        /// Specifies the value of the modulation and coding scheme (MCS) index.    The MCS index is a compact representation that determines the modulation scheme, coding rate,    and number of spatial streams as specified in section 20.3.5 of IEEE Standard 802.11n-2009.
        ///      Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE     802.11a/b/g/n license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 0. Valid values are 0 to 31, inclusive. 
        /// 
        /// </summary>
        public int SetMcsIndex(string channel, int value)
        {
            return SetInt32(niWLANGProperties.McsIndex, channel, value);
        }
        /// <summary>
        /// Specifies the value of the modulation and coding scheme (MCS) index.    The MCS index is a compact representation that determines the modulation scheme, coding rate,    and number of spatial streams as specified in section 20.3.5 of IEEE Standard 802.11n-2009.
        ///      Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE     802.11a/b/g/n license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 0. Valid values are 0 to 31, inclusive. 
        /// 
        /// </summary>
        public int GetMcsIndex(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.McsIndex, channel, out value);
        }
        /// <summary>
        /// Specifies the number of extension spatial streams (N_ESS) as defined in section 20.3.9.4.6 of IEEE Standard 802.11n-2009.
        ///     The value of N_ESS follows the definition N_SS + N_ESS &#60;= N_Tx
        ///      where N_SS is the number of spatial streams that is determined by the MCS index and N_Tx     is the number of transmit channels specified by the NIWLANG_NUMBER_OF_TRANSMIT_CHANNELS attribute.
        ///      Note: N_TX must be greater than or equal to N_SS.
        ///     Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE 802.11a/b/g/n     license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 0. Valid values are 0 to 3.       
        /// 
        /// </summary>
        public int SetNumberOfExtensionSpatialStreams(string channel, int value)
        {
            return SetInt32(niWLANGProperties.NumberOfExtensionSpatialStreams, channel, value);
        }
        /// <summary>
        /// Specifies the number of extension spatial streams (N_ESS) as defined in section 20.3.9.4.6 of IEEE Standard 802.11n-2009.
        ///     The value of N_ESS follows the definition N_SS + N_ESS &#60;= N_Tx
        ///      where N_SS is the number of spatial streams that is determined by the MCS index and N_Tx     is the number of transmit channels specified by the NIWLANG_NUMBER_OF_TRANSMIT_CHANNELS attribute.
        ///      Note: N_TX must be greater than or equal to N_SS.
        ///     Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE 802.11a/b/g/n     license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 0. Valid values are 0 to 3.       
        /// 
        /// </summary>
        public int GetNumberOfExtensionSpatialStreams(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.NumberOfExtensionSpatialStreams, channel, out value);
        }
        /// <summary>
        /// Specifies the number of frames to generate. Each iteration of the    niWLANG_CreateWaveformComplexF64 or niWLANG_CreateMIMOWaveformsComplexF64 function generates only    one frame along with the idle interval you specify using the    NIWLANG_IDLE_INTERVAL attribute.
        ///    If you set the NIWLANG_NUMBER_OF_FRAMES attribute to a value greater than 1, create a while loop around the    niWLANG_CreateWaveformComplexF64 function and concatenate the output values from different iterations.    If you encounter memory usage issues,    download a single frame to the RF signal generator memory on each    iteration.
        ///     To generate the required number of frames, pass the NIWLANG_NUMBER_OF_FRAMES attribute to the loop iteration     count. You also can use the done parameter on the niWLANG_CreateWaveformComplexF64 or     niWLANG_CreateMIMOWaveformsComplexF64 function as a termination signal.
        ///    You can use the niRFSG_AllocateArbWaveform function to preallocate arb memory    and then download the waveform in chunks.
        ///    The default value is 1.        
        /// 
        /// </summary>
        public int SetNumberOfFrames(string channel, int value)
        {
            return SetInt32(niWLANGProperties.NumberOfFrames, channel, value);
        }
        /// <summary>
        /// Specifies the number of frames to generate. Each iteration of the    niWLANG_CreateWaveformComplexF64 or niWLANG_CreateMIMOWaveformsComplexF64 function generates only    one frame along with the idle interval you specify using the    NIWLANG_IDLE_INTERVAL attribute.
        ///    If you set the NIWLANG_NUMBER_OF_FRAMES attribute to a value greater than 1, create a while loop around the    niWLANG_CreateWaveformComplexF64 function and concatenate the output values from different iterations.    If you encounter memory usage issues,    download a single frame to the RF signal generator memory on each    iteration.
        ///     To generate the required number of frames, pass the NIWLANG_NUMBER_OF_FRAMES attribute to the loop iteration     count. You also can use the done parameter on the niWLANG_CreateWaveformComplexF64 or     niWLANG_CreateMIMOWaveformsComplexF64 function as a termination signal.
        ///    You can use the niRFSG_AllocateArbWaveform function to preallocate arb memory    and then download the waveform in chunks.
        ///    The default value is 1.        
        /// 
        /// </summary>
        public int GetNumberOfFrames(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.NumberOfFrames, channel, out value);
        }
      /// <summary>
      /// Specifies the number of transmit channels for multiple input multiple output (MIMO) signals as defined in section 20.3.3 of IEEE Standard 802.11n-2009.
      ///     The number of transmit channels must be greater than or equal to the number of spatial streams.     The number of spatial streams is defined by the modulation and coding scheme (MCS) index as specified in IEEE Standard 802.11a-1999.
      ///     Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE 802.11a/b/g/n     license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
      ///     The default value is 1. Valid values are 1 to 4, inclusive.   
      /// 
      /// </summary>
      public int GetNumberOfTransmitChannels(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.NumberOfTransmitChannels, channel, out value);
        }
        /// <summary>
        /// Specifies the number of transmit channels for multiple input multiple output (MIMO) signals as defined in section 20.3.3 of IEEE Standard 802.11n-2009.
        ///     The number of transmit channels must be greater than or equal to the number of spatial streams.     The number of spatial streams is defined by the modulation and coding scheme (MCS) index as specified in IEEE Standard 802.11a-1999.
        ///     Note: To use this attribute, you must have the NI WLAN Generation Toolkit for IEEE 802.11a/b/g/n     license and set the standard parameter of the niWLANG_SetStandard function to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 1. Valid values are 1 to 4, inclusive.   
        /// 
        /// </summary>
        public int SetNumberOfTransmitChannels(string channel, int value)
        {
            return SetInt32(niWLANGProperties.NumberOfTransmitChannels, channel, value);
        }
        /// <summary>
        /// Specifies the data rate, in Mbps, for the orthogonal frequency division multiplexing (OFDM) payload, as defined in    section 17.3.2.2 of IEEE Standard 802.11a-1999.
        ///     This attribute is not applicable when the standard parameter of the niWLANG_SetStandard     function is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM. In this     case, set the NIWLANG_MCS_INDEX, NIWLANG_GUARD_INTERVAL , and NIWLANG_CHANNEL_BANDWIDTH     attributes and the toolkit internally computes the appropriate data    rates using niWLANG_SetMCSIndex function as described in section 20.6 of IEEE Standard 802.11n-2009.
        ///    The default value is NIWLANG_VAL_OFDM_DATA_RATE_6.  
        /// 
        /// </summary>
        public int SetOfdmDataRate(string channel, int value)
        {
            return SetInt32(niWLANGProperties.OfdmDataRate, channel, value);
        }
        /// <summary>
        /// Specifies the data rate, in Mbps, for the orthogonal frequency division multiplexing (OFDM) payload, as defined in    section 17.3.2.2 of IEEE Standard 802.11a-1999.
        ///     This attribute is not applicable when the standard parameter of the niWLANG_SetStandard     function is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM. In this     case, set the NIWLANG_MCS_INDEX, NIWLANG_GUARD_INTERVAL , and NIWLANG_CHANNEL_BANDWIDTH     attributes and the toolkit internally computes the appropriate data    rates using niWLANG_SetMCSIndex function as described in section 20.6 of IEEE Standard 802.11n-2009.
        ///    The default value is NIWLANG_VAL_OFDM_DATA_RATE_6.  
        /// 
        /// </summary>
        public int GetOfdmDataRate(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.OfdmDataRate, channel, out value);
        }
        /// <summary>
        /// Specifies the number of times the toolkit increases the Nyquist sampling    rate to get the final sample rate of the signal.
        ///    The default value is 4.        
        /// 
        /// </summary>
        public int SetOversamplingFactor(string channel, int value)
        {
            return SetInt32(niWLANGProperties.OversamplingFactor, channel, value);
        }
        /// <summary>
        /// Specifies the number of times the toolkit increases the Nyquist sampling    rate to get the final sample rate of the signal.
        ///    The default value is 4.        
        /// 
        /// </summary>
        public int GetOversamplingFactor(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.OversamplingFactor, channel, out value);
        }
        /// <summary>
        /// Specifies length of the payload, in bytes, excluding the length of    the medium access control (MAC) header. The payload length encoded    into the physical layer (PHY) header is the sum of the payload data length and    the length of the MAC header. If the NIWLANG_MAC_HEADER_ENABLED    attribute is enabled, the toolkit extends    the length by 34 bytes. Of the 34 bytes, 30 bytes of zeros are    appended before the PHY payload, and the 4 byte frame checksum (FCS) computed    over the extended payload is appended to the end of the PHY payload, as    described in section 7.1.2 of IEEE Standard 802.11-1999 and section 20.3.9.4 of IEEE Standard 802.11n-2009.
        ///    If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, the default value is 4096. Otherwise, the default value is 1024.    For IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, and IEEE Standard 802.11g-2003, the valid values are 0 to 4095,    inclusive. For IEEE Standard 802.11n-2009, the valid values are 0 to 16,384 (inclusive).        
        /// 
        /// </summary>
        public int SetPayloadDataLength(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PayloadDataLength, channel, value);
        }
        /// <summary>
        /// Specifies length of the payload, in bytes, excluding the length of    the medium access control (MAC) header. The payload length encoded    into the physical layer (PHY) header is the sum of the payload data length and    the length of the MAC header. If the NIWLANG_MAC_HEADER_ENABLED    attribute is enabled, the toolkit extends    the length by 34 bytes. Of the 34 bytes, 30 bytes of zeros are    appended before the PHY payload, and the 4 byte frame checksum (FCS) computed    over the extended payload is appended to the end of the PHY payload, as    described in section 7.1.2 of IEEE Standard 802.11-1999 and section 20.3.9.4 of IEEE Standard 802.11n-2009.
        ///    If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, the default value is 4096. Otherwise, the default value is 1024.    For IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, and IEEE Standard 802.11g-2003, the valid values are 0 to 4095,    inclusive. For IEEE Standard 802.11n-2009, the valid values are 0 to 16,384 (inclusive).        
        /// 
        /// </summary>
        public int GetPayloadDataLength(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadDataLength, channel, out value);
        }
        /// <summary>
        /// Specifies the type of payload for waveform generation.
        ///    The default value is NIWLANG_VAL_PN_SEQUENCE.        
        /// 
        /// </summary>
        public int SetPayloadDataType(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PayloadDataType, channel, value);
        }
        /// <summary>
        /// Specifies the type of payload for waveform generation.
        ///    The default value is NIWLANG_VAL_PN_SEQUENCE.        
        /// 
        /// </summary>
        public int GetPayloadDataType(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadDataType, channel, out value);
        }
        /// <summary>
        /// Specifies whether to enable convolutional encoding of the orthogonal frequency division multiplexing (OFDM) payload, as defined    in section 17.3.5.5 of IEEE Standard 802.11a-1999.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    the toolkit always sets the NIWLANG_PAYLOAD_ENCODER_ENABLED attribute to NIWLANG_VAL_TRUE. 
        ///     The default value is NIWLANG_VAL_TRUE. 
        /// 
        /// </summary>
        public int SetPayloadEncoderEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PayloadEncoderEnabled, channel, value);
        }
        /// <summary>
        /// Specifies whether to enable convolutional encoding of the orthogonal frequency division multiplexing (OFDM) payload, as defined    in section 17.3.5.5 of IEEE Standard 802.11a-1999.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    the toolkit always sets the NIWLANG_PAYLOAD_ENCODER_ENABLED attribute to NIWLANG_VAL_TRUE. 
        ///     The default value is NIWLANG_VAL_TRUE. 
        /// 
        /// </summary>
        public int GetPayloadEncoderEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadEncoderEnabled, channel, out value);
        }
        /// <summary>
        /// Specifies whether to enable interleaving for the orthogonal frequency division multiplexing (OFDM) payload, as defined    in section 17.3.5.6 of IEEE Standard 802.11a-1999.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    the toolkit always sets the NIWLANG_PAYLOAD_INTERLEAVER_ENABLED attribute to NIWLANG_VAL_TRUE. 
        ///     The default value is NIWLANG_VAL_TRUE. 
        /// 
        /// </summary>
        public int SetPayloadInterleaverEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PayloadInterleaverEnabled, channel, value);
        }
        /// <summary>
        /// Specifies whether to enable interleaving for the orthogonal frequency division multiplexing (OFDM) payload, as defined    in section 17.3.5.6 of IEEE Standard 802.11a-1999.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    the toolkit always sets the NIWLANG_PAYLOAD_INTERLEAVER_ENABLED attribute to NIWLANG_VAL_TRUE. 
        ///     The default value is NIWLANG_VAL_TRUE. 
        /// 
        /// </summary>
        public int GetPayloadInterleaverEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadInterleaverEnabled, channel, out value);
        }
        /// <summary>
        /// Specifies the order (length of memory) of the pseudorandom bit sequence    (PRBS) generator. The generated sequence is repeated (2^PN order)-1    bits. If the NIWLANG_PAYLOAD_DATA_TYPE attribute is set to    NIWLANG_VAL_USER_DEFINED, the    toolkit ignores the NIWLANG_PAYLOAD_PN_ORDER attribute.
        ///    The default value is 9.        
        /// 
        /// </summary>
        public int SetPayloadPnOrder(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PayloadPnOrder, channel, value);
        }
        /// <summary>
        /// Specifies the order (length of memory) of the pseudorandom bit sequence    (PRBS) generator. The generated sequence is repeated (2^PN order)-1    bits. If the NIWLANG_PAYLOAD_DATA_TYPE attribute is set to    NIWLANG_VAL_USER_DEFINED, the    toolkit ignores the NIWLANG_PAYLOAD_PN_ORDER attribute.
        ///    The default value is 9.        
        /// 
        /// </summary>
        public int GetPayloadPnOrder(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadPnOrder, channel, out value);
        }
        /// <summary>
        /// Specifies the initialization seed used for the pseudorandom bit sequence    (PRBS) generator. If the NIWLANG_PAYLOAD_DATA_TYPE attribute is set    to NIWLANG_VAL_USER_DEFINED, the toolkit ignores NIWLANG_PAYLOAD_PN_SEED attribute.
        ///    If you set the NIWLANG_NUMBER_OF_FRAMES attribute to a value    greater than 1 and the reset parameter is set to FALSE in the    niWLANG_CreateWaveformComplexF64 function,    the PRBS generator state at the end of the payload in frame n is used as the seed    for frame n + 1. If the reset parameter is set to TRUE in the    niWLANG_CreateWaveformComplexF64 function,    all frames use the value of the NIWLANG_PAYLOAD_PN_SEED attribute.
        ///    The default value is -1.         
        /// 
        /// </summary>
        public int SetPayloadPnSeed(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PayloadPnSeed, channel, value);
        }
        /// <summary>
        /// Specifies the initialization seed used for the pseudorandom bit sequence    (PRBS) generator. If the NIWLANG_PAYLOAD_DATA_TYPE attribute is set    to NIWLANG_VAL_USER_DEFINED, the toolkit ignores NIWLANG_PAYLOAD_PN_SEED attribute.
        ///    If you set the NIWLANG_NUMBER_OF_FRAMES attribute to a value    greater than 1 and the reset parameter is set to FALSE in the    niWLANG_CreateWaveformComplexF64 function,    the PRBS generator state at the end of the payload in frame n is used as the seed    for frame n + 1. If the reset parameter is set to TRUE in the    niWLANG_CreateWaveformComplexF64 function,    all frames use the value of the NIWLANG_PAYLOAD_PN_SEED attribute.
        ///    The default value is -1.         
        /// 
        /// </summary>
        public int GetPayloadPnSeed(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadPnSeed, channel, out value);
        }
        /// <summary>
        /// Specifies whether to enable scrambling of the payload for orthogonal frequency division multiplexing (OFDM) packets    and the entire burst for direct sequence spread spectrum (DSSS) packets, as defined in section 17.3.5.4    of IEEE Standard 802.11a-1999 and section 18.2.4 of IEEE Standard    802.11a-1999.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    the toolkit always sets the NIWLANG_PAYLOAD_SCRAMBLER_ENABLED attribute to NIWLANG_VAL_TRUE. 
        ///    The default value is NIWLANG_VAL_TRUE.        
        /// 
        /// </summary>
        public int SetPayloadScramblerEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PayloadScramblerEnabled, channel, value);
        }
        /// <summary>
        /// Specifies whether to enable scrambling of the payload for orthogonal frequency division multiplexing (OFDM) packets    and the entire burst for direct sequence spread spectrum (DSSS) packets, as defined in section 17.3.5.4    of IEEE Standard 802.11a-1999 and section 18.2.4 of IEEE Standard    802.11a-1999.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    the toolkit always sets the NIWLANG_PAYLOAD_SCRAMBLER_ENABLED attribute to NIWLANG_VAL_TRUE. 
        ///    The default value is NIWLANG_VAL_TRUE.        
        /// 
        /// </summary>
        public int GetPayloadScramblerEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadScramblerEnabled, channel, out value);
        }
        /// <summary>
        /// Specifies the initial state of the scrambler (seed).
        ///      For direct sequence spread spectrum (DSSS) packets,    the default value follows the requirements defined in sections 18.2.3.1    and 18.2.3.8 of IEEE Standard 802.11b-1999. For orthogonal frequency division multiplexing (OFDM) and DSSS-OFDM packets,    the default value is 93.
        ///     This attribute is not applicable when the standard parameter of the     niWLANG_SetStandard function is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.        
        /// 
        /// </summary>
        public int SetPayloadScramblerSeed(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PayloadScramblerSeed, channel, value);
        }
        /// <summary>
        /// Specifies the initial state of the scrambler (seed).
        ///      For direct sequence spread spectrum (DSSS) packets,    the default value follows the requirements defined in sections 18.2.3.1    and 18.2.3.8 of IEEE Standard 802.11b-1999. For orthogonal frequency division multiplexing (OFDM) and DSSS-OFDM packets,    the default value is 93.
        ///     This attribute is not applicable when the standard parameter of the     niWLANG_SetStandard function is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM.        
        /// 
        /// </summary>
        public int GetPayloadScramblerSeed(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadScramblerSeed, channel, out value);
        }
        /// <summary>
        /// Specifies a user-defined bit pattern as an array of zeros and ones.    If the array length is greater than the configured payload length, the    toolkit uses a subset of the required length from the beginning of the array    for waveform generation. If the array length is less than the configured    payload length, the user-defined bit pattern is repeated until the required    length is achieved. If the NIWLANG_PAYLOAD_DATA_TYPE attribute is set to    NIWLANG_VAL_PN_SEQUENCE, the    toolkit ignores the NIWLANG_PAYLOAD_USER_DEFINED_BITS attribute.
        ///    Valid values include arrays    of zeros and ones.
        ///    The default is an empty array. Valid values include arrays of zeros and ones.        
        /// 
        /// </summary>
        public int SetPayloadUserDefinedBits(string channel, int[] data, int dataArraySize)
        {
            return SetVectorAttributeI32(channel, niWLANGProperties.PayloadUserDefinedBits, data, dataArraySize);
        }
        /// <summary>
        /// Specifies a user-defined bit pattern as an array of zeros and ones.    If the array length is greater than the configured payload length, the    toolkit uses a subset of the required length from the beginning of the array    for waveform generation. If the array length is less than the configured    payload length, the user-defined bit pattern is repeated until the required    length is achieved. If the NIWLANG_PAYLOAD_DATA_TYPE attribute is set to    NIWLANG_VAL_PN_SEQUENCE, the    toolkit ignores the NIWLANG_PAYLOAD_USER_DEFINED_BITS attribute.
        ///    Valid values include arrays    of zeros and ones.
        ///    The default is an empty array. Valid values include arrays of zeros and ones.        
        /// 
        /// </summary>
        public int GetPayloadUserDefinedBits(string channel, int[] data, int dataArraySize, out int actualNumDataElements)
        {
            return GetVectorAttributeI32(channel, niWLANGProperties.PayloadUserDefinedBits, data, dataArraySize, out actualNumDataElements);
        }
        /// <summary>
        /// Specifies the average power level, in dBm, of the active portion of the    burst for signal generation. The active portion of the burst is the    WLAN packet excluding the interframe spacing.
        ///     If you set the standard parameter of the niWLANG_SetStandard function to     NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, you must use an active channel string to   configure this attribute.
        ///     The default value is -10.          
        /// 
        /// </summary>
        public int SetPowerLevel(string channel, double value)
        {
            return SetDouble(niWLANGProperties.PowerLevel, channel, value);
        }
        /// <summary>
        /// Specifies the average power level, in dBm, of the active portion of the    burst for signal generation. The active portion of the burst is the    WLAN packet excluding the interframe spacing.
        ///     If you set the standard parameter of the niWLANG_SetStandard function to     NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, you must use an active channel string to   configure this attribute.
        ///     The default value is -10.          
        /// 
        /// </summary>
        public int GetPowerLevel(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.PowerLevel, channel, out value);
        }
        /// <summary>
        /// Specifies whether to apply pulse shaping filter to the generated signal.
        ///     Note: The toolkit ignores this attribute and sets the value to NIWLANG_VAL_TRUE if the compatibilityVersion parameter    of the niWLANG_OpenSession function is set to NIWLANG_VAL_COMPATIBILITY_VERSION_010000.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANA_VAL_STANDARD_80211BG_DSSS, the default value is NIWLANG_VAL_TRUE.    If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM     or NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, the default value is NIWLANG_VAL_FALSE.      
        /// 
        /// </summary>
        public int SetPulseShapingFilterEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PulseShapingFilterEnabled, channel, value);
        }
        /// <summary>
        /// Specifies whether to apply pulse shaping filter to the generated signal.
        ///     Note: The toolkit ignores this attribute and sets the value to NIWLANG_VAL_TRUE if the compatibilityVersion parameter    of the niWLANG_OpenSession function is set to NIWLANG_VAL_COMPATIBILITY_VERSION_010000.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANA_VAL_STANDARD_80211BG_DSSS, the default value is NIWLANG_VAL_TRUE.    If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211AG_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM     or NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, the default value is NIWLANG_VAL_FALSE.      
        /// 
        /// </summary>
        public int GetPulseShapingFilterEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PulseShapingFilterEnabled, channel, out value);
        }
        /// <summary>
        /// Specifies the value of the rolloff factor (alpha) if the NIWLANG_PULSE_SHAPING_FILTER_TYPE    attribute is set to    NIWLANG_VAL_FILTER_RAISED_COSINE or NIWLANG_VAL_FILTER_ROOT_RAISED_COSINE.    If the NIWLANG_PULSE_SHAPING_FILTER_TYPE attribute is set    to NIWLANG_VAL_FILTER_GAUSSIAN, the     NIWLANG_PULSE_SHAPING_FILTER_PARAMETER attribute specifies the BT, which is the product of the -3 dB bandwidth    and the symbol period for a Gaussian filter. If the    NIWLANG_PULSE_SHAPING_FILTER_TYPE attribute is set to NIWLANG_VAL_FILTER_RECTANGULAR,    the toolkit ignores NIWLANG_PULSE_SHAPING_FILTER_PARAMETER attribute.
        ///    The default value is 0.5. Valid values are 0.1 to 0.95, inclusive.        
        /// 
        /// </summary>
        public int SetPulseShapingFilterParameter(string channel, double value)
        {
            return SetDouble(niWLANGProperties.PulseShapingFilterParameter, channel, value);
        }
        /// <summary>
        /// Specifies the value of the rolloff factor (alpha) if the NIWLANG_PULSE_SHAPING_FILTER_TYPE    attribute is set to    NIWLANG_VAL_FILTER_RAISED_COSINE or NIWLANG_VAL_FILTER_ROOT_RAISED_COSINE.    If the NIWLANG_PULSE_SHAPING_FILTER_TYPE attribute is set    to NIWLANG_VAL_FILTER_GAUSSIAN, the     NIWLANG_PULSE_SHAPING_FILTER_PARAMETER attribute specifies the BT, which is the product of the -3 dB bandwidth    and the symbol period for a Gaussian filter. If the    NIWLANG_PULSE_SHAPING_FILTER_TYPE attribute is set to NIWLANG_VAL_FILTER_RECTANGULAR,    the toolkit ignores NIWLANG_PULSE_SHAPING_FILTER_PARAMETER attribute.
        ///    The default value is 0.5. Valid values are 0.1 to 0.95, inclusive.        
        /// 
        /// </summary>
        public int GetPulseShapingFilterParameter(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.PulseShapingFilterParameter, channel, out value);
        }
        /// <summary>
        /// Specifies the pulse-shaping filter type to use to ensure that the signal spectrum meets the     spectral mask criteria as defined in section 17.3.9.2 of IEEE Standard 802.11a-1999, section     18.4.7.3 of IEEE Standard 802.11b-1999, and section 20.3.21.1 of IEEE standard 802.11n-2009.   
        /// 
        /// </summary>
        public int SetPulseShapingFilterType(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PulseShapingFilterType, channel, value);
        }
        /// <summary>
        /// Specifies the pulse-shaping filter type to use to ensure that the signal spectrum meets the     spectral mask criteria as defined in section 17.3.9.2 of IEEE Standard 802.11a-1999, section     18.4.7.3 of IEEE Standard 802.11b-1999, and section 20.3.21.1 of IEEE standard 802.11n-2009.   
        /// 
        /// </summary>
        public int GetPulseShapingFilterType(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PulseShapingFilterType, channel, out value);
        }

        /// <summary>
        /// Specifies the length, in symbols, of the pulse-shaping filter. The length affects the frequency response of the filter. The toolkit ignores this attribute when the NIWLANG_PULSE_SHAPING_FILTER_LENGTH attribute is set to NIWLANG_VAL_FALSE.
        ///Default value is 8. 
        /// </summary>
        public int SetPulseShapingFilterLength(string channel, int value)
        {
            return SetInt32(niWLANGProperties.PulseShapingFilterLength, channel, value);
        }
        /// <summary>
        /// Specifies the length, in symbols, of the pulse-shaping filter. The length affects the frequency response of the filter. The toolkit ignores this attribute when the NIWLANG_PULSE_SHAPING_FILTER_LENGTH attribute is set to NIWLANG_VAL_FALSE.
        /// Default value is 8. 
        /// </summary>
        public int GetPulseShapingFilterLength(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.PulseShapingFilterLength, channel, out value);
        }

        /// <summary>
        /// Specifies the value of the DC offset in the quadrature-phase (Q)    channel as percentage of the root mean square (RMS) magnitude of the unaltered Q channel.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,     you must use an active channel string to configure the NIWLANG_Q_DC_OFFSET attribute.
        ///    The default value is 0. Valid values are -100 to +100, inclusive.        
        /// 
        /// </summary>
        public int SetQDcOffset(string channel, double value)
        {
            return SetDouble(niWLANGProperties.QDcOffset, channel, value);
        }
        /// <summary>
        /// Specifies the value of the DC offset in the quadrature-phase (Q)    channel as percentage of the root mean square (RMS) magnitude of the unaltered Q channel.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,     you must use an active channel string to configure the NIWLANG_Q_DC_OFFSET attribute.
        ///    The default value is 0. Valid values are -100 to +100, inclusive.        
        /// 
        /// </summary>
        public int GetQDcOffset(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.QDcOffset, channel, out value);
        }
        /// <summary>
        /// Specifies the deviation in angle from 90 degrees between the in-phase (I)    and quadrature-phase (Q) signals.
        ///    Quadrature skew follows the definition
        ///    Real(output) = Real(input) - Gs * Imag(input)
        ///    Imag(output) = Gc * Imag(input)
        ///    where
        ///    Gs = G * sin(Q) and
        ///    Gc = G * cos(Q) 
        ///    where G is the I/Q gain imbalance and Q is the quadrature skew.
        ///    Refer to the Quadrature Skew topic for more information.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,     you must use an active channel string to configure the NIWLANG_QUADRATURE_SKEW attribute.
        ///    The default value is 0. Valid values are -30 to +30, inclusive.        
        /// 
        /// </summary>
        public int SetQuadratureSkew(string channel, double value)
        {
            return SetDouble(niWLANGProperties.QuadratureSkew, channel, value);
        }
        /// <summary>
        /// Specifies the deviation in angle from 90 degrees between the in-phase (I)    and quadrature-phase (Q) signals.
        ///    Quadrature skew follows the definition
        ///    Real(output) = Real(input) - Gs * Imag(input)
        ///    Imag(output) = Gc * Imag(input)
        ///    where
        ///    Gs = G * sin(Q) and
        ///    Gc = G * cos(Q) 
        ///    where G is the I/Q gain imbalance and Q is the quadrature skew.
        ///    Refer to the Quadrature Skew topic for more information.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,     you must use an active channel string to configure the NIWLANG_QUADRATURE_SKEW attribute.
        ///    The default value is 0. Valid values are -30 to +30, inclusive.        
        /// 
        /// </summary>
        public int GetQuadratureSkew(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.QuadratureSkew, channel, out value);
        }
        /// <summary>
        /// Specifies the offset in the sample clock frequency, in parts per million (ppm), from the    sampling frequency defined by the NIWLANG_OVERSAMPLING_FACTOR    attribute. For    large offset values, with large waveform sizes, clock cycle slips    may occur. Clock cycle slips can cause the final waveform size    to be different from the expected size, given the ideal burst length    and the interframe spacing.
        ///    The default value is 0.        
        /// 
        /// </summary>
        public int SetSampleClockOffset(string channel, double value)
        {
            return SetDouble(niWLANGProperties.SampleClockOffset, channel, value);
        }
        /// <summary>
        /// Specifies the offset in the sample clock frequency, in parts per million (ppm), from the    sampling frequency defined by the NIWLANG_OVERSAMPLING_FACTOR    attribute. For    large offset values, with large waveform sizes, clock cycle slips    may occur. Clock cycle slips can cause the final waveform size    to be different from the expected size, given the ideal burst length    and the interframe spacing.
        ///    The default value is 0.        
        /// 
        /// </summary>
        public int GetSampleClockOffset(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.SampleClockOffset, channel, out value);
        }
        /// <summary>
        /// Specifies the standard for signal generation.
        ///    Note: If you do not select a standard, the toolkit returns an error.   
        /// 
        /// </summary>
        public int SetStandard(string channel, int value)
        {
            return SetInt32(niWLANGProperties.Standard, channel, value);
        }
        /// <summary>
        /// Specifies the standard for signal generation.
        ///    Note: If you do not select a standard, the toolkit returns an error.   
        /// 
        /// </summary>
        public int GetStandard(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.Standard, channel, out value);
        }
        /// <summary>
        /// Specifies the sequence of attenuation values on each subcarrier in the signal and payload symbols if    you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AG_OFDM    or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM. You must specify a 64-element array.    The first element of the array    corresponds to subcarrier index -32,    and the 64th element corresponds to subcarrier index 31. Subcarrier indexing    follows the definition in section 17.3.2.5 in IEEE Standard 802.11a-1999.        
        /// 
        /// </summary>
        public int SetSubcarrierMask(string channel, double value)
        {
            return SetDouble(niWLANGProperties.SubcarrierMask, channel, value);
        }
        /// <summary>
        /// Specifies the sequence of attenuation values on each subcarrier in the signal and payload symbols if    you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AG_OFDM    or NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM. You must specify a 64-element array.    The first element of the array    corresponds to subcarrier index -32,    and the 64th element corresponds to subcarrier index 31. Subcarrier indexing    follows the definition in section 17.3.2.5 in IEEE Standard 802.11a-1999.        
        /// 
        /// </summary>
        public int GetSubcarrierMask(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.SubcarrierMask, channel, out value);
        }
        /// <summary>
        /// Specifies the window length, in seconds. If you do not want windowing,    set the value to 0.
        ///    For direct sequence spread spectrum (DSSS) signals, this attribute provides power ramp up and down to the    entire burst. For orthogonal frequency division multiplexing (OFDM) signals, this attribute provides a smooth, spurii-free    transition from the end of one OFDM symbol to the cyclic prefix of the next.    For OFDM signals, a value of 50 ns conforms to the normative recommendation of    section 17.3.2.5 of IEEE Standard 802.11a-1999.
        ///     Refer to the Windowing for DSSS and OFDM Signals topic     for the difference between windowing for DSSS and OFDM signals.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211BG_DSSS, the default value is 2 &#181;. Otherwise, the default value is 100 n.         
        /// 
        /// </summary>
        [Obsolete("Use SetDsssWindowLength()")]
        public int SetWindowLength(string channel, double value)
        {
            return SetDouble(niWLANGProperties.WindowLength, channel, value);
        }
        /// <summary>
        /// Specifies the window length, in seconds. If you do not want windowing,    set the value to 0.
        ///    For direct sequence spread spectrum (DSSS) signals, this attribute provides power ramp up and down to the    entire burst. For orthogonal frequency division multiplexing (OFDM) signals, this attribute provides a smooth, spurii-free    transition from the end of one OFDM symbol to the cyclic prefix of the next.    For OFDM signals, a value of 50 ns conforms to the normative recommendation of    section 17.3.2.5 of IEEE Standard 802.11a-1999.
        ///     Refer to the Windowing for DSSS and OFDM Signals topic     for the difference between windowing for DSSS and OFDM signals.
        ///     If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211BG_DSSS, the default value is 2 &#181;. Otherwise, the default value is 100 n.         
        /// 
        /// </summary>
        [Obsolete("Use GetDsssWindowLength()")]
        public int GetWindowLength(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.WindowLength, channel, out value);
        }

        /// <summary>
        ///Specifies the type of forward error correction (FEC) coding to use if you set the NIWLANG_STANDARD attribute to  NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    as defined in section 20.3.11.3 of IEEE Standard 802.11n-2009.
        ///    The default value is NIWLANG_VAL_FEC_CODING_TYPE_BCC.
        ///    Set Function: niWLANG_SetFECCodingType
        ///    Get Function: niWLANG_GetFECCodingType
        /// 
        /// </summary>
        public int SetFecCodingType(string channel, int value)
        {
            return SetInt32(niWLANGProperties.FecCodingType, channel, value);
        }
        /// <summary>
        ///Specifies the type of forward error correction (FEC) coding to use if you set the NIWLANG_STANDARD attribute to  NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM,    as defined in section 20.3.11.3 of IEEE Standard 802.11n-2009.
        ///    The default value is NIWLANG_VAL_FEC_CODING_TYPE_BCC.
        ///    Set Function: niWLANG_SetFECCodingType
        ///    Get Function: niWLANG_GetFECCodingType
        /// 
        /// </summary>
        public int GetFecCodingType(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.FecCodingType, channel, out value);
        }
        /// <summary>
        ///Specifies the difference between the number of space-time streams and the number of spatial streams, as defined in section    20.3.9.4.3 of IEEE Standard 802.11n-2009. The number of spatial streams is derived from the NIWLANG_MCS_INDEX attribute. Different    space-time coding schemes are defined in section 20.3.11.8.1 of IEEE Standard 802.11n-2009.
        ///    The default value is 0.Valid Values are 0 to 2, inclusive.
        ///    Set Function: niWLANG_SetSTBCIndex
        ///    Get Function: niWLANG_GetSTBCIndex
        /// 
        /// </summary>
        public int SetStbcIndex(string channel, int value)
        {
            return SetInt32(niWLANGProperties.StbcIndex, channel, value);
        }
        /// <summary>
        ///Specifies the difference between the number of space-time streams and the number of spatial streams, as defined in section    20.3.9.4.3 of IEEE Standard 802.11n-2009. The number of spatial streams is derived from the NIWLANG_MCS_INDEX attribute. Different    space-time coding schemes are defined in section 20.3.11.8.1 of IEEE Standard 802.11n-2009.
        ///    The default value is 0.Valid Values are 0 to 2, inclusive.
        ///    Set Function: niWLANG_SetSTBCIndex
        ///    Get Function: niWLANG_GetSTBCIndex
        /// 
        /// </summary>
        public int GetStbcIndex(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.StbcIndex, channel, out value);
        }
        /// <summary>
        ///Specifies whether the toolkit calculates the headroom or uses a user-defined value.   For multiframe generation, the toolkit uses the headroom calculated on the first frame to scale the waveform.    National Instruments recommends that you do not set this attribute to NIWLANG_VAL_TRUE for multiframe generation because variation of the peak-to-average    power ratio (PAPR) across frames may lead to excessive clipping. To avoid excessive clipping, set this attribute to NIWLANG_VAL_FALSE and use the    default values for the NIWLANG_HEADROOM attribute.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Note: Use this attribute only if you set the NIWLANG_COMPATIBILITY_VERSION attribute to NIWLANG_VAL_COMPATIBILITY_VERSION_030000.
        ///    Set Function: niWLANG_SetAutoHeadroomEnabled
        ///    Get Function: niWLANG_GetAutoHeadroomEnabled
        /// 
        /// </summary>
        public int SetAutoHeadroomEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.AutoHeadroomEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether the toolkit calculates the headroom or uses a user-defined value.   For multiframe generation, the toolkit uses the headroom calculated on the first frame to scale the waveform.    National Instruments recommends that you do not set this attribute to NIWLANG_VAL_TRUE for multiframe generation because variation of the peak-to-average    power ratio (PAPR) across frames may lead to excessive clipping. To avoid excessive clipping, set this attribute to NIWLANG_VAL_FALSE and use the    default values for the NIWLANG_HEADROOM attribute.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Note: Use this attribute only if you set the NIWLANG_COMPATIBILITY_VERSION attribute to NIWLANG_VAL_COMPATIBILITY_VERSION_030000.
        ///    Set Function: niWLANG_SetAutoHeadroomEnabled
        ///    Get Function: niWLANG_GetAutoHeadroomEnabled
        /// 
        /// </summary>
        public int GetAutoHeadroomEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.AutoHeadroomEnabled, channel, out value);
        }
        /// <summary>
        ///Specifies the headroom, in dB, for each transmit channel. This attribute represents the maximum peak-to-average power ratio (PAPR)    allowed in the signal to be generated. The toolkit clips any portion of the signal that exceeds the peak power corresponding to this value.    The toolkit ignores this attribute if you set the NIWLANG_AUTO_HEADROOM_ENABLED attribute to NIWLANG_VAL_TRUE.
        ///     If you set the NIWLANG_AUTO_HEADROOM_ENABLED attribute to NIWLANG_VAL_FALSE, the toolkit uses default values based on the NIWLANG_STANDARD attribute.    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211BG_DSSS, the default value is 5. Otherwise, the default value is 12.
        ///    Note: If you specify a value that is more than the actual PAPR of the signal, there is loss of    dynamic range of the digital-to-analog converter (DAC). If you specify a value that is less than the actual PAPR of the signal, the toolkit clips the generated signal.
        ///     Note: In toolkit version 2.0.0, the NIWLANG_HEADROOM attribute was called NIWLANG_MAX_EXPECTED_PAPR. To get the same behavior of this attribute     as in version 2.0.0, you must set the NIWLANG_AUTO_HEADROOM_ENABLED attribute to NIWLANG_VAL_FALSE in version 3.0.0.
        ///    If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, use a channelString parameter to configure this attribute. Refer to the Syntax for Channel String help topic for more information about configuring the channelString parameters.
        ///    Set Function: niWLANG_SetHeadroom
        ///    Get Function: niWLANG_GetHeadroom
        /// 
        /// </summary>
        public int SetHeadroom(string channel, double value)
        {
            return SetDouble(niWLANGProperties.Headroom, channel, value);
        }
        /// <summary>
        ///Specifies the headroom, in dB, for each transmit channel. This attribute represents the maximum peak-to-average power ratio (PAPR)    allowed in the signal to be generated. The toolkit clips any portion of the signal that exceeds the peak power corresponding to this value.    The toolkit ignores this attribute if you set the NIWLANG_AUTO_HEADROOM_ENABLED attribute to NIWLANG_VAL_TRUE.
        ///     If you set the NIWLANG_AUTO_HEADROOM_ENABLED attribute to NIWLANG_VAL_FALSE, the toolkit uses default values based on the NIWLANG_STANDARD attribute.    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211BG_DSSS, the default value is 5. Otherwise, the default value is 12.
        ///    Note: If you specify a value that is more than the actual PAPR of the signal, there is loss of    dynamic range of the digital-to-analog converter (DAC). If you specify a value that is less than the actual PAPR of the signal, the toolkit clips the generated signal.
        ///     Note: In toolkit version 2.0.0, the NIWLANG_HEADROOM attribute was called NIWLANG_MAX_EXPECTED_PAPR. To get the same behavior of this attribute     as in version 2.0.0, you must set the NIWLANG_AUTO_HEADROOM_ENABLED attribute to NIWLANG_VAL_FALSE in version 3.0.0.
        ///    If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, use a channelString parameter to configure this attribute. Refer to the Syntax for Channel String help topic for more information about configuring the channelString parameters.
        ///    Set Function: niWLANG_SetHeadroom
        ///    Get Function: niWLANG_GetHeadroom
        /// 
        /// </summary>
        public int GetHeadroom(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.Headroom, channel, out value);
        }
        /// <summary>
        ///Returns the recommended sample rate, in samples per second, for the current signal configuration.    The dt parameter of the created waveform is the inverse of the recommended sample rate.
        ///     Get Function: niWLANG_GetIQRate
        /// 
        /// </summary>
        public int GetIqRate(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.IqRate, channel, out value);
        }
        /// <summary>
        ///Returns the actual headroom, in dB, which the toolkit applies to the waveform.
        ///    If the NIWLANG_STANDARD attribute is set to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, use the channelString parameter to read this attribute for a transmit channel. Refer to the Syntax for Channel String help topic for more information about configuring active channels.
        ///    Get Function: niWLANG_GetActualHeadroom
        /// 
        /// </summary>
        public int GetActualHeadroom(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.ActualHeadroom, channel, out value);
        }
        /// <summary>
        ///Specifies the 2-byte frame control field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant bit (LSB) at the rightmost position.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFF. For values outside this range, the toolkit uses the least    significant two bytes.
        ///    Set Function: niWLANG_SetMACFrameControl
        ///    Get Function: niWLANG_GetMACFrameControl
        /// 
        /// </summary>
        public int SetMacFrameControl(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacFrameControl, channel, value);
        }
        /// <summary>
        ///Specifies the 2-byte frame control field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant bit (LSB) at the rightmost position.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFF. For values outside this range, the toolkit uses the least    significant two bytes.
        ///    Set Function: niWLANG_SetMACFrameControl
        ///    Get Function: niWLANG_GetMACFrameControl
        /// 
        /// </summary>
        public int GetMacFrameControl(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacFrameControl, channel, out value);
        }
        /// <summary>
        ///Specifies the 2-byte duration field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant bit (LSB) in the rightmost position.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFF. For values outside this range, the toolkit uses the least significant 2 bytes.
        ///    Set Function: niWLANG_SetMACDurationOrID
        ///    Get Function: niWLANG_GetMACDurationOrID
        /// 
        /// </summary>
        public int SetMacDurationOrId(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacDurationOrId, channel, value);
        }
        /// <summary>
        ///Specifies the 2-byte duration field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant bit (LSB) in the rightmost position.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFF. For values outside this range, the toolkit uses the least significant 2 bytes.
        ///    Set Function: niWLANG_SetMACDurationOrID
        ///    Get Function: niWLANG_GetMACDurationOrID
        /// 
        /// </summary>
        public int GetMacDurationOrId(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacDurationOrId, channel, out value);
        }
        /// <summary>
        ///Specifies the 6-byte address1 field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant byte in the leftmost position and each byte is represented with the    least significant bit in the rightmost position.
        ///    For example, the MAC address 12-34-56-78-9A-BC is represented by the number 0 x 123456789ABC.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFFFFFFFFFF. For values outside this range, the toolkit uses    the least significant 6 bytes.
        ///    Set Function: niWLANG_SetMACAddress1
        ///    Get Function: niWLANG_GetMACAddress1
        /// 
        /// </summary>
        public int SetMacAddress1(string channel, long value)
        {
            int pInvokeResult = PInvoke.niWLANG_SetMACAddress1(Handle, channel, value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        ///Specifies the 6-byte address1 field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant byte in the leftmost position and each byte is represented with the    least significant bit in the rightmost position.
        ///    For example, the MAC address 12-34-56-78-9A-BC is represented by the number 0 x 123456789ABC.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFFFFFFFFFF. For values outside this range, the toolkit uses    the least significant 6 bytes.
        ///    Set Function: niWLANG_SetMACAddress1
        ///    Get Function: niWLANG_GetMACAddress1
        /// 
        /// </summary>
        public int GetMacAddress1(string channel, out long value)
        {
            int pInvokeResult = PInvoke.niWLANG_GetMACAddress1(Handle, channel, out value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///Specifies whether to enable the address1 field of the MAC header.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACAddress1Enabled
        ///    Get Function: niWLANG_GetMACAddress1Enabled
        /// 
        /// </summary>
        public int SetMacAddress1Enabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacAddress1Enabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to enable the address1 field of the MAC header.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACAddress1Enabled
        ///    Get Function: niWLANG_GetMACAddress1Enabled
        /// 
        /// </summary>
        public int GetMacAddress1Enabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacAddress1Enabled, channel, out value);
        }

        /// <summary>
        ///Specifies the 6-byte address2 field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant byte in the leftmost position and each byte is represented with the    least significant bit in the rightmost position.
        ///    For example, the MAC address 12-34-56-78-9A-BC is represented by the number 0 x 123456789ABC.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFFFFFFFFFF. For values outside this range, the toolkit uses the    least significant 6 bytes.
        ///    Set Function: niWLANG_SetMACAddress2
        ///    Get Function: niWLANG_GetMACAddress2
        /// 
        /// </summary>
        public int SetMacAddress2(string channel, long value)
        {
            int pInvokeResult = PInvoke.niWLANG_SetMACAddress2(Handle, channel, value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        ///Specifies the 6-byte address2 field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant byte in the leftmost position and each byte is represented with the    least significant bit in the rightmost position.
        ///    For example, the MAC address 12-34-56-78-9A-BC is represented by the number 0 x 123456789ABC.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFFFFFFFFFF. For values outside this range, the toolkit uses the    least significant 6 bytes.
        ///    Set Function: niWLANG_SetMACAddress2
        ///    Get Function: niWLANG_GetMACAddress2
        /// 
        /// </summary>
        public int GetMacAddress2(string channel, out long value)
        {
            int pInvokeResult = PInvoke.niWLANG_GetMACAddress2(Handle, channel, out value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///Specifies whether to enable the address2 field of the MAC header.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACAddress2Enabled
        ///    Get Function: niWLANG_GetMACAddress2Enabled
        /// 
        /// </summary>
        public int SetMacAddress2Enabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacAddress2Enabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to enable the address2 field of the MAC header.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACAddress2Enabled
        ///    Get Function: niWLANG_GetMACAddress2Enabled
        /// 
        /// </summary>
        public int GetMacAddress2Enabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacAddress2Enabled, channel, out value);
        }

        /// <summary>
        ///Specifies the 6-byte address3 field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant byte in the leftmost position and each byte is represented with the    least significant bit in the rightmost position.
        ///    For example, the MAC address 12-34-56-78-9A-BC is represented by the number 0x123456789ABC.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFFFFFFFFFF. For values outside this range, the toolkit uses the    least significant 6 bytes.
        ///    Set Function: niWLANG_SetMACAddress3
        ///    Get Function: niWLANG_GetMACAddress3
        /// 
        /// </summary>
        public int SetMacAddress3(string channel, long value)
        {
            int pInvokeResult = PInvoke.niWLANG_SetMACAddress3(Handle, channel, value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        ///Specifies the 6-byte address3 field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant byte in the leftmost position and each byte is represented with the    least significant bit in the rightmost position.
        ///    For example, the MAC address 12-34-56-78-9A-BC is represented by the number 0x123456789ABC.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFFFFFFFFFF. For values outside this range, the toolkit uses the    least significant 6 bytes.
        ///    Set Function: niWLANG_SetMACAddress3
        ///    Get Function: niWLANG_GetMACAddress3
        /// 
        /// </summary>
        public int GetMacAddress3(string channel, out long value)
        {
            int pInvokeResult = PInvoke.niWLANG_GetMACAddress3(Handle, channel, out value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///Specifies whether to enable the address3 field of the MAC header.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACAddress3Enabled
        ///    Get Function: niWLANG_GetMACAddress3Enabled
        /// 
        /// </summary>
        public int SetMacAddress3Enabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacAddress3Enabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to enable the address3 field of the MAC header.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACAddress3Enabled
        ///    Get Function: niWLANG_GetMACAddress3Enabled
        /// 
        /// </summary>
        public int GetMacAddress3Enabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacAddress3Enabled, channel, out value);
        }

        /// <summary>
        ///Specifies the 6-byte address4 field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.   This field is represented with the least significant byte in the leftmost position and each byte is represented with the    least significant bit in the rightmost position.
        ///    For example, the MAC address 12-34-56-78-9A-BC is represented by the number 0 x 123456789ABC.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFFFFFFFFFF. For values outside this range, the toolkit uses the    least significant 6 bytes.
        ///    Set Function: niWLANG_SetMACAddress4
        ///    Get Function: niWLANG_GetMACAddress4
        /// 
        /// </summary>
        public int SetMacAddress4(string channel, long value)
        {
            int pInvokeResult = PInvoke.niWLANG_SetMACAddress4(Handle, channel, value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        ///Specifies the 6-byte address4 field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.   This field is represented with the least significant byte in the leftmost position and each byte is represented with the    least significant bit in the rightmost position.
        ///    For example, the MAC address 12-34-56-78-9A-BC is represented by the number 0 x 123456789ABC.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFFFFFFFFFF. For values outside this range, the toolkit uses the    least significant 6 bytes.
        ///    Set Function: niWLANG_SetMACAddress4
        ///    Get Function: niWLANG_GetMACAddress4
        /// 
        /// </summary>
        public int GetMacAddress4(string channel, out long value)
        {
            int pInvokeResult = PInvoke.niWLANG_GetMACAddress4(Handle, channel, out value);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }
        /// <summary>
        ///Specifies whether to the enable address4 field of the MAC header.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACAddress4Enabled
        ///    Get Function: niWLANG_GetMACAddress4Enabled
        /// 
        /// </summary>
        public int SetMacAddress4Enabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacAddress4Enabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to the enable address4 field of the MAC header.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACAddress4Enabled
        ///    Get Function: niWLANG_GetMACAddress4Enabled
        /// 
        /// </summary>
        public int GetMacAddress4Enabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacAddress4Enabled, channel, out value);
        }
        /// <summary>
        ///Specifies whether to enable the sequence control field of the MAC header.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACSequenceControlEnabled
        ///    Get Function: niWLANG_GetMACSequenceControlEnabled
        /// 
        /// </summary>
        public int SetMacSequenceControlEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacSequenceControlEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to enable the sequence control field of the MAC header.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACSequenceControlEnabled
        ///    Get Function: niWLANG_GetMACSequenceControlEnabled
        /// 
        /// </summary>
        public int GetMacSequenceControlEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacSequenceControlEnabled, channel, out value);
        }
        /// <summary>
        ///Specifies the 2-byte sequence control field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant bit in the rightmost position.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFF. For values outside this range, the toolkit uses the least    significant 2 bytes.
        ///    Set Function: niWLANG_SetMACSequenceControl
        ///    Get Function: niWLANG_GetMACSequenceControl
        /// 
        /// </summary>
        public int SetMacSequenceControl(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacSequenceControl, channel, value);
        }
        /// <summary>
        ///Specifies the 2-byte sequence control field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant bit in the rightmost position.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFF. For values outside this range, the toolkit uses the least    significant 2 bytes.
        ///    Set Function: niWLANG_SetMACSequenceControl
        ///    Get Function: niWLANG_GetMACSequenceControl
        /// 
        /// </summary>
        public int GetMacSequenceControl(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacSequenceControl, channel, out value);
        }
        /// <summary>
        ///Specifies whether to enable the QoS control field of the MAC header.
        ///    The default value is NIWLANG_VAL_FALSE.  
        ///    Set Function: niWLANG_SetMACQOSControlEnabled
        ///    Get Function: niWLANG_GetMACQOSControlEnabled
        /// 
        /// </summary>
        public int SetMacQosControlEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacQosControlEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to enable the QoS control field of the MAC header.
        ///    The default value is NIWLANG_VAL_FALSE.  
        ///    Set Function: niWLANG_SetMACQOSControlEnabled
        ///    Get Function: niWLANG_GetMACQOSControlEnabled
        /// 
        /// </summary>
        public int GetMacQosControlEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacQosControlEnabled, channel, out value);
        }
        /// <summary>
        ///Specifies the 2-byte QoS control field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant bit in the rightmost position.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFF. For values outside this range, the toolkit uses the least    significant 2 bytes.
        ///    Set Function: niWLANG_SetMACQOSControl
        ///    Get Function: niWLANG_GetMACQOSControl
        /// 
        /// </summary>
        public int SetMacQosControl(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacQosControl, channel, value);
        }
        /// <summary>
        ///Specifies the 2-byte QoS control field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant bit in the rightmost position.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFF. For values outside this range, the toolkit uses the least    significant 2 bytes.
        ///    Set Function: niWLANG_SetMACQOSControl
        ///    Get Function: niWLANG_GetMACQOSControl
        /// 
        /// </summary>
        public int GetMacQosControl(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacQosControl, channel, out value);
        }
        /// <summary>
        ///Specifies whether to enable the HT control field of the MAC header.
        ///    The default value is NIWLANG_VAL_FALSE.  
        ///    Set Function: niWLANG_SetMACHTControlEnabled
        ///    Get Function: niWLANG_GetMACHTControlEnabled
        /// 
        /// </summary>
        public int SetMacHtControlEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacHtControlEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to enable the HT control field of the MAC header.
        ///    The default value is NIWLANG_VAL_FALSE.  
        ///    Set Function: niWLANG_SetMACHTControlEnabled
        ///    Get Function: niWLANG_GetMACHTControlEnabled
        /// 
        /// </summary>
        public int GetMacHtControlEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacHtControlEnabled, channel, out value);
        }
        /// <summary>
        ///Specifies the 4-byte HT Control field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant bit in the rightmost position.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFFFFFF. For values outside this range, the toolkit uses the least significant four bytes.
        ///    Set Function: niWLANG_SetMACHTControl
        ///    Get Function: niWLANG_GetMACHTControl
        /// 
        /// </summary>
        public int SetMacHtControl(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacHtControl, channel, value);
        }
        /// <summary>
        ///Specifies the 4-byte HT Control field as defined in section 7.1.3 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.    This field is represented with the least significant bit in the rightmost position.
        ///    The default value is 0 x 0. Valid values are 0 x 0 to 0 x FFFFFFFF. For values outside this range, the toolkit uses the least significant four bytes.
        ///    Set Function: niWLANG_SetMACHTControl
        ///    Get Function: niWLANG_GetMACHTControl
        /// 
        /// </summary>
        public int GetMacHtControl(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacHtControl, channel, out value);
        }
        /// <summary>
        ///Specifies whether to increment the sequence number in a sequence of frames.
        ///    The default value is NIWLANG_VAL_FALSE. 
        ///    Set Function: niWLANG_SetMACSequenceNumberIncrementEnabled
        ///    Get Function: niWLANG_GetMACSequenceNumberIncrementEnabled
        /// 
        /// </summary>
        public int SetMacSequenceNumberIncrementEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacSequenceNumberIncrementEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to increment the sequence number in a sequence of frames.
        ///    The default value is NIWLANG_VAL_FALSE. 
        ///    Set Function: niWLANG_SetMACSequenceNumberIncrementEnabled
        ///    Get Function: niWLANG_GetMACSequenceNumberIncrementEnabled
        /// 
        /// </summary>
        public int GetMacSequenceNumberIncrementEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacSequenceNumberIncrementEnabled, channel, out value);
        }
        /// <summary>
        ///Specifies the number of frames after which the sequence number is incremented by 1.    The starting number is the value represented by the sequence number sub-field of the sequence control field.    The sequence number is wrapped to 0 after reaching the value 4095 (2^12-1). The toolkit ignores this attribute if you set the    NIWLANG_MAC_SEQUENCE_NUMBER_INCREMENT_ENABLED attribute to NIWLANG_VAL_FALSE.
        ///    The default value is 0. Valid values are 0 to 4,095, inclusive.
        ///    Set Function: niWLANG_SetMACSequenceNumberIncrementInterval
        ///    Get Function: niWLANG_GetMACSequenceNumberIncrementInterval
        /// 
        /// </summary>
        public int SetMacSequenceNumberIncrementInterval(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacSequenceNumberIncrementInterval, channel, value);
        }
        /// <summary>
        ///Specifies the number of frames after which the sequence number is incremented by 1.    The starting number is the value represented by the sequence number sub-field of the sequence control field.    The sequence number is wrapped to 0 after reaching the value 4095 (2^12-1). The toolkit ignores this attribute if you set the    NIWLANG_MAC_SEQUENCE_NUMBER_INCREMENT_ENABLED attribute to NIWLANG_VAL_FALSE.
        ///    The default value is 0. Valid values are 0 to 4,095, inclusive.
        ///    Set Function: niWLANG_SetMACSequenceNumberIncrementInterval
        ///    Get Function: niWLANG_GetMACSequenceNumberIncrementInterval
        /// 
        /// </summary>
        public int GetMacSequenceNumberIncrementInterval(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacSequenceNumberIncrementInterval, channel, out value);
        }
        /// <summary>
        ///Specifies whether to increment fragment number in a sequence of frames. The starting number is the value represented by    the fragment number sub-field of the NIWLANG_MAC_SEQUENCE_CONTROL attribute. If you set the NIWLANG_MAC_FRAGMENT_NUMBER_INCREMENT_ENABLED    attribute to NIWLANG_VAL_TRUE, the fragment number increments by 1 for every successive frame having the same sequence number.    The fragment number wraps to the starting number when the sequence number increments. The fragment number wraps to 0 after    reaching the value 15. 
        ///    The default value is NIWLANG_VAL_FALSE.
        ///    Set Function: niWLANG_SetMACFragmentNumberIncrementEnabled
        ///    Get Function: niWLANG_GetMACFragmentNumberIncrementEnabled
        /// 
        /// </summary>
        public int SetMacFragmentNumberIncrementEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacFragmentNumberIncrementEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to increment fragment number in a sequence of frames. The starting number is the value represented by    the fragment number sub-field of the NIWLANG_MAC_SEQUENCE_CONTROL attribute. If you set the NIWLANG_MAC_FRAGMENT_NUMBER_INCREMENT_ENABLED    attribute to NIWLANG_VAL_TRUE, the fragment number increments by 1 for every successive frame having the same sequence number.    The fragment number wraps to the starting number when the sequence number increments. The fragment number wraps to 0 after    reaching the value 15. 
        ///    The default value is NIWLANG_VAL_FALSE.
        ///    Set Function: niWLANG_SetMACFragmentNumberIncrementEnabled
        ///    Get Function: niWLANG_GetMACFragmentNumberIncrementEnabled
        /// 
        /// </summary>
        public int GetMacFragmentNumberIncrementEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacFragmentNumberIncrementEnabled, channel, out value);
        }
        /// <summary>
        ///Returns the length, in bytes, of the medium access control (MAC) protocol data unit (MPDU). An MPDU comprises of a MAC header, a frame body, and a    frame check sequence (FCS).    The NIWLANG_MPDU_LENGTH attribute is the sum of the length of MAC header, the value of the NIWLANG_PAYLOAD_DATA_LENGTH attribute, and the length    of FCS, which is 4 bytes. If you disable MAC header and FCS, the lengths of MAC header and FCS are zero.
        ///    Get Function: niWLANG_GetMPDULength
        /// 
        /// </summary>
        public int GetMpduLength(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MpduLength, channel, out value);
        }
        /// <summary>
        ///Specifies whether to enable the medium access control (MAC) frame check sequence (FCS),    as defined in section 7.1.2 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACFCSEnabled
        ///    Get Function: niWLANG_GetMACFCSEnabled
        /// 
        /// </summary>
        public int SetMacFcsEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacFcsEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to enable the medium access control (MAC) frame check sequence (FCS),    as defined in section 7.1.2 of IEEE Standard 802.11-2007 and IEEE Standard 802.11n-2009.
        ///    The default value is NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACFCSEnabled
        ///    Get Function: niWLANG_GetMACFCSEnabled
        /// 
        /// </summary>
        public int GetMacFcsEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacFcsEnabled, channel, out value);
        }
        /// <summary>
        ///Returns the OFDM data rate, in Mbps, depending upon the values of the NIWLANG_CHANNEL_BANDWIDTH and  NIWLANG_OFDM_DATA_RATE attributes,    as defined in section 17.2.3.3 of IEEE Standard 802.11-2007.
        ///    Note: You can read this attribute only if you set the NIWLANG_STANDARD attribute to  NIWLANG_VAL_STANDARD_80211AGJP_OFDM or    NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM. 
        ///    Get Function: niWLANG_GetActualOFDMDataRate
        /// 
        /// </summary>
        public int GetActualOfdmDataRate(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.ActualOfdmDataRate, channel, out value);
        }
        /// <summary>
        ///Specifies the value of the not sounding field of the HT-SIG if you set the NIWLANG_STANDARD    to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM as defined in section 20.3.9.4.3 of the IEEE Standard 802.11n-2009.
        ///    Set Function: niWLANG_SetNotSoundingBit
        ///    Get Function: niWLANG_GetNotSoundingBit
        /// 
        /// </summary>
        public int SetNotSoundingBit(string channel, int value)
        {
            return SetInt32(niWLANGProperties.NotSoundingBit, channel, value);
        }
        /// <summary>
        ///Specifies the value of the not sounding field of the HT-SIG if you set the NIWLANG_STANDARD    to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM as defined in section 20.3.9.4.3 of the IEEE Standard 802.11n-2009.
        ///    Set Function: niWLANG_SetNotSoundingBit
        ///    Get Function: niWLANG_GetNotSoundingBit
        /// 
        /// </summary>
        public int GetNotSoundingBit(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.NotSoundingBit, channel, out value);
        }
        /// <summary>
        ///Specifies whether to apply I/Q impairments such as I DC Offset, Q DC Offset, quadrature skew, and I/Q gain imbalance    to the waveform. 
        ///    The default value is NIWLANG_VAL_TRUE.
        ///    Set Function: niWLANG_SetAllIQImpairmentsEnabled
        ///    Get Function: niWLANG_GetAllIQImpairmentsEnabled
        /// 
        /// </summary>
        public int SetAllIqImpairmentsEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.AllIqImpairmentsEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to apply I/Q impairments such as I DC Offset, Q DC Offset, quadrature skew, and I/Q gain imbalance    to the waveform. 
        ///    The default value is NIWLANG_VAL_TRUE.
        ///    Set Function: niWLANG_SetAllIQImpairmentsEnabled
        ///    Get Function: niWLANG_GetAllIQImpairmentsEnabled
        /// 
        /// </summary>
        public int GetAllIqImpairmentsEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.AllIqImpairmentsEnabled, channel, out value);
        }
        /// <summary>
        ///Specifies whether to add additive white Gaussian noise (AWGN) to the baseband waveform. The toolkit uses the value specified    in the NIWLANG_CARRIER_TO_NOISE_RATIO attribute to add the AWGN.
        ///    The default value is NIWLANG_VAL_FALSE.  
        ///    Set Function: niWLANG_SetAWGNEnabled
        ///    Get Function: niWLANG_GetAWGNEnabled
        /// 
        /// </summary>
        public int SetAwgnEnabled(string channel, int value)
        {
            return SetInt32(niWLANGProperties.AwgnEnabled, channel, value);
        }
        /// <summary>
        ///Specifies whether to add additive white Gaussian noise (AWGN) to the baseband waveform. The toolkit uses the value specified    in the NIWLANG_CARRIER_TO_NOISE_RATIO attribute to add the AWGN.
        ///    The default value is NIWLANG_VAL_FALSE.  
        ///    Set Function: niWLANG_SetAWGNEnabled
        ///    Get Function: niWLANG_GetAWGNEnabled
        /// 
        /// </summary>
        public int GetAwgnEnabled(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.AwgnEnabled, channel, out value);
        }
        /// <summary>
        ///Specifies the carrier-to-noise ratio (CNR), in dB, of the waveform generated. Noise bandwidth is equal to the value of the    NIWLANG_IQ_RATE attribute. The toolkit ignores the NIWLANG_CARRIER_TO_NOISE_RATIO attribute if you set the NIWLANG_AWGN_ENABLED attribute to NIWLANG_VAL_FALSE.    If you set the NIWLANG_STANDARD attribute to  NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, use the channelString to configure    the NIWLANG_CARRIER_TO_NOISE_RATIO attribute. Refer to the Syntax for Channel String help topic for more information about configuring active channels.
        ///    The default value is 50. Valid values are -100 to 100, inclusive.
        ///    Set Function: niWLANG_SetCarrierToNoiseRatio
        ///    Get Function: niWLANG_GetCarrierToNoiseRatio
        /// 
        /// </summary>
        public int SetCarrierToNoiseRatio(string channel, double value)
        {
            return SetDouble(niWLANGProperties.CarrierToNoiseRatio, channel, value);
        }
        /// <summary>
        ///Specifies the carrier-to-noise ratio (CNR), in dB, of the waveform generated. Noise bandwidth is equal to the value of the    NIWLANG_IQ_RATE attribute. The toolkit ignores the NIWLANG_CARRIER_TO_NOISE_RATIO attribute if you set the NIWLANG_AWGN_ENABLED attribute to NIWLANG_VAL_FALSE.    If you set the NIWLANG_STANDARD attribute to  NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, use the channelString to configure    the NIWLANG_CARRIER_TO_NOISE_RATIO attribute. Refer to the Syntax for Channel String help topic for more information about configuring active channels.
        ///    The default value is 50. Valid values are -100 to 100, inclusive.
        ///    Set Function: niWLANG_SetCarrierToNoiseRatio
        ///    Get Function: niWLANG_GetCarrierToNoiseRatio
        /// 
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetCarrierToNoiseRatio(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.CarrierToNoiseRatio, channel, out value);
        }
        #region 14.5

        /// <summary>
        ///Specifies whether the medium access control (MAC) frame is long or short.
        ///    The default value is NIWLANG_VAL_MAC_FRAME_FORMAT_LONG.
        ///    Note: Configure this attribute only when you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM.
        ///       If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use the following active channel    string formats to configure this attribute. 
        ///    An empty string active channel string format if you set the NIWLANG_AMPDU_ENABLED attribute to NIWLANG_VAL_FALSE, or use the 'mpdux' active channel string     if the NIWLANG_AMPDU_ENABLED attribute is set to NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACFrameFormat
        ///    Get Function: niWLANG_GetMACFrameFormat
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetMacFrameFormat(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacFrameFormat, channel, value);
        }

        /// <summary>
        ///Specifies whether the medium access control (MAC) frame is long or short.
        ///    The default value is NIWLANG_VAL_MAC_FRAME_FORMAT_LONG.
        ///    Note: Configure this attribute only when you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM.
        ///       If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use the following active channel    string formats to configure this attribute. 
        ///    An empty string active channel string format if you set the NIWLANG_AMPDU_ENABLED attribute to NIWLANG_VAL_FALSE, or use the 'mpdux' active channel string     if the NIWLANG_AMPDU_ENABLED attribute is set to NIWLANG_VAL_TRUE. 
        ///    Set Function: niWLANG_SetMACFrameFormat
        ///    Get Function: niWLANG_GetMACFrameFormat
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetMacFrameFormat(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacFrameFormat, channel, out value);
        }

        /// <summary>
        ///Specifies the length of Address1 field when the NIWLANG_MAC_FRAME_FORMAT attribute is set to NIWLANG_VAL_MAC_FRAME_FORMAT_SHORT.
        ///       If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use the following active channel    string formats to configure this attribute. 
        ///    An empty string active channel string format if you set the NIWLANG_AMPDU_ENABLED attribute to NIWLANG_VAL_FALSE, or use the 'mpdux' active channel string     if the NIWLANG_AMPDU_ENABLED attribute is set to NIWLANG_VAL_TRUE. 
        ///    The default value is 2. Valid values are 2 and 6.
        ///    Set Function: niWLANG_SetMACAddress1Length
        ///    Get Function: niWLANG_GetMACAddress1Length
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetMacAddress1Length(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacAddress1Length, channel, value);
        }

        /// <summary>
        ///Specifies the length of Address1 field when the NIWLANG_MAC_FRAME_FORMAT attribute is set to NIWLANG_VAL_MAC_FRAME_FORMAT_SHORT.
        ///       If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use the following active channel    string formats to configure this attribute. 
        ///    An empty string active channel string format if you set the NIWLANG_AMPDU_ENABLED attribute to NIWLANG_VAL_FALSE, or use the 'mpdux' active channel string     if the NIWLANG_AMPDU_ENABLED attribute is set to NIWLANG_VAL_TRUE. 
        ///    The default value is 2. Valid values are 2 and 6.
        ///    Set Function: niWLANG_SetMACAddress1Length
        ///    Get Function: niWLANG_GetMACAddress1Length
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetMacAddress1Length(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacAddress1Length, channel, out value);
        }

        /// <summary>
        ///Specifies the length of Address2 field if you set the NIWLANG_MAC_FRAME_FORMAT attribute to NIWLANG_VAL_MAC_FRAME_FORMAT_SHORT.
        ///       If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use the following active channel    string formats to configure this attribute. 
        ///    An empty string active channel string format if you set the NIWLANG_AMPDU_ENABLED attribute to NIWLANG_VAL_FALSE, or use the 'mpdux' active channel string     if the NIWLANG_AMPDU_ENABLED attribute is set to NIWLANG_VAL_TRUE. 
        ///       The default value is 2. Valid values are 2 and 6.
        ///    Set Function: niWLANG_SetMACAddress2Length
        ///    Get Function: niWLANG_GetMACAddress2Length
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetMacAddress2Length(string channel, int value)
        {
            return SetInt32(niWLANGProperties.MacAddress2Length, channel, value);
        }

        /// <summary>
        ///Specifies the length of Address2 field if you set the NIWLANG_MAC_FRAME_FORMAT attribute to NIWLANG_VAL_MAC_FRAME_FORMAT_SHORT.
        ///       If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use the following active channel    string formats to configure this attribute. 
        ///    An empty string active channel string format if you set the NIWLANG_AMPDU_ENABLED attribute to NIWLANG_VAL_FALSE, or use the 'mpdux' active channel string     if the NIWLANG_AMPDU_ENABLED attribute is set to NIWLANG_VAL_TRUE. 
        ///       The default value is 2. Valid values are 2 and 6.
        ///    Set Function: niWLANG_SetMACAddress2Length
        ///    Get Function: niWLANG_GetMACAddress2Length
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetMacAddress2Length(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.MacAddress2Length, channel, out value);
        }

        /// <summary>
        ///Specifies the window length for direct spread spectrum signals. This value is expressed in seconds. If you do not want windowing,    set this attribute to 0.
        ///    This attribute provides power ramp-up and ramp-down for the    entire burst.
        ///    Refer to the Windowing help topic for more information about windowing for DSSS signals.
        ///    The default value is 2 microseconds.
        ///    Set Function: niWLANG_SetDSSSWindowLength
        ///    Get Function: niWLANG_GetDSSSWindowLength
        /// 
        /// </summary>
        public int SetDsssWindowLength(string channel, double value)
        {
            return SetDouble(niWLANGProperties.DsssWindowLength, channel, value);
        }

        /// <summary>
        ///Specifies the window length for direct spread spectrum signals. This value is expressed in seconds. If you do not want windowing,    set this attribute to 0.
        ///    This attribute provides power ramp-up and ramp-down for the    entire burst.
        ///    Refer to the Windowing help topic for more information about windowing for DSSS signals.
        ///    The default value is 2 microseconds.
        ///    Set Function: niWLANG_SetDSSSWindowLength
        ///    Get Function: niWLANG_GetDSSSWindowLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        public int GetDsssWindowLength(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.DsssWindowLength, channel, out value);
        }

        /// <summary>
        ///Specifies the window length for OFDM signals at the sampling rate equal to the channel    bandwidth. This value is expressed in samples. For example, if the window    length is 2, the channel bandwidth is 20 MHz and the oversampling factor is 4, then the    samples over which windowing is applied is 8.
        ///    This attribute provides a smooth, spurious free transition from the end of    one OFDM symbol to the cyclic prefix of the next symbol. If you do not want windowing, set this attribute to 0. 
        ///    Refer to the Windowing help topic for more information about windowing for OFDM signals. 
        ///    The default value is 2. 
        ///     Set Function: niWLANG_SetOFDMWindowLength
        ///    Get Function: niWLANG_GetOFDMWindowLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmWindowLength(string channel, int value)
        {
            return SetInt32(niWLANGProperties.OfdmWindowLength, channel, value);
        }

        /// <summary>
        ///Specifies the window length for OFDM signals at the sampling rate equal to the channel    bandwidth. This value is expressed in samples. For example, if the window    length is 2, the channel bandwidth is 20 MHz and the oversampling factor is 4, then the    samples over which windowing is applied is 8.
        ///    This attribute provides a smooth, spurious free transition from the end of    one OFDM symbol to the cyclic prefix of the next symbol. If you do not want windowing, set this attribute to 0. 
        ///    Refer to the Windowing help topic for more information about windowing for OFDM signals. 
        ///    The default value is 2. 
        ///     Set Function: niWLANG_SetOFDMWindowLength
        ///    Get Function: niWLANG_GetOFDMWindowLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmWindowLength(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.OfdmWindowLength, channel, out value);
        }

        /// <summary>
        ///Specifies the preamble type of  packet if you set the NIWLANG_STANDARD attribute to 80211AH MIMOOFDM as    defined in section 24.3.8.2 of IEEE Standard P802.11ah/D1.3. 
        ///    The default value is Short Preamble.
        ///    Set Function: niWLANG_Set80211ahPreambleType
        ///    Get Function: niWLANG_Get80211ahPreambleType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int Set_80211ahPreambleType(string channel, int value)
        {
            return SetInt32(niWLANGProperties._80211ahPreambleType, channel, value);
        }

        /// <summary>
        ///Specifies the preamble type of  packet if you set the NIWLANG_STANDARD attribute to 80211AH MIMOOFDM as    defined in section 24.3.8.2 of IEEE Standard P802.11ah/D1.3. 
        ///    The default value is Short Preamble.
        ///    Set Function: niWLANG_Set80211ahPreambleType
        ///    Get Function: niWLANG_Get80211ahPreambleType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int Get_80211ahPreambleType(string channel, out int value)
        {
            return GetInt32(niWLANGProperties._80211ahPreambleType, channel, out value);
        }

        /// <summary>
        ///Specifies the value of the uplink indication field of the S1G-SIG field when you    set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM as defined in section 24.3.8.2.1.4 of IEEE Standard P802.11ah/D1.3. 
        ///    The default value is 0.
        ///    Set Function: niWLANG_Set80211ahUplinkIndication
        ///    Get Function: niWLANG_Get80211ahUplinkIndication
        /// 
        /// </summary>
        [Obsolete]
        public int Set_80211ahUplinkIndication(string channel, int value)
        {
            return SetInt32(niWLANGProperties._80211ahUplinkIndication, channel, value);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>    
        /// <returns></returns>
        [Obsolete]
        public int Get_80211ahUplinkIndication(string channel, out int value)
        {
            return GetInt32(niWLANGProperties._80211ahUplinkIndication, channel, out value);
        }


        /// <summary>
        /// Specifies the type of guard interval (cyclic prefix) in an OFDM symbol.
        /// 
        /// </summary>
        ///<param name = "channel">
        ///</param>
        ///<param name = "value">
        /// Specifies whether to use a long or short guard interval in an OFDM symbol. The default value is NIWLANG_VAL_GUARD_INTERVAL_TYPE_LONG.
        /// NIWLANG_VAL_GUARD_INTERVAL_TYPE_LONG (0)
        /// Uses a long preamble, as defined in section 18.2.2.1 of IEEE Standard 802.11b-1999.
        /// NIWLANG_VAL_GUARD_INTERVAL_TYPE_SHORT (1)
        /// Uses a short preamble, as defined in section 18.2.2.2 of IEEE Standard 802.11b-1999. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetOFDMGuardIntervalType
        /// int32 __stdcall SetOFDMGuardIntervalType (niWLANGenerationSession session,
        ///     char channelString[],
        ///     int32 value);
        /// Purpose
        /// Specifies the type of guard interval (cyclic prefix) in an OFDM symbol.
        /// 
        ///</returns>
        public int SetOFDMGuardIntervalType(string channel, int value)
        {
            return SetInt32(niWLANGProperties.GuardIntervalType, channel, value);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMGuardIntervalType(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.GuardIntervalType, channel, out value);
        }

        #endregion

        # region 15.0

        /// <summary>
        ///Specifies whether the format of the incoming OFDM signal is non-high throughput (HT). This attribute is valid only    if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM,    or NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM. A non-HT format signal has only L-LTF, L-STF, and L-SIG symbols in the preamble, which    are similar to 802.11n, 802.11ac, or 802.11af signals with same bandwidth. The payload is modulated in the same manner    as an 802.11a signal with bandwidth of 20 MHz. The payload is repeated with appropriate tone rotation to fill the channel bandwidth. 
        ///    Set Function: niWLANG_SetNonHTModulationMode
        ///    Get Function: niWLANG_GetNonHTModulationMode
        /// 
        /// </summary>
        public int SetNonHTModulationMode(string channel, int nonHTDuplicateModulationMode)
        {
            return SetInt32(niWLANGProperties.NonHtModulationMode, channel, nonHTDuplicateModulationMode);
        }

        /// <summary>
        ///Specifies whether the format of the incoming OFDM signal is non-high throughput (HT). This attribute is valid only    if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM,    or NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM. A non-HT format signal has only L-LTF, L-STF, and L-SIG symbols in the preamble, which    are similar to 802.11n, 802.11ac, or 802.11af signals with same bandwidth. The payload is modulated in the same manner    as an 802.11a signal with bandwidth of 20 MHz. The payload is repeated with appropriate tone rotation to fill the channel bandwidth. 
        ///    Set Function: niWLANG_SetNonHTModulationMode
        ///    Get Function: niWLANG_GetNonHTModulationMode
        /// 
        /// </summary>
        public int GetNonHTModulationMode(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.NonHtModulationMode, channel, out value);
        }

        /// <summary>
        ///Specifies whether the format of the incoming OFDM signal is non-high throughput (HT). This attribute is valid only    if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM,    or NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM. A non-HT format signal has only L-LTF, L-STF, and L-SIG symbols in the preamble, which    are similar to 802.11n, 802.11ac, or 802.11af signals with same bandwidth. The payload is modulated in the same manner    as an 802.11a signal with bandwidth of 20 MHz. The payload is repeated with appropriate tone rotation to fill the channel bandwidth. 
        ///    Set Function: niWLANG_SetNonHTModulationMode
        ///    Get Function: niWLANG_GetNonHTModulationMode
        /// 
        /// </summary>
        public int SetNonHtModulationMode(string channel, int nonHTDuplicateModulationMode)
        {
            return SetInt32(niWLANGProperties.NonHtModulationMode, channel, nonHTDuplicateModulationMode);
        }

        /// <summary>
        ///Specifies whether the format of the incoming OFDM signal is non-high throughput (HT). This attribute is valid only    if you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AC_MIMO_OFDM,    or NIWLANG_VAL_STANDARD_80211AF_MIMO_OFDM. A non-HT format signal has only L-LTF, L-STF, and L-SIG symbols in the preamble, which    are similar to 802.11n, 802.11ac, or 802.11af signals with same bandwidth. The payload is modulated in the same manner    as an 802.11a signal with bandwidth of 20 MHz. The payload is repeated with appropriate tone rotation to fill the channel bandwidth. 
        ///    Set Function: niWLANG_SetNonHTModulationMode
        ///    Get Function: niWLANG_GetNonHTModulationMode
        /// 
        /// </summary>
        public int GetNonHtModulationMode(string channel, out int value)
        {
            return GetInt32(niWLANGProperties.NonHtModulationMode, channel, out value);
        }

        /// <summary>
        /// Calculates the carrier frequency of 802.11af channels, as defined in section 23.3.14 of IEEE Standard 802.11af-2013.
        /// 
        /// </summary>
        ///<param name = "channelStartingFrequency">
        /// Specifies the start frequency of the frequency band. The default value is 45 MHz. The channel start frequency is given by the following formula: 
        /// Channel Starting Frequency (Hz) = Channel Starting Factor * 500 kHz
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelBandwidth">
        /// Specifies the channel bandwidth used for transmitting the signal. The default value is 6 MHz.
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelNumber">
        /// Specifies the offset of the center frequency, in increments of the channel bandwidth used for transmitting the signal. This value is expressed in Hz. The default value is 1 MHz.
        /// 
        ///</param>
        ///<param name = "TVHTMode">
        /// Specifies the mode of the 802.11af signal transmission. 
        /// The default value is NIWLANG_VAL_TVHT_MODE_4.
        /// NIWLANG_VAL_TVHT_MODE_1(0)
        ///  Specifies the TVHT mode representing a single Basic Channel Unit (BCU).
        /// NIWLANG_VAL_TVHT_MODE_2C(1)
        /// Specifies the TVHT mode representing two contiguous BCUs.
        /// NIWLANG_VAL_TVHT_MODE_2N(2)
        /// Specifies the TVHT mode representing two noncontiguous BCUs.
        /// NIWLANG_VAL_TVHT_MODE_4C(3)
        /// Specifies the TVHT mode representing four contiguous BCUs.
        /// NIWLANG_VAL_TVHT_MODE_4N(4)
        /// Specifies the TVHT mode representing two noncontiguous frequency segments, each of which are composed of two BCUs.
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Returns the carrier frequency. This value is expressed in Hz. The function calculates the carrier frequency using the following equation:
        /// carrier frequency (Hz) = channel starting frequency (Hz) + (TVHT_W * channel number + channel center frequency correction (Hz)
        /// where channel center frequency correction (Hz) is used to adjust the carrier frequency in the different TVHT modes. It is 0 for NIWLANG_VAL_TVHT_MODE_1 and NIWLANG_VAL_TVHT_MODE_2N, 0.5 * TVHT_W for NIWLANG_VAL_TVHT_MODE_2C and NIWLANG_VAL_TVHT_MODE_4N and 1.5 * TVHT_W for NIWLANG_VAL_TVHT_MODE_4C.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_ChannelNumberToCarrierFrequency80211af
        /// int32 __stdcall niWLANG_ChannelNumberToCarrierFrequency80211af (float64 channelStartingFrequency,
        ///     float64 channelBandwidth,
        ///     int32 channelNumber,
        ///     int32 TVHTMode,
        ///     float64 *carrierFrequency);
        /// Purpose
        /// Calculates the carrier frequency of 802.11af channels, as defined in section 23.3.14 of IEEE Standard 802.11af-2013.
        /// 
        ///</returns>
        public int ChannelNumberToCarrierFrequency80211af(double channelStartingFrequency, double channelBandwidth, int channelNumber, int TVHTMode, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANG_ChannelNumberToCarrierFrequency80211af(channelStartingFrequency, channelBandwidth, channelNumber, TVHTMode, out  carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        # endregion

        # region 15.5

        /// <summary>
        ///Specifies whether to use a single generator or two generators for each channel of a multi-segment (80+80) MHz 802.11ac signal. This attribute is    applicable when you set the NIWLANG_NUMBER_OF_SEGMENTS attribute to 2 and the channel bandwidth is    80 MHz. When you set this attribute to NIWLANG_VAL_SINGLE_GENERATOR, you have to specify the value of the    NIWLANG_CARRIER_FREQUENCY attribute for both the segments. 
        ///    The default value is NIWLANG_VAL_MULTIPLE_GENERATORS. 
        ///    Set Function: niWLANG_SetMultiSegmentGenerationMode
        ///    Get Function: niWLANG_GetMultiSegmentGenerationMode
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetMultiSegmentGenerationMode(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.MultiSegmentGenerationMode, channelString, value);
        }

        /// <summary>
        ///Specifies whether to use a single generator or two generators for each channel of a multi-segment (80+80) MHz 802.11ac signal. This attribute is    applicable when you set the NIWLANG_NUMBER_OF_SEGMENTS attribute to 2 and the channel bandwidth is    80 MHz. When you set this attribute to NIWLANG_VAL_SINGLE_GENERATOR, you have to specify the value of the    NIWLANG_CARRIER_FREQUENCY attribute for both the segments. 
        ///    The default value is NIWLANG_VAL_MULTIPLE_GENERATORS. 
        ///    Set Function: niWLANG_SetMultiSegmentGenerationMode
        ///    Get Function: niWLANG_GetMultiSegmentGenerationMode
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetMultiSegmentGenerationMode(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.MultiSegmentGenerationMode, channelString, out value);
        }

        # endregion

        #region 17.0

        /// <summary>
        ///Specifies the size of resource unit (RU) in terms of the number of subcarriers    for the 802.11ax signal. You must configure this attribute you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    When you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU,    this attribute supports only NIWLANG_VAL_RU_SIZE_242 and NIWLANG_VAL_RU_SIZE_106 as valid values. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, use    'userx' as the active channel string format, if the NIWLANG_PPDU_TYPE attribute is set    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, or use an empty string as    the string format if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU to configure this attribute. 
        ///    The default value is NIWLANG_VAL_RU_SIZE_26. 
        ///    Set Function: niWLANG_SetRUSize
        ///    Get Function: niWLANG_GetRUSize
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetRUSize(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.RuSize, channelString, value);
        }

        /// <summary>
        ///Specifies the size of resource unit (RU) in terms of the number of subcarriers    for the 802.11ax signal. You must configure this attribute you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    When you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU,    this attribute supports only NIWLANG_VAL_RU_SIZE_242 and NIWLANG_VAL_RU_SIZE_106 as valid values. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, use    'userx' as the active channel string format, if the NIWLANG_PPDU_TYPE attribute is set    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, or use an empty string as    the string format if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU to configure this attribute. 
        ///    The default value is NIWLANG_VAL_RU_SIZE_26. 
        ///    Set Function: niWLANG_SetRUSize
        ///    Get Function: niWLANG_GetRUSize
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetRUSize(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.RuSize, channelString, out value);
        }

        /// <summary>
        ///Specifies the location of the resource unit (RU), in terms of the index of 26-tone RU, assuming the    entire bandwidth is composed of 26-tone RUs in the 802.11ax signal. Refer    to the Configuring RU Offset topic in NI LabWindows/CVI WLAN Analysis Toolkit Reference Help for more information. 
        ///    This attribute is valid only    if you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    The valid values are as follows: 
        ///    If the NIWLANG_CHANNEL_BANDWIDTH is 20 MHz and the NIWLANG_NUMBER_OF_SEGMENTS is 1, the valid values are 0 to 8. 
        ///    If the NIWLANG_CHANNEL_BANDWIDTH is 40 MHz and the NIWLANG_NUMBER_OF_SEGMENTS is 1, the valid values are 0 to 17. 
        ///    If the NIWLANG_CHANNEL_BANDWIDTH is 80 MHz and the NIWLANG_NUMBER_OF_SEGMENTS is 1, the valid values are 0 to 36. 
        ///    If the NIWLANG_CHANNEL_BANDWIDTH is 160 MHz and the NIWLANG_NUMBER_OF_SEGMENTS is 1, the valid values are 0 to 73. 
        ///    If the NIWLANG_CHANNEL_BANDWIDTH is 80 MHz and the NIWLANG_NUMBER_OF_SEGMENTS is 2, the valid values are 0 to 73. 
        ///    The default value is 0. 
        ///    Set Function: niWLANG_SetRUOffset
        ///    Get Function: niWLANG_GetRUOffset
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetRUOffset(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.RuOffset, channelString, value);
        }

        /// <summary>
        ///Specifies the location of the resource unit (RU), in terms of the index of 26-tone RU, assuming the    entire bandwidth is composed of 26-tone RUs in the 802.11ax signal. Refer    to the Configuring RU Offset topic in NI LabWindows/CVI WLAN Analysis Toolkit Reference Help for more information. 
        ///    This attribute is valid only    if you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    The valid values are as follows: 
        ///    If the NIWLANG_CHANNEL_BANDWIDTH is 20 MHz and the NIWLANG_NUMBER_OF_SEGMENTS is 1, the valid values are 0 to 8. 
        ///    If the NIWLANG_CHANNEL_BANDWIDTH is 40 MHz and the NIWLANG_NUMBER_OF_SEGMENTS is 1, the valid values are 0 to 17. 
        ///    If the NIWLANG_CHANNEL_BANDWIDTH is 80 MHz and the NIWLANG_NUMBER_OF_SEGMENTS is 1, the valid values are 0 to 36. 
        ///    If the NIWLANG_CHANNEL_BANDWIDTH is 160 MHz and the NIWLANG_NUMBER_OF_SEGMENTS is 1, the valid values are 0 to 73. 
        ///    If the NIWLANG_CHANNEL_BANDWIDTH is 80 MHz and the NIWLANG_NUMBER_OF_SEGMENTS is 2, the valid values are 0 to 73. 
        ///    The default value is 0. 
        ///    Set Function: niWLANG_SetRUOffset
        ///    Get Function: niWLANG_GetRUOffset
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetRUOffset(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.RuOffset, channelString, out value);
        }

        /// <summary>
        ///Specifies the per user power scaling value of the 802.11ax signal when you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. This value is expressed in dB. The power scaling value is with reference    to the user with index 0. The toolkit ignores the attribute value, if it is specified for the user with index 0. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_OFDM, you muse    use 'userx' as the active channel string format to configure this attribute. 
        ///       The default value is 0. The valid values are -100 to 100, inclusive. 
        ///    Set Function:  niWLANG_SetRelativePower
        ///    Get Function:  niWLANG_GetRelativePower
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetRelativePower(string channelString, double value)
        {
            return SetDouble(niWLANGProperties.RelativePower, channelString, value);
        }

        /// <summary>
        ///Specifies the per user power scaling value of the 802.11ax signal when you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. This value is expressed in dB. The power scaling value is with reference    to the user with index 0. The toolkit ignores the attribute value, if it is specified for the user with index 0. 
        ///     If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_OFDM, you muse    use 'userx' as the active channel string format to configure this attribute. 
        ///       The default value is 0. The valid values are -100 to 100, inclusive. 
        ///    Set Function:  niWLANG_SetRelativePower
        ///    Get Function:  niWLANG_GetRelativePower
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetRelativePower(string channelString, out double value)
        {
            return GetDouble(niWLANGProperties.RelativePower, channelString, out value);
        }

        /// <summary>
        ///Specifies the per resource unit (RU) amplitude scaling for the HE modulated fields    of 802.11ax signals, when you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_MU_PPDU. The value of this attribute    must be the same across all users.    An RU is defined by the NIWLANG_RU_SIZE and NIWLANG_RU_OFFSET attributes. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_OFDM, you muse    use 'userx' as the active channel string format to configure this attribute. 
        ///    The default value is 1. The valid values are 0.1 to 10, inclusive. To convert this value to dB, use the following formula: 
        ///    Power Boost Factor (dB) = 20 * log (Power Boost Factor) 
        ///    Set Function: niWLANG_SetPowerBoostFactor
        ///    Get Function: niWLANG_GetPowerBoostFactor
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetPowerBoostFactor(string channelString, double value)
        {
            return SetDouble(niWLANGProperties.PowerBoostFactor, channelString, value);
        }

        /// <summary>
        ///Specifies the per resource unit (RU) amplitude scaling for the HE modulated fields    of 802.11ax signals, when you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_MU_PPDU. The value of this attribute    must be the same across all users.    An RU is defined by the NIWLANG_RU_SIZE and NIWLANG_RU_OFFSET attributes. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_OFDM, you muse    use 'userx' as the active channel string format to configure this attribute. 
        ///    The default value is 1. The valid values are 0.1 to 10, inclusive. To convert this value to dB, use the following formula: 
        ///    Power Boost Factor (dB) = 20 * log (Power Boost Factor) 
        ///    Set Function: niWLANG_SetPowerBoostFactor
        ///    Get Function: niWLANG_GetPowerBoostFactor
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetPowerBoostFactor(string channelString, out double value)
        {
            return GetDouble(niWLANGProperties.PowerBoostFactor, channelString, out value);
        }

        /// <summary>
        ///Specifies the number of HE-LTF symbols in the transmitted 802.11ax signal when you set    the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    The default value is -1, which indicates that the value is derived from the maximum index of space time streams    across users. The valid values are -1, 1, 2, 4, 6, and 8. 
        ///    Set Function: niWLANG_SetNumberOfHELTFSymbols
        ///    Get Function: niWLANG_GetNumberOfHELTFSymbols
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetNumberOfHELTFSymbols(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.NumberOfHeLtfSymbols, channelString, value);
        }

        /// <summary>
        ///Specifies the number of HE-LTF symbols in the transmitted 802.11ax signal when you set    the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    The default value is -1, which indicates that the value is derived from the maximum index of space time streams    across users. The valid values are -1, 1, 2, 4, 6, and 8. 
        ///    Set Function: niWLANG_SetNumberOfHELTFSymbols
        ///    Get Function: niWLANG_GetNumberOfHELTFSymbols
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetNumberOfHELTFSymbols(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.NumberOfHeLtfSymbols, channelString, out value);
        }

        /// <summary>
        ///Specifies 11 LSBs of AID of the user in a 802.11ax signal when you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU and AID12 of    the user in a 802.11ax signal when you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    When the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_MU_PPDU, the valid    values are 0 to 2047. When the NIWLANG_PPDU_TYPE attribute is set    to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the valid values are 0 to 4095. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, use    'userx' as the active channel string format to configure this attirbute, if the NIWLANG_PPDU_TYPE attribute is set    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    The default value is 0. 
        ///    Set Function: niWLANG_SetSTAID
        ///    Get Function: niWLANG_GetSTAID
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetSTAID(string channelString, int value)
        {

            return SetInt32(niWLANGProperties.StaId, channelString, value);
        }

        /// <summary>
        ///Specifies 11 LSBs of AID of the user in a 802.11ax signal when you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU and AID12 of    the user in a 802.11ax signal when you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    When the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_MU_PPDU, the valid    values are 0 to 2047. When the NIWLANG_PPDU_TYPE attribute is set    to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the valid values are 0 to 4095. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, use    'userx' as the active channel string format to configure this attirbute, if the NIWLANG_PPDU_TYPE attribute is set    to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    The default value is 0. 
        ///    Set Function: niWLANG_SetSTAID
        ///    Get Function: niWLANG_GetSTAID
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetSTAID(string channelString, out int value)
        {

            return GetInt32(niWLANGProperties.StaId, channelString, out value);
        }

        /// <summary>
        ///Specifies the value of the modulation and coding scheme (MCS) index of the HE-SIG-B field of 802.11ax    signal when you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_MU_PPDU. 
        ///    The default value is 0. The valid values are 0 to 5, inclusive. 
        ///    Set Function: niWLANG_SetHESIGBMCSIndex
        ///    Get Function: niWLANG_GetHESIGBMCSIndex
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetHESIGBMCSIndex(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.HeSigBMcsIndex, channelString, value);
        }

        /// <summary>
        ///Specifies the value of the modulation and coding scheme (MCS) index of the HE-SIG-B field of 802.11ax    signal when you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_MU_PPDU. 
        ///    The default value is 0. The valid values are 0 to 5, inclusive. 
        ///    Set Function: niWLANG_SetHESIGBMCSIndex
        ///    Get Function: niWLANG_GetHESIGBMCSIndex
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetHESIGBMCSIndex(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.HeSigBMcsIndex, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetHESIGBDualCarrierModulationEnabled(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.HeSigBDualCarrierModulationEnabled, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetHESIGBDualCarrierModulationEnabled(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.HeSigBDualCarrierModulationEnabled, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetDualCarrierModulationEnabled(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.DualCarrierModulationEnabled, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetDualCarrierModulationEnabled(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.DualCarrierModulationEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies the value of the uplink indication field of the S1G-SIG field when    you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM. This attribute also specifies    whether the packet is uplink or downlink when you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM. 
        ///    Refer to section 24.3.8.2.1.4 of IEEE Standard P802.11ah/D1.3 for more information about the 80211ah Uplink Indication. 
        ///    The default value is NIWLANG_VAL_TRANSMISSION_MODE_DL. 
        ///    Set Function: niWLANG_SetTransmissionMode
        ///    Get Function: niWLANG_GetTransmissionMode
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetTransmissionMode(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.TransmissionMode, channelString, value);
        }

        /// <summary>
        ///Specifies the value of the uplink indication field of the S1G-SIG field when    you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM. This attribute also specifies    whether the packet is uplink or downlink when you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM. 
        ///    Refer to section 24.3.8.2.1.4 of IEEE Standard P802.11ah/D1.3 for more information about the 80211ah Uplink Indication. 
        ///    The default value is NIWLANG_VAL_TRANSMISSION_MODE_DL. 
        ///    Set Function: niWLANG_SetTransmissionMode
        ///    Get Function: niWLANG_GetTransmissionMode
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetTransmissionMode(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.TransmissionMode, channelString, out value);
        }

        /// <summary>
        ///Specifies the additional scaling factor applied to the waveform when you set    the NIWLANG_AUTO_HEADROOM_ENABLED attribute to NIWLANG_VAL_TRUE. This value is expressed in dB. 
        ///    The toolkit ignores this attribute, if you set NIWLANG_AUTO_HEADROOM_ENABLED attribute to NIWLANG_VAL_FALSE. 
        ///    The default value is 2. 
        ///    Set Function: niWLANG_SetFullscaleBackoff
        ///    Get Function: niWLANG_GetFullscaleBackoff
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetFullscaleBackoff(string channelString, double value)
        {
            return SetDouble(niWLANGProperties.FullscaleBackOff, channelString, value);
        }

        /// <summary>
        ///Specifies the additional scaling factor applied to the waveform when you set    the NIWLANG_AUTO_HEADROOM_ENABLED attribute to NIWLANG_VAL_TRUE. This value is expressed in dB. 
        ///    The toolkit ignores this attribute, if you set NIWLANG_AUTO_HEADROOM_ENABLED attribute to NIWLANG_VAL_FALSE. 
        ///    The default value is 2. 
        ///    Set Function: niWLANG_SetFullscaleBackoff
        ///    Get Function: niWLANG_GetFullscaleBackoff
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetFullscaleBackoff(string channelString, out double value)
        {

            return GetDouble(niWLANGProperties.FullscaleBackOff, channelString, out value);
        }

        /// <summary>
        ///Specifies the packet fields used to compute the average power value to apply waveform    power scaling. This attribute is valid when you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU. 
        ///    The default value is NIWLANG_VAL_AVERAGE_POWER_REFERENCE_NON_BOOSTED_FIELDS. 
        ///    Set Function: niWLANG_SetAveragePowerReference
        ///    Get Function: niWLANG_GetAveragePowerReference
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetAveragePowerReference(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.AveragePowerReference, channelString, value);
        }

        /// <summary>
        ///Specifies the packet fields used to compute the average power value to apply waveform    power scaling. This attribute is valid when you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_MU_PPDU or NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU. 
        ///    The default value is NIWLANG_VAL_AVERAGE_POWER_REFERENCE_NON_BOOSTED_FIELDS. 
        ///    Set Function: niWLANG_SetAveragePowerReference
        ///    Get Function: niWLANG_GetAveragePowerReference
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetAveragePowerReference(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.AveragePowerReference, channelString, out value);
        }

        /// <summary>
        ///Returns the array of sample positions of start of the burst, within the waveform. 
        ///    Set Function: niWLANG_SetBurstStartLocations
        ///    Get Function: niWLANG_GetBurstStartLocations
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="dataArray"></param>
        /// <param name="actualNumDataArrayElements"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetBurstStartLocations(string channelString, int[] dataArray, out int actualNumDataArrayElements)
        {
            int pInvokeResult = PInvoke.niWLANG_GetBurstStartLocations(Handle, channelString, dataArray, dataArray.Length, out actualNumDataArrayElements);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///Returns the array of sample positions of end of the burst, within the waveform. 
        ///    Set Function: niWLANG_SetBurstStopLocations
        ///    Get Function: niWLANG_GetBurstStopLocations
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="dataArray"></param>
        /// <param name="actualNumDataArrayElements"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetBurstStopLocations(string channelString, int[] dataArray, out int actualNumDataArrayElements)
        {
            int pInvokeResult = PInvoke.niWLANG_GetBurstStopLocations(Handle, channelString, dataArray, dataArray.Length, out actualNumDataArrayElements);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetAPTXPower(string channelString, int value)
         {
            return SetInt32(niWLANGProperties.TriggerFrameApTxPower, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetAPTXPower(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.TriggerFrameApTxPower, channelString, out value);
        }

        /// <summary>
        /// Specifies the value of the Target RSSI field of the Trigger frame. The power values -110 dBm to -20 dBm are mapped    to the field values 0 to 90, respectively. To specify maximum transmit power for the assigned MCS, you must set a value of 127.
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM,    you must use 'userx' as the active channel string format to configure this attribute    if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    The default value is 78, which is the corresponding power value -32 dBm. The valid values are 0 to 127, both inclusive. 
        ///    Set Function: niWLANG_SetTargetRSSI
        ///    Get Function: niWLANG_GetTargetRSSI
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetTargetRSSI(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.TriggerFrameTargetRssi, channelString, value);

        }

        /// <summary>
        ///Specifies the value of the Target RSSI field of the Trigger frame. The power values -110 dBm to -20 dBm are mapped    to the field values 0 to 90, respectively. To specify maximum transmit power for the assigned MCS, you must set a value of 127.
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM,    you must use 'userx' as the active channel string format to configure this attribute    if the NIWLANG_PPDU_TYPE attribute is set to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    The default value is 78, which is the corresponding power value -32 dBm. The valid values are 0 to 127, both inclusive. 
        ///    Set Function: niWLANG_SetTargetRSSI
        ///    Get Function: niWLANG_GetTargetRSSI
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetTargetRSSI(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.TriggerFrameTargetRssi, channelString, out value);
        }

        /// <summary>
        ///Specifies the time delay for each user within an 802.11ax Trigger-Based signal. This value    is expressed in seconds. You must set the NIWLANG_STANDARD attribute    to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. Use this attribute to introduce relative time delays between    multiple users within an 802.11ax Trigger-Based signal. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, use    'userx' as the active channel string format, if you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    The default value is 0. 
        ///    Set Function: niWLANG_SetTimeDelay
        ///    Get Function: niWLANG_GetTimeDelay
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetTimeDelay(string channelString, double value)
        {
            return SetDouble(niWLANGProperties.TimeDelay, channelString, value);
        }

        /// <summary>
        ///Specifies the time delay for each user within an 802.11ax Trigger-Based signal. This value    is expressed in seconds. You must set the NIWLANG_STANDARD attribute    to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. Use this attribute to introduce relative time delays between    multiple users within an 802.11ax Trigger-Based signal. 
        ///    If you set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM, use    'userx' as the active channel string format, if you set the NIWLANG_PPDU_TYPE attribute    to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU. 
        ///    The default value is 0. 
        ///    Set Function: niWLANG_SetTimeDelay
        ///    Get Function: niWLANG_GetTimeDelay
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetTimeDelay(string channelString, out double value)
        {
            return GetDouble(niWLANGProperties.TimeDelay, channelString, out value);
        }

        /// <summary>
        ///Specifies the HE-LTF symbol size in the 802.11ax signals. The IEEE Standard 802.11ax specifies the    following combinations of the HE-LTF symbol size and the NIWLANG_GUARD_INTERVAL attribute. 
        ///    If you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, NIWLANG_VAL_PPDU_TYPE_MU_PPDU or    NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANG_HE_LTF_SIZE attribute    is NIWLANG_VAL_HE_LTF_SIZE_4X, and the NIWLANG_GUARD_INTERVAL attribute value is 1/4. 
        ///    If you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, NIWLANG_VAL_PPDU_TYPE_MU_PPDU or    NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANG_HE_LTF_SIZE attribute value    is NIWLANG_VAL_HE_LTF_SIZE_2X, and the NIWLANG_GUARD_INTERVAL attribute    value is 1/8. 
        ///    If you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, NIWLANG_VAL_PPDU_TYPE_MU_PPDU or    NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANG_HE_LTF_SIZE attribute value    is NIWLANG_VAL_HE_LTF_SIZE_2X or NIWLANG_VAL_HE_LTF_SIZE_4X, and the NIWLANG_GUARD_INTERVAL attribute value    is 1/16. 
        ///    If you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the NIWLANG_HE_LTF_SIZE attribute    value is NIWLANG_VAL_HE_LTF_SIZE_4X and the NIWLANG_GUARD_INTERVAL attribute value    is 1/4. 
        ///    If you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the NIWLANG_HE_LTF_SIZE attribute    value is NIWLANG_VAL_HE_LTF_SIZE_2X and the NIWLANG_GUARD_INTERVAL attribute value is 1/8. 
        ///    The default value is NIWLANG_VAL_HE_LTF_SIZE_AUTO. 
        ///    Set Function: niWLANG_SetOFDMHELTFSize
        ///    Get Function: niWLANG_GetOFDMHELTFSize
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetOFDMHELTFSize(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.HeLtfSize, channelString, value);
        }

        /// <summary>
        ///Specifies the HE-LTF symbol size in the 802.11ax signals. The IEEE Standard 802.11ax specifies the    following combinations of the HE-LTF symbol size and the NIWLANG_GUARD_INTERVAL attribute. 
        ///    If you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, NIWLANG_VAL_PPDU_TYPE_MU_PPDU or    NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANG_HE_LTF_SIZE attribute    is NIWLANG_VAL_HE_LTF_SIZE_4X, and the NIWLANG_GUARD_INTERVAL attribute value is 1/4. 
        ///    If you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, NIWLANG_VAL_PPDU_TYPE_MU_PPDU or    NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANG_HE_LTF_SIZE attribute value    is NIWLANG_VAL_HE_LTF_SIZE_2X, and the NIWLANG_GUARD_INTERVAL attribute    value is 1/8. 
        ///    If you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_SU_PPDU, NIWLANG_VAL_PPDU_TYPE_MU_PPDU or    NIWLANG_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANG_HE_LTF_SIZE attribute value    is NIWLANG_VAL_HE_LTF_SIZE_2X or NIWLANG_VAL_HE_LTF_SIZE_4X, and the NIWLANG_GUARD_INTERVAL attribute value    is 1/16. 
        ///    If you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the NIWLANG_HE_LTF_SIZE attribute    value is NIWLANG_VAL_HE_LTF_SIZE_4X and the NIWLANG_GUARD_INTERVAL attribute value    is 1/4. 
        ///    If you set the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the NIWLANG_HE_LTF_SIZE attribute    value is NIWLANG_VAL_HE_LTF_SIZE_2X and the NIWLANG_GUARD_INTERVAL attribute value is 1/8. 
        ///    The default value is NIWLANG_VAL_HE_LTF_SIZE_AUTO. 
        ///    Set Function: niWLANG_SetOFDMHELTFSize
        ///    Get Function: niWLANG_GetOFDMHELTFSize
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetOFDMHELTFSize(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.HeLtfSize, channelString, out value);
        }

        /// <summary>
        ///Specifies the LO frequency offset to be used when you set the NIWLANG_LO_FREQUENCY_OFFSET_MODE attribute    to NIWLANG_VAL_LO_FREQUENCY_OFFSET_MODE_USER_DEFINED. 
        ///    The default value is 0 Hz. 
        ///    Set Function: niWLANG_SetLOFrequencyOffset
        ///    Get Function: niWLANG_GetLOFrequencyOffset
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetLOFrequencyOffset(string channelString, double value)
        {
            return SetDouble(niWLANGProperties.LOFrequencyOffset, channelString, value);
        }

        /// <summary>
        ///Specifies the LO frequency offset to be used when you set the NIWLANG_LO_FREQUENCY_OFFSET_MODE attribute    to NIWLANG_VAL_LO_FREQUENCY_OFFSET_MODE_USER_DEFINED. 
        ///    The default value is 0 Hz. 
        ///    Set Function: niWLANG_SetLOFrequencyOffset
        ///    Get Function: niWLANG_GetLOFrequencyOffset
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetLOFrequencyOffset(string channelString, out double value)
        {
            return GetDouble(niWLANGProperties.LOFrequencyOffset, channelString, out value);
        }

        /// <summary>
        ///Specifies how the LO frequency offset is derived to configure frequency on the NI RF vector signal generators and the NI    synthesizers in the niWLANG_RFSGConfigureFrequecySingleLO and niWLANG_RFSGConfigureFrequecyMultipleLO functions. The toolkit    ignores this attribute if you do not use NI 5840 or NI 5646R devices. 
        ///    The default value is NIWLANG_VAL_LO_FREQUENCY_OFFSET_MODE_AUTO. 
        ///    Set Function: niWLANG_SetLOFrequencyOffsetMode
        ///    Get Function: niWLANG_GetLOFrequencyOffsetMode
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetLOFrequencyOffsetMode(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.LOFrequencyOffsetMode, channelString, value);
        }

        /// <summary>
        ///Specifies how the LO frequency offset is derived to configure frequency on the NI RF vector signal generators and the NI    synthesizers in the niWLANG_RFSGConfigureFrequecySingleLO and niWLANG_RFSGConfigureFrequecyMultipleLO functions. The toolkit    ignores this attribute if you do not use NI 5840 or NI 5646R devices. 
        ///    The default value is NIWLANG_VAL_LO_FREQUENCY_OFFSET_MODE_AUTO. 
        ///    Set Function: niWLANG_SetLOFrequencyOffsetMode
        ///    Get Function: niWLANG_GetLOFrequencyOffsetMode
        /// 
        /// </summary>
        /// <param name = "channelString">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetLOFrequencyOffsetMode(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.LOFrequencyOffsetMode, channelString, out value);
        }

        /// <summary>
        /// Configures the frequency on NI RF vector signal generators and NI RF synthesizers. NI RF synthesizers are used as external local oscillator (LO) devices. This function also configures LO frequency offset based on the NIWLANG_LO_FREQUENCY_OFFSET_MODE and NIWLANG_LO_FREQUENCY_OFFSET attributes. It also configures the NIWLANG_CARRIER_FREQUENCY attribute.
        ///  You must ensure that after a frequency configuration change, the output of the external LO device settles before generating the WLAN signal. You must use one of the following programming flows:
        /// Before calling the niWLANG_RFSGConfigureFrequencySingleLO function, if the external LO device is in generation state, ensure that it is brought in configuration state, by stopping signal generation. Initiate signal generation on the external LO device after calling the niWLANG_RFSGConfigureFrequencySingleLO function.
        /// You may choose to do on-the-fly frequency change on the external LO device while the device is in generation state. You must allow it's output to settle by calling the niRFSG_WaitUntilSettled function after the niWLANG_RFSGConfigureFrequencySingleLO function.
        /// </summary>
        ///<param name = "rfsgHandles">
        /// Specifies a reference to an NI-RFSG instrument session. This parameter is obtained from the niRFSG_init or niRFSG_InitWithOptions functions and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "LOSource">
        /// Specifies whether to use the internal or the external LO source. This value is applicable only for the first RFSG device if the rfsgLODaisyChainEnabled parameter is set to TRUE. The default value is NIWLANG_VAL_LO_SOURCE_ONBOARD.  
        /// NIWLANG_VAL_LO_SOURCE_EXTERNAL (0)
        /// Uses an external LO as the LO source.
        /// NIWLANG_VAL_LO_SOURCE_ONBOARD (2)
        /// Uses an internal LO as the LO source.
        /// 
        ///</param>
        ///<param name = "exteralLOHandle">
        /// Identifies the instrument session of the external LO device. This parameter is obtained from the niRFSG_Initialize function or the niRFSG_InitializeWithOptions function. 
        /// 
        ///</param>
        ///<param name = "carrierFrequencies">
        /// Specifies  the carrier frequency used to generate signals. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "rfsgLODaisyChainEnabled">
        /// Specifies whether to export the LO signal from one RFSG device to the next. The default value is FALSE.
        /// 
        ///</param>
        ///<param name = "LOExportToExternalDevicesEnabled">
        /// Specifies whether to export the LO signal from each RFSG device on its LO OUT terminal, which you can use to share the LO signal with an external device. An example of an external device would be an RFSA device. The default value is FALSE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_RFSGConfigureFrequencySingleLO
        /// int32 __stdcall niWLANG_RFSGConfigureFrequencySingleLO (niWLANGenerationSession session, 
        ///     ViSession rfsgSessions[], 
        ///     int32 numberOfRFSGSessions,
        ///     int32 LOSource,
        ///     ViSession externalLOHandle,
        ///     float64 carrierFrequency, 
        ///     int32 rfsgLODaisyChainEnabled,
        ///     int32 LOExportToExternalDevicesEnabled);    
        /// Purpose
        /// Configures the frequency on NI RF vector signal generators and NI RF synthesizers. NI RF synthesizers are used as external local oscillator (LO) devices. This function also configures LO frequency offset based on the NIWLANG_LO_FREQUENCY_OFFSET_MODE and NIWLANG_LO_FREQUENCY_OFFSET attributes. It also configures the NIWLANG_CARRIER_FREQUENCY attribute.
        ///  You must ensure that after a frequency configuration change, the output of the external LO device settles before generating the WLAN signal. You must use one of the following programming flows:
        /// Before calling the niWLANG_RFSGConfigureFrequencySingleLO function, if the external LO device is in generation state, ensure that it is brought in configuration state, by stopping signal generation. Initiate signal generation on the external LO device after calling the niWLANG_RFSGConfigureFrequencySingleLO function.
        /// You may choose to do on-the-fly frequency change on the external LO device while the device is in generation state. You must allow it's output to settle by calling the niRFSG_WaitUntilSettled function after the niWLANG_RFSGConfigureFrequencySingleLO function.
        /// 
        ///</returns>
        public int RFSGConfigureFrequencySingleLO(HandleRef[] rfsgHandles, int LOSource, HandleRef exteralLOHandle, double carrierFrequencies, int rfsgLODaisyChainEnabled, int LOExportToExternalDevicesEnabled)
        {

            Int32[] rfsgSessions = GetInt32Sessions(rfsgHandles);
            Int32 exteralLOSessions = GetInt32Sessions(exteralLOHandle);

            int pInvokeResult = PInvoke.niWLANG_RFSGConfigureFrequencySingleLO(Handle, rfsgSessions, rfsgSessions.Length, LOSource, exteralLOSessions, carrierFrequencies, rfsgLODaisyChainEnabled, LOExportToExternalDevicesEnabled);
            TestForError(pInvokeResult, rfsgHandles);
            return pInvokeResult;
        }

        /// <summary>
        /// Configures the frequency on NI RF vector signal generators and NI RF synthesizers. NI RF synthesizers are used as external LO devices. This function also configures LO frequency offset based on the NIWLANG_LO_FREQUENCY_OFFSET_MODE and NIWLANG_LO_FREQUENCY_OFFSET attributes. This function equally divides the NI RF vector signal generators and NI RF synthesizers into sets such that each set corresponds to one carrier frequency. The number of sets is equal to the size of the carrier frequencies array. In each set, the first NI RF vector signal generator is used as the master device for LO daisy chaining. It also configures the NIWLANG_CARRIER_FREQUENCY attribute.
        ///  You must ensure that after a frequency configuration change, the output of the external LO device settles before generating the WLAN signal. You must use one of the following programming flows:
        /// Before calling the niWLANG_RFSGConfigureFrequencyMultipleLO function, if the external LO device is in generation state, ensure that it is brought in configuration state, by stopping signal generation. Initiate signal generation on the external LO device after calling the niWLANG_RFSGConfigureFrequencyMultipleLO function.
        /// You may choose to do on-the-fly frequency change on the external LO device while the device is in generation state. You must allow it's output to settle by calling the niRFSG_WaitUntilSettled function after the niWLANG_RFSGConfigureFrequencyMultipleLO function.
        /// 
        /// </summary>
        ///<param name = "rfsgHandles">
        /// Specifies a reference to an NI-RFSG instrument session. This parameter is obtained from the niRFSG_init or niRFSG_InitWithOptions functions and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "LOSource">
        /// Specifies whether to use the internal or the external LO source. This value is applicable only for the first RFSG device within a set if the rfsgLODaisyChainEnabled parameter is set to TRUE. The default value is NIWLANG_VAL_LO_SOURCE_ONBOARD.  
        /// NIWLANG_VAL_LO_SOURCE_EXTERNAL (0)
        /// Uses an external LO as the LO source.
        /// NIWLANG_VAL_LO_SOURCE_ONBOARD (2)
        /// Uses an internal LO as the LO source.
        /// 
        ///</param>
        ///<param name = "exteralLOHandles">
        /// Identifies the instrument sessions of external LO devices. This parameter is obtained from the niRFSG_init or niRFSG_InitWithOptions functions.
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Specifies an array of the carrier frequencies used to generate signals. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the carrierFrequency array. This value should be the same as the value you set for the NIWLANG_NUMBER_OF_SEGMENTS attribute.
        /// 
        ///</param>
        ///<param name = "rfsgLODaisyChainEnabled">
        /// Specifies whether to export the LO signal from one RFSG device to the next. The default value is FALSE. 
        /// 
        ///</param>
        ///<param name = "LOExportToExternalDevicesEnabled">
        /// Specifies whether to export the LO signal from each RFSG device on its LO OUT terminal, which you can use to share the LO signal with an external device. An example of an external device would be an RFSA device. The default value is FALSE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_RFSGConfigureFrequencyMultipleLO
        /// int32 __stdcall niWLANG_RFSGConfigureFrequencyMultipleLO (niWLANGenerationSession session, 
        ///     ViSession rfsgSessions[],
        ///     int32 numberOfRFSGSessions, 
        ///     int32 LOSource,
        ///     ViSession externalLOHandles[],
        ///     int32 numberOfexternalLOHandles,
        ///     float64 carrierFrequency[],
        ///     int32 dataArraySize,
        ///     int32 rfsgLODaisyChainEnabled,
        ///     int32 LOExportToExternalDevicesEnabled);    
        /// Purpose
        /// Configures the frequency on NI RF vector signal generators and NI RF synthesizers. NI RF synthesizers are used as external LO devices. This function also configures LO frequency offset based on the NIWLANG_LO_FREQUENCY_OFFSET_MODE and NIWLANG_LO_FREQUENCY_OFFSET attributes. This function equally divides the NI RF vector signal generators and NI RF synthesizers into sets such that each set corresponds to one carrier frequency. The number of sets is equal to the size of the carrier frequencies array. In each set, the first NI RF vector signal generator is used as the master device for LO daisy chaining. It also configures the NIWLANG_CARRIER_FREQUENCY attribute.
        ///  You must ensure that after a frequency configuration change, the output of the external LO device settles before generating the WLAN signal. You must use one of the following programming flows:
        /// Before calling the niWLANG_RFSGConfigureFrequencyMultipleLO function, if the external LO device is in generation state, ensure that it is brought in configuration state, by stopping signal generation. Initiate signal generation on the external LO device after calling the niWLANG_RFSGConfigureFrequencyMultipleLO function.
        /// You may choose to do on-the-fly frequency change on the external LO device while the device is in generation state. You must allow it's output to settle by calling the niRFSG_WaitUntilSettled function after the niWLANG_RFSGConfigureFrequencyMultipleLO function.
        /// 
        ///</returns>
        public int RFSGConfigureFrequencyMultipleLO(HandleRef[] rfsgHandles, int LOSource, HandleRef[] exteralLOHandles, double[] carrierFrequency, int dataArraySize, int rfsgLODaisyChainEnabled, int LOExportToExternalDevicesEnabled)
        {
            Int32[] rfsgSessions = GetInt32Sessions(rfsgHandles);
            Int32[] exteralLOSessions = GetInt32Sessions(exteralLOHandles);
            int pInvokeResult = PInvoke.niWLANG_RFSGConfigureFrequencyMultipleLO(Handle, rfsgSessions, rfsgSessions.Length, LOSource, exteralLOSessions, exteralLOHandles.Length, carrierFrequency, dataArraySize, rfsgLODaisyChainEnabled, LOExportToExternalDevicesEnabled);
            TestForError(pInvokeResult, rfsgHandles);
            return pInvokeResult;
        }

        /// <summary>
        /// Configures the packet extension (PE) thresholds that determine the maximum PE duration of the 802.11ax signal. This function configures the thresholds for each resource unit (RU) size and each spatial stream of the 802.11ax DUT. You must configure this table based on the packet extension requirements of the DUT.
        /// The PE field of in 802.11ax signal provides additional processing time to the receiver to decode the last symbol. The possible durations of the PE field are 0 microseconds, 4 microseconds, 8 microseconds, 12 microseconds, or 16 microseconds. The PE duration is determined by both the pre-FEC padding factor of the Data field, and the maximum PE duration requested by the recipient, and the modulation scheme of the current PPDU. The maximum PE durations as defined by the HE Capabilities element are 0 microseconds, 8 microseconds and 16 microseconds, which can be specified using this function.
        /// The maximum PE duration is computed by comparing the constellation index and the threshold values. Packet extension device capability threshold values are defined for all RU sizes greater than or equal to 242 tones. No thresholds are defined for an RU size less than 242 tones. The supported constellations are assigned with a unique index value as shown in following table.
        /// Modulation Scheme
        /// Constellation Index Value
        /// BPSK
        /// 0
        /// QPSK
        /// 1
        /// 16-QAM
        /// 2
        /// 64-QAM
        /// 3
        /// 256-QAM
        /// 4
        /// 1024-QAM
        /// 5
        /// Reserved
        /// 6
        /// None
        /// 7
        /// The PE can be defined in two modes.Max PE mode 8 microseconds: PE duration is 0, 0, 4 and 8 microseconds for pre-FEC padding factor of 1, 2, 3 and 4 respectively 
        /// PE mode 16 microseconds: PE duration is 4, 8, 12 and 16 microseconds for pre-FEC padding factor of 1, 2, 3 and 4 respectively
        /// The maximum PE is calculated from the threshold values and the constellation index for the specified MCS index as following. 
        /// If the constellation is greater than or equal to PPET16, you must apply the value of the maximum PPET16 parameter, or if the constellation is greater than or equal to PPET8, you must apply the value of the maximum PPET8 parameter; otherwise, there is no packet extension.
        /// If no PE is required for all constellations, set PPET8 and PPET16 to "" (empty array).
        /// If only the max PE 8 microseconds mode is required, set PPET16 to be "" (empty array), and PPET8 to be the constellation at which max PE 8 microseconds mode starts.
        /// If only the max PE 16 microseconds mode is required, set PPET16 to be the constellation at which max PE 16 microseconds mode starts, and PPET8 to be "" (empty array).
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "PPET16">
        /// Specifies the 16 microsecond mode PE threshold values. The default value is "" (empty array). 
        /// 
        ///</param>
        ///<param name = "PPET8">
        /// Specifies the size of PPET8 array.
        /// 
        ///</param>
        ///<param name = "numberOfSpatialStreams">
        /// Specifies the size of numberOfSpatialStreams array.
        /// 
        ///</param>
        ///<param name = "RUSize">
        /// Specifies the size of RU size array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_SetOFDMPacketExtensionThresholds
        /// int32 __stdcall niWLANG_SetOFDMPacketExtensionThresholds (niWLANGenerationSession session,
        ///     char channelString[],
        ///     int32 PPET16[],
        ///     int32 PPET8[],
        ///     int32 numberOfSpatialStreams[],
        ///     int32 RUSize[],
        ///     int32 PPET16ArraySize,
        ///     int32 PPET8ArraySize,
        ///     int32 numberOfSpatialStreamsArraySize,
        ///     int32 RUArraySize);
        /// Purpose
        /// Configures the packet extension (PE) thresholds that determine the maximum PE duration of the 802.11ax signal. This function configures the thresholds for each resource unit (RU) size and each spatial stream of the 802.11ax DUT. You must configure this table based on the packet extension requirements of the DUT.
        /// The PE field of in 802.11ax signal provides additional processing time to the receiver to decode the last symbol. The possible durations of the PE field are 0 microseconds, 4 microseconds, 8 microseconds, 12 microseconds, or 16 microseconds. The PE duration is determined by both the pre-FEC padding factor of the Data field, and the maximum PE duration requested by the recipient, and the modulation scheme of the current PPDU. The maximum PE durations as defined by the HE Capabilities element are 0 microseconds, 8 microseconds and 16 microseconds, which can be specified using this function.
        /// The maximum PE duration is computed by comparing the constellation index and the threshold values. Packet extension device capability threshold values are defined for all RU sizes greater than or equal to 242 tones. No thresholds are defined for an RU size less than 242 tones. The supported constellations are assigned with a unique index value as shown in following table.
        /// Modulation Scheme
        /// Constellation Index Value
        /// BPSK
        /// 0
        /// QPSK
        /// 1
        /// 16-QAM
        /// 2
        /// 64-QAM
        /// 3
        /// 256-QAM
        /// 4
        /// 1024-QAM
        /// 5
        /// Reserved
        /// 6
        /// None
        /// 7
        /// The PE can be defined in two modes.Max PE mode 8 microseconds: PE duration is 0, 0, 4 and 8 microseconds for pre-FEC padding factor of 1, 2, 3 and 4 respectively 
        /// PE mode 16 microseconds: PE duration is 4, 8, 12 and 16 microseconds for pre-FEC padding factor of 1, 2, 3 and 4 respectively
        /// The maximum PE is calculated from the threshold values and the constellation index for the specified MCS index as following. 
        /// If the constellation is greater than or equal to PPET16, you must apply the value of the maximum PPET16 parameter, or if the constellation is greater than or equal to PPET8, you must apply the value of the maximum PPET8 parameter; otherwise, there is no packet extension.
        /// If no PE is required for all constellations, set PPET8 and PPET16 to "" (empty array).
        /// If only the max PE 8 microseconds mode is required, set PPET16 to be "" (empty array), and PPET8 to be the constellation at which max PE 8 microseconds mode starts.
        /// If only the max PE 16 microseconds mode is required, set PPET16 to be the constellation at which max PE 16 microseconds mode starts, and PPET8 to be "" (empty array).
        /// 
        ///</returns>
        public int SetOFDMPacketExtensionThresholds(string channelString, int[] PPET16, int[] PPET8, int[] numberOfSpaceTimeStreams, int[] RUSize)
        {
            int pInvokeResult = PInvoke.niWLANG_SetOFDMPacketExtensionThresholds(Handle, PPET16, PPET8, numberOfSpaceTimeStreams, RUSize, PPET16.Length, PPET8.Length, numberOfSpaceTimeStreams.Length, RUSize.Length);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Creates 802.11ax trigger frame MSDU bits according to the configuration you specify. You must set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU to configure this function. For more information about Trigger frame generation, refer to the Generating the Trigger Frame topic.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "generationDone">
        /// Indicates whether the function has generated all the data.  
        /// 
        ///</param>
        ///<param name = "triggerFrameMSDUBits">
        /// Returns an array of the encoded bits trace. 
        /// 
        ///</param>
        ///<param name = "actualDataArraySize">
        /// Returns the actual number of elements populated in the TriggerFrameMSDUBits array parameter. If the array is not large enough to hold all the samples, the function returns an error and actualDataArraySize parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        /// niWLANG_CreateTriggerFrameMSDU
        /// int32 __stdcall niWLANG_CreateTriggerFrameMSDU (niWLANGenerationSession session,
        ///     char channelString[],
        ///     int32 *generationDone,
        ///     int32 triggerFrameMSDUBits[],
        ///     int32 dataArraySize,
        ///     int32 *actualDataArraySize);
        /// Purpose
        /// Creates 802.11ax trigger frame MSDU bits according to the configuration you specify. You must set the NIWLANG_STANDARD attribute to NIWLANG_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANG_PPDU_TYPE attribute to NIWLANG_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU to configure this function. For more information about Trigger frame generation, refer to the Generating the Trigger Frame topic.
        /// 
        ///</returns>
        public int CreateTriggerFrameMSDU(string channelString, out int generationDone, int[] triggerFrameMSDUBits, out int actualDataArraySize)
        {
            int pInvokeResult;
            if(triggerFrameMSDUBits == null)
               pInvokeResult = PInvoke.niWLANG_CreateTriggerFrameMSDU(Handle, channelString, out generationDone, null, 0, out actualDataArraySize);
            else 
               pInvokeResult = PInvoke.niWLANG_CreateTriggerFrameMSDU(Handle, channelString, out generationDone, triggerFrameMSDUBits, triggerFrameMSDUBits.Length, out actualDataArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Reads the burst start locations from a TDMS file. You can save this file using the NI WLAN Generation Soft Front Panel or the niWLANG_CreateandWriteWaveformstoFile function in a programming environment. 
        /// 
        /// </summary>
        ///<param name = "filePath">
        /// Specifies the absolute path to the TDMS file from which the toolkit reads the waveform.
        /// 
        ///</param>
        ///<param name = "waveformName">
        ///</param>
        ///<param name = "burstStartLocations">
        /// Returns the burst start locations saved in the TDMS file. It is an array of sample positions of the start of the burst, within the waveform.
        /// 
        ///</param>
        ///<param name = "actualDataArraySize">
        /// Returns the actual number of elements populated in the burstStartLocations array parameter. If the array is not large enough to hold all the samples, the function returns an error and actualDataArraySize parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        /// niWLANG_ReadBurstStartLocationsFromFile
        /// int32 __stdcall niWLANG_ReadBurstStartLocationsFromFile (char filePath[],
        ///     char channelString[],
        ///     int32 burstStartLocations[],
        ///     int32 dataArraySize,
        ///     int32 *actualDataArraySize);
        /// Purpose
        /// Reads the burst start locations from a TDMS file. You can save this file using the NI WLAN Generation Soft Front Panel or the niWLANG_CreateandWriteWaveformstoFile function in a programming environment. 
        /// 
        ///</returns>
        public int ReadBurstStartLocationsFromFile(string filePath, string waveformName, int[] burstStartLocations, out int actualDataArraySize)
        {
            int pInvokeResult = PInvoke.niWLANG_ReadBurstStartLocationsFromFile(filePath, waveformName, burstStartLocations, burstStartLocations.Length, out actualDataArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Reads the burst stop locations from a TDMS file. You can save this file using the NI WLAN Generation Soft Front Panel or the niWLANG_CreateandWriteWaveformstoFile function in a programming environment.
        /// 
        /// </summary>
        ///<param name = "filePath">
        /// Specifies the absolute path to the TDMS file from which the toolkit reads the waveform.
        /// 
        ///</param>
        ///<param name = "waveformName">
        ///</param>
        ///<param name = "burstStopLocations">
        /// Returns the burst stop locations saved in the TDMS file. It is an array of sample positions of the end of the burst, within the waveform. 
        /// 
        ///</param>
        ///<param name = "actualDataArraySize">
        /// Returns the actual number of elements populated in the burstStartLocations array parameter. If the array is not large enough to hold all the samples, the function returns an error and actualDataArraySize parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_ReadBurstStopLocationsFromFile
        /// int32 __stdcall niWLANG_ReadBurstStopLocationsFromFile (char filePath[],
        ///     char channelString[],
        ///     int32 burstStopLocations[],
        ///     int32 dataArraySize,
        ///     int32 *actualDataArraySize);
        /// Purpose
        /// Reads the burst stop locations from a TDMS file. You can save this file using the NI WLAN Generation Soft Front Panel or the niWLANG_CreateandWriteWaveformstoFile function in a programming environment.
        /// 
        ///</returns>
        public int ReadBurstStopLocationsFromFile(string filePath, string waveformName, int[] burstStopLocations, out int actualDataArraySize)
        {
            int pInvokeResult = PInvoke.niWLANG_ReadBurstStopLocationsFromFile(filePath, waveformName, burstStopLocations, burstStopLocations.Length, out actualDataArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the burst start locations stored in the RFSG database.
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "rfsgHandle">
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to retrieve the burst start locations. The toolkit uses this parameter as the key to retrieve the waveform properties in the RFSG database.
        /// 
        ///</param>
        ///<param name = "burstStartLocations">
        /// Returns the burst start locations stored, for the waveform you specified in the waveformName parameter. It is an array of sample positions at the start of the burst, within the waveform.
        /// 
        ///</param>
        ///<param name = "actualDataArraySize">
        /// Returns the actual number of elements populated in the burstStartLocations array parameter. If the array is not large enough to hold all the samples, the function returns an error and actualDataArraySize parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_RFSGRetrieveBurstStartLocations
        /// int32 __stdcall niWLANG_RFSGRetrieveBurstStartLocations (ViSession rfsgSession, 
        ///     char waveformName[], 
        ///     int32 burstStartLocations[],
        ///     int32 dataArraySize,
        ///     int32* actualDataArraySize);
        /// Purpose
        /// Returns the burst start locations stored in the RFSG database.
        /// 
        ///</returns>
        public int RFSGRetrieveBurstStartLocations(string channelString, HandleRef rfsgHandle, string waveformName, int[] burstStartLocations, out int actualDataArraySize)
        {
            Int32 rfsgSession = GetInt32Sessions(rfsgHandle);
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrieveBurstStartLocations(rfsgSession, waveformName, burstStartLocations, burstStartLocations.Length, out actualDataArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the burst stop locations stored in the RFSG database.
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "rfsgHandle">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSG_init function or the niRFSG_InitWithOptions function.
        /// 
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to retrieve the burst stop locations. The toolkit uses this parameter as the key to retrieve the waveform properties in the RFSG database. 
        /// 
        ///</param>
        ///<param name = "burstStopLocations">
        /// Returns the burst stop locations stored, for the waveform you specified in the waveformName parameter. It is an array of sample positions of the end of the burst, within the waveform. 
        /// 
        ///</param>
        ///<param name = "actualDataArraySize">
        /// Returns the actual number of elements populated in the burstStopLocations array parameter. If the array is not large enough to hold all the samples, the function returns an error and actualDataArraySize parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_RFSGRetrieveBurstStopLocations
        /// int32 __stdcall niWLANG_RFSGRetrieveBurstStopLocations (ViSession rfsgSession, 
        ///     char waveformName[], 
        ///     int32 burstStopLocations[],
        ///     int32 dataArraySize,
        ///     int32* actualDataArraySize);
        /// Purpose
        /// Returns the burst stop locations stored in the RFSG database.
        /// 
        /// 
        ///</returns>
        public int RFSGRetrieveBurstStopLocations(string channelString, HandleRef rfsgHandle, string waveformName, int[] burstStopLocations, out int actualDataArraySize)
        {
            Int32 rfsgSession = GetInt32Sessions(rfsgHandle);
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrieveBurstStopLocations(rfsgSession, waveformName, burstStopLocations, burstStopLocations.Length, out actualDataArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the waveform size stored in the RFSG database.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "rfsgHandle">
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to retrieve the waveform size. The toolkit uses this parameter as the key to retrieve the waveform properties in the RFSG database.
        /// 
        ///</param>
        ///<param name = "waveformSize">
        /// Returns the waveform size stored, for the waveform you specified in the waveformName parameter.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///  niWLANG_RFSGRetrieveWaveformSize
        /// int32 __stdcall niWLANG_RFSGRetrieveWaveformSize (ViSession rfsgSession, 
        ///     char waveformName[], 
        ///     int32* waveformSize);
        /// Purpose
        /// Returns the waveform size stored in the RFSG database.
        /// 
        ///</returns>
        public int RFSGRetrieveWaveformSize(string channelString, HandleRef rfsgHandle, string waveformName, out int waveformSize)
        {
            Int32 rfsgSession = GetInt32Sessions(rfsgHandle);
            int pInvokeResult = PInvoke.niWLANG_RFSGRetrieveWaveformSize(rfsgSession, waveformName, out waveformSize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Stores the burst start locations that you specify in the burstStartLocations parameter in the RFSG database.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "rfsgHandle">
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to retrieve the burst start locations. The toolkit uses this parameter as the key to retrieve the waveform properties in the RFSG database.
        /// 
        ///</param>
        ///<param name = "burstStartLocations">
        /// Returns the burst start locations stored, for the waveform you specified in the waveformName parameter. It is an array of sample positions of the start of the burst, within the waveform. The default value is  "" (empty array).
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_RFSGStoreBurstStartLocations
        /// int32 __stdcall niWLANG_RFSGStoreBurstStartLocations (ViSession rfsgSession, 
        ///     char waveformName[], 
        ///     int32 burstStartLocations[],
        ///     int32 dataArraySize);
        /// Purpose
        /// Stores the burst start locations that you specify in the burstStartLocations parameter in the RFSG database.
        /// 
        ///</returns>
        public int RFSGStoreBurstStartLocations(string channelString, HandleRef rfsgHandle, string waveformName, int[] burstStartLocations)
        {
            Int32 rfsgSession = GetInt32Sessions(rfsgHandle);
            int pInvokeResult = PInvoke.niWLANG_RFSGStoreBurstStartLocations(rfsgSession, waveformName, burstStartLocations, burstStartLocations.Length);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Stores the burst stop locations that you specify in the burst stop locations parameter in the RFSG database.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "rfsgHandle">
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform for which you want to store the burst stop locations.
        /// 
        ///</param>
        ///<param name = "burstStopLocations">
        /// specifies the burst stop locations to store. It is an array of sample positions of the end of the burst, within the waveform. The default value is  "" (empty array).
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANG_RFSGStoreBurstStopLocations
        /// int32 __stdcall niWLANG_RFSGStoreBurstStopLocations (ViSession rfsgSession, 
        ///     char waveformName[], 
        ///     int32 burstStopLocations[],
        ///     int32 dataArraySize);
        /// Purpose
        /// Stores the burst stop locations that you specify in the burst stop locations parameter in the RFSG database.
        /// 
        ///</returns>
        public int RFSGStoreBurstStopLocations(string channelString, HandleRef rfsgHandle, string waveformName, int[] burstStopLocations)
        {
            Int32 rfsgSession = GetInt32Sessions(rfsgHandle);
            int pInvokeResult = PInvoke.niWLANG_RFSGStoreBurstStopLocations(rfsgSession, waveformName, burstStopLocations, burstStopLocations.Length);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        #endregion


        #region 17.5

        public int SetPayloadAutoNumberOfMpdus(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.PayloadAutoNumberOfMPDUs, channelString, value);
        }

        public int GetPayloadAutoNumberOfMpdus(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadAutoNumberOfMPDUs, channelString, out value);
        }

        [Obsolete("Use SetAutoPayloadDataLengthMode")]
        public int SetPayloadAutoDataLength(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.PayloadAutoDataLength, channelString, value);
        }

        [Obsolete("Use GetAutoPayloadDataLengthMode")]
        public int GetPayloadAutoDataLength(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadAutoDataLength, channelString, out value);
        }

        public int SetLSIGLength(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.LSIGLength, channelString, value);
        }

        public int GetLSIGLength(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.LSIGLength, channelString, out value);
        }

        public int SetPreFECPaddingFactor(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.PreFECPaddingFactor, channelString, value);
        }

        public int GetPreFECPaddingFactor(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.PreFECPaddingFactor, channelString, out value);
        }

        public int SetPEDisambiguity(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.PEDisambiguity, channelString, value);
        }

        public int GetPEDisambiguity(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.PEDisambiguity, channelString, out value);
        }

        public int SetLdpcExtraSymbolSegment(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.LdpcExtraSymbolSegment, channelString, value);
        }

        public int GetLdpcExtraSymbolSegment(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.LdpcExtraSymbolSegment, channelString, out value);
        }

        public int SetBSSColor(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.BSSColor, channelString, value);
        }

        public int GetBSSColor(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.BSSColor, channelString, out value);
        }

        public int SetSpatialMappingMode(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.SpatialMappingMode, channelString, value);
        }

        public int GetSpatialMappingMode(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.SpatialMappingMode, channelString, out value);
        }

        public int SetSpaceTimeStreamOffset(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.SpaceTimeStreamOffset, channelString, value);
        }

        public int GetSpaceTimeStreamOffset(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.SpaceTimeStreamOffset, channelString, out value);
        }

        public int SetMUMimoLtfModeEnabled(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.MuMimoLtfModeEnabled, channelString, value);
        }

        public int GetMUMimoLtfModeEnabled(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.MuMimoLtfModeEnabled, channelString, out value);
        }

        public int SetPayloadMacFrameType(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.PayloadMacFrameType, channelString, value);
        }

        public int GetPayloadMacFrameType(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.PayloadMacFrameType, channelString, out value);
        }

        public int SetTriggerFrameCSRequired(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.TriggerFrameCSRequired, channelString, value);
        }

        public int GetTriggerFrameCSRequired(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.TriggerFrameCSRequired, channelString, out value);
        }

        public int SetTriggerFrameMaximumMacPaddingDuration(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.TriggerFrameMaximumMacPaddingDuration, channelString, value);
        }

        public int GetTriggerFrameMaximumMacPaddingDuration(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.TriggerFrameMaximumMacPaddingDuration, channelString, out value);
        }

        public int SetPreamblePuncturingEnabled(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.PreamblePuncturingEnabled, channelString, value);
        }

        public int GetPreamblePuncturingEnabled(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.PreamblePuncturingEnabled, channelString, out value);
        }

        public int SetPrimary20MHzChannelIndex(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.Primary20MHzChannelIndex, channelString, value);
        }

        public int GetPrimary20MHzChannelIndex(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.Primary20MHzChannelIndex, channelString, out value);
        }

        public int SetTriggerFrameAID12(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.TriggerFrameAID12, channelString, value);
        }

        public int GetTriggerFrameAID12(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.TriggerFrameAID12, channelString, out value);
        }

        public int GetSignalBandwidth(string channelString, out double value)
        {
            return GetDouble(niWLANGProperties.SignalBandwidth, channelString, out value);
        }

        public int GetPacketExtensionDuration(string channelString, out double value)
        {
            return GetDouble(niWLANGProperties.PacketExtensionDuration, channelString, out value);
        }

        public int SetNominalPacketPadding(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.NominalPacketPadding, channelString, value);
        }

        public int GetNominalPacketPadding(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.NominalPacketPadding, channelString, out value);
        }

        public int SetPreamblePuncturingMask(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.PreamblePuncturingMask, channelString, value);
        }

        public int GetPreamblePuncturingMask(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.PreamblePuncturingMask, channelString, out value);
        }

        public int RFSGForceTClkSynchronization(HandleRef[] rfsgHandles, int forceSync)
        {
            Int32[] rfsgSessions = GetInt32Sessions(rfsgHandles);
            int pInvokeResult = PInvoke.niWLANG_RFSGForceTClkSynchronization(Handle, rfsgSessions, rfsgSessions.Length, forceSync);
            TestForError(pInvokeResult, rfsgHandles);
            return pInvokeResult;
        }

        public int RFSGMultipleDeviceInitiate(HandleRef[] rfsgHandles)
        {
            Int32[] rfsgSessions = GetInt32Sessions(rfsgHandles);
            int pInvokeResult = PInvoke.niWLANG_RFSGMultipleDeviceInitiate(Handle, rfsgSessions, rfsgSessions.Length);
            TestForError(pInvokeResult, rfsgHandles);
            return pInvokeResult;
     
        }
        #endregion 

        #region 18.0 

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetRUAllocationMode(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.RUAllocationMode, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRUAllocationMode(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.RUAllocationMode, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="data"></param>
        /// <param name="dataArraySize"></param>
        /// <returns></returns>
        public int SetRUAllocation(string channel, int[] data, int dataArraySize)
        {
            return SetVectorAttributeI32(channel, niWLANGProperties.RUAllocation, data, dataArraySize);
        }
        /// <summary>
        /// Specifies a user-defined bit pattern as an array of zeros and ones.    If the array length is greater than the configured payload length, the    toolkit uses a subset of the required length from the beginning of the array    for waveform generation. If the array length is less than the configured    payload length, the user-defined bit pattern is repeated until the required    length is achieved. If the NIWLANG_PAYLOAD_DATA_TYPE attribute is set to    NIWLANG_VAL_PN_SEQUENCE, the    toolkit ignores the NIWLANG_PAYLOAD_USER_DEFINED_BITS attribute.
        ///    Valid values include arrays    of zeros and ones.
        ///    The default is an empty array. Valid values include arrays of zeros and ones.        
        /// 
        /// </summary>
        public int GetRUAllocation(string channel, int[] data, int dataArraySize, out int actualNumDataElements)
        {
            return GetVectorAttributeI32(channel, niWLANGProperties.RUAllocation, data, dataArraySize, out actualNumDataElements);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetIdleIntervalMode(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.IdleIntervalMode, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetIdleIntervalMode(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.IdleIntervalMode, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmMidamblePeriodicity(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.MidamblePeriodicity, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmMidamblePeriodicity(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.MidamblePeriodicity, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetUserEnabled(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.UserEnabled, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetUserEnabled(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.UserEnabled, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="numberOfUsers"></param>
        /// <returns></returns>
        public int GetNumberOfUsersFromRUAllocation(string channelString, out int numberOfUsers)
        {
            int pInvokeResult = PInvoke.niWLANG_GetNumberOfUsersFromRUAllocation(Handle, channelString, out numberOfUsers);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }



        #endregion

        #region 19.1
        //#define NIWLANG_AUTO_PALOAD_DATA_LENGTH_MODE					0xB3	/*int*/
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetAutoPayloadDataLengthMode(string channelString, int value)
        {
            return SetInt32(niWLANGProperties.AutoPayloadDataLengthMode, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAutoPayloadDataLengthMode(string channelString, out int value)
        {
            return GetInt32(niWLANGProperties.AutoPayloadDataLengthMode, channelString, out value);
        }

        //#define NIWLANG_FRAME_DURATION					0xD1	/*float64*/
        /// <summary>
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int SetFrameDuration(string channel, double value)
        {
            return SetDouble(niWLANGProperties.FrameDuration, channel, value);
        }

        /// <summary>
        /// </summary>
        /// <param name = "channel">Set this parameter to "" (empty string) or NULL.</param>
        /// <param name="value"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetFrameDuration(string channel, out double value)
        {
            return GetDouble(niWLANGProperties.FrameDuration, channel, out value);
        }

        #endregion



        /// <summary>
        /// 
        /// </summary>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int DeallocateMemory()
        {
            return TestForError(PInvoke.niWLANG_DeallocateMemory());
        }

        private int SetInt32(niWLANGProperties propertyId, string repeatedCapabilityOrChannel, int val)
        {
            return TestForError(PInvoke.niWLANG_SetScalarAttributeI32(Handle, repeatedCapabilityOrChannel, propertyId, val));
        }
        private int GetInt32(niWLANGProperties propertyId, string repeatedCapabilityOrChannel, out int val)
        {
            return TestForError(PInvoke.niWLANG_GetScalarAttributeI32(Handle, repeatedCapabilityOrChannel, propertyId, out val));
        }
        private int SetDouble(niWLANGProperties propertyId, string repeatedCapabilityOrChannel, double val)
        {
            return TestForError(PInvoke.niWLANG_SetScalarAttributeF64(Handle, repeatedCapabilityOrChannel, propertyId, val));
        }
        private int GetDouble(niWLANGProperties propertyId, string repeatedCapabilityOrChannel, out double val)
        {
            return TestForError(PInvoke.niWLANG_GetScalarAttributeF64(Handle, repeatedCapabilityOrChannel, propertyId, out val));
        }
        private class PInvoke
        {
            const string nativeDllName = "niWLANGeneration_net.dll";

            [DllImport(nativeDllName, EntryPoint = "niWLANG_CloseSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_CloseSession(HandleRef session);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_CreateMIMOWaveformsComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_CreateMIMOWaveformsComplexF64(HandleRef session, int reset, [In, Out] double[] t0, [In, Out] double[] dt, [Out] niComplexNumber[] waveforms, int numberofChannels, int individualWaveformSize, out int actualNumSamplesinEachWfm, out int done);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_CreateWaveformComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_CreateWaveformComplexF64(HandleRef session, int reset, out double t0, out double dt, [Out] niComplexNumber[] waveform, int waveformSize, out int actualNumWaveformSamples, out int done);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetErrorString", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetErrorString(HandleRef session, int errorCode, StringBuilder errorMessage, int errorMessageLen);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetMappingMatrix", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetMappingMatrix(HandleRef session, string channelString, [Out] niComplexNumber[] mappingMatrix, int numMappingMatrixRows, int numMappingMatrixColumns);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetScalarAttributeF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetScalarAttributeF64(HandleRef session, string channelString, niWLANGProperties attributeID, out double attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetScalarAttributeI32", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetScalarAttributeI32(HandleRef session, string channelString, niWLANGProperties attributeID, out int attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetVectorAttributeF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetVectorAttributeF64(HandleRef session, string channelString, niWLANGProperties attributeID, [In, Out] double[] data, int dataArraySize, out int actualNumDataElements);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetVectorAttributeI32", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetVectorAttributeI32(HandleRef session, string channelString, niWLANGProperties attributeID, [In, Out] int[] data, int dataArraySize, out int actualNumDataElements);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_OpenSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_OpenSession(string sessionName, int compatibilityVersion, out IntPtr session, out int isNewSession);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_ResetSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_ResetSession(HandleRef session);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGConfigure", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGConfigure(HandleRef session, string wLANChannelString, System.Runtime.InteropServices.HandleRef rFSGSession, string hardwareChannelString);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGConfigureWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGConfigureWaveform(HandleRef session, string wLANChannelString, System.Runtime.InteropServices.HandleRef rFSGSession, string hardwareChannelString, int resetHardware, out int waveformSize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGStorePAPR", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGStorePAPR(System.Runtime.InteropServices.HandleRef rFSGSession, string channelString, string waveformName, double pAPR);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGStoreIQRate", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGStoreIQRate(System.Runtime.InteropServices.HandleRef rFSGSession, string channelString, string waveformName, double iQRate);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGRetrievePAPR", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGRetrievePAPR(System.Runtime.InteropServices.HandleRef rFSGSession, string channelString, string waveformName, out double pAPR);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGRetrieveIQRate", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGRetrieveIQRate(System.Runtime.InteropServices.HandleRef rFSGSession, string channelString, string waveformName, out double iQRate);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGRetrieveMinimumPAPRAllWaveforms", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGRetrieveMinimumPAPRAllWaveforms(System.Runtime.InteropServices.HandleRef rFSGSession, string channelString, string script, out double pAPR);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGRetrieveIQRateAllWaveforms", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGRetrieveIQRateAllWaveforms(System.Runtime.InteropServices.HandleRef rFSGSession, string channelString, string script, out double iQRate);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGCreateAndDownloadWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGCreateAndDownloadWaveform(HandleRef session, System.Runtime.InteropServices.HandleRef rFSGSession, string hardwareChannelString, string waveformName);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGCreateAndDownloadMIMOWaveforms", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGCreateAndDownloadMIMOWaveforms(HandleRef session, Int32[] rFSGSessions, string[] hardwareChannelStrings, int numberofChannels, string waveformName);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGConfigureScript", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGConfigureScript(System.Runtime.InteropServices.HandleRef rFSGSession, string channelString, string script, double powerLevel);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGConfigurePowerLevel", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGConfigurePowerLevel(System.Runtime.InteropServices.HandleRef rFSGSession, string channelString, string script, double powerLevel);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGClearDatabase", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGClearDatabase(System.Runtime.InteropServices.HandleRef rFSGSession, string channelString, string waveformName);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetMappingMatrix", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetMappingMatrix(HandleRef session, string channelString, niComplexNumber[] mappingMatrix, int numMappingMatrixRows, int numMappingMatrixColumns);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetScalarAttributeF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetScalarAttributeF64(HandleRef session, string channelString, niWLANGProperties attributeID, double attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetScalarAttributeI32", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetScalarAttributeI32(HandleRef session, string channelString, niWLANGProperties attributeID, int attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetVectorAttributeF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetVectorAttributeF64(HandleRef session, string channelString, niWLANGProperties attributeID, double[] data, int dataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetVectorAttributeI32", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetVectorAttributeI32(HandleRef session, string channelString, niWLANGProperties attributeID, int[] data, int dataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SaveConfigurationToFile", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SaveConfigurationToFile(HandleRef session, string filePath, int operation);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_LoadConfigurationFromFile", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_LoadConfigurationFromFile(HandleRef session, string filePath, int reset);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_CreateAndWriteWaveformsToFile", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_CreateAndWriteWaveformsToFile(HandleRef session, string filePath, int operation);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_ReadWaveformFromFile", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_ReadWaveformFromFile(string filePath, string waveformName, long offset, long count, out double t0, out double dt, [In, Out] niComplexNumber[] waveform, int waveformSize, out int actualSize, out double iQRate, out double headroom, out int eOF);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetScalarAttributeI64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetScalarAttributeI64(HandleRef session, string channelString, niWLANGProperties attributeID, int attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetScalarAttributeI64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetScalarAttributeI64(HandleRef session, string channelString, niWLANGProperties attributeID, out int attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetScalarAttributeI64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetScalarAttributeI64(HandleRef session, string channelString, niWLANGProperties attributeID, long attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetScalarAttributeI64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetScalarAttributeI64(HandleRef session, string channelString, niWLANGProperties attributeID, out long attributeValue);


            [DllImport(nativeDllName, EntryPoint = "niWLANG_ChannelNumberToCarrierFrequency", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_ChannelNumberToCarrierFrequency(int frequencyBand, double channelBandwidth, int channelNumber, int secondaryFactor, double chStartingFactor, out double carrierFrequency);


            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetMACAddress1", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetMACAddress1(HandleRef session, string channel, long value);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetMACAddress1", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetMACAddress1(HandleRef session, string channel, out long value);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetMACAddress2", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetMACAddress2(HandleRef session, string channel, long value);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetMACAddress2", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetMACAddress2(HandleRef session, string channel, out long value);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetMACAddress3", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetMACAddress3(HandleRef session, string channel, long value);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetMACAddress3", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetMACAddress3(HandleRef session, string channel, out long value);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetMACAddress4", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetMACAddress4(HandleRef session, string channel, long value);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetMACAddress4", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetMACAddress4(HandleRef session, string channel, out long value);


            [DllImport(nativeDllName, EntryPoint = "niWLANG_DeallocateMemory", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_DeallocateMemory();

            #region Version 4.1

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGReadAndDownloadWaveformsFromFile", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGReadAndDownloadWaveformsFromFile([In, Out] Int32[] rfsgSessions, int numberOfChannels, String waveformName, String filePath);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGConfigureMultipleDeviceSynchronization", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGConfigureMultipleDeviceSynchronization(HandleRef session, Int32[] rfsgHandles, int noOfChannels, string masterReferenceClockSource, int[] triggerLines, int noOfTriggerLines);

            #endregion

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetMACCurrentSequenceControl", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetMACCurrentSequenceControl(HandleRef session, string channel, int value);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetMACCurrentSequenceControl", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetMACCurrentSequenceControl(HandleRef session, string channel, out int value);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetMACOverheadLength", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetMACOverheadLength(HandleRef session, string channel, out int value);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_niWLANG_ChannelNumberToCarrierFrequency80211abgjpn", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_ChannelNumberToCarrierFrequency80211abgjpn(double channelStartingFrequency, double channelBandwidth, int channelNumber, int secondaryFactor, out double carrierFrequency);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_niWLANG_ChannelNumberToCarrierFrequency80211ac", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_ChannelNumberToCarrierFrequency80211ac(double channelStartingFrequencyHz, int channelNumber, out double carrierFrequency);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_niWLANG_ChannelNumberToCarrierFrequency80211ah", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_ChannelNumberToCarrierFrequency80211ah(double channelStartingFrequencyHz, int channelNumber, out double carrierFrequency);

            # region Version 15.0

            [DllImport(nativeDllName, EntryPoint = "niWLANG_ChannelNumberToCarrierFrequency80211af", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_ChannelNumberToCarrierFrequency80211af(double channelStartingFrequency, double channelBandwidth, int channelNumber, int TVHTMode, out double carrierFrequency);

            # endregion

            #region Version 17.0

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetBurstStartLocations", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetBurstStartLocations(HandleRef session, string channel, int[] dataArray, int dataArraySize, out int actualNumDataArrayElements);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetBurstStopLocations", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetBurstStopLocations(HandleRef session, string channel, int[] dataArray, int dataArraySize, out int actualNumDataArrayElements);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_SetOFDMPacketExtensionThresholds", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_SetOFDMPacketExtensionThresholds(HandleRef session, int[] PPET16, int[] PPET8, int[] numberOfSpaceTimeStreams, int[] RUSize, int PPET16ArraySize, int PPET8ArraySize, int numberOfSpaceTimeStreamsLength, int RUArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_CreateTriggerFrameMSDU", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_CreateTriggerFrameMSDU(HandleRef session, string channelString, out int generationDone, int[] triggerFrameMSDUBits, int dataArraySize, out int actualDataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_ReadBurstStartLocationsFromFile", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_ReadBurstStartLocationsFromFile(string filePath, string waveformName, [In, Out]  int[] burstStartLocations, int dataArraySize, out int actualDataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_ReadBurstStopLocationsFromFile", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_ReadBurstStopLocationsFromFile(string filePath, string waveformName, [In, Out]  int[] burstStopLocations, int dataArraySize, out int actualDataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGRetrieveBurstStartLocations", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGRetrieveBurstStartLocations(Int32 rfsgHandle, string waveformName, int[] burstStartLocations, int dataArraySize, out int actualDataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGRetrieveBurstStopLocations", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGRetrieveBurstStopLocations(Int32 rfsgHandle, string waveformName, [In, Out] int[] burstStopLocations, int dataArraySize, out int actualDataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGRetrieveWaveformSize", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGRetrieveWaveformSize(Int32 rfsgHandle, string waveformName, out int waveformSize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGStoreBurstStartLocations", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGStoreBurstStartLocations(Int32 rfsgHandle, string waveformName, [In, Out] int[] burstStartLocations, int dataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGStoreBurstStopLocations", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGStoreBurstStopLocations(Int32 rfsgHandle, string waveformName, [In, Out]  int[] burstStopLocations, int dataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGConfigureFrequencySingleLO", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGConfigureFrequencySingleLO(HandleRef session, Int32[] rfsgsession, int numberOfRfsgHandles, int LOSource, Int32 exteralLOHandle, double carrierFrequency, int rfsgLODaisyChainEnabled, int LOExportToExternalDevicesEnabled);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGConfigureFrequencyMultipleLO", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGConfigureFrequencyMultipleLO(HandleRef session, Int32[] rfsgSessions, int numberOfChannels, int LOSource, Int32[] exteralLOHandles, int numberOfexteralLOHandles, double[] carrierFrequency, int dataArraySize, int rfsgLODaisyChainEnabled, int LOExportToExternalDevicesEnabled);

            # endregion
            #region 17.5
            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGForceTClkSynchronization", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGForceTClkSynchronization(HandleRef session, Int32[] rfsgSessions, int numberOfChannels, int forceSync);

            [DllImport(nativeDllName, EntryPoint = "niWLANG_RFSGMultipleDeviceInitiate", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_RFSGMultipleDeviceInitiate(HandleRef session, Int32[] rfsgSessions, int numberOfChannels);
            
            # endregion

            [DllImport(nativeDllName, EntryPoint = "niWLANG_GetNumberOfUsersFromRUAllocation", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANG_GetNumberOfUsersFromRUAllocation(HandleRef session, string channelString, out int numberOfUsers); 
            
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="status"></param>
        /// <param name="msg"></param>
        ///<returns> Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. </returns>
        public int GetErrorString(int status, StringBuilder msg)
        {
            int size = PInvoke.niWLANG_GetErrorString(Handle, status, null, 0);
            if ((size >= 0))
            {
                msg.Capacity = size;
                PInvoke.niWLANG_GetErrorString(Handle, status, msg, size);
            }
            return status;
        }

        private int TestForError(int status)
        {
            if ((status < 0))
            {
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                status = GetErrorString(status, msg);
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), status);
            }
            return status;
        }

        private int TestForError(int status, HandleRef rfsgHandle)
        {
            if ((status < 0))
            {
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                GetErrorString(status, msg);
                // get RFSG detailed error message.

                if (String.IsNullOrEmpty(msg.ToString()))
                    niRFSG.GetError(rfsgHandle, status, msg);
                //get rfsg general error message.
                if (String.IsNullOrEmpty(msg.ToString()))
                    niRFSG.ErrorMessage(rfsgHandle, status, msg);
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), status);
            }
            return status;
        }

        private int TestForError(int status, HandleRef[] rfsgHandles)
        {
            if ((status < 0))
            {
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                 GetErrorString(status, msg);
                for (int i = 0; String.IsNullOrEmpty(msg.ToString()) && i < rfsgHandles.Length; i++)
                {
                    if (rfsgHandles[i].Handle != IntPtr.Zero)
                    {
                        //get rfsa detailed error message
                        niRFSG.GetError(rfsgHandles[i], status, msg);
                        //get rfsa general error message
                        if (String.IsNullOrEmpty(msg.ToString()))
                            niRFSG.ErrorMessage(rfsgHandles[i], status, msg);
                    }
                }
                if (String.IsNullOrEmpty(msg.ToString()))
                    GetErrorString(status, msg);
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), status);
            }
            return status;
        }

        private static int TestForErrorForNullHandle(int status, HandleRef[] rfsgHandles)
        {
            if ((status < 0))
            {
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                for (int i = 0; String.IsNullOrEmpty(msg.ToString()) && i < rfsgHandles.Length; i++)
                {
                    if (rfsgHandles[i].Handle != IntPtr.Zero)
                    {
                        //get rfsa detailed error message
                        niRFSG.GetError(rfsgHandles[i], status, msg);
                        //get rfsa general error message
                        if (String.IsNullOrEmpty(msg.ToString()))
                            niRFSG.ErrorMessage(rfsgHandles[i], status, msg);
                    }
                }
                if (String.IsNullOrEmpty(msg.ToString()))
                {
                    // GetErrorString(status, msg);
                    Object wrapObj = new Object();
                    HandleRef nullHandle = new HandleRef(wrapObj, IntPtr.Zero);
                    int size = PInvoke.niWLANG_GetErrorString(nullHandle, status, null, 0);
                    if ((size >= 0))
                    {
                        msg.Capacity = size;
                        PInvoke.niWLANG_GetErrorString(nullHandle, status, msg, size);
                    }
                }
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), status);
            }
            return status;
        }

        private static int TestForErrorForNullHandle(int status, HandleRef rfsgHandle)
        {
            if ((status < 0))
            {

                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                Object wrapObj = new Object();
                HandleRef nullHandle = new HandleRef(wrapObj, IntPtr.Zero);
                int size = PInvoke.niWLANG_GetErrorString(nullHandle, status, null, 0);
                if ((size >= 0))
                {
                    msg.Capacity = size;
                    PInvoke.niWLANG_GetErrorString(nullHandle, status, msg, size);
                }

                //GetErrorString(status, msg);
                // get RFSG detailed error message.
                if (String.IsNullOrEmpty(msg.ToString()))
                    niRFSG.GetError(rfsgHandle, status, msg);
                //get rfsg general error message.
                if (String.IsNullOrEmpty(msg.ToString()))
                    niRFSG.ErrorMessage(rfsgHandle, status, msg);
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), status);
            }
            return status;
        }

        private static Int32 GetInt32Sessions(HandleRef session)
        {
            Int32 int32sessions = 0;
            if (session.Handle.ToInt32() > 0)
            {
                int32sessions = session.Handle.ToInt32();
            }
            return int32sessions;
        }

        private static Int32[] GetInt32Sessions(HandleRef[] sessions)
        {
            Int32[] int32sessions = null;
            if (sessions != null)
            {
                int32sessions = new Int32[sessions.Length];
                for (int i = 0; i < sessions.Length; i++)
                {
                    int32sessions[i] = sessions[i].Handle.ToInt32();
                }
            }
            return int32sessions;
        }

        #region IDisposable Members

        /// <summary>
        /// Closes the niWLAN generation unnamed session and releases resources associated with that unnamed session.
        /// 
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            System.GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Dispose managed resources.
            }
            if (!_isNamedSession)
            {
                //Dispose unmanaged resources
                if (!Handle.Handle.Equals(IntPtr.Zero))
                {
                    PInvoke.niWLANG_CloseSession(Handle);
                }
            }
        }

        #endregion
    }
    /// <summary>
    /// 
    /// </summary>
    public class niWLANGConstants
    {
        /// <summary>
        /// 
        /// </summary>
        public const int CompatibilityVersion010000 = 10000;
        /// <summary>
        /// 
        /// </summary>
        public const int CompatibilityVersion020000 = 20000;
        /// <summary>
        /// 
        /// </summary>        
        public const int Standard80211agOfdm = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211bgDsss = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211gDsssOfdm = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211nMimoOfdm = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate6 = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate9 = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate12 = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate18 = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate24 = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate36 = 5;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate48 = 6;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate54 = 7;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate1 = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate2 = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate5p5Cck = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate5p5Pbcc = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate11Cck = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate11Pbcc = 5;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate22 = 6;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate33 = 7;
        /// <summary>
        /// 
        /// </summary>
        public const int PreambleTypeShortPreamble = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int PreambleTypeLongPreamble = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int UserDefined = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int PnSequence = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int False = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int True = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int FilterRectangular = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int FilterRaisedCosine = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int FilterRootRaisedCosine = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int FilterGaussian = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int _80211nPlcpFrameFormatMixed = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int _80211nPlcpFrameFormatGreenfield = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int MappingMatrixTypeDirect = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int MappingMatrixTypeHadamard = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int MappingMatrixTypeFourier = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int MappingMatrixTypeUserDefined = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int CompatibilityVersion030000 = 30000;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int Standard80211agjpOfdm = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int FrequencyBand5ghz = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int FileOperationModeOpen = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int FileOperationModeOpenOrCreate = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int FileOperationModeCreateOrReplace = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int FileOperationModeCreate = 3;

        #region Version 4.0
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211AcMimoOfdm = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int FecCodingTypeBcc = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int FecCodingTypeLdpc = 1;

        #endregion

        #region Version 4.1
        /// <summary>
        /// 
        /// </summary>
        public const int PpduTypeSuPpdu = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int PpduTypeMuPpdu = 1;

        #endregion

        #region Missing Constants
        /// <summary>
        /// 
        /// </summary>
        [Obsolete("Use FrequencyBand2p4ghz")]
        public const int FrequencyBand2ghz = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int FrequencyBand2p4ghz = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int WinMethodCenteredAtSymbolBoundary = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int WinMethodStartingAtSymbolBoundary = 1;

        #endregion


        #region Version 14.5
        /// <summary>
        /// 
        /// </summary>
        public const int CompatibilityVersion040000 = 40000;
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211AhMimoOfdm = 5;
        /// <summary>
        /// 
        /// </summary>
        public const int MacFrameFormatLong = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int MacFrameFormatShort = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int ShortPreambleType80211ah = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int LongPreambleType80211ah = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmGuardIntervalTypeLong = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmGuardIntervalTypeShort = 1;
        #endregion

        #region Version 15.0
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211AfMimoOfdm = 6;
        /// <summary>
        /// 
        /// </summary>
        public const int TvhtMode1 = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int TvhtMode2c = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int TvhtMode2n = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int TvhtMode4c = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int TvhtMode4n = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int NonHtModulationModeOff = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int NonHtModulationModeOn = 1;
        #endregion

        #region Version 15.5

        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211jOfdm = 7;
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211pOfdm = 8;
        /// <summary>
        /// 
        /// </summary>
        public const int SingleGenerator = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int MultipleGenerators = 1;

        #endregion

        #region Version 17.0

        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211AxMimoOfdm = 9;

        /// <summary>
        /// 
        /// </summary>
        public const int PowerReferenceNonBoostedFields = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int PowerReferencePowerBoostedFields = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int PowerReferencePowerReferenceEntirePacket = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int RuSize26 = 26;
        /// <summary>
        /// 
        /// </summary>
        public const int RuSize52 = 52;
        /// <summary>
        /// 
        /// </summary>
        public const int RuSize106 = 106;
        /// <summary>
        /// 
        /// </summary>
        public const int RuSize242 = 242;
        /// <summary>
        /// 
        /// </summary>
        public const int RuSize484 = 484;
        /// <summary>
        /// 
        /// </summary>
        public const int RuSize996 = 996;
        /// <summary>
        /// 
        /// </summary>
        public const int RuSize2x996 = 1992;
        /// <summary>
        /// 
        /// </summary>
        public const int TransmissionModeDownlinl = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int TransmissionModeUplink = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int PpduTypeExtendedRangeSuPpdu = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int PpduTypeTriggerBasedPpdu = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int GuardIntervalTypeOneByFour = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int GuardIntervalTypeOneByEight = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int GuardIntervalTypeOneBySixteen = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int HeLtfSizeAuto = -1;
        /// <summary>
        /// 
        /// </summary>
        public const int HeLtfSize4X = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int HeLtfSizeAuto2X = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int CompatibilityVersion050000 = 50000;
        /// <summary>
        /// 
        /// </summary>
        public const int LOFrequencyOffsetModeAuto = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int LOFrequencyOffsetModeUserDefined = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int LOFrequencyOffsetModeDisabled = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int LOSourceOnboard = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int LOSourceExternal = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int LOSourceSgSaShared = 3;


        #endregion

        #region 17.1
        /// <summary>
        /// 
        /// </summary>
        public const int SpatialMappingModeCommon = 0;

        public const int SpatialMappingModeUserSpecific = 1;

        public const int HeLtfSizeAuto1X = 2;

        public const int PayloadFrameTypeDataFrame = 0;

        public const int PayloadFrameTypeTriggerFrame = 1;

        public const int MaximumPaddingDuration0us = 0;

        public const int MaximumPaddingDuration8us = 1;

        public const int MaximumPaddingDuration16us = 2;


        #endregion

        #region 18.0

        /// <summary>
        /// 
        /// </summary>
        public const int IdleIntervalModeSplit = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int IdleIntervalModePostBurst = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int RUAllocationModeIndividual = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int RUAllocationModeGroup = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int MidamblePeriodicityNone = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int MidamblePeriodicity10Symbols = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int MidamblePeriodicity20Symbols = 2;

        #endregion

        #region 19.1

        /// <summary>
        /// 
        /// </summary>
        public const int AutoPayloadDataLengthModeDisabled = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int AutoPayloadDataLengthModeLSIGLength = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int AutoPayloadDataLengthModeFrameDuration  = 2;

        #endregion
    }
    /// <summary>
    /// 
    /// </summary>
    public enum niWLANGProperties
    {
        /// <summary>
        /// int
        /// </summary>
        _80211nPlcpFrameFormat = 43,

        /// <summary>
        /// double
        /// </summary>
        CarrierFrequency = 0,

        /// <summary>
        /// double
        /// </summary>
        CarrierFrequencyOffset = 20,

        /// <summary>
        /// double
        /// </summary>
        ChannelBandwidth = 42,

        /// <summary>
        /// int
        /// </summary>
        CompatibilityVersion = 56,

        /// <summary>
        /// int
        /// </summary>
        DsssDataRate = 33,

        /// <summary>
        /// int
        /// </summary>
        DsssPreambleType = 4,

        /// <summary>
        /// double
        /// </summary>
        [Obsolete]
        GuardInterval = 44,

        /// <summary>
        /// int
        /// </summary>
        HeaderEncoderEnabled = 14,

        /// <summary>
        /// int
        /// </summary>
        HeaderInterleaverEnabled = 15,

        /// <summary>
        /// double
        /// </summary>
        IDcOffset = 22,

        /// <summary>
        /// double
        /// </summary>
        IdleInterval = 3,

        /// <summary>
        /// double
        /// </summary>
        IqGainImbalance = 21,

        /// <summary>
        /// int
        /// </summary>
        IqWaveformSize = 37,

        /// <summary>
        /// int
        /// </summary>
        LockedClockBitEnabled = 13,

        /// <summary>
        /// int
        /// </summary>
        MacHeaderEnabled = 11,

        /// <summary>
        /// int
        /// </summary>
        MappingMatrixType = 55,

        /// <summary>
        /// double
        /// </summary>
        [Obsolete]
        MaxExpectedPapr = 40,

        /// <summary>
        /// int
        /// </summary>
        McsIndex = 41,

        /// <summary>
        /// int
        /// </summary>
        NumberOfExtensionSpatialStreams = 46,

        /// <summary>
        /// int
        /// </summary>
        NumberOfFrames = 6,

        /// <summary>
        /// int
        /// </summary>
        NumberOfTransmitChannels = 47,

        /// <summary>
        /// int
        /// </summary>
        OfdmDataRate = 32,

        /// <summary>
        /// int
        /// </summary>
        OversamplingFactor = 2,

        /// <summary>
        /// int
        /// </summary>
        PayloadDataLength = 5,

        /// <summary>
        /// int
        /// </summary>
        PayloadDataType = 7,

        /// <summary>
        /// int
        /// </summary>
        PayloadEncoderEnabled = 18,

        /// <summary>
        /// int
        /// </summary>
        PayloadInterleaverEnabled = 19,

        /// <summary>
        /// int
        /// </summary>
        PayloadPnOrder = 8,

        /// <summary>
        /// int
        /// </summary>
        PayloadPnSeed = 9,

        /// <summary>
        /// int
        /// </summary>
        PayloadScramblerEnabled = 16,

        /// <summary>
        /// int
        /// </summary>
        PayloadScramblerSeed = 17,

        /// <summary>
        /// int[]
        /// </summary>
        PayloadUserDefinedBits = 10,

        /// <summary>
        /// double
        /// </summary>
        PowerLevel = 1,

        /// <summary>
        /// int
        /// </summary>
        PulseShapingFilterEnabled = 54,

        /// <summary>
        /// double
        /// </summary>
        PulseShapingFilterParameter = 27,

        /// <summary>
        /// int
        /// </summary>
        PulseShapingFilterType = 26,

        /// <summary>
        /// double
        /// </summary>
        QDcOffset = 23,

        /// <summary>
        /// double
        /// </summary>
        QuadratureSkew = 24,

        /// <summary>
        /// double
        /// </summary>
        SampleClockOffset = 25,

        /// <summary>
        /// int
        /// </summary>
        Standard = 31,

        /// <summary>
        /// double[]
        /// </summary>
        SubcarrierMask = 12,

        /// <summary>
        /// double
        /// </summary>
        [Obsolete]
        WindowLength = 29,

        /// <summary>
        /// int
        /// </summary>
        MacFrameControl = 57,

        /// <summary>
        /// int
        /// </summary>
        MacDurationOrId = 58,

        /// <summary>
        /// int
        /// </summary>
        MacAddress1 = 60,

        /// <summary>
        /// int
        /// </summary>
        MacAddress1Enabled = 59,

        /// <summary>
        /// int
        /// </summary>
        MacAddress2 = 62,

        /// <summary>
        /// int
        /// </summary>
        MacAddress2Enabled = 61,

        /// <summary>
        /// int
        /// </summary>
        MacAddress3 = 64,

        /// <summary>
        /// int
        /// </summary>
        MacAddress3Enabled = 63,

        /// <summary>
        /// int
        /// </summary>
        MacAddress4 = 68,

        /// <summary>
        /// int
        /// </summary>
        MacAddress4Enabled = 67,

        /// <summary>
        /// int
        /// </summary>
        MacSequenceControl = 66,

        /// <summary>
        /// int
        /// </summary>
        MacSequenceControlEnabled = 65,

        /// <summary>
        /// int
        /// </summary>
        MacQosControl = 71,

        /// <summary>
        /// int
        /// </summary>
        MacQosControlEnabled = 53,

        /// <summary>
        /// int
        /// </summary>
        MacHtControl = 73,

        /// <summary>
        /// int
        /// </summary>
        MacHtControlEnabled = 72,

        /// <summary>
        /// int
        /// </summary>
        MacSequenceNumberIncrementEnabled = 80,

        /// <summary>
        /// int
        /// </summary>
        MacSequenceNumberIncrementInterval = 81,

        /// <summary>
        /// int
        /// </summary>
        MacFragmentNumberIncrementEnabled = 82,

        /// <summary>
        /// int
        /// </summary>
        MpduLength = 83,

        /// <summary>
        /// int
        /// </summary>
        MacFcsEnabled = 100,

        /// <summary>
        /// int
        /// </summary>
        AllIqImpairmentsEnabled = 96,

        /// <summary>
        /// int
        /// </summary>
        AwgnEnabled = 97,

        /// <summary>
        /// double
        /// </summary>
        CarrierToNoiseRatio = 98,

        /// <summary>
        /// int
        /// </summary>
        StbcIndex = 49,

        /// <summary>
        /// int
        /// </summary>
        AutoHeadroomEnabled = 87,

        /// <summary>
        /// double
        /// </summary>
        Headroom = 40,

        /// <summary>
        /// double
        /// </summary>
        IqRate = 35,

        /// <summary>
        /// double
        /// </summary>
        ActualHeadroom = 88,

        /// <summary>
        /// double
        /// </summary>
        ActualOfdmDataRate = 89,

        /// <summary>
        /// int
        /// </summary>
        NotSoundingBit = 86,

        /// <summary>
        /// int
        /// </summary>
        FecCodingType = 70,

        #region Version 4.0

        /// <summary>
        /// int
        /// </summary>
        PayloadNumberOfMpdus = 104,//NIWLANG_PAYLOAD_NUMBER_OF_MPDUS 0x68

        /// <summary>
        /// int
        /// </summary>
        AmpduEnabled = 103,// NIWLANG_AMPDU_ENABLED                             	0x67	/*int32*/


        /// <summary>
        /// double
        /// </summary>
        TimingSkew = 79, // #define NIWLANG_TIMING_SKEW									0x4F	/*float64*/


        /// <summary>
        /// double
        /// </summary>
        MaximumHardwareIqRate = 102,//#define NIWLANG_MAXIMUM_HARDWARE_IQ_RATE					0x66	/*float64*/
        /// <summary>
        /// int
        /// </summary>


        NumberOfSegments = 75,//define NIWLANG_NUMBER_OF_SEGMENTS							0x4B	/*int32*/

        /// <summary>
        /// int
        /// </summary>
        NumberOfSpaceTimeStreams = 76,//#define NIWLANG_NUMBER_OF_SPACE_TIME_STREAMS				0x4C	/*int32*/


        /// <summary>
        /// int
        /// </summary>
        StbcAllStreamsEnabled = 77,        //#define NIWLANG_STBC_ALL_STREAMS_ENABLED					0x4D	/*int32*/

        /// <summary>
        /// int
        /// </summary>
        SwapIAndQEnabled = 78,       //define NIWLANG_SWAP_I_AND_Q_ENABLED						0x4E	/*int32*/


        /// <summary>
        /// double
        /// </summary>
        SampleClockRateFactor = 107,        //#define NIWLANG_SAMPLE_CLOCK_RATE_FACTOR					0x6B	/*float64*/

        /// <summary>
        /// int
        /// </summary>
        [Obsolete]
        OfdmLegacyScalingEnabled = 101, //#define NIWLANG_OFDM_LEGACY_SCALING_ENABLED					0x65	/*int32*/

        #endregion

        #region Version 4.1

        /// <summary>
        /// int
        /// </summary>
        PpduType = 95,

        /// <summary>
        /// int
        /// </summary>
        NumberOfDataSymbols = 94,

        /// <summary>
        /// int
        /// </summary>
        NumberOfUsers = 115,

        /// <summary>
        /// int
        /// </summary>
        RfBlankingEnabled = 90,

        /// <summary>
        /// int
        /// </summary>
        LoSharingEnabled = 118,

        /// <summary>
        /// int[]
        /// </summary>
        RfBlankingMarkerPositions = 91,

        /// <summary>
        /// int
        /// </summary>
        PulseShapingFilterLength = 112,

        #endregion
        #region Version 14.5
        /// <summary>
        /// int
        /// </summary>
        MacFrameFormat = 120,   //x78

        /// <summary>
        /// int
        /// </summary>
        MacAddress1Length = 121,  //0x79

        /// <summary>
        /// int
        /// </summary>
        MacAddress2Length = 121,  //0x7a

        /// <summary>
        /// int
        /// </summary>
        DsssWindowLength = 29, //1d

        /// <summary>
        /// int
        /// </summary>
        OfdmWindowLength = 125,  //7d

        /// <summary>
        /// int
        /// </summary>
        _80211ahPreambleType = 119,

        /// <summary>
        /// int
        /// </summary>
        [Obsolete("Use TransmissionMode")]
        _80211ahUplinkIndication = 124,

        /// <summary>
        /// int
        /// </summary>
        GuardIntervalType = 123,

        #endregion

        #region Missing Properties

        /// <summary>
        /// int
        /// </summary>
        WindowingMethod = 74,

        #endregion

        # region Version 15.0

        /// <summary>
        /// int
        /// </summary>
        NonHtModulationMode = 127,

        # endregion

        #region Version 15.5

        /// <summary>
        /// int
        /// </summary>
        MultiSegmentGenerationMode = 134,

        #endregion

        #region Version 17.0

        /// <summary>
        /// int
        /// </summary>
        RuSize = 132,

        /// <summary>
        /// int
        /// </summary>
        RuOffset = 133,

        /// <summary>
        /// double
        /// </summary>
        RelativePower = 136,

        /// <summary>
        /// double
        /// </summary>
        PowerBoostFactor = 164,

        /// <summary>
        /// int
        /// </summary>
        StaId = 163,

        /// <summary>
        /// int
        /// </summary>
        DualCarrierModulationEnabled = 154,

        /// <summary>
        /// int
        /// </summary>
        TriggerFrameApTxPower = 172,

        /// <summary>
        /// int
        /// </summary>
        TriggerFrameTargetRssi = 173,

        /// <summary>
        /// double
        /// </summary>
        TimeDelay = 135,

        /// <summary>
        /// int
        /// </summary>
        HeSigBMcsIndex = 161,

        /// <summary>
        /// int
        /// </summary>
        HeSigBDualCarrierModulationEnabled = 162,

        /// <summary>
        /// int
        /// </summary>
        TransmissionMode = 124,

        /// <summary>
        /// double
        /// </summary>
        FullscaleBackOff = 168,

        /// <summary>
        /// int
        /// </summary>
        AveragePowerReference = 170,

        /// <summary>
        /// int
        /// </summary>
        BurstStartLocation = 174,

        /// <summary>
        /// int
        /// </summary>
        BurstStopLocation = 175,

        /// <summary>
        /// int
        /// </summary>
        NumberOfHeLtfSymbols = 165,

        /// <summary>
        /// int
        /// </summary>
        HeLtfSize = 144,

        /// <summary>
        /// int
        /// </summary>
        LOFrequencyOffsetMode = 176,

        /// <summary>
        /// double
        /// </summary>
        LOFrequencyOffset = 177,

        #endregion
        #region 17.1
        /// <summary>
        /// int 
        /// </summary>
        PayloadAutoNumberOfMPDUs = 178,

       [Obsolete("Use AutoPayloadDataLengthMode")]
        /// <summary>
        /// int
        /// </summary>
        PayloadAutoDataLength = 179,
        /// <summary>
        /// int
        /// </summary>
        LSIGLength = 180,
        /// <summary>
        /// int
        /// </summary>
        PreFECPaddingFactor = 181,
        /// <summary>
        /// int
        /// </summary>
        PEDisambiguity = 182,
        /// <summary>
        /// int
        /// </summary>
        LdpcExtraSymbolSegment =183,
        /// <summary>
        /// int
        /// </summary>
         BSSColor =  184,
        /// <summary>
        /// int
        /// </summary>
         SpatialMappingMode = 185,
        /// <summary>
        /// int 
        /// </summary>
         SpaceTimeStreamOffset = 187,
        /// <summary>
        /// int
        /// </summary>
         MuMimoLtfModeEnabled = 186,
        /// <summary>
        /// int
        /// </summary>
         PayloadMacFrameType = 188,
        /// <summary>
        /// int 
        /// </summary>
         TriggerFrameCSRequired = 190,
        /// <summary>
        /// int
        /// </summary>
        TriggerFrameMaximumMacPaddingDuration = 189,
        /// <summary>
        /// int
        /// </summary>
        PreamblePuncturingEnabled = 191,
        /// <summary>
        /// int
        /// </summary>
        Primary20MHzChannelIndex = 192,
        /// <summary>
        /// int
        /// </summary>
        PreamblePuncturingMask = 193,
        /// <summary>
        /// 
        /// </summary>
        TriggerFrameAID12 =196,
        /// <summary>
        /// 
        /// </summary>
        SignalBandwidth = 194,
        /// <summary>
        /// 
        /// </summary>
        NominalPacketPadding = 195,
        /// <summary>
        /// 
        /// </summary>
        PacketExtensionDuration  = 159,
        #endregion

        #region 18.0

        /// <summary>
        /// int
        /// </summary>
        IdleIntervalMode = 199,

        /// <summary>
        /// int
        /// </summary>
        RUAllocationMode = 205,

        /// <summary>
        /// int
        /// </summary>
        RUAllocation = 206,

        /// <summary>
        /// int
        /// </summary>
        UserEnabled = 207,

        /// <summary>
        /// int
        /// </summary>
        MidamblePeriodicity = 204,
        #endregion

        #region 19.1

        /// <summary>
        /// double
        /// </summary>
        FrameDuration = 209,

        /// <summary>
        /// int
        /// </summary>
        AutoPayloadDataLengthMode = 179,

        #endregion
    }
}


