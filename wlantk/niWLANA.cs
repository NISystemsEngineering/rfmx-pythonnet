using System;
using System.Runtime.InteropServices;
using System.Text;
using NationalInstruments.ModularInstruments.Interop;

namespace NationalInstruments.RFToolkits.Interop
{
    /// <summary>   
    /// 
    /// </summary>
    public class niWLANA : object, IDisposable
    {
        private System.Runtime.InteropServices.HandleRef _handle;

        private bool _isNamedSession;
        /// <summary>
        /// 
        /// </summary>
        ~niWLANA()
        {
            Dispose(false);
        }

        /// <summary>
        /// Returns a reference to a new or existing niWLAN analysis session.
        /// 
        /// </summary>
        ///<param name = "toolkitCompatibilityVersion">
        /// compatibilityVersion
        /// int32
        /// Specifies the toolkit compatibility version. 
        ///                         NIWLANA_VAL_COMPATIBILITY_VERSION_010000(10000)
        /// Specifies that the toolkit exhibits version 1.0 behavior and all new features in later releases are unavailable. Select this option if you purchased version 1.0 and want to maintain functional behavior. Refer to the NI WLAN Analysis Toolkit Readme for a list of changes between versions 1.0 and 2.0.
        ///  NIWLANA_VAL_COMPATIBILITY_VERSION_020000(20000)
        /// Specifies that the toolkit exhibits version 2.0 behavior. Select this option to if you want 2.0 behavior and access to new features and bug fixes. Refer to the NI WLAN Analysis Toolkit Readme for a list of changes between versions 1.0 and 2.0.
        /// 
        ///</param>
        public niWLANA(int toolkitCompatibilityVersion)
        {
            System.IntPtr handle;
            int isNewSession;
            int pInvokeResult = PInvoke.niWLANA_OpenSession(String.Empty, toolkitCompatibilityVersion, out handle, out isNewSession);
            TestForError(pInvokeResult);
            _handle = new HandleRef(this, handle);
            _isNamedSession = false;
        }
        /// <summary>
        /// Returns a reference to a new or existing niWLAN analysis session.
        /// 
        /// </summary>
        ///<param name = "sessionName">
        /// sessionName
        /// char[]
        /// Specifies the name of the session that you are looking up or creating. If a session with the same name already exists, this function returns a reference to that session. If you want to get reference to an already opened session x, specify x as the session name. You can obtain a reference to an already existing session multiple times if you have not called the niWLANA_CloseSession function in that session. You do not need to close the session multiple times. To create an unnamed session, pass an empty string or NULL to the sessionName parameter.
        /// Tip  National Instruments recommends that you call the niWLANA_CloseSession function for each uniquely-named instance of the niWLANA_OpenSession function or each instance of the niWLANA_OpenSession function with an unnamed session.
        /// 
        ///</param>
        ///<param name = "toolkitCompatibilityVersion">
        /// compatibilityVersion
        /// int32
        /// Specifies the toolkit compatibility version. 
        ///                         NIWLANA_VAL_COMPATIBILITY_VERSION_010000(10000)
        /// Specifies that the toolkit exhibits version 1.0 behavior and all new features in later releases are unavailable. Select this option if you purchased version 1.0 and want to maintain functional behavior. Refer to the NI WLAN Analysis Toolkit Readme for a list of changes between versions 1.0 and 2.0.
        ///  NIWLANA_VAL_COMPATIBILITY_VERSION_020000(20000)
        /// Specifies that the toolkit exhibits version 2.0 behavior. Select this option to if you want 2.0 behavior and access to new features and bug fixes. Refer to the NI WLAN Analysis Toolkit Readme for a list of changes between versions 1.0 and 2.0.
        /// 
        ///</param>
        ///<param name = "isNewSession">
        /// isNewSession
        /// int32*
        /// Returns NIWLANA_VAL_TRUE if the function creates a new session. This attribute returns NIWLANA_VAL_FALSE if the function returns a reference to an existing session. 
        /// 
        ///</param>
        public niWLANA(string sessionName, int toolkitCompatibilityVersion, out int isNewSession)
        {
            System.IntPtr handle;
            int pInvokeResult = PInvoke.niWLANA_OpenSession(sessionName, toolkitCompatibilityVersion, out handle, out isNewSession);
            TestForError(pInvokeResult);
            _handle = new HandleRef(this, handle);
            if (String.IsNullOrEmpty(sessionName))
                _isNamedSession = false;
            else
                _isNamedSession = true;
        }
        /// <summary>
        /// 
        /// </summary>
        public HandleRef Handle
        {
            get
            {
                return _handle;
            }
        }

        /// <summary>
        /// Performs time-domain power, CCDF, OFDM, direct sequence spread spectrum (DSSS) demodulation, and simultaneous I/Q and spectrum measurements on the complex-valued signal specified by the waveform parameter. Time-domain power measurement results include average and peak burst power. OFDM demodulation results include EVM, header-related and packet-related parameters, gated power, and impairments. DSSS demodulation results include EVM, header-related and packet-related parameters, gated power, and impairments. You can use this function to perform I/Q and spectrum measurements simultaneously. Spectral measurements include spectral mask, OBW, max spectral density, ACP channel power and ETSI in-band emission measurements. You also can use this function to measure the ramp-up and ramp-down times for DSSS bursts. 
        /// Run this function and an NI-RFSA function that performs acquisition in a loop for the number of times equal to the NIWLANA_RECOMMENDED_NUMBER_OF_RECORDS attribute. The function sets the averagingDone parameter to NIWLANA_VAL_TRUE, when the specified number of averages is complete.
        /// After all averages are complete, you can query the results computed by this function. You cannot query results while averaging is in progress.
        /// 
        /// </summary>
        ///<param name = "t0">
        /// Specifies the start time of the data array. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "dt">
        /// Specifies the time interval between data points in the data array. The reciprocal of dt indicates the I/Q rate of the input signal. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "data">
        /// Specifies the acquired complex-valued signal. The real and imaginary parts of this complex array correspond to the in-phase (I) and quadrature-phase (Q) data, respectively.
        /// 
        ///</param>
        ///<param name = "numberofSamples">
        /// Specifies the number of complex samples in the data array.
        /// 
        ///</param>
        ///<param name = "reset">
        /// Specifies whether to reset the function. The default value is NIWLANA_VAL_FALSE.
        /// NIWLANA_VAL_FALSE (0)
        /// Does not reset the function.
        /// NIWLANA_VAL_TRUE (1)
        /// Resets the function. The function overwrites the results of the previous measurement.
        /// 
        ///</param>
        ///<param name = "averagingDone">
        /// Indicates whether the function has completed averaging.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_AnalyzeIQComplexF64
        /// int32 __stdcall niWLANA_AnalyzeIQComplexF64 (niWLANA session,
        ///     float64 t0, 
        ///     float64 dt,
        ///     NIComplexNumber waveform[],
        ///     int32 numberOfSamples,
        ///     int32 reset,
        ///     int32 *averagingDone);
        /// Purpose
        /// Performs time-domain power, CCDF, OFDM, direct sequence spread spectrum (DSSS) demodulation, and simultaneous I/Q and spectrum measurements on the complex-valued signal specified by the waveform parameter. Time-domain power measurement results include average and peak burst power. OFDM demodulation results include EVM, header-related and packet-related parameters, gated power, and impairments. DSSS demodulation results include EVM, header-related and packet-related parameters, gated power, and impairments. You can use this function to perform I/Q and spectrum measurements simultaneously. Spectral measurements include spectral mask, OBW, max spectral density, ACP channel power and ETSI in-band emission measurements. You also can use this function to measure the ramp-up and ramp-down times for DSSS bursts. 
        /// Run this function and an NI-RFSA function that performs acquisition in a loop for the number of times equal to the NIWLANA_RECOMMENDED_NUMBER_OF_RECORDS attribute. The function sets the averagingDone parameter to NIWLANA_VAL_TRUE, when the specified number of averages is complete.
        /// After all averages are complete, you can query the results computed by this function. You cannot query results while averaging is in progress.
        /// 
        ///</returns>
        public int AnalyzeIQComplexF64(double t0, double dt, niComplexNumber[] data, int numberofSamples, int reset, out int averagingDone)
        {
            int pInvokeResult = PInvoke.niWLANA_AnalyzeIQComplexF64(Handle, t0, dt, data, numberofSamples, reset, out averagingDone);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetObw(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultObw, channelString, out value);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetTxPowerMeasurementMode(string channelString, int value)
        {
                return SetInt(niWLANAProperties.TxpowerMeasurementsMode, channelString, value);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetTxPowerMeasurementMode(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.TxpowerMeasurementsMode, channelString,out value);
        }

        /// <summary>
        /// Specifies the reference data constellation when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// The reference data constellation is used for combined signal demodulation. You must set the reference data constellation using this function when you set the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE and set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM.
        /// To improve speed of OFDM demod measurement, you can specify the reference data constellation, which is used for EVM computation. You must set the reference data constellation using this function when you set the NIWLANA_OFDM_DEMOD_ENABLED attribute to NIWLANA_VAL_TRUE, the NIWLANA_OFDM_DEMOD_REFERENCE_DATA_CONSTELLATION_ENABLED attribute to NIWLANA_VAL_TRUE, and the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute
        ///                     Active channel string syntax
        ///                       NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM
        ///                     ""(empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     "streamx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     "segmentx/streamy"
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Specifies the active channel string.
        /// The default value is "" (empty string).
        /// 
        ///</param>
        ///<param name = "I">
        /// Specifies the real part of the constellation points.
        /// 
        ///</param>
        ///<param name = "Q">
        /// Specifies the imaginary part of the constellation points.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the data array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetReferenceDataConstellation
        /// int32 __stdcall niWLANA_SetReferenceDataConstellation (niWLANA session, char activeChannel[], float64 I[], float64 Q[], int32 dataArraySize); 
        /// Purpose
        /// Specifies the reference data constellation when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// The reference data constellation is used for combined signal demodulation. You must set the reference data constellation using this function when you set the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE and set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM.
        /// To improve speed of OFDM demod measurement, you can specify the reference data constellation, which is used for EVM computation. You must set the reference data constellation using this function when you set the NIWLANA_OFDM_DEMOD_ENABLED attribute to NIWLANA_VAL_TRUE, the NIWLANA_OFDM_DEMOD_REFERENCE_DATA_CONSTELLATION_ENABLED attribute to NIWLANA_VAL_TRUE, and the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute
        ///                     Active channel string syntax
        ///                       NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM
        ///                     ""(empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     "streamx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     "segmentx/streamy"
        /// 
        ///</returns>
        public int SetReferenceDataConstellation(string channelString, double[] I, double[] Q, int dataArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_SetReferenceDataConstellation(Handle, channelString, I, Q, dataArraySize);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Performs time-domain and OFDM demodulation measurements on the waveform parameter. Time-domain power measurement results include average and peak burst power. OFDM demodulation results include EVM, header-related and packet-related parameters, gated power, and impairments. You can use this function to perform I/Q and spectrum measurements simultaneously. Spectral measurements include spectral mask, OBW, max spectral density, ACP channel power and ETSI in-band emission measurements.
        /// Use this function if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// 
        /// </summary>
        ///<param name = "t0">
        /// Specifies the start time of the data array. This array must be at least the size specified in numberOfRxChains parameter. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "dt">
        /// Specifies the time interval between data points in the data array. This array must be at least the size specified in numberOfRxChains parameter. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "waveforms">
        /// Specifies the acquired complex-valued signal. The real and imaginary parts of this complex array correspond to the in-phase (I) and quadrature-phase (Q) data, respectively.
        /// You must sequentially append the waveforms from each channel before passing it to analyzer. Size of this array must at least be numberOfRxChains times numberOfSamplesInEachWfm.
        /// 
        ///</param>
        ///<param name = "numberofRxChains">
        /// Specifies the number of channels (waveforms) to process during analysis measurements. The number of received channels must be less than or equal to the number of channels acquired.
        /// 
        ///</param>
        ///<param name = "numberofSamplesInEachWfm">
        /// Specifies the number of complex samples in each WLAN channel waveform. You can obtain the size of waveform per channel from the samplesPerRecord output of niWLANA_RFSAConfigureHardware function. 
        /// 
        ///</param>
        ///<param name = "reset">
        /// Specifies whether to reset the function. The default value is NIWLANA_VAL_FALSE.
        /// NIWLANA_VAL_FALSE (0)
        /// The function does not overwrite the results of the previous measurements.
        /// NIWLANA_VAL_TRUE (1)
        /// The function overwrites the results of the previous measurements.
        /// 
        ///</param>
        ///<param name = "averagingDone">
        /// Indicates whether the function has completed averaging.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_AnalyzeMIMOIQComplexF64
        /// int32 __stdcall niWLANA_AnalyzeMIMOIQComplexF64 (niWLANA session, 
        ///     float64 t0[], 
        ///     float64 dt[], 
        ///     NIComplexNumber *waveforms, 
        ///     int32 numberOfRxChains, 
        ///     int32 numberOfSamplesInEachWfm, 
        ///     int32 reset, 
        ///     int32 *averagingDone);
        /// Purpose
        /// Performs time-domain and OFDM demodulation measurements on the waveform parameter. Time-domain power measurement results include average and peak burst power. OFDM demodulation results include EVM, header-related and packet-related parameters, gated power, and impairments. You can use this function to perform I/Q and spectrum measurements simultaneously. Spectral measurements include spectral mask, OBW, max spectral density, ACP channel power and ETSI in-band emission measurements.
        /// Use this function if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// 
        ///</returns>
        public int AnalyzeMIMOIQComplexF64(double[] t0, double[] dt, niComplexNumber[] waveforms, int numberofRxChains, int numberofSamplesInEachWfm, int reset, out int averagingDone)
        {
            int pInvokeResult = PInvoke.niWLANA_AnalyzeMIMOIQComplexF64(Handle, t0, dt, waveforms, numberofRxChains, numberofSamplesInEachWfm, reset, out averagingDone);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Performs spectral measurements on the input power spectrum. Pass the array of the powerSpectrumData parameter from the niRFSA_ReadPowerSpectrumF64 function or niWLANA_RFSAReadGatedPowerSpectrum function to the niWLANA_AnalyzeMIMOPowerSpectrum function.  The toolkit configures hardware for the number of averages specified for spectral measurements. Spectral measurements results include spectral mask margin, maximum spectral density, ACP, channel power, OBW and ETSI in-band emission measurements. 
        /// 
        /// </summary>
        ///<param name = "f0">
        /// Specifies the start frequency of the spectrum. This array must be at least the size specified in numberOfRxChains parameter. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "df">
        /// Specifies the frequency interval between data points in the spectrum. This array must be at least the size specified in numberOfRxChains parameter. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "powerSpectra">
        /// Returns the real-value power spectrum. You must sequentially append the spectrums from each channel before passing it to the analyzer. The Size of this array must at least be numberOfRxChains times numberOfSamplesInEachSpectrum.
        /// 
        ///</param>
        ///<param name = "numberofRxChains">
        /// Specifies the number of channels (waveforms) to process during analysis measurements. The number of received channels must be less than or equal to the number of channels acquired.
        /// 
        ///</param>
        ///<param name = "numofSamplesInEachSpectrum">
        /// Specifies the number of samples in each WLAN channel spectrum.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_AnalyzeMIMOPowerSpectrum
        /// int32 __stdcall niWLANA_AnalyzeMIMOPowerSpectrum (niWLANA session, 
        ///     float64 f0[],
        ///     float64 df[],
        ///     float64 *powerSpectra,  
        ///     int32 numberOfRxChains,
        ///     int32 numberOfSamplesInEachSpectrum);
        /// Purpose
        /// Performs spectral measurements on the input power spectrum. Pass the array of the powerSpectrumData parameter from the niRFSA_ReadPowerSpectrumF64 function or niWLANA_RFSAReadGatedPowerSpectrum function to the niWLANA_AnalyzeMIMOPowerSpectrum function.  The toolkit configures hardware for the number of averages specified for spectral measurements. Spectral measurements results include spectral mask margin, maximum spectral density, ACP, channel power, OBW and ETSI in-band emission measurements. 
        /// 
        ///</returns>
        public int AnalyzeMIMOPowerSpectrum(double[] f0, double[] df, double[] powerSpectra, int numberofRxChains, int numofSamplesInEachSpectrum)
        {
            int pInvokeResult = PInvoke.niWLANA_AnalyzeMIMOPowerSpectrum(Handle, f0, df, powerSpectra, numberofRxChains, numofSamplesInEachSpectrum);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Performs spectral measurements on the input power spectrum. Pass the powerSpectrumData parameter from the niRFSA_ReadPowerSpectrumF64 function or niWLANA_RFSAReadGatedPowerSpectrum
        /// function to the niWLANA_AnalyzePowerSpectrum function. The toolkit configures hardware for the number of averages specified for spectral measurements. 
        /// After this measurement is complete, you can query spectral measurements such as OBW, maximum spectral density, channel power and spectral mask margin. You also can fetch the spectral mask trace.
        /// To compute more than one spectral measurement with a single spectral acquisition, set the Number of Averages attribute to be the same for all measurements.
        /// 
        /// </summary>
        ///<param name = "f0">
        /// Specifies the start frequency of the spectrum . This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "df">
        /// Specifies the frequency interval between data points in the spectrum. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "powerSpectrumData">
        /// Contains the real-value power spectrum.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the powerSpectrumData data array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_AnalyzePowerSpectrum
        /// int32 __stdcall niWLANA_AnalyzePowerSpectrum (niWLANA session,
        ///     float64 f0, 
        ///     float64 df,
        ///     float64 powerSpectrumData[],
        ///     int32 powerSpectrumDataArraySize);
        /// Purpose
        /// Performs spectral measurements on the input power spectrum. Pass the powerSpectrumData parameter from the niRFSA_ReadPowerSpectrumF64 function or niWLANA_RFSAReadGatedPowerSpectrum
        /// function to the niWLANA_AnalyzePowerSpectrum function. The toolkit configures hardware for the number of averages specified for spectral measurements. 
        /// After this measurement is complete, you can query spectral measurements such as OBW, maximum spectral density, channel power and spectral mask margin. You also can fetch the spectral mask trace.
        /// To compute more than one spectral measurement with a single spectral acquisition, set the Number of Averages attribute to be the same for all measurements.
        /// 
        ///</returns>
        public int AnalyzePowerSpectrum(double f0, double df, double[] powerSpectrumData, int dataArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_AnalyzePowerSpectrum(Handle, f0, df, powerSpectrumData, dataArraySize);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// Returns the constellation trace of all modulated symbols, which are used to compute error vector magnitude (EVM), after applying all relevant corrections. Enable the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_CONSTELLATION_TRACE_ENABLED attributes to get the orthogonal frequency division multiplexing (OFDM) constellation trace. Enable the NIWLANA_DSSS_DEMOD_ENABLED and NIWLANA_DSSS_DEMOD_CONSTELLATION_TRACE_ENABLED attributes to get the direct sequence spread spectrum (DSSS) constellation trace.
        /// If you set the standard parameter of the niWLANA_SetStandard function to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use streamx active channel  string to configure this function. 
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// Specifies the WLAN channel for which you want to fetch the measurement.
        /// 
        ///</param>
        ///<param name = "iData">
        /// IData
        /// float64[]
        /// Returns the real part of the constellation.
        /// 
        ///</param>
        ///<param name = "qData">
        /// QData
        /// float64[]
        /// Returns the imaginary part of the constellation. If you pass NULL to IData and QData array top the function returns the size of arrays in the actulaNumDataArrayElements parameter.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// dataArraySize
        /// int32
        /// Specifies the size of the data array.
        /// 
        ///</param>
        ///<param name = "actualNumDataArrayElements">
        /// actualNumDataArrayElements
        /// int32*
        /// Returns the number of elements in the data array. If the IData or the QData arrays are not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.	
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        [Obsolete]
        public int GetCurrentIterationConstellation(string channelString, double[] iData, double[] qData, int dataArraySize, out int actualNumDataArrayElements)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationConstellation(Handle, channelString, iData, qData, dataArraySize, out actualNumDataArrayElements);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// Returns the EVM per symbol number, in dB, for each iteration when the toolkit processes the acquired burst. The toolkit obtains this trace from the EVM per symbol per subcarrier trace by averaging over the subcarriers.
        /// Set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_EVM_PER_SYMBOL_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE to get the current iteration EVM per symbol for signals that conform to IEEE Standard 802.11a-1999, IEEE Standard 802.11g-2003, and IEEE Standard 802.11n-2009.
        /// Set the NIWLANA_DSSS_DEMOD_ENABLED and NIWLANA_DSSS_DEMOD_EVM_PER_SYMBOL_TRACE_ENABLED attributes to NIWLANA_VAL_TRUE to get the current iteration EVM per symbol for signals that conform to IEEE Standard 802.11b-1999.
        /// If you set the standard parameter of the niWLANA_SetStandard function to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use channelx or streamx active channel  string to configure this function. 
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// Specifies the WLAN channel for which you want to fetch the trace.
        /// 
        ///</param>
        ///<param name = "eVMperSymbol">
        /// evmPerSymbol
        /// float64[]
        /// Returns the EVM per symbol, in dB, for each iteration during processing of the acquired burst. You can pass NULL to evmPerSymbol parameter to get size of the array in actualArraySize parameter.
        /// 
        ///</param>
        ///<param name = "eVMperSymbolArraySize">
        /// evmPerSymbolArraySize
        /// int32
        /// Specifies the size of the evmPerSymbol array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// actualArraySize
        /// int32*
        /// Returns the number of elements in the evmPerSymbol array. If the evmPerSymbol array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        [Obsolete]
        public int GetCurrentIterationEVMPerSymbol(string channelString, double[] eVMperSymbol, int eVMperSymbolArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationEVMPerSymbol(Handle, channelString, eVMperSymbol, eVMperSymbolArraySize, out actualArraySize);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Returns the reference constellation trace if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,  NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_REFERENCE_CONSTELLATION_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                    NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "streamx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "I">
        /// Returns the real part of the constellation points.
        /// 
        ///</param>
        ///<param name = "Q">
        /// Returns the imaginary part of the constellation points.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the data array. If the I or the Q arrays are not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the output arrays.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationReferenceConstellationTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationReferenceConstellationTrace(
        ///     niWLANA session, 
        ///     char channelString[], 
        ///     float64 I[], 
        ///     float64 Q[], 
        ///     int32 dataArraySize, 
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the reference constellation trace if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,  NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_REFERENCE_CONSTELLATION_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                    NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "streamx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        ///</returns>
        public int GetCurrentIterationReferenceConstellationTrace(string channelString, double[] I, double[] Q, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationReferenceConstellationTrace(Handle, channelString, I, Q, dataArraySize, out actualArraySize);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Returns the number of spatial streams according to the modulation and coding scheme (MCS) index that is detected from the signal header or from the information you provide.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "numStreams">
        /// Returns the number of spatial streams according to the MCS index that is detected from the signal header or from information you provide. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodNumberOfSpatialStreams
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodNumberOfSpatialStreams (niWLANA session,
        ///     char channelString[],
        ///     int32 *numStreams);
        /// Purpose
        /// Returns the number of spatial streams according to the modulation and coding scheme (MCS) index that is detected from the signal header or from the information you provide.
        /// 
        ///</returns>
        public int GetCurrentIterationOFDMDemodNumberOfSpatialStreams(string channelString, out int numStreams)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodNumberOfSpatialStreams(Handle, channelString, out numStreams);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Returns the EVM per subcarrier number, in dB, for each iteration when the toolkit processes the acquired burst. The toolkit obtains this trace from the EVM per symbol per subcarrier trace by averaging over the symbols.
        /// Set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_EVM_PER_SUBCARRIER_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE to get the current iteration EVM per subcarrier.
        /// If you set the standard parameter of the niWLANA_SetStandard function to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use channelx or streamx active channel  string to configure this function. 
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// Specifies the WLAN channel for which you want to fetch the trace.
        /// 
        ///</param>
        ///<param name = "eVMperSubcarrier">
        /// evmPerSubcarrier
        /// float64[]
        /// Returns the EVM per subcarrier, in dB, for each iteration during processing of the acquired burst. You can pass NULL to evmPerSubcarrier parameter to get size of the array in actualArraySize parameter. 
        /// 
        ///</param>
        ///<param name = "eVMperSubcarrierArraySize">
        /// evmPerSubcarrierArraySize
        /// int32
        /// Specifies the size of the evmPerSubcarrier array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// actualArraySize
        /// int32*
        /// Returns the number of elements in the evmPerSubcarrier array. If the evmPerSubcarrier array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array. 
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.	
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        [Obsolete]
        public int GetCurrentIterationOFDMEVMPerSubcarrier(string channelString, double[] eVMperSubcarrier, int eVMperSubcarrierArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMEVMPerSubcarrier(Handle, channelString, eVMperSubcarrier, eVMperSubcarrierArraySize, out actualArraySize);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// Returns the EVM per symbol per subcarrier number, in dB, for each iteration when the toolkit processes the acquired burst.
        /// Set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_EVM_PER_SYMBOL_PER_SUBCARRIER_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE to get the current iteration EVM per symbol per subcarrier.
        /// If you set the standard parameter of the niWLANA_SetStandard function to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use channelx or streamx active channel  string to configure this function. 
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// Specifies the WLAN channel for which you want to fetch the measurement.
        /// 
        ///</param>
        ///<param name = "eVMTrace">
        /// evmTrace
        /// float64*
        /// Returns the EVM per symbol per subcarrier, in dB, for each iteration during processing of the acquired burst. The size of this array should at least be numRows times numColumns. You can pass NULL to get actual size in actualNumRows and actualNumColumns parameters.
        /// 
        ///</param>
        ///<param name = "numRows">
        /// numRows
        /// int32
        /// Specifies the number of rows.
        /// 
        ///</param>
        ///<param name = "numColumns">
        /// numColumns
        /// int32
        /// Specifies the number of columns.
        /// 
        ///</param>
        ///<param name = "actualNumRows">
        /// actualNumRows
        /// int32*
        /// Returns the actual number of rows. If the actualNumRows array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the expected number of rows of the evmTrace. 
        /// 
        ///</param>
        ///<param name = "actualNumColumns">
        /// actualNumColumns
        /// int32*
        /// Returns the actual number of columns. If the actualNumColumns array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the expected number of columns of the evmTrace.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.	
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        [Obsolete]
        public int GetCurrentIterationOFDMEVMPerSymbolPerSubcarrier(string channelString, out double eVMTrace, int numRows, int numColumns, out int actualNumRows, out int actualNumColumns)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMEVMPerSymbolPerSubcarrier(Handle, channelString, out eVMTrace, numRows, numColumns, out actualNumRows, out actualNumColumns);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// Returns a power versus time (PvT) trace, in dBm, for the acquired burst. Set the NIWLANA_TXPOWER_MEASUREMENTS_ENABLED and NIWLANA_TXPOWER_MEASUREMENTS_PVT_TRACE_ENABLED attributes to NIWLANA_VAL_TRUE to get the current iteration PvT.
        /// If you set the standard parameter of the niWLANA_SetStandard function to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use channelx active channel  string to configure this function. 
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// Specifies the WLAN channel for which you want to fetch the measurement.
        /// 
        ///</param>
        ///<param name = "t0">
        /// t0
        /// float64*
        /// Returns the time of the first value in the data array.
        /// 
        ///</param>
        ///<param name = "dt">
        /// dt
        /// float64*
        /// Returns the time difference between the values in the data array.
        /// 
        ///</param>
        ///<param name = "data">
        /// data
        /// float64[]
        /// Returns the PvT array. You can pass NULL to data parameter to get size of the array in actualArraySize parameter.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// dataArraySize
        /// int32
        /// Specifies the size of the data array. If the array is not large enough to hold all the samples, the function returns error cand this parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<param name = "actualNumDataArrayElements">
        /// actualNumDataArrayElements
        /// int32*
        /// Returns the number of elements in the data array. If the data array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.	
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        [Obsolete]
        public int GetCurrentIterationPvT(string channelString, out double t0, out double dt, double[] data, int dataArraySize, out int actualNumDataArrayElements)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationPvT(Handle, channelString, out t0, out dt, data, dataArraySize, out actualNumDataArrayElements);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// Takes the error code returned by niWLAN Analysis functions and returns the interpretation as a user-readable string.
        /// 
        /// </summary>
        ///<param name = "status">
        /// errorCode
        /// int32
        /// Identifies the error code that is returned from any of the WLAN Analysis functions.
        /// 
        ///</param>
        ///<param name = "msg">
        /// errorMessage
        /// char[]
        /// Returns the user-readable message string that corresponds to the error code you specify. The errorMessage buffer must have at least as many elements as are indicated in errorMessageLen.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        public int GetErrorString(int status, StringBuilder msg)
        {
            int size = PInvoke.niWLANA_GetErrorString(Handle, status, null, 0);
            if ((size >= 0))
            {
                msg.Capacity = size;
                PInvoke.niWLANA_GetErrorString(Handle, status, msg, size);
            }
            return status;
        }
        /// <summary>
        /// 
        /// Queries the value of an niWLAN Analysis 64-bit floating point number (float64) attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// If the attribute is channel-based, this parameter specifies the channel to which the attribute applies. If the attribute is not channel-based, set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// attributeID
        /// niWLANA_Attr
        /// Specifies the ID of a float64 niWLAN Analysis attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// attributeValue
        /// float64*
        /// Returns the current value of an attribute.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        public int GetScalarAttributeF64(string channelString, niWLANAProperties attributeID, out double attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANA_GetScalarAttributeF64(Handle, channelString, attributeID, out attributeValue);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// Queries the value of an niWLAN Analysis 32-bit integer (int32) attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// If the attribute is channel-based, this parameter specifies the channel to which the attribute applies. If the attribute is not channel-based, set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// attributeID
        /// niWLANA_Attr
        /// Specifies the ID of an int32 niWLAN Analysis attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// attributeValue
        /// int32*
        /// Returns the current value of an attribute.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        public int GetScalarAttributeI32(string channelString, niWLANAProperties attributeID, out int attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANA_GetScalarAttributeI32(Handle, channelString, attributeID, out attributeValue);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// Returns the spectral mask and power spectral density (PSD) spectrum, as defined in section 18.4.7.3 of IEEE Standard 802.11b-1999, section 17.9.3.2 of IEEE Standard 802.11a-1999, and IEEE Standard 802.11n-2009. Set the NIWLANA_SPECTRAL_MASK_TRACE_ENABLED attribute and either the NIWLANA_SPECTRAL_MEASUREMENTS_ALL_ENABLED or the NIWLANA_SPECTRAL_MASK_ENABLED attribute to NIWLANA_VAL_TRUE to get the current iteration spectral mask trace.
        /// The first element of the spectralMask array contains the spectral mask. The second element of the array contains the PSD trace.
        /// If you set the standard parameter of the niWLANA_SetStandard function to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use channelx active channel  string to configure this function. 
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// Specifies the WLAN channel for which you want to fetch the measurement.
        /// 
        ///</param>
        ///<param name = "f0">
        /// f0
        /// float64*
        /// Returns the initial frequency of the spectrum, in hertz (Hz).
        /// 
        ///</param>
        ///<param name = "df">
        /// df
        /// float64*
        /// Returns the frequency intervals between data points in the spectrum.
        /// 
        ///</param>
        ///<param name = "spectralMask">
        /// spectralMask
        /// float64[]
        /// Returns the spectral mask as the first element of the output array. The second element contains the PSD trace.
        /// 
        ///</param>
        ///<param name = "spectrum">
        /// spectrum
        /// float64[]
        /// Returns the spectral mask with the PSD spectrum superimposed on it. You can pass NULL to spectrum and spectralMask parameter to get size of the array in actualNumDataArrayElements parameter.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// dataArraySize
        /// int32
        /// Specifies the size of the data array.
        /// 
        ///</param>
        ///<param name = "actualNumDataArrayElements">
        /// actualNumDataArrayElements
        /// int32*
        /// Returns the number of elements in the data array. If the spectrum and spectralMask arrays are not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        [Obsolete]
        public int GetSpectralMask(string channelString, out double f0, out double df, double[] spectralMask, double[] spectrum, int dataArraySize, out int actualNumDataArrayElements)
        {
            int pInvokeResult = PInvoke.niWLANA_GetSpectralMask(Handle, channelString, out f0, out df, spectralMask, spectrum, dataArraySize, out actualNumDataArrayElements);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// Queries the value of an niWLAN analysis 64-bit floating point number (float64) array attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// If the attribute is channel-based, this parameter specifies the channel to which the attribute applies. If the attribute is not channel-based, set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// attributeID
        /// niWLANA_Attr
        /// Specifies the ID of a float64 niWLAN analysis vector attribute.
        /// 
        ///</param>
        ///<param name = "data">
        /// data
        /// float64
        /// Returns the current value of a float64 vector attribute. The array must have at least as many elements as are indicated in the dataArraySize parameter.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// dataArraySize
        /// int32
        /// Specifies the number of elements in the data array.
        /// 
        ///</param>
        ///<param name = "actualNumDataArrayElements">
        /// actualNumDataArrayElements
        /// int32*
        /// Returns the actual number of elements populated in data array attribute. If the array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        public int GetVectorAttributeF64(string channelString, niWLANAProperties attributeID, double[] data, int dataArraySize, out int actualNumDataArrayElements)
        {
            int pInvokeResult = PInvoke.niWLANA_GetVectorAttributeF64(Handle, channelString, attributeID, data, dataArraySize, out actualNumDataArrayElements);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// Resets all the attributes of the session to their default values.
        /// 
        /// </summary>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.	
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        public int ResetSession()
        {
            int pInvokeResult = PInvoke.niWLANA_ResetSession(Handle);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// Performs an acquisition and sets the best reference level for the instrument, based on the peak power of the measured signal.
        /// 
        /// </summary>
        ///<param name = "rFSASession">
        /// rfsaSession
        /// ViSession
        /// Specifies a reference to an NI-RFSA instrument session. This parameter is obtained from the niRFSA_init or niRFSA_InitWithOptions function and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "hardwareChannelString">
        /// hwChannelString[]
        /// char
        /// Specifies the RFSA device channel. Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// carrierFrequency
        /// double
        /// Specifies the carrier frequency, in hertz (Hz), around which the RF signal analyzer acquires a WLAN signal. Set this value equal to the carrier frequency of the transmitting device under test (DUT). 
        /// 
        ///</param>
        ///<param name = "bandwidth">
        /// bandwidth
        /// double
        /// Specifies the bandwidth, in hertz (Hz), of the signal to be analyzed. 
        /// 
        ///</param>
        ///<param name = "measurementInterval">
        /// measurementInterval
        /// double
        /// Specifies the acquisition length in seconds. This value is used to compute the number of samples to acquire from NI RF signal analyzer. 
        /// 
        ///</param>
        ///<param name = "maxNumberofIterations">
        /// maxNumberOfIterations
        /// int32
        /// Specifies the maximum number of iterations to perform while computing the reference level to be set on NI RF Signal Analyzer. 
        /// 
        ///</param>
        ///<param name = "resultantReferenceLevel">
        /// resultantReferenceLevel
        /// double*
        /// Returns the reference level, in dBm/Hz, that the toolkit uses for spectral mask measurements. 
        /// 
        ///</param>
        ///<returns>	
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.	
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.	
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.	
        /// The general meaning of the status code is as follows:	
        /// Value           Meaning	
        /// 0               Success	
        /// Positive Values Warnings	
        /// Negative Values Errors	
        ///	
        /// </returns>
        [Obsolete("use static method WLANA_RFSAAutoLevel")]
        public int RFSAAutoLevel(HandleRef rFSASession, string hardwareChannelString, double carrierFrequency, double bandwidth, double measurementInterval, int maxNumberofIterations, out double resultantReferenceLevel)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAAutoLevel(rFSASession, hardwareChannelString, carrierFrequency, bandwidth, measurementInterval, maxNumberofIterations, out resultantReferenceLevel);
            TestForError(pInvokeResult, rFSASession);
            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="rFSASession"></param>
        /// <param name="hardwareChannelString"></param>
        /// <param name="bandwidth"></param>
        /// <param name="measurementInterval"></param>
        /// <param name="maxNumberofIterations"></param>
        /// <param name="resultantReferenceLevel"></param>
        /// <returns></returns>
        [Obsolete("use static method WLANSA_RFSAAutoLevel")]
        public int RFSAAutoLevel(HandleRef rFSASession, string hardwareChannelString, double bandwidth, double measurementInterval, int maxNumberofIterations, out double resultantReferenceLevel)
        {
            int pInvokeResult = PInvoke.niWLANSA_RFSAAutoLevel(rFSASession, hardwareChannelString, bandwidth, measurementInterval, maxNumberofIterations, out resultantReferenceLevel);
            TestForError(pInvokeResult, rFSASession);
            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="rFSASession"></param>
        /// <param name="hardwareChannelString"></param>
        /// <param name="carrierFrequency"></param>
        /// <param name="bandwidth"></param>
        /// <param name="measurementInterval"></param>
        /// <param name="maxNumberofIterations"></param>
        /// <param name="resultantReferenceLevel"></param>
        /// <returns></returns>
        public static int WLANA_RFSAAutoLevel(HandleRef rFSASession, string hardwareChannelString, double carrierFrequency, double bandwidth, double measurementInterval, int maxNumberofIterations, out double resultantReferenceLevel)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAAutoLevel(rFSASession, hardwareChannelString, carrierFrequency, bandwidth, measurementInterval, maxNumberofIterations, out resultantReferenceLevel);
            StaticTestForError(pInvokeResult, rFSASession);
            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="rFSASession"></param>
        /// <param name="hardwareChannelString"></param>
        /// <param name="bandwidth"></param>
        /// <param name="measurementInterval"></param>
        /// <param name="maxNumberofIterations"></param>
        /// <param name="resultantReferenceLevel"></param>
        /// <returns></returns>
        public static int WLANSA_RFSAAutoLevel(HandleRef rFSASession, string hardwareChannelString, double bandwidth, double measurementInterval, int maxNumberofIterations, out double resultantReferenceLevel)
        {
            int pInvokeResult = PInvoke.niWLANSA_RFSAAutoLevel(rFSASession, hardwareChannelString, bandwidth, measurementInterval, maxNumberofIterations, out resultantReferenceLevel);
            StaticTestForError(pInvokeResult, rFSASession);
            return pInvokeResult;
        }

        /// <summary>
        /// 
        /// Analyzes the incoming signal to measure the maximum input power and acquisition length of the burst and sets these values to the NIWLANA_RESULT_AUTORANGE_MAX_INPUT_POWER and NIWLANA_AUTORANGE_MAX_ACQUISITION_LENGTH attributes, respectively.
        /// You must configure the niRFSA NIWLANA_AUTORANGE_MAX_ACQUISITION_LENGTH attribute before using this function. This function queries the IQ Rate attribute, multiplies this value by the NIWLANA_AUTORANGE_MAX_ACQUISITION_LENGTH value, and sets the value equal to the niRFSA Number Of Samples attribute.
        /// You must configure the NIWLANA_AUTORANGE_MAX_IDLE_TIME attribute before using this function. This function sets the timeout value on the niRFSA Fetch IQ function equal to this parameter.
        /// This function is not available for non-gated spectrum mode.
        /// 
        /// </summary>
        ///<param name = "wLANChannelString">
        /// wlanChannelString
        /// char[]
        /// Specifies the WLAN channel to be used for configuration.
        /// 
        ///</param>
        ///<param name = "rFSASession">
        /// rfsaSession
        /// ViSession
        /// Specifies a reference to an NI-RFSA instrument session. This parameter is obtained from the niRFSA_init or niRFSA_InitWithOptions function and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "hardwareChannelString">
        /// hwChannelString
        /// char[]
        /// Specifies the RFSA device channel. Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        public int RFSAAutoRange(string wLANChannelString, HandleRef rFSASession, string hardwareChannelString)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAAutoRange(Handle, wLANChannelString, rFSASession, hardwareChannelString);

            TestForError(pInvokeResult, rFSASession);

            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// Configures the NI&#160;PXIe-5663 and NI&#160;PXIe-5663E for the type of WLAN measurement you specify. If the resetHardware parameter is set to NIWLANA_VAL_TRUE, this function resets the device to a default initialization state.
        /// Note&#160;&#160;For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, or IEEE Standard 802.11g-2003, if the compatibilityVersion parameter of the 
        /// niWLANA_OpenSession function is set to NIWLANA_VAL_COMPATIBILITY_VERSION_010000, the toolkit supports NI PXI-5661, NI PXIe-5663, and NI PXIe-5663E. For signals conforming to IEEE Standard 802.11a-1999, IEEE Standard 802.11b-1999, IEEE Standard 802.11g-2003, or IEEE Standard 802.11n-2009, if the compatibilityVersion parameter is set to NIWLANA_VAL_COMPATIBILITY_VERSION_020000, the toolkit supports NI PXIe-5663 and NI PXIe-5663E.
        /// If you use an RF signal analyzer other than the NI PXIe-5663 or NI PXIe-5663E with this function, the function returns an error. If any of the spectral measurements are enabled, this function configures the analyzer for spectral acquisition. Otherwise, this function configures the analyzer for I/Q acquisition. For NI PXIe-5663 and NI PXIe-5663E, this function configures the NIRFSA_ATTR_REFERENCE_LEVEL attribute as x-overdrive, where x is the NIWLANA_MAX_INPUT_POWER property and overdrive value is chosen to be 6 dB. 
        /// This function configures the NIRFSA_ATTR_REFERENCE_LEVEL attribute according to the following table.
        /// This function also configures the following NI-RFSA attributes:
        /// Resets the NIRFSA_ATTR_IQ_CARRIER_FREQUENCY and sets it to the user-specified value.
        /// Sets the NIRFSA_ATTR_ACQUISITION_TYPE to NIRFSA_VAL_IQ.
        /// Sets the NIRFSA_ATTR_REF_TRIGGER_TYPE to NIRFSA_VAL_IQ_POWER_EDGE if the NIWLANA_IQ_POWER_EDGE_REFERENCE_TRIGGER_ENABLED attribute is set to NIWLANA_VAL_TRUE.
        /// Sets the NIRFSA_ATTR_IQ_POWER_EDGE_REF_TRIGGER_LEVEL attribute to approximately 30&#160;dB below the user-specified mean power.
        /// Sets the NIRFSA_ATTR_IQ_RATE attribute according to the following table. 
        /// Device
        /// Value of the NIWLANA_STANDARD Attribute
        /// Value of the NIRFSA_ATTR_IQ_RATE Attribute
        /// NI PXIe-5663
        /// NIWLANA_VAL_80211AG_OFDM
        /// 40M
        /// NI PXIe-5663
        /// NIWLANA_VAL_80211BG_DSSS
        /// 44M
        /// NI PXIe-5663
        /// NIWLANA_VAL_80211G_DSSS_OFDM
        /// 25M
        /// NI PXIe-5663
        /// NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        /// 40M, if channel bandwidth is 20; 50M, if channel bandwidth is 40M
        /// Sets the NIRFSA_ATTR_REF_TRIGGER_PRETRIGGER_SAMPLES attribute to ceil(20 ?s ? sample rate).
        /// Sets the NIRFSA_ATTR_IQ_POWER_EDGE_REF_TRIGGER_MINIMUM_QUIET_TIME attribute to 8 ?s.
        /// Sets the NIRFSA_ATTR_NUM_RECORDS attribute to the maximum of all enabled number of averages, as defined in the NIWLANA_NUMBER_OF_ITERATIONS attribute.
        /// Sets the NIRFSA_ATTR_NUM_RECORDS_IS_FINITE attribute to NIWLANA_VAL_TRUE. 
        /// Sets the NIRFSA_ATTR_NUM_SAMPLES attribute to to IQ Rate*(Acquisition Length+Pretrigger Samples+10 ?s). 
        /// For spectral measurements, this function configures NI-RFSA attributes as follows:
        /// Resets the previous trigger configuration. 
        /// Sets the NIRFSA_ATTR_ACQUISITION_TYPE attribute to NIRFSA_VAL_SPECTRUM.
        /// Sets the NIRFSA_ATTR_RESOLUTION_BANDWIDTH attribute a user-specified value. If the NIWLANA_SPECTRAL_MASK_ENABLED attribute is set to NIWLANA_VAL_TRUE and the NIWLANA_STANDARD attribute is set to NIWLANA_VAL_80211AG_OFDM, NIWLANA_VAL_80211G_DSSS_OFDM, or NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, the toolkit multiplies the number of spectral averages by three to emulate the effects of video bandwidth (VBW).
        /// Sets the NIRFSA_ATTR_SPECTRUM_SPAN attribute  to a user-specified value.
        /// Sets the NIRFSA_ATTR_SPECTRUM_CENTER_FREQUENCY, NIRFSA_ATTR_POWER_SPECTRUM_UNITS, NIRFSA_ATTR_FFT_WINDOW_TYPE, and NIRFSA_ATTR_SPECTRUM_NUMBER_OF_AVERAGES attributes to user-specified values.
        /// 
        /// </summary>
        ///<param name = "wLANChannelString">
        /// wlanChannelString
        /// char[]
        /// Specifies the WLAN channel to be used for configuration.
        /// 
        ///</param>
        ///<param name = "rFSASession">
        /// rfsaSession
        /// ViSession
        /// Specifies a reference to an NI-RFSA instrument session. This parameter is obtained from the niRFSA_init or niRFSA_InitWithOptions function and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "hardwareChannelString">
        /// hwChannelString
        /// char[]
        /// Specifies the RFSA device channel. Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "resetHardware">
        /// resetHardware
        /// int32
        /// Specifies whether the NI RF signal analyzer is reset. Set this parameter to TRUE to reset the hardware.
        /// 
        ///</param>
        ///<param name = "samplesPerRecord">
        /// samplesPerRecord
        /// int64*
        /// Returns the number of samples per record configured for the NI-RFSA session.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        public int RFSAConfigure(string wLANChannelString, HandleRef rFSASession, string hardwareChannelString, int resetHardware, out long samplesPerRecord)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAConfigure(Handle, wLANChannelString, rFSASession, hardwareChannelString, resetHardware, out samplesPerRecord);

            TestForError(pInvokeResult, rFSASession);

            return pInvokeResult;
        }

        /// <summary>
        /// Performs I/Q measurements or spectral measurements, or both. This function configures and initiates the NI-RFSAs for acquisition and then performs the configured WLAN measurements on the acquired data using the niWLANA_AnalyzeIQComplexF64, niWLANA_AnalyzeMIMOIQComplexF64, niWLANA_AnalyzePowerSpectrum, or niWLANA_AnalyzeMIMOPowerSpectrum function.
        /// The niWLANA_RFSAMeasure function does the following steps:
        /// Configures NI-RFSA for IQ or Spectrum acquisitions depending on the type of WLAN measurements, by calling the niWLANA_RFSAConfigureHardware function. For multiple devices functions are called in a loop. 
        /// If you set the NIWLANA_RECOMMENDED_ACQUISITION_TYPE attribute to NIWLANA_VAL_ACQUISITION_TYPE_IQ:The niWLANA_RFSAMeasure function calls the niRFSA_Initiate function in case of single device, or niWLANA_RFSAMultipleDeviceInitiate function in case of multiple devices for data acquisition.
        /// The niWLANA_RFSAMeasure function fetches the data by calling the niRFSA_FetchIQ and performs the measurements by calling the niWLANA_AnalyzeIQComplexF64 or niWLANA_AnalyzeMIMOIQComplexF64 functions. The niWLANA_RFSAMeasure function repeats this step till the averaging is done for the recommended number of records. 
        /// If you set the NIWLANA_RECOMMENDED_ACQUISITION_TYPE attribute to NIWLANA_VAL_ACQUISITION_TYPE_SPECTRUM:
        /// The niWLANA_RFSAMeasure function calls the niRFSA_ReadPowerSpectrum function if you set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_FALSE or calls the niWLANA_RFSAReadGatedPowerSpectrum function if you set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE, to get the averaged power spectrum data.
        /// The niWLANA_RFSAMeasure function performs spectral measurements by calling the niWLANA_AnalyzePowerSpectrum or niWLANA_AnalyzeMIMOPowerSpectrum functions.
        /// The niWLANA_RFSAMeasure function calls the niRFSA_Abort function to stop any further acquisitions initiated earlier.
        /// 
        /// </summary>
        ///<param name = "rFSASession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSA_init function or the niRFSA_InitWithOptions function. 
        /// 
        ///</param>
        ///<param name = "hardwareChannelString">
        ///</param>
        ///<param name = "timeout">
        /// Specifies the time allotted for the function to complete before returning a timeout error. A value of -1 specifies that the function waits until all data is available. The default value is 10.  This value is expressed in seconds.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAMeasure
        /// int32 __stdcall niWLANA_RFSAMeasure (niWLANA session, 
        ///     ViSession rfsaSession,
        ///     char hwChannelString[], 
        ///     double timeout);
        /// Purpose
        /// Performs I/Q measurements or spectral measurements, or both. This function configures and initiates the NI-RFSAs for acquisition and then performs the configured WLAN measurements on the acquired data using the niWLANA_AnalyzeIQComplexF64, niWLANA_AnalyzeMIMOIQComplexF64, niWLANA_AnalyzePowerSpectrum, or niWLANA_AnalyzeMIMOPowerSpectrum function.
        /// The niWLANA_RFSAMeasure function does the following steps:
        /// Configures NI-RFSA for IQ or Spectrum acquisitions depending on the type of WLAN measurements, by calling the niWLANA_RFSAConfigureHardware function. For multiple devices functions are called in a loop. 
        /// If you set the NIWLANA_RECOMMENDED_ACQUISITION_TYPE attribute to NIWLANA_VAL_ACQUISITION_TYPE_IQ:The niWLANA_RFSAMeasure function calls the niRFSA_Initiate function in case of single device, or niWLANA_RFSAMultipleDeviceInitiate function in case of multiple devices for data acquisition.
        /// The niWLANA_RFSAMeasure function fetches the data by calling the niRFSA_FetchIQ and performs the measurements by calling the niWLANA_AnalyzeIQComplexF64 or niWLANA_AnalyzeMIMOIQComplexF64 functions. The niWLANA_RFSAMeasure function repeats this step till the averaging is done for the recommended number of records. 
        /// If you set the NIWLANA_RECOMMENDED_ACQUISITION_TYPE attribute to NIWLANA_VAL_ACQUISITION_TYPE_SPECTRUM:
        /// The niWLANA_RFSAMeasure function calls the niRFSA_ReadPowerSpectrum function if you set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_FALSE or calls the niWLANA_RFSAReadGatedPowerSpectrum function if you set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE, to get the averaged power spectrum data.
        /// The niWLANA_RFSAMeasure function performs spectral measurements by calling the niWLANA_AnalyzePowerSpectrum or niWLANA_AnalyzeMIMOPowerSpectrum functions.
        /// The niWLANA_RFSAMeasure function calls the niRFSA_Abort function to stop any further acquisitions initiated earlier.
        /// 
        ///</returns>
        public int RFSAMeasure(HandleRef rFSASession, string hardwareChannelString, double timeout)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAMeasure(Handle, rFSASession, hardwareChannelString, timeout);
            TestForError(pInvokeResult, rFSASession);
            return pInvokeResult;
        }

        /// <summary>
        /// Performs measurements on a signal if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, 
        /// IWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM,
        /// or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// </summary>
        ///<param name = "rFSASessions">
        /// Specifies an array of references to multiple NI-RFSA instrument sessions. This parameter is obtained from the niRFSA_init or niRFSA_InitWithOptions function and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "hardwareChannelStrings">
        /// Specifies the RFSA device channel. Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "numberofRxChains">
        /// Specifies the number of channels (waveforms) to process during analysis measurements. The number of received channels must be less than or equal to the number of channels acquired.
        /// 
        ///</param>
        ///<param name = "timeout">
        /// Specifies the time allotted for the function to complete before returning a timeout error. A value of &#45;1 specifies the function waits until all data is available. The default value is 10.  This value is expressed in seconds.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAMIMOMeasure
        /// int32 __stdcall niWLANA_RFSAMIMOMeasure (niWLANA session,
        ///     ViSession rfsaSessions[],
        ///     char *hwChannelStrings[], 
        ///     int32 numberOfrxChains,
        ///     double timeout);
        /// Purpose
        /// Performs measurements on a signal if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,
        /// NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        ///</returns>
        public int RFSAMIMOMeasure(HandleRef[] rFSASessions, string[] hardwareChannelStrings, int numberofRxChains, double timeout)
        {
            Int32[] rfsaIntPtrHandles = new Int32[rFSASessions.Length];
            for (int i = 0; i < rFSASessions.Length; i++)
            {
                rfsaIntPtrHandles[i] = rFSASessions[i].Handle.ToInt32();
            }
            int pInvokeResult = PInvoke.niWLANA_RFSAMIMOMeasure(Handle, rfsaIntPtrHandles, hardwareChannelStrings, numberofRxChains, timeout);
            // Rfsa handles are passed into PInvokes as Int32[], so we need to make sure that the rfsa wrapper object 
            // is not eligible for garbage collection.
            // TestForError call below, uses HandleRef[] and HandleRef contains the wrapper object hence in this case wrapper object is kept alive.
            // If handles are not used after the PInvoke, unlike this case, then you need to GC.KeepAlive to keep the wrapper object alive.
            TestForError(pInvokeResult, rFSASessions);

            return pInvokeResult;
        }


        /// <summary>
        /// Initiates a gated spectrum acquisition for a single channel and returns averaged power spectrum data when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM. This value is expressed in volts squared.
        /// Gated spectrum is the spectrum of the signal acquired in a specified time interval. The signal transition from an idle state to an active state triggers and initiates this acquisition. Configure a Reference trigger in NI-RFSA when you want the acquisition of the signal to be triggered. Set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE before calling this function.
        /// 
        /// </summary>
        ///<param name = "wLANChannelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///  No help available
        /// 
        ///</param>
        ///<param name = "rFSASession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSA_init or niRFSA_InitWithOptions function and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "hardwareChannelString">
        ///</param>
        ///<param name = "timeout">
        /// Specifies the time allotted for the function to complete before returning a timeout error. A value of -1 specifies that the function waits until all data is available. The default value is 10.  This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "f0">
        /// Returns the start frequency of the spectrum.  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "df">
        /// Returns the frequency interval between data points in the spectrum. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "powerSpectrum">
        /// Returns the real-value power spectrum.
        /// 
        ///</param>
        ///<param name = "powerSpectrumArraySize">
        /// Specifies the size of the powerSpectrum array. The actualNumPowerSpectrumElements parameter contains the size of the spectrum. To obtain the size of the power spectrum, pass NULL to the powerSpectrum parameter. 
        /// 
        ///</param>
        ///<param name = "actualNumPowerSpectrumElement">
        /// Returns the actual number of elements populated in the powerSpectrum array. If the powerSpectrum array is not large enough to hold all the samples, the function returns error and this parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAReadGatedPowerSpectrum
        ///  int32 __stdcall niWLANA_RFSAReadGatedPowerSpectrum (niWLANA session, 
        ///     char wlanChannelString[],
        ///     ViSession rfsaSession, 
        ///     char hwChannelString[],
        ///     float64 timeout,
        ///     float64 *f0,
        ///     float64 *df,
        ///     float64 powerSpectrum[],
        ///     int32 powerSpectrumArraySize,
        ///     int32 *actualNumPowerSpectrumElements);
        /// Purpose
        /// Initiates a gated spectrum acquisition for a single channel and returns averaged power spectrum data when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM. This value is expressed in volts squared.
        /// Gated spectrum is the spectrum of the signal acquired in a specified time interval. The signal transition from an idle state to an active state triggers and initiates this acquisition. Configure a Reference trigger in NI-RFSA when you want the acquisition of the signal to be triggered. Set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE before calling this function.
        /// 
        ///</returns>
        public int RFSAReadGatedPowerSpectrum(string wLANChannelString, HandleRef rFSASession, string hardwareChannelString, double timeout, out double f0, out double df, double[] powerSpectrum, int powerSpectrumArraySize, out int actualNumPowerSpectrumElement)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAReadGatedPowerSpectrum(Handle, wLANChannelString, rFSASession, hardwareChannelString, timeout, out f0, out df, powerSpectrum, powerSpectrumArraySize, out actualNumPowerSpectrumElement);

            TestForError(pInvokeResult, rFSASession);

            return pInvokeResult;
        }

        /// <summary>
        /// Initiates a gated spectrum acquisition for one or more channels and returns averaged power spectrum data when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. This value is expressed in volts squared.
        /// Gated spectrum is the spectrum of the signal acquired in a specified time interval. The signal transition from an idle state to an active state triggers and initiates this acquisition. Configure a Reference trigger in NI-RFSA when you want the acquisition of the signal to be triggered. Set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE before calling this function.
        /// 
        /// </summary>
        ///<param name = "wLANChannelStrings">
        /// Set this parameter to NULL.
        /// 
        ///</param>
        ///<param name = "rFSASessions">
        /// Identifies an array instruments for multiple NI-RFSA sessions. The toolkit obtains this parameter from the niRFSA_init or niRFSA_InitWithOptions function and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "hwChannelStrings">
        /// Specifies the RFSA device channel. Set this parameter to NULL.
        /// 
        ///</param>
        ///<param name = "timeout">
        /// Specifies the time allotted for the function to complete before returning a timeout error. A value of -1 specifies the function waits until all data is available. The default value is 10.  This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "f0">
        /// Returns the start frequency of the spectrum on each channel This array must be at least the size specified in numberOfRxChains parameter. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "df">
        /// Returns the per channel frequency interval between data points in the spectrum. This array must be at least the size specified in numberOfRxChains parameter.
        /// 
        ///</param>
        ///<param name = "powerSpectra">
        /// Returns the real-value power spectra. The spectrums are written sequentially in the array. Allocate an array at least as large as numberOfRxChains times individualSpectrumSize for this parameter.
        /// 
        ///</param>
        ///<param name = "numberofRxChains">
        /// Specifies the number of channels (waveforms) to process during analysis measurements. The number of received channels must be less than or equal to the number of channels acquired.
        /// 
        ///</param>
        ///<param name = "individualSpectrumSize">
        /// Specifies size of spectrum per WLAN channel. The actualNumSamplesInEachSpectrum parameter contains the size of the spectrum. To obtain the size of the power spectrum, pass NULL to the powerSpectra parameter. 
        /// 
        ///</param>
        ///<param name = "actualNumSamplesInEachSpec">
        /// Returns the actual number of elements for each WLAN channel power spectrum. If the powerSpectra array is not large enough to hold all the samples, the function returns error and this parameter returns the per channel minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAReadMIMOGatedPowerSpectrum
        ///  int32 __stdcall  niWLANA_RFSAReadMIMOGatedPowerSpectrum (niWLANA session, 
        ///      char *wlanChannelStrings[],
        ///      ViSession rfsaSessions[], 
        ///      char *hwChannelStrings[], 
        ///      float64 timeout,
        ///      float64 f0[], 
        ///      float64 df[], 
        ///      double *powerSpectra,
        ///      int32 numberOfRxChains,
        ///      int32 individualSpectrumSize,
        ///      int32* actualNumSamplesInEachSpectrum);
        /// Purpose
        /// Initiates a gated spectrum acquisition for one or more channels and returns averaged power spectrum data when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. This value is expressed in volts squared.
        /// Gated spectrum is the spectrum of the signal acquired in a specified time interval. The signal transition from an idle state to an active state triggers and initiates this acquisition. Configure a Reference trigger in NI-RFSA when you want the acquisition of the signal to be triggered. Set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE before calling this function.
        /// 
        ///</returns>
        public int RFSAReadMIMOGatedPowerSpectrum(string wLANChannelStrings, HandleRef[] rFSASessions, string hwChannelStrings, double timeout, double[] f0, double[] df, double[] powerSpectra, int numberofRxChains, int individualSpectrumSize, out int actualNumSamplesInEachSpec)
        {
            Int32[] rfsaIntPtrHandles = new Int32[rFSASessions.Length];
            for (int i = 0; i < rFSASessions.Length; i++)
            {
                rfsaIntPtrHandles[i] = rFSASessions[i].Handle.ToInt32();
            }
            int pInvokeResult = PInvoke.niWLANA_RFSAReadMIMOGatedPowerSpectrum(Handle, wLANChannelStrings, rfsaIntPtrHandles, hwChannelStrings, timeout, f0, df, powerSpectra, numberofRxChains, individualSpectrumSize, out actualNumSamplesInEachSpec);
            // Rfsa handles are passed into PInvokes as Int32[], so we need to make sure that the rfsa wrapper object 
            // is not eligible for garbage collection.
            // TestForError call below, uses HandleRef[] and HandleRef contains the wrapper object hence in this case wrapper object is kept alive.
            // If handles are not used after the PInvoke, unlike this case, then you need to GC.KeepAlive to keep the wrapper object alive.
            TestForError(pInvokeResult, rFSASessions);
            return pInvokeResult;
        }


        /// <summary>
        /// Enables either demodulation-based or spectral-based measurements.
        /// 
        /// </summary>
        ///<param name = "measurement">
        /// Specifies the measurement to enable. The default value is NIWLANA_VAL_OFDM_DEMOD_MEASUREMENT.
        /// Note&#160;&#160;Do not select demodulation and spectral measurements simultaneously. Refer to Simultaneous Measurements for more information about compatible measurements.
        /// NIWLANA_VAL_OFDM_DEMOD_MEASUREMENT (0x00000001)
        /// Enables 
        /// OFDM demodulation-based measurements.
        /// NIWLANA_VAL_OFDM_DEMOD_WITH_GATED_POWER_MEASUREMENT (0x00000002)
        /// Enables OFDM demodulation with gated power measurements.
        /// NIWLANA_VAL_DSSS_DEMOD_MEASUREMENT (0x00000004)
        /// Enables direct sequence spread spectrum (DSSS) demodulation-based measurements.
        /// NIWLANA_VAL_DSSS_DEMOD_WITH_GATED_POWER_MEASUREMENT (0x00000008)
        /// Enables DSSS demodulation with gated power measurements.
        /// NIWLANA_VAL_DSSS_POWER_RAMP_MEASUREMENT (0x00000010)
        /// Enables DSSS power ramp measurements.
        /// NIWLANA_VAL_TXPOWER_MEASUREMENT (0x00000020)
        /// Enables transmit power measurements.
        /// NIWLANA_VAL_SPECTRAL_MASK_MEASUREMENT (0x00000040)
        /// Enables spectral mask measurements.
        /// NIWLANA_VAL_OBW_MEASUREMENT (0x00000080)
        /// Enables OBW measurements.
        /// NIWLANA_VAL_MAX_SPECTRAL_DENSITY_MEASUREMENT (0x00000100)
        /// Enables maximum spectral density measurements.
        /// NIWLANA_VAL_CHANNEL_POWER_MEASUREMENT (0x00000200)
        /// Enables channel power measurements.
        /// NIWLANA_VAL_CCDF_MEASUREMENT (0x00000400)
        /// Enables CCDF measurements.
        /// NIWLANA_VAL_ACP_MEASUREMENT (0x00001000)
        /// Enables ACP measurements.
        /// NIWLANA_VAL_ETSI_IBE_MEASUREMENT (0x00002000)
        /// Enables ETSI in-band emission measurements.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SelectMeasurements
        /// int32 __stdcall niWLANA_SelectMeasurements(
        ///     niWLANA session, 
        ///     uInt32 measurements);
        /// Purpose
        /// Enables either demodulation-based or spectral-based measurements.
        /// 
        ///</returns>
        public int SelectMeasurements(uint measurement)
        {
            int pInvokeResult = PInvoke.niWLANA_SelectMeasurements(Handle, measurement);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Configures NI-RFSA to acquire an I/Q waveform and detects the IEEE 802.11 standard, which includes the type of physical layer, of the acquired signal.
        /// This function sets the NIWLANA_DETECTED_STANDARD and NIWLANA_DETECTED_CHANNEL_BANDWIDTH attributes. Query these attributes after calling this function, and set the NIWLANA_STANDARD and NIWLANA_CHANNEL_BANDWIDTH attributes to the same values prior to performing signal analysis.
        /// 
        /// </summary>
        ///<param name = "rfsaSession">
        /// Specifies a reference to an NI-RFSA instrument session. This parameter is obtained from the niRFSA_init or niRFSA_InitWithOptions functions. 
        /// 
        ///</param>
        ///<param name = "hwChannelString">
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAAutoDetectionOfStandard
        /// int32 __stdcall niWLANA_RFSAAutoDetectionOfStandard (niWLANA session, 
        ///     ViSession rfsaSession,
        ///     char hwChannelString[]);
        /// Purpose
        /// Configures NI-RFSA to acquire an I/Q waveform and detects the IEEE 802.11 standard, which includes the type of physical layer, of the acquired signal.
        /// This function sets the NIWLANA_DETECTED_STANDARD and NIWLANA_DETECTED_CHANNEL_BANDWIDTH attributes. Query these attributes after calling this function, and set the NIWLANA_STANDARD and NIWLANA_CHANNEL_BANDWIDTH attributes to the same values prior to performing signal analysis.
        /// 
        ///</returns>
        public int AutoDetectionOfStandard(HandleRef rfsaSession, string hwChannelString)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAAutoDetectionOfStandard(Handle, rfsaSession.Handle, hwChannelString);
            TestForError(pInvokeResult, rfsaSession);
            return pInvokeResult;
        }


        /// <summary>
        /// Specifies the minimum duration of the waveform to be acquired by the NI-RFSA. This value is expressed in seconds.
        /// If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to NIWLANA_VAL_AUTO_DETECTION_STANDARD_MODE_OFF, the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute specifies common measurement length for all measurements that are enabled. However, if you enable more than one measurement, it is recommended that you set the following attributes instead, if the corresponding measurement is enabled.
        /// NIWLANA_TXPOWER_MEASUREMENT_LENGTH
        /// NIWLANA_CCDF_MEASUREMENT_LENGTH
        /// NIWLANA_GATED_SPECTRUM_MEASUREMENT_LENGTH
        /// NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_LENGTH
        /// NIWLANA_OFDM_DEMOD_MEASUREMENT_LENGTH 
        /// NIWLANA_DSSS_DEMOD_MEASUREMENT_LENGTH
        /// You cannot set the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute along with any of the previous attributes. This attribute is ignored in the following cases:
        /// The NIWLANA_OFDM_DEMOD_ENABLED and the NIWLANA_OFDM_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attributes are set to NIWLANA_VAL_TRUE, and no other measurement is enabled.
        /// The NIWLANA_DSSS_DEMOD_ENABLED and the NIWLANA_DSSS_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attributes are set to NIWLANA_VAL_TRUE, and no other measurement is enabled.
        /// If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to NIWLANA_VAL_AUTO_DETECTION_STANDARD_MODE_PACKET_FILTER, the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute specifies the waveform length to be acquired by the NI-RFSA. This attribute does not specify the measurement lengths for the measurements that are enabled. You must set the individual measurement lengths.
        /// The default value is 10 ms if you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to NIWLANA_VAL_AUTO_DETECTION_STANDARD_MODE_PACKET_FILTER, and 1 ms if you set the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute to NIWLANA_VAL_AUTO_DETECTION_STANDARD_MODE_OFF.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "acquisitionLength">
        /// Specifies the minimum duration of the waveform to be acquired by the NI-RFSA. The default value is 1 ms. This value is expressed in seconds.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetAcquisitionLength
        /// int32 __stdcall niWLANA_SetAcquisitionLength (niWLANA session,
        ///     char channelString[],
        ///     float64 acquisitionLength);
        /// Purpose
        /// Specifies the minimum duration of the waveform to be acquired by the NI-RFSA. This value is expressed in seconds.
        /// If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to NIWLANA_VAL_AUTO_DETECTION_STANDARD_MODE_OFF, the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute specifies common measurement length for all measurements that are enabled. However, if you enable more than one measurement, it is recommended that you set the following attributes instead, if the corresponding measurement is enabled.
        /// NIWLANA_TXPOWER_MEASUREMENT_LENGTH
        /// NIWLANA_CCDF_MEASUREMENT_LENGTH
        /// NIWLANA_GATED_SPECTRUM_MEASUREMENT_LENGTH
        /// NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_LENGTH
        /// NIWLANA_OFDM_DEMOD_MEASUREMENT_LENGTH 
        /// NIWLANA_DSSS_DEMOD_MEASUREMENT_LENGTH
        /// You cannot set the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute along with any of the previous attributes. This attribute is ignored in the following cases:
        /// The NIWLANA_OFDM_DEMOD_ENABLED and the NIWLANA_OFDM_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attributes are set to NIWLANA_VAL_TRUE, and no other measurement is enabled.
        /// The NIWLANA_DSSS_DEMOD_ENABLED and the NIWLANA_DSSS_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attributes are set to NIWLANA_VAL_TRUE, and no other measurement is enabled.
        /// If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to NIWLANA_VAL_AUTO_DETECTION_STANDARD_MODE_PACKET_FILTER, the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute specifies the waveform length to be acquired by the NI-RFSA. This attribute does not specify the measurement lengths for the measurements that are enabled. You must set the individual measurement lengths.
        /// The default value is 10 ms if you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to NIWLANA_VAL_AUTO_DETECTION_STANDARD_MODE_PACKET_FILTER, and 1 ms if you set the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute to NIWLANA_VAL_AUTO_DETECTION_STANDARD_MODE_OFF.
        /// 
        ///</returns>
        public int SetAcquisitionLength(string channelString, double acquisitionLength)
        {   
            return SetDouble(niWLANAProperties.AcquisitionLength, channelString, acquisitionLength);
        }

        /// <summary>
        ///Specifies the carrier frequency which you configure on the NI-RFSA to acquire a WLAN signal. This value is expressed in Hz.    Set this value equal to the carrier frequency of the transmitting device under test (DUT).
        ///    Note: You must configure this attribute if you set the    NIWLANA_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED attribute    to NIWLANA_VAL_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED_TRUE using the niWLANA_RFSAConfigureFrequencySingleLO or    the niWLANA_RFSAConfigureFrequencyMultipleLO functions. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED attribute    to NIWLANA_VAL_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED_FALSE. 
        ///    Note: You must configure this attribute if you enable any TxPower, DSSS Power Ramp, DSSS Demod, or OFDM Demod    attribute along with spectrum measurements. 
        ///    Refer to Simultaneous Measurements for more information about compatible simultaneous measurements. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211G_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM,    or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx]' as the active channel string syntax to query this attribute. You can use an empty string to    query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///      The default value is 2.412 GHz.
        ///    Get Function: niWLANA_GetCarrierFrequency
        ///    Set Function: niWLANA_SetCarrierFrequency
        /// 
        /// </summary>
        public int SetCarrierFrequency(string channelString, double carrierFrequency)
        {
            return SetDouble(niWLANAProperties.CarrierFrequency, channelString, carrierFrequency);
        }

        /// <summary>
        /// Specifies the bandwidth of the 
        /// OFDM signal to be analyzed. This value is expressed in Hz. The toolkit uses this value in the NIWLANA_RECOMMENDED_IQ_SAMPLING_RATE attribute and symbol structure for demodulation purposes. This value is valid only when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,, NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// 
        /// </summary>      
        ///<param name = "channelString">
        ///channelString
        /// char[]
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "channelBandwidth">
        /// Specifies the bandwidth of the signal to be analyzed. The default value is 20 MHz. Valid value is 20 MHz if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, 10 MHz or 20 MHz if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211J_OFDM, 5 MHz, 10 MHz or 20 MHz if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211P_OFDM, 20 MHz or 40 MHz if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, 20 MHz, 40 MHz, 80 MHz, or 160 MHz if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, 1 MHz,2 MHz, 4 MHz, 8 MHz, and 16 MHz if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and 6M,7M, and 8M, if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM. This value is expressed in Hz.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetChannelBandwidth
        /// int32 __stdcall niWLANA_SetChannelBandwidth (niWLANA session,
        ///     char channelString[],
        ///     float64 channelBandwidth);
        /// Purpose
        /// Specifies the bandwidth of the 
        /// OFDM signal to be analyzed. This value is expressed in Hz. The toolkit uses this value in the NIWLANA_RECOMMENDED_IQ_SAMPLING_RATE attribute and symbol structure for demodulation purposes. This value is valid only when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,, NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// 
        ///</returns>
        public int SetChannelBandwidth(string channelString, double channelBandwidth)
        {
            return SetDouble(niWLANAProperties.ChannelBandwidth, channelString, channelBandwidth);
        }

        /// <summary>
        /// Specifies whether to enable demodulation-based measurements if you set the  NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211BG_DSSS.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "enabled">
        /// Specifies whether to enable demodulation-based measurements for 802.11b and 802.11g DSSS signals. The default value is NIWLANA_VAL_FALSE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetDSSSDemodEnabled
        /// int32 __stdcall niWLANA_SetDSSSDemodEnabled (niWLANA session,
        ///     char channelString[],
        ///     int32 enable);
        /// Purpose
        /// Specifies whether to enable demodulation-based measurements if you set the  NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211BG_DSSS.
        /// 
        ///</returns>
        public int SetDSSSDemodEnabled(string channelString, int enabled)
        {
            return SetInt(niWLANAProperties.DsssDemodEnabled, channelString, enabled);
        }
        /// <summary>
        /// Specifies the number of iterations over which the toolkit averages direct sequence spread spectrum (DSSS) demodulation-based measurements.
        /// If you increase the number of averages, the toolkit provides smoother values but takes longer to compute the values.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "numberofAverages">
        /// Specifies the number of iterations over which the toolkit averages DSSS demodulation-based measurements. The default value is 1. Valid values are 1 to 1,000, inclusive.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetDSSSDemodNumberOfAverages
        /// int32 __stdcall niWLANA_SetDSSSDemodNumberOfAverages (niWLANA session,
        ///     char channelString[],
        ///     int32 numberOfAverages);
        /// Purpose
        /// Specifies the number of iterations over which the toolkit averages direct sequence spread spectrum (DSSS) demodulation-based measurements.
        /// If you increase the number of averages, the toolkit provides smoother values but takes longer to compute the values.
        /// 
        ///</returns>
        public int SetDSSSDemodNumberOfAverages(string channelString, int numberofAverages)
        {
            return SetInt(niWLANAProperties.DsssDemodNumberOfAverages, channelString, numberofAverages);
        }

        /// <summary>
        /// Specifies whether to enable measurement of the power ramp-up or ramp-down time for 802.11b and 802.11g direct sequence spread spectrum (DSSS) signals.
        /// To use the NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_ENABLED attribute, you must set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211BG_DSSS. If you set the NIWLANA_STANDARD attribute to any other value and configure the NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_ENABLED attribute, the toolkit returns an error.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "enabled">
        /// Specifies whether to enable measurement of the power ramp-up or ramp-down time. The default value is NIWLANA_VAL_FALSE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetDSSSPowerRampMeasurementEnabled
        /// int32 __stdcall niWLANA_SetDSSSPowerRampMeasurementEnabled (niWLANA session,
        ///     char channelString[],
        ///     int32 enable);
        /// Purpose
        /// Specifies whether to enable measurement of the power ramp-up or ramp-down time for 802.11b and 802.11g direct sequence spread spectrum (DSSS) signals.
        /// To use the NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_ENABLED attribute, you must set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211BG_DSSS. If you set the NIWLANA_STANDARD attribute to any other value and configure the NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_ENABLED attribute, the toolkit returns an error.
        /// 
        ///</returns>
        public int SetDSSSPowerRampMeasurementEnabled(string channelString, int enabled)
        {
            return SetInt(niWLANAProperties.DsssPowerRampMeasurementEnabled, channelString, enabled);
        }

        /// <summary>
        /// Specifies the number of iterations over which the toolkit averages direct sequence spread spectrum (DSSS) power ramp measurements.
        /// If you increase the number of averages, the toolkit provides smoother values but takes longer to compute the values.
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "numberofAverages">
        /// Specifies the number of iterations over which the toolkit averages power ramp measurements. Valid values are 1 to 1,000, inclusive.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetDSSSPowerRampMeasurementNumberOfAverages
        /// int32 __stdcall niWLANA_SetDSSSPowerRampMeasurementNumberOfAverages (niWLANA session,
        ///     char channelString[],
        ///     int32 numberOfAverages);
        /// Purpose
        /// Specifies the number of iterations over which the toolkit averages direct sequence spread spectrum (DSSS) power ramp measurements.
        /// If you increase the number of averages, the toolkit provides smoother values but takes longer to compute the values.
        /// 
        ///</returns>
        public int SetDSSSPowerRampMeasurementNumberOfAverages(string channelString, int numberofAverages)
        {
            return SetInt(niWLANAProperties.DsssPowerRampMeasurementNumberOfAverages, channelString, numberofAverages);
        }

        /// <summary>
        /// Specifies the number of channels (waveforms) to process during analysis measurements. The number of received channels must be less than or equal to the number of channels acquired. You can process fewer number of waveforms than the acquired waveforms by setting the numberOfReceiveChannels parameter to the number of waveforms. 
        /// Tip  Set the numberOfReceiveChannels parameter equal to number of transmission antennas of the device under test (DUT).
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "numberofReceiveChannels">
        /// Specifies the number of channels (waveforms) to process during analysis measurements. The default value is 1. If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, the valid values are 1 to 4, inclusive. If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, the valid values are 1 to 8, inclusive. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetNumberOfReceiveChannels
        /// int32 __stdcall niWLANA_SetNumberOfReceiveChannels (niWLANA session,
        ///     char channelString[],
        ///     int32 numberOfReceiveChannels);
        /// Purpose
        /// Specifies the number of channels (waveforms) to process during analysis measurements. The number of received channels must be less than or equal to the number of channels acquired. You can process fewer number of waveforms than the acquired waveforms by setting the numberOfReceiveChannels parameter to the number of waveforms. 
        /// Tip  Set the numberOfReceiveChannels parameter equal to number of transmission antennas of the device under test (DUT).
        /// 
        ///</returns>
        public int SetNumberOfReceiveChannels(string channelString, int numberofReceiveChannels)
        {
            return SetInt(niWLANAProperties.NumberOfReceiveChannels, channelString, numberofReceiveChannels);
        }

        /// <summary>
        /// 
        /// Specifies the expected maximum input power level, in dBm, of the incoming signal at the input of the RF signal analyzer. 
        /// If you set the standard parameter of the niWLANA_SetStandard function to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use an active channel  string to configure this function. 
        /// Note&#160;&#160;If you do not know what power level to set, use the niWLANA_RFSAAutoRange or niWLANA_RFSAAutoLevel function.
        /// Note&#160;&#160;In version 1.0, power was specified as average power. In version 2.0, we specify power level as maximum input power.
        /// Note&#160;&#160;If the toolkit compatibility version is NIWLANA_VAL_COMPATIBILITY_VERSION_010000, do not use this function to set the power level. Instead, use niWLANA_SetScalarAttributeF64
        /// function with the attributeId parameter set to  NIWLANAV1_POWER_LEVEL.
        /// Tip  Measurements might not be accurate if the incoming burst has an average power of less than -30 dBm. Consider using a preamplifier to better use the dynamic range of the signal analyzer.
        /// The default value is 0.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// Specifies the WLAN channel to be used for configuration.
        /// 
        ///</param>
        ///<param name = "maxInputPower">
        /// maxInputPower
        /// float64
        /// Specifies the expected maximum power level, in dBm, of the incoming signal at the input of the RF signal analyzer.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        [Obsolete]
        public int SetPowerLevel(string channelString, double maxInputPower)
        {
            int pInvokeResult = PInvoke.niWLANA_SetPowerLevel(Handle, channelString, maxInputPower);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// Sets the value of an niWLAN Analysis 64-bit floating point number (float64) attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// If the attribute is channel-based, this parameter specifies the channel to which the attribute applies. If the attribute is not channel-based, set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// attributeID
        /// niWLANA_Attr
        /// Specifies the ID of a float64 niWLAN Analysis attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// attributeValue
        /// float64
        /// Specifies the value to which you want to set the attribute.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        public int SetScalarAttributeF64(string channelString, niWLANAProperties attributeID, double attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANA_SetScalarAttributeF64(Handle, channelString, attributeID, attributeValue);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// 
        /// Sets the value of an niWLAN Analysis 32-bit integer (int32) attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// If the attribute is channel-based, this parameter specifies the channel to which the attribute applies. If the attribute is not channel-based, set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "attributeID">
        /// attributeID
        /// niWLANA_Attr
        /// Specifies the ID of an int32 niWLAN Analysis attribute.
        /// 
        ///</param>
        ///<param name = "attributeValue">
        /// attributeValue
        /// int32
        /// Specifies the value to which you want to set the attribute.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        public int SetScalarAttributeI32(string channelString, niWLANAProperties attributeID, int attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANA_SetScalarAttributeI32(Handle, channelString, attributeID, attributeValue);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// Specifies whether to enable spectral mask-related measurements.
        /// Refer to section 17.9.3.2 of IEEE Standard 802.11a-1999, section 18.4.7.3 of IEEE Standard 802.11b-1999, section 19.5.4 of IEEE Standard 802.11g-2003, section 20.3.21.1 of IEEE Standard 802.11n-2009, section 22.3.18.1 of IEEE Standard 802.11ac-2013, section 24.3.16.1 of IEEE P802.11ah/D1.3, section 23.3.18.1 of IEEE Standard 802.11af-2013, and section 28.3.18.1 of IEEE P802.11ax/D1.2 for more information about performing spectral mask measurements.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "enabled">
        /// Specifies whether to enable spectral mask-related measurements. The default value is NIWLANA_VAL_FALSE.
        /// NIWLANA_VAL_TRUE (1)
        /// Enables the following measurements:
        /// NIWLANA_RESULT_SPECTRAL_MASK_MARGIN
        /// NIWLANA_RESULT_SPECTRAL_MASK_MARGIN_VECTOR
        /// NIWLANA_RESULT_SPECTRAL_MASK_REFERENCE_LEVEL
        /// NIWLANA_VAL_FALSE (0)
        /// Disables spectral mask-related measurements.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetSpectralMaskEnabled
        /// int32 __stdcall niWLANA_SetSpectralMaskEnabled (niWLANA session,
        ///     char channelString[],
        ///     int32 enable);
        /// Purpose
        /// Specifies whether to enable spectral mask-related measurements.
        /// Refer to section 17.9.3.2 of IEEE Standard 802.11a-1999, section 18.4.7.3 of IEEE Standard 802.11b-1999, section 19.5.4 of IEEE Standard 802.11g-2003, section 20.3.21.1 of IEEE Standard 802.11n-2009, section 22.3.18.1 of IEEE Standard 802.11ac-2013, section 24.3.16.1 of IEEE P802.11ah/D1.3, section 23.3.18.1 of IEEE Standard 802.11af-2013, and section 28.3.18.1 of IEEE P802.11ax/D1.2 for more information about performing spectral mask measurements.
        /// 
        ///</returns>
        public int SetSpectralMaskEnabled(string channelString, int enabled)
        {
            return SetInt(niWLANAProperties.SpectralMaskEnabled, channelString, enabled);
        }

        /// <summary>
        /// Specifies the number of iterations over which the toolkit averages spectral mask measurements.
        /// If you increase the number of averages, the toolkit provides smoother values but takes longer to compute the values.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "numberofAverages">
        /// Specifies the number of iterations over which the toolkit averages spectral mask measurements. The default value is 10. Valid values are 1 to 1,000, inclusive.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetSpectralMaskNumberOfAverages
        /// int32 __stdcall niWLANA_SetSpectralMaskNumberOfAverages (niWLANA session,
        ///     char channelString[],
        ///     int32 numberOfAverages);
        /// Purpose
        /// Specifies the number of iterations over which the toolkit averages spectral mask measurements.
        /// If you increase the number of averages, the toolkit provides smoother values but takes longer to compute the values.
        /// 
        ///</returns>
        public int SetSpectralMaskNumberOfAverages(string channelString, int numberofAverages)
        {
            return SetInt(niWLANAProperties.SpectralMaskNumberOfAverages, channelString, numberofAverages);
        }

        /// <summary>
        /// Specifies the IEEE 802.11 standard, which includes the type of physical layer, for signal analysis.
        /// The toolkit sets the NIWLANA_STANDARD attribute to this value.
        /// Note&#160;&#160;If you do not select a standard, the toolkit returns an error.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "standard">
        /// Specifies the IEEE 802.11 standard, which includes the type of physical layer, for signal analysis. The default value is NIWLANA_VAL_STANDARD_80211AG_OFDM.
        /// NIWLANA_VAL_STANDARD_80211AG_OFDM (0)
        /// Corresponds to the OFDM mode defined in the IEEE Standard 802.11a-1999 and the extended rate physical layer-OFDM (ERP-OFDM) mode, as defined in IEEE Standard 802.11g-2003.
        /// NIWLANA_VAL_STANDARD_80211J_OFDM (7)
        /// Corresponds to the OFDM mode defined in the IEEE Standard 802.11j-2004.
        /// NIWLANA_VAL_STANDARD_80211P_OFDM (8)
        /// Corresponds to the OFDM mode defined in the IEEE Standard 802.11p-2010.
        /// NIWLANA_VAL_STANDARD_80211BG_DSSS (1)
        /// Corresponds to all the compulsory and optional modes defined in IEEE Standard 802.11b-1999 and the ERP-packet binary convolutional coding (ERP-PBCC) mode in IEEE Standard 802.11g-2003.
        /// NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM (2)
        /// Corresponds to the optional DSSS-OFDM mode defined in IEEE Standard 802.11g-2003.
        /// NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM (3)
        /// Corresponds to IEEE Standard 802.11n-2009. To use this option, you must set the compatibilityVersion parameter of the niWLANA_OpenSession function to NIWLANA_VAL_COMPATIBILITY_VERSION_020000, NIWLANA_VAL_COMPATIBILITY_VERSION_030000, NIWLANA_VAL_COMPATIBILITY_VERSION_040000, or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        /// NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM (4)
        /// Corresponds to IEEE Standard 802.11ac. To use this option, you must set the compatibilityVersion parameter of the niWLANA_OpenSession function to NIWLANA_VAL_COMPATIBILITY_VERSION_030000, NIWLANA_VAL_COMPATIBILITY_VERSION_040000, or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        /// NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM (5)
        /// Corresponds to IEEE P802.11ah/D1.3. To use this option, you must set the compatibilityVersion parameter of the niWLANA_OpenSession function to NIWLANA_VAL_COMPATIBILITY_VERSION_030000, NIWLANA_VAL_COMPATIBILITY_VERSION_040000, or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        /// NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM (6)
        /// Corresponds to IEEE Standard 802.11af-2013. To use this option, you must set the compatibilityVersion parameter of the niWLANA_OpenSession function to NIWLANA_VAL_COMPATIBILITY_VERSION_030000, NIWLANA_VAL_COMPATIBILITY_VERSION_040000, or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM (9)
        /// Corresponds to IEEE P802.11ax/D1.2. To use this option, you must set the compatibilityVersion parameter of the niWLANA_OpenSession function to NIWLANA_VAL_COMPATIBILITY_VERSION_030000, NIWLANA_VAL_COMPATIBILITY_VERSION_040000, or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetStandard
        /// int32 __stdcall niWLANA_SetStandard (niWLANA session,
        ///     char channelString[],
        ///     int32 standard);
        /// Purpose
        /// Specifies the IEEE 802.11 standard, which includes the type of physical layer, for signal analysis.
        /// The toolkit sets the NIWLANA_STANDARD attribute to this value.
        /// Note&#160;&#160;If you do not select a standard, the toolkit returns an error.
        /// 
        ///</returns>
        public int SetStandard(string channelString, int standard)
        {
            return SetInt(niWLANAProperties.Standard, channelString, standard);
        }

        /// <summary>
        /// Specifies whether to enable measurement of peak power and average power in the acquired burst. The toolkit automatically detects the start and end of a valid burst corresponding to a WLAN packet. This value is expressed in dBm.
        /// The toolkit detects the start of the burst by determining the position where the total power of a nonoverlapping moving window increases by at least 12&#160;dB between two consecutive windows, as well as two windows separated by one window and two window lengths. The toolkit detects the end of the burst by determining the position where the total power of a moving window decreases by at least 12&#160;dB between two consecutive windows, as well as two windows separated by one window.
        /// If the toolkit cannot automatically determine the start of the burst, the toolkit returns an error. If the toolkit cannot determine the end of the burst, the toolkit uses the whole acquired waveform.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "enabled">
        /// Specifies whether to enable measurement of peak power and average power in the acquired burst. The default value is NIWLANA_VAL_FALSE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetTxPowerMeasurementEnabled
        /// int32 __stdcall niWLANA_SetTxPowerMeasurementEnabled (niWLANA session,
        ///     char channelString[],
        ///     int32 enable);
        /// Purpose
        /// Specifies whether to enable measurement of peak power and average power in the acquired burst. The toolkit automatically detects the start and end of a valid burst corresponding to a WLAN packet. This value is expressed in dBm.
        /// The toolkit detects the start of the burst by determining the position where the total power of a nonoverlapping moving window increases by at least 12&#160;dB between two consecutive windows, as well as two windows separated by one window and two window lengths. The toolkit detects the end of the burst by determining the position where the total power of a moving window decreases by at least 12&#160;dB between two consecutive windows, as well as two windows separated by one window.
        /// If the toolkit cannot automatically determine the start of the burst, the toolkit returns an error. If the toolkit cannot determine the end of the burst, the toolkit uses the whole acquired waveform.
        /// 
        ///</returns>
        public int SetTxPowerMeasurementEnabled(string channelString, int enabled)
        {
            return SetInt(niWLANAProperties.TxpowerMeasurementsEnabled, channelString, enabled);
        }

        /// <summary>
        /// Specifies the number of iterations over which the toolkit averages burst power measurements.
        /// If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "numberofAverages">
        /// Specifies the number of iterations over which the toolkit averages burst power measurements. The default value is 1. Valid values are 1 to 1,000, inclusive.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetTxPowerMeasurementNumberOfAverages
        /// int32 __stdcall niWLANA_SetTxPowerMeasurementNumberOfAverages (niWLANA session,
        ///     char channelString[],
        ///     int32 numberOfAverages);
        /// Purpose
        /// Specifies the number of iterations over which the toolkit averages burst power measurements.
        /// If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values.
        /// 
        ///</returns>
        public int SetTxPowerMeasurementNumberOfAverages(string channelString, int numberofAverages)
        {
            return SetInt(niWLANAProperties.TxpowerMeasurementsNumberOfAverages, channelString, numberofAverages);
        }
        /// <summary>
        /// Sets the value of an niWLAN analysis 64-bit floating point number (float64) array attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "attributeID">
        /// Specifies the ID of a float64 niWLAN Analysis vector attribute.
        /// 
        ///</param>
        ///<param name = "data">
        /// Specifies the float64 array you want to set.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the data array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetVectorAttributeF64
        /// int32 __stdcall niWLANA_SetVectorAttributeF64 (niWLANA session,
        ///                                      char channelString[], niWLANA_Attr attributeID,
        ///                                      float64 data[], int32 dataArraySize);
        /// Purpose
        /// Sets the value of an niWLAN analysis 64-bit floating point number (float64) array attribute.
        /// 
        ///</returns>
        public int SetVectorAttributeF64(string channelString, niWLANAProperties attributeID, double[] data, int dataArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_SetVectorAttributeF64(Handle, channelString, attributeID, data, dataArraySize);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Enables either demodulation-based or spectral-based measurements with the option to enable all traces relevant to the selected measurements.
        /// 
        /// </summary>
        ///<param name = "measurement">
        /// Specifies the measurement to enable. The default value is "" (empty array).
        /// Note&#160;&#160;Do not select demodulation and spectral measurements simultaneously. Refer to Simultaneous Measurements for more information about compatible measurements.
        /// NIWLANA_VAL_OFDM_DEMOD_MEASUREMENT (0x00000001)
        /// Enables 
        /// OFDM demodulation-based measurements.
        /// NIWLANA_VAL_OFDM_DEMOD_WITH_GATED_POWER_MEASUREMENT (0x00000002)
        /// Enables OFDM demodulation with gated power measurements.
        /// NIWLANA_VAL_DSSS_DEMOD_MEASUREMENT (0x00000004)
        /// Enables direct sequence spread spectrum (DSSS) demodulation-based measurements.
        /// NIWLANA_VAL_DSSS_DEMOD_WITH_GATED_POWER_MEASUREMENT (0x00000008)
        /// Enables DSSS demodulation with gated power measurements.
        /// NIWLANA_VAL_DSSS_POWER_RAMP_MEASUREMENT (0x00000010)
        /// Enables DSSS power ramp measurements.
        /// NIWLANA_VAL_TXPOWER_MEASUREMENT (0x00000020)
        /// Enables transmit power measurements.
        /// NIWLANA_VAL_SPECTRAL_MASK_MEASUREMENT (0x00000040)
        /// Enables spectral mask measurements.
        /// NIWLANA_VAL_OBW_MEASUREMENT (0x00000080)
        /// Enables OBW measurements.
        /// NIWLANA_VAL_MAX_SPECTRAL_DENSITY_MEASUREMENT (0x00000100)
        /// Enables maximum spectral density measurements.
        /// NIWLANA_VAL_CHANNEL_POWER_MEASUREMENT (0x00000200)
        /// Enables channel power measurements.
        /// NIWLANA_VAL_CCDF_MEASUREMENT (0x00000400)
        /// Enables CCDF measurements.
        /// NIWLANA_VAL_ACP_MEASUREMENT (0x00001000)
        /// Enables ACP measurements.
        /// NIWLANA_VAL_ETSI_IBE_MEASUREMENT (0x00002000)
        /// Enables ETSI in-band emission measurements.
        /// 
        ///</param>
        ///<param name = "enableTraces">
        /// Specifies whether to enable all traces relevant to the selected measurement. The default value is NIWLANA_VAL_FALSE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SelectMeasurementsWithTraces
        /// int32 __stdcall niWLANA_SelectMeasurementsWithTraces (niWLANA session, uInt32 measurement, int32 tracesEnabled);
        /// Purpose
        /// Enables either demodulation-based or spectral-based measurements with the option to enable all traces relevant to the selected measurements.
        /// 
        ///</returns>
        public int SelectMeasurementsWithTraces(int measurement, int enableTraces)
        {
            int pInvokeResult = PInvoke.niWLANA_SelectMeasurementsWithTraces(Handle, measurement, enableTraces);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Returns the number of space-time streams for an 802.11n, 802.11ac, 802.11ah, or an 802.11ax signal. When you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, this value is derived from the MCS Index value decoded from the HT-SIG field. When you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, for a packet of SU PPDU format, this value is derived by adding 1 to the value of SU NSTS field, as decoded from the VHT-SIG-A field and for a packet with MU PPDU format, the value of number of space-time streams is decoded for each user from the respective MU NSTS field (MU[0] NSTS, MU[1] NSTS, MU[2] NSTS or MU[3] NSTS) within the VHT-SIG-A field. When you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, this value is decoded from decoding S1G-SIG/SIG-A field.
        /// When you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, for a packet of SU PPDU format or Extended Range SU PPDU format, this value is derived from NSTS field, as decoded from the HE-SIG-A field and for a packet with MU PPDU format, this value is decoded for each user from the HE-SIG-B field.
        /// If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the value you specify in this function specifies the number of space-time streams.
        /// To understand which  active channel strings are required to configure this function, refer to the NIWLANA_RESULT_OFDM_DEMOD_NUMBER_OF_SPACE_TIME_STREAMS attribute.
        /// </summary>
        ///<param name = "channelString">
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "numStreams">
        /// Returns the number of space-time streams according to the MCS index  and STBC index detected from the header or from the information you provide. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodNumberOfSpaceTimeStreams
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodNumberOfSpaceTimeStreams(
        ///     niWLANAnalysisSession session,
        ///     char channelString[],
        ///     int32 *numStreams);
        /// Purpose
        /// Returns the number of space-time streams for an 802.11n, 802.11ac, 802.11ah, or an 802.11ax signal. When you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, this value is derived from the MCS Index value decoded from the HT-SIG field. When you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, for a packet of SU PPDU format, this value is derived by adding 1 to the value of SU NSTS field, as decoded from the VHT-SIG-A field and for a packet with MU PPDU format, the value of number of space-time streams is decoded for each user from the respective MU NSTS field (MU[0] NSTS, MU[1] NSTS, MU[2] NSTS or MU[3] NSTS) within the VHT-SIG-A field. When you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, this value is decoded from decoding S1G-SIG/SIG-A field.
        /// When you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, for a packet of SU PPDU format or Extended Range SU PPDU format, this value is derived from NSTS field, as decoded from the HE-SIG-A field and for a packet with MU PPDU format, this value is decoded for each user from the HE-SIG-B field.
        /// If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the value you specify in this function specifies the number of space-time streams.
        /// To understand which  active channel strings are required to configure this function, refer to the NIWLANA_RESULT_OFDM_DEMOD_NUMBER_OF_SPACE_TIME_STREAMS attribute.        
        ///</returns>
        public int GetCurrentIterationOFDMDemodNumberOfSpaceTimeStreams(string channelString, out int numStreams)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodNumberOfSpaceTimeStreams(Handle, channelString, out numStreams);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }
        /// <summary>
        /// Returns the sequence of demodulated complex symbols after applying all relevant corrections for the current iteration. These complex symbols are used to compute EVM.
        /// To get the constellation trace, enable the demodulation measurements and the corresponding constellation trace before performing signal analysis. 
        /// If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,  NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM set the NIWLANA_OFDM_DEMOD_ENABLED attribute and NIWLANA_OFDM_DEMOD_ALL_TRACES_ENABLED attribute or NIWLANA_OFDM_DEMOD_CONSTELLATION_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        ///  If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211BG_DSSS, set the NIWLANA_DSSS_DEMOD_ENABLED attribute and NIWLANA_DSSS_DEMOD_ALL_TRACES_ENABLED attribute or NIWLANA_DSSS_DEMOD_CONSTELLATION_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        /// NIWLANA_STANDARD attribute setting
        /// Active channel string syntax
        ///   NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///  "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///  "streamx"
        ///   NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM                  
        /// 					"[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// "userx/[segmenty/]streamz" if the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE  attribute is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Specifies the active channel string.
        /// 
        ///</param>
        ///<param name = "iData">
        /// Returns the real part of the constellation point. If you pass NULL to the IData and QData array top, the function returns the size of arrays in the actualArraySize parameter.
        /// 
        ///</param>
        ///<param name = "qData">
        /// Returns the imaginary part of the constellation point. If you pass NULL to IData and QData array top, the function returns the size of arrays in the actualArraySize parameter.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the IData and QData arrays.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the data array. If the IData or the QData arrays are not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationConstellationTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationConstellationTrace (niWLANA session,
        ///     char channelString[], 
        ///     float64 IData[],
        ///     float64 QData[],
        ///     int32 dataArraySize,
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the sequence of demodulated complex symbols after applying all relevant corrections for the current iteration. These complex symbols are used to compute EVM.
        /// To get the constellation trace, enable the demodulation measurements and the corresponding constellation trace before performing signal analysis. 
        /// If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,  NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM set the NIWLANA_OFDM_DEMOD_ENABLED attribute and NIWLANA_OFDM_DEMOD_ALL_TRACES_ENABLED attribute or NIWLANA_OFDM_DEMOD_CONSTELLATION_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        ///  If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211BG_DSSS, set the NIWLANA_DSSS_DEMOD_ENABLED attribute and NIWLANA_DSSS_DEMOD_ALL_TRACES_ENABLED attribute or NIWLANA_DSSS_DEMOD_CONSTELLATION_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        /// NIWLANA_STANDARD attribute setting
        /// Active channel string syntax
        ///   NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///  "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///  "streamx"
        ///   NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM                  
        /// 					"[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// "userx/[segmenty/]streamz" if the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE  attribute is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        ///</returns>
        public int GetCurrentIterationConstellationTrace(string channelString, double[] iData, double[] qData, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationConstellationTrace(Handle, channelString, iData, qData, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the power versus time (PvT) trace for the acquired burst. This value is expressed in dBm. 
        /// Before performing signal analysis, set the NIWLANA_TXPOWER_MEASUREMENTS_ENABLED and NIWLANA_TXPOWER_MEASUREMENTS_PVT_TRACE_ENABLED attributes to NIWLANA_VAL_TRUE to get the PvT trace for the current iteration.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "t0">
        /// Returns the time of the first value in the pvT array.
        /// 
        ///</param>
        ///<param name = "dt">
        /// Returns the time difference between the values in the pvT array.
        /// 
        ///</param>
        ///<param name = "pvT">
        /// Returns the PvT trace for the acquired burst. You can pass NULL to the pvT parameter to get the size of the array in the actualArraySize parameter. This value is expressed in dBm.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the pvT array. If the array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the pvT array. If the pvT array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationPvTTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationPvTTrace (niWLANA session, 
        ///     char channelString[], 
        ///     float64 *t0, 
        ///     float64 *dt,
        ///     float64 pvT[],
        ///     int32 dataArraySize, 
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the power versus time (PvT) trace for the acquired burst. This value is expressed in dBm. 
        /// Before performing signal analysis, set the NIWLANA_TXPOWER_MEASUREMENTS_ENABLED and NIWLANA_TXPOWER_MEASUREMENTS_PVT_TRACE_ENABLED attributes to NIWLANA_VAL_TRUE to get the PvT trace for the current iteration.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        ///</returns>
        public int GetCurrentIterationPvTTrace(string channelString, out double t0, out double dt, double[] pvT, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationPvTTrace(Handle, channelString, out t0, out dt, pvT, dataArraySize, out actualArraySize);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Returns the EVM per symbol/chip number for each iteration when the toolkit processes the acquired burst.
        /// If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,  NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, set the NIWLANA_OFDM_DEMOD_ENABLED, and NIWLANA_OFDM_DEMOD_ALL_TRACES_ENABLED or NIWLANA_OFDM_DEMOD_EVM_PER_SYMBOL_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE to get the current iteration EVM per symbol. The toolkit obtains the current iteration EVM per symbol trace from the niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace function by averaging over the subcarriers for each symbol.
        /// If you set the NIWLANA_STANDARD attribute to 80211BG_DSSS, set the NIWLANA_DSSS_DEMOD_ENABLED, and NIWLANA_DSSS_DEMOD_ALL_TRACES_ENABLED or NIWLANA_DSSS_DEMOD_EVM_PER_CHIP_TRACE_ENABLED attributes to NIWLANA_VAL_TRUE to get the current iteration EVM per chip.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS
        ///                  N.A. 
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx"
        ///                                     "streamx"
        ///                                     NIWLANA_VAL_TRUE
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                 NIWLANA_VAL_TRUE
        /// 					"segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                   
        ///                     "channelx"
        ///       
        ///                     "streamx"
        ///                      NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM
        ///                   
        ///                     "[segmentx]/channely"
        ///       
        ///                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 
        /// "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// "userx/[segmenty/]streamz"if the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE  attribute is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.) 
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "index">
        /// Returns the array of indices of the subcarriers.
        /// 
        ///</param>
        ///<param name = "eVMperSymbol">
        /// Returns the EVM per symbol for each iteration during processing of the acquired burst. You can pass NULL to evmPerSymbol parameter to get size of the array in actualArraySize parameter. This value is expressed in dB.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the evmPerSymbol array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the evmPerSymbol array. If the evmPerSymbol array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationEVMPerSymbolTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationEVMPerSymbolTrace (niWLANA session, 
        ///     char channelString[],
        ///     int32 index[],
        ///     float64 evmPerSymbol[], 
        ///     int32 dataArraySize,
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the EVM per symbol/chip number for each iteration when the toolkit processes the acquired burst.
        /// If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,  NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, set the NIWLANA_OFDM_DEMOD_ENABLED, and NIWLANA_OFDM_DEMOD_ALL_TRACES_ENABLED or NIWLANA_OFDM_DEMOD_EVM_PER_SYMBOL_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE to get the current iteration EVM per symbol. The toolkit obtains the current iteration EVM per symbol trace from the niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace function by averaging over the subcarriers for each symbol.
        /// If you set the NIWLANA_STANDARD attribute to 80211BG_DSSS, set the NIWLANA_DSSS_DEMOD_ENABLED, and NIWLANA_DSSS_DEMOD_ALL_TRACES_ENABLED or NIWLANA_DSSS_DEMOD_EVM_PER_CHIP_TRACE_ENABLED attributes to NIWLANA_VAL_TRUE to get the current iteration EVM per chip.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS
        ///                  N.A. 
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx"
        ///                                     "streamx"
        ///                                     NIWLANA_VAL_TRUE
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                 NIWLANA_VAL_TRUE
        /// 					"segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                   
        ///                     "channelx"
        ///       
        ///                     "streamx"
        ///                      NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM
        ///                   
        ///                     "[segmentx]/channely"
        ///       
        ///                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 
        /// "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// "userx/[segmenty/]streamz"if the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE  attribute is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.) 
        /// 
        ///</returns>
        public int GetCurrentIterationEVMPerSymbolTrace(string channelString, int[] index, double[] eVMperSymbol, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationEVMPerSymbolTrace(Handle, channelString, index, eVMperSymbol, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns the sequence of bits obtained from the signal after demodulation and decoding for each iteration when the toolkit processes the acquired burst.
        /// Note&#160;&#160;The toolkit does not support decoding of received bits for direct sequence spread spectrum (DSSS) signals with a data rate of 33 Mbps, and the toolkit cannot return the decoded bits trace. The toolkit returns an error if you call this function after performing demodulation measurements on DSSS signals with a data rate of 33 Mbps.
        /// If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANA_VAL_STANDARD80211AC_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_ALL_TRACES_ENABLED attributes to NIWLANA_VAL_TRUE, or set the NIWLANA_OFDM_DEMOD_DECODED_BITS_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE to get the current iteration decoded bits trace.
        /// If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211BG_DSSS, set the NIWLANA_DSSS_DEMOD_ENABLED and NIWLANA_DSSS_DEMOD_ALL_TRACES_ENABLED attributes to NIWLANA_VAL_TRUE, or set the NIWLANA_DSSS_DEMOD_DECODED_BITS_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE to get the current iteration decoded bits trace.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD
        ///                     NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                  N.A. 
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU 
        ///                     "" (empty string)
        ///                  NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU 
        ///                     "userx"
        ///                                     NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU
        ///                     "" (empty string)
        ///                   NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU
        ///                     "userx
        /// 
        /// </summary>
        ///<param name = "decodedbits">
        /// Returns the sequence of bits obtained from the signal after demodulation and decoding for each iteration while the toolkit processes the acquired burst.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the decodedBits array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the data array. If the decodedBits array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationDecodedBitsTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationDecodedBitsTrace (niWLANA session,
        ///     int32 decodedBits[],
        ///     int32 dataArraySize,
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the sequence of bits obtained from the signal after demodulation and decoding for each iteration when the toolkit processes the acquired burst.
        /// Note&#160;&#160;The toolkit does not support decoding of received bits for direct sequence spread spectrum (DSSS) signals with a data rate of 33 Mbps, and the toolkit cannot return the decoded bits trace. The toolkit returns an error if you call this function after performing demodulation measurements on DSSS signals with a data rate of 33 Mbps.
        /// If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANA_VAL_STANDARD80211AC_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_ALL_TRACES_ENABLED attributes to NIWLANA_VAL_TRUE, or set the NIWLANA_OFDM_DEMOD_DECODED_BITS_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE to get the current iteration decoded bits trace.
        /// If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211BG_DSSS, set the NIWLANA_DSSS_DEMOD_ENABLED and NIWLANA_DSSS_DEMOD_ALL_TRACES_ENABLED attributes to NIWLANA_VAL_TRUE, or set the NIWLANA_DSSS_DEMOD_DECODED_BITS_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE to get the current iteration decoded bits trace.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD
        ///                     NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                  N.A. 
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU 
        ///                     "" (empty string)
        ///                  NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU 
        ///                     "userx"
        ///                                     NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU
        ///                     "" (empty string)
        ///                   NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU
        ///                     "userx
        /// 
        ///</returns>
        public int GetCurrentIterationDecodedBitsTrace(int[] decodedbits, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationDecodedBitsTrace(Handle, decodedbits, dataArraySize, out actualArraySize);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Returns the spectral mask and PSD spectrum, as defined in section 17.4.7.4, section 18.3.9.3, and section 20.3.20.1 of IEEE Standard 802.11-2012, section 22.3.18.1 of IEEE Standard 802.11ac-2013, section 24.3.16.1 of IEEE P802.11ah/D1, section 23.3.18.1 of IEEE Standard 80211af-2013, and section 28.3.18.1 of IEEE P802.11ax/D1.2.
        /// To use this function, you must set the NIWLANA_SPECTRAL_MASK_TRACE_ENABLED attribute and either the NIWLANA_SPECTRAL_MEASUREMENTS_ALL_ENABLED or the NIWLANA_SPECTRAL_MASK_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// The first element of the spectralMask array contains the spectral mask. The second element of the array contains the PSD trace.
        /// You must use the following active channel string formats to query this function.
        ///                                                    NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"[segmentx]/channely"
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "f0">
        /// Indicates the start frequency of the spectrum. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "df">
        /// Indicates the frequency intervals between data points in the spectrum. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "spectralMask">
        /// Returns the spectral mask as the first element of the output array. The second element contains the PSD trace.
        /// 
        ///</param>
        ///<param name = "spectrum">
        /// Indicates the PSD values. You can pass NULL to the spectrum and spectralMask parameters to get the size of the array in the actualArraySize parameter. This value is expressed in dBm/Hz.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the spectralMask and spectrum data arrays.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the data array. If the spectrum and spectralMask arrays are not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetSpectralMaskTrace
        /// int32 __stdcall niWLANA_GetSpectralMaskTrace (niWLANA session,
        ///     char channelString[], 
        ///     float64 *f0,
        ///     float64 *df,
        ///     float64 spectralMask[],
        ///     float64 spectrum[],
        ///     int32 dataArraySize,
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the spectral mask and PSD spectrum, as defined in section 17.4.7.4, section 18.3.9.3, and section 20.3.20.1 of IEEE Standard 802.11-2012, section 22.3.18.1 of IEEE Standard 802.11ac-2013, section 24.3.16.1 of IEEE P802.11ah/D1, section 23.3.18.1 of IEEE Standard 80211af-2013, and section 28.3.18.1 of IEEE P802.11ax/D1.2.
        /// To use this function, you must set the NIWLANA_SPECTRAL_MASK_TRACE_ENABLED attribute and either the NIWLANA_SPECTRAL_MEASUREMENTS_ALL_ENABLED or the NIWLANA_SPECTRAL_MASK_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// The first element of the spectralMask array contains the spectral mask. The second element of the array contains the PSD trace.
        /// You must use the following active channel string formats to query this function.
        ///                                                    NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"[segmentx]/channely"
        /// 
        ///</returns>
        public int GetSpectralMaskTrace(string channelString, out double f0, out double df, double[] spectralMask, double[] spectrum, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetSpectralMaskTrace(Handle, channelString, out f0, out df, spectralMask, spectrum, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }



        /// <summary>
        /// Returns the EVM per symbol per subcarrier number for each iteration when the toolkit processes the acquired burst. This value is expressed in dB.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_EVM_PER_SYMBOL_PER_SUBCARRIER_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute setting
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        /// N.A.
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx"
        ///                                     "streamx"
        ///                                     NIWLANA_VAL_TRUE
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 				NIWLANA_VAL_TRUE
        /// 					"segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        /// 
        ///                      "channelx/" streamx
        ///                     NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///         
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///         
        ///                      "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "index">
        /// Returns the indices of the subcarriers.
        /// 
        ///</param>
        ///<param name = "eVMTrace">
        /// Returns the EVM per symbol per subcarrier for each iteration during processing of the acquired burst. The size of this array should at least be numRows times numColumns. You can pass NULL to get actual size in the actualNumRows and actualNumColumns parameters. This value is expressed in dB.
        /// 
        ///</param>
        ///<param name = "numRows">
        /// Specifies the number of rows for the evmTrace data array.
        /// 
        ///</param>
        ///<param name = "numColumns">
        /// Specifies the number of columns for the evmTrace data array.
        /// 
        ///</param>
        ///<param name = "actualNumRows">
        /// Returns the actual number of rows. If the actualNumRows array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the expected number of rows of the evmTrace. 
        /// 
        ///</param>
        ///<param name = "actualNumColumns">
        /// Returns the actual number of columns. If the actualNumColumns array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the expected number of columns of the evmTrace.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace (niWLANA session,
        ///     char channelString[],
        ///     int32 index[],
        ///     float64 *evmTrace,
        ///     int32 numRows,  
        ///     int32 numColumns, 
        ///     int32 *actualNumRows,
        ///     int32 *actualNumColumns);
        /// Purpose
        /// Returns the EVM per symbol per subcarrier number for each iteration when the toolkit processes the acquired burst. This value is expressed in dB.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_EVM_PER_SYMBOL_PER_SUBCARRIER_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute setting
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        /// N.A.
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx"
        ///                                     "streamx"
        ///                                     NIWLANA_VAL_TRUE
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 				NIWLANA_VAL_TRUE
        /// 					"segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        /// 
        ///                      "channelx/" streamx
        ///                     NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///         
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///         
        ///                      "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        ///</returns>
        public int GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace(string channelString, int[] index, out double eVMTrace, int numRows, int numColumns, out int actualNumRows, out int actualNumColumns)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace(Handle, channelString, index, out eVMTrace, numRows, numColumns, out actualNumRows, out actualNumColumns);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns the EVM per subcarrier number for each iteration when the toolkit processes the acquired burst. The toolkit obtains this trace from the niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace function by averaging over the symbols for each subcarrier.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_EVM_PER_SUBCARRIER_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        ///         N.A.
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx"
        ///                                     "streamx"
        ///                                     NIWLANA_VAL_TRUE
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 				NIWLANA_VAL_TRUE
        /// 					"segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///         
        ///                      "channelx"
        ///         
        ///                      "streamx"
        ///                      NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM 
        ///         
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///         
        ///                      "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 
        /// "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                  
        /// "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                
        /// "userx/[segmenty/]streamz" if the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE  attribute is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "index">
        /// Returns the indices of the subcarriers. 
        /// 
        ///</param>
        ///<param name = "eVMperSubcarrier">
        /// Returns the EVM per subcarrier for each iteration during processing of the acquired burst. You can pass NULL to evmPerSubcarrier parameter to get size of the array in actualArraySize parameter.  This value is expressed in dB.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the evmPerSubcarrier array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the evmPerSubcarrier array. If the evmPerSubcarrier array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodEVMPerSubcarrierTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodEVMPerSubcarrierTrace (niWLANA session, 
        ///     char channelString[],
        ///     int32 index[],
        ///     float64 evmPerSubcarrier[], 
        ///     int32 dataArraySize,
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the EVM per subcarrier number for each iteration when the toolkit processes the acquired burst. The toolkit obtains this trace from the niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace function by averaging over the symbols for each subcarrier.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_EVM_PER_SUBCARRIER_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        ///         N.A.
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx"
        ///                                     "streamx"
        ///                                     NIWLANA_VAL_TRUE
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 				NIWLANA_VAL_TRUE
        /// 					"segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///         
        ///                      "channelx"
        ///         
        ///                      "streamx"
        ///                      NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM 
        ///         
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///         
        ///                      "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 
        /// "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                  
        /// "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                
        /// "userx/[segmenty/]streamz" if the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE  attribute is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        ///</returns>
        public int GetCurrentIterationOFDMDemodEVMPerSubcarrierTrace(string channelString, int[] index, double[] eVMperSubcarrier, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodEVMPerSubcarrierTrace(Handle, channelString, index, eVMperSubcarrier, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns the EVM per symbol number for data subcarriers for each iteration when the toolkit processes the acquired burst. The toolkit obtains this trace from the niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace function by averaging over the data subcarriers for each symbol.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_ENABLED attribute to NIWLANA_VAL_TRUE and you must set either the NIWLANA_OFDM_DEMOD_ALL_TRACES_ENABLED attribute or the NIWLANA_OFDM_DEMOD_DATA_EVM_PER_SYMBOL_TRACE_ENABLED 
        /// attribute to NIWLANA_VAL_TRUE
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        ///         N.A.
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx"
        ///                                     "streamx"
        ///                                     NIWLANA_VAL_TRUE
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely"("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 				NIWLANA_VAL_TRUE
        /// 					"segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///         
        ///                      "channelx/streamx"
        ///                      NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM 
        ///         
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///         
        ///                      "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 
        /// "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                  
        /// "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                
        /// "userx/[segmenty/]streamz" if the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE  attribute is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "index">
        /// Returns the indices of the symbols.
        /// 
        ///</param>
        ///<param name = "dataEVMperSymbol">
        /// Returns the data EVM of symbols and corresponding symbol indices. This value is expressed in dB.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the evmPerSymbol array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the evmPerSymbol array. If the evmPerSymbol array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodDataEVMPerSymbolTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodDataEVMPerSymbolTrace (niWLANA session,
        ///     char channelString[], 
        ///     int32 index[],
        ///     float64 dataEVMPerSymbol[],
        ///     int32 dataArraySize,
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the EVM per symbol number for data subcarriers for each iteration when the toolkit processes the acquired burst. The toolkit obtains this trace from the niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace function by averaging over the data subcarriers for each symbol.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_ENABLED attribute to NIWLANA_VAL_TRUE and you must set either the NIWLANA_OFDM_DEMOD_ALL_TRACES_ENABLED attribute or the NIWLANA_OFDM_DEMOD_DATA_EVM_PER_SYMBOL_TRACE_ENABLED 
        /// attribute to NIWLANA_VAL_TRUE
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        ///         N.A.
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx"
        ///                                     "streamx"
        ///                                     NIWLANA_VAL_TRUE
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely"("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 				NIWLANA_VAL_TRUE
        /// 					"segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///         
        ///                      "channelx/streamx"
        ///                      NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM 
        ///         
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///         
        ///                      "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 
        /// "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                  
        /// "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                
        /// "userx/[segmenty/]streamz" if the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE  attribute is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        ///</returns>
        public int GetCurrentIterationOFDMDemodDataEVMPerSymbolTrace(string channelString, int[] index, double[] dataEVMperSymbol, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodDataEVMPerSymbolTrace(Handle, channelString, index, dataEVMperSymbol, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns the EVM per symbol number for pilot subcarriers for each iteration when the toolkit processes the acquired burst. The toolkit obtains this trace from the  niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace function by averaging over the pilot subcarrier for each symbol.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_EVM_PER_SYMBOL_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///         N.A.
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx"
        ///                                     "streamx"
        ///                                     NIWLANA_VAL_TRUE
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 				NIWLANA_VAL_TRUE
        /// 					"segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///         
        ///                     "channelx"
        ///         
        ///                      "streamx"
        ///                      NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM 
        ///         
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///         
        ///                      "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 
        /// "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                  
        /// "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                
        /// "userx/[segmenty/]streamz" if the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE  attribute is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "index">
        /// Returns the indices of the symbols.
        /// 
        ///</param>
        ///<param name = "pilotEVMperSymbol">
        /// Returns the pilot EVM per symbol for each iteration during processing of the acquired burst. This value is expressed in dB.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the pilotEvmPerSymbol array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the pilotEvmPerSymbol array. If the pilotEvmPerSymbol array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodPilotEVMPerSymbolTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodPilotEVMPerSymbolTrace (niWLANA session,
        ///     char channelString[], 
        ///     int32 index[],
        ///     float64 pilotEVMPerSymbol[],
        ///     int32 dataArraySize,
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the EVM per symbol number for pilot subcarriers for each iteration when the toolkit processes the acquired burst. The toolkit obtains this trace from the  niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace function by averaging over the pilot subcarrier for each symbol.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_EVM_PER_SYMBOL_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///         N.A.
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx"
        ///                                     "streamx"
        ///                                     NIWLANA_VAL_TRUE
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                     "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 				NIWLANA_VAL_TRUE
        /// 					"segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///         
        ///                     "channelx"
        ///         
        ///                      "streamx"
        ///                      NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM 
        ///         
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///         
        ///                      "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 
        /// "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                  
        /// "[segmentx/]streamy" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                
        /// "userx/[segmenty/]streamz" if the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE  attribute is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        ///</returns>
        public int GetCurrentIterationOFDMDemodPilotEVMPerSymbolTrace(string channelString, int[] index, double[] pilotEVMperSymbol, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodPilotEVMPerSymbolTrace(Handle, channelString, index, pilotEVMperSymbol, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns the channel frequency response magnitude and phase for each subcarrier for each iteration when the toolkit processes the acquired burst. The portion of the signal that the toolkit uses to obtain this trace is specified by the NIWLANA_OFDM_DEMOD_CHANNEL_ESTIMATION_METHOD attribute.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_CHANNEL_FREQUENCY_RESPONSE_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        ///         N.A.
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx/streamy"
        ///                      NIWLANA_VAL_TRUE 
        ///                     "streamy"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM 
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely/streamz" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                   NIWLANA_VAL_TRUE
        ///                     "[segmentx/]streamz" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                              NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///         
        ///                      "channelx/streamy"
        ///                              NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///         
        ///                     "[segmentx]/channely/streamz" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "index">
        /// Returns the indices of the subcarriers. 
        /// 
        ///</param>
        ///<param name = "magnitude">
        /// Returns the magnitude of the channel frequency response.  This value is expressed in dB.
        /// 
        ///</param>
        ///<param name = "phase">
        /// Returns the phase of the channel frequency response. This value is expressed in radians.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the data array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the CFRMagnitude and CFRPhase arrays. If the arrays are not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output arrays. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodChannelFrequencyResponseTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodChannelFrequencyResponseTrace (niWLANA session,
        ///     char channelString[], 
        ///     int32 index[],
        ///     float64 CFRMagnitude[],
        ///     float64 CFRPhase[],
        ///     int32 dataArraySize,
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the channel frequency response magnitude and phase for each subcarrier for each iteration when the toolkit processes the acquired burst. The portion of the signal that the toolkit uses to obtain this trace is specified by the NIWLANA_OFDM_DEMOD_CHANNEL_ESTIMATION_METHOD attribute.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_CHANNEL_FREQUENCY_RESPONSE_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        ///         N.A.
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     NIWLANA_VAL_FALSE 
        ///                     "channelx/streamy"
        ///                      NIWLANA_VAL_TRUE 
        ///                     "streamy"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM 
        ///                     NIWLANA_VAL_FALSE
        ///                     "[segmentx/]channely/streamz" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                                   NIWLANA_VAL_TRUE
        ///                     "[segmentx/]streamz" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        ///                              NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///         
        ///                      "channelx/streamy"
        ///                              NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///         
        ///                     &quot;[segmentx]/channely/streamz&quot; ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        ///</returns>
        public int GetCurrentIterationOFDMDemodChannelFrequencyResponseTrace(string channelString, int[] index, double[] magnitude, double[] phase, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodChannelFrequencyResponseTrace(Handle, channelString, index, magnitude, phase, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns the relative channel energy, in dB, for each subcarrier for each iteration when the toolkit processes the acquired burst. This trace is derived from the niWLANA_GetCurrentIterationOFDMDemodChannelFrequencyResponseTrace function, as defined in section 17.3.9.6.2 of the IEEE Standard 802.11-2007 and section 20.3.21.2 of the IEEE Standard 802.11n-2009.
        /// Set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_SPECTRAL_FLATNESS_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE to get the current iteration spectral flatness trace.
        /// If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use a channelx/streamy active channel string to configure this function, which returns the spectral flatness trace for the corresponding stream of the corresponding channel that is derived from the niWLANA_GetCurrentIterationOFDMDemodChannelFrequencyResponseTrace function for a channelx/streamy active channel string. 
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// Specifies the WLAN channel for which you want to fetch the trace.
        /// 
        ///</param>
        ///<param name = "index">
        /// Returns the indices of the subcarrier. 
        /// 
        ///</param>
        ///<param name = "upperMask">
        /// Returns the upper limits on the relative channel energy for each subcarrier. 
        /// 
        ///</param>
        ///<param name = "spectralFlatness">
        /// Returns the relative channel energy for each subcarrier. 
        /// 
        ///</param>
        ///<param name = "lowerMask">
        /// Returns the lower limits on the relative channel energy for each subcarrier. 
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the data array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the upperMask, spectralFlatness, and lowerMask arrays. If the arrays are not large enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output arrays. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodSpectralFlatnessTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodSpectralFlatnessTrace(
        ///     niWLANAnalysisSession session,
        ///     char channelString[],
        ///     int32 index[],
        ///     float64 upperMask[],
        ///     float64 spectralFlatness[],
        ///     float64 lowerMask[],
        ///     int32 dataArraySize,
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the relative channel energy, in dB, for each subcarrier for each iteration when the toolkit processes the acquired burst. This trace is derived from the niWLANA_GetCurrentIterationOFDMDemodChannelFrequencyResponseTrace function, as defined in section 17.3.9.6.2 of the IEEE Standard 802.11-2007 and section 20.3.21.2 of the IEEE Standard 802.11n-2009.
        /// Set the NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_SPECTRAL_FLATNESS_TRACE_ENABLED 
        /// attributes to NIWLANA_VAL_TRUE to get the current iteration spectral flatness trace.
        /// If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use a channelx/streamy active channel string to configure this function, which returns the spectral flatness trace for the corresponding stream of the corresponding channel that is derived from the niWLANA_GetCurrentIterationOFDMDemodChannelFrequencyResponseTrace function for a channelx/streamy active channel string. 
        /// 
        ///</returns>
        public int niWLANA_GetCurrentIterationOFDMDemodSpectralFlatnessTrace(string channelString, int[] index, double[] upperMask, double[] spectralFlatness, double[] lowerMask, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodSpectralFlatnessTrace(Handle, channelString, index, upperMask, spectralFlatness, lowerMask, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Saves all attributes of the session to a file located at a specified path. Use this file to save the current state of the toolkit.
        /// 
        /// </summary>
        ///<param name = "filePath">
        /// Specifies the complete path to the technical data management streaming (TDMS) file to which the toolkit saves the configuration.
        /// 
        ///</param>
        ///<param name = "operation">
        /// Specifies the operation to perform on the file. The default value is NIWLANA_VAL_FILE_OPERATION_MODE_CREATE_OR_REPLACE.
        ///  NIWLANA_VAL_FILE_OPERATION_MODE_OPEN(0)
        /// Opens an existing file to write the niWLANA settings.
        /// NIWLANA_VAL_FILE_OPERATION_MODE_OPEN_OR_CREATE(1)
        /// Opens an existing file or creates a new file if the file does not exist.
        /// NIWLANA_VAL_FILE_OPERATION_MODE_CREATE_OR_REPLACE(2)
        /// Creates a new file or replaces an existing file.
        /// NIWLANA_VAL_FILE_OPERATION_MODE_CREATE(3)
        /// Creates a new file.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SaveConfigurationToFile
        /// int32 __stdcall niWLANA_SaveConfigurationToFile (niWLANA session,
        ///     char filePath[],
        ///     int32 operation);
        /// Purpose
        /// Saves all attributes of the session to a file located at a specified path. Use this file to save the current state of the toolkit.
        /// 
        ///</returns>
        public int SaveConfigurationToFile(string filePath, int operation)
        {
            int pInvokeResult = PInvoke.niWLANA_SaveConfigurationToFile(Handle, filePath, operation);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Loads the attributes of a session saved in a file and restores the previous state of the toolkit.
        /// 
        /// </summary>
        ///<param name = "filePath">
        /// Specifies the complete path to the technical data management streaming (TDMS) file to which the toolkit saves the configuration.
        /// 
        ///</param>
        ///<param name = "reset">
        /// Specifies whether to reset all the attributes of the session before loading the settings from a file.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_LoadConfigurationFromFile
        /// int32 __stdcall niWLANA_LoadConfigurationFromFile (niWLANA session,
        ///     char filePath[],
        ///     int32 reset);
        /// Purpose
        /// Loads the attributes of a session saved in a file and restores the previous state of the toolkit.
        /// 
        ///</returns>
        public int LoadConfigurationFromFile(string filePath, int reset)
        {
            int pInvokeResult = PInvoke.niWLANA_LoadConfigurationFromFile(Handle, filePath, reset);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Reads a waveform from the file saved using the WLAN Analysis Soft Front Panel, located at Start&#187;All Programs&#187;National Instruments&#187;NI WLAN Analysis Toolkit.
        /// This function returns waveform data that you can use with the niWLANA_AnalyzeIQComplexF64 or niWLANA_AnalyzeMIMOIQComplexF64 functions. If you use the technical data management streaming (TDMS) file format, the file may have more than one waveform depending on the Number of Averages attributes used for measurements.
        /// Use the following string format for the waveformName parameter when reading a specific acquisition waveform.
        ///                                     NIWLANA_STANDARD attribute
        ///                     String Format
        ///                     Example
        ///                                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM
        ///                     "IQwfmy" 
        ///                     IQwfm0 for a waveform with index 0
        ///                                     NIWLANA_VAL_STANDARD_80211BG_DSSS
        ///                     "IQwfmy" 
        ///                     IQwfm0 for a waveform with index 0
        ///                                     NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "IQwfmy" 
        ///                     IQwfm0 for a waveform with index 0
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx::IQwfmy" 
        ///                     channel1::IQwfm2 for a waveform with index 2 of channel with index 1
        ///                                         NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     "[segmentz::]channelx::IQwfmy" 
        ///                     segment0::channel2::IQwfm3 for a waveform with index 3 of channel with index 2 of segment with index 0. "segment0::" is optional if the segment index is 0.
        /// where x represents an identified number for the channel index, y represents an identified number for the waveform index, and z represents an identified number for the segment index.
        /// 
        /// </summary>
        ///<param name = "filePath">
        /// Specifies the complete path to the file from which the toolkit reads the waveform.
        /// 
        ///</param>
        ///<param name = "waveformName">
        /// Specifies the name of the waveform to read from the file.
        /// 
        ///</param>
        ///<param name = "offset">
        /// Specifies the number of samples into the waveform at which the function begins reading the I/Q data. If you set the count parameter to 1,000 and the offset parameter to 2, the function returns 1,000 samples, starting from index 2 and ending at index 1,002.
        /// The default value is 0.
        /// 
        ///</param>
        ///<param name = "count">
        /// Specifies the maximum number of samples of the I/Q complex waveform to read from the file. If you set the count parameter to 1,000 and the offset parameter to 2, the function returns 1,000 samples, starting from index 2 and ending at index 1,002. The default value is -1, which returns all samples.
        /// 
        ///</param>
        ///<param name = "t0">
        /// Returns the start time of the waveform array. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "dt">
        /// Returns the time interval between the samples in the waveform array. The reciprocal of dt indicates the I/Q rate of the input signal. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "waveform">
        /// Returns the baseband time-domain waveform.
        /// 
        ///</param>
        ///<param name = "waveformSize">
        /// Specifies the size of the waveform to read from the file.
        /// 
        ///</param>
        ///<param name = "actualSize">
        /// Returns the size of the data array. You can pass NULL to the waveform parameter to obtain the size of the waveform.
        /// 
        ///</param>
        ///<param name = "eOF">
        /// Indicates whether the end of the file has been reached.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_ReadWaveformFromFile
        /// int32 __stdcall niWLANA_ReadWaveformFromFile (char filePath[], 
        ///     char waveformName[], 
        ///     int64 offset, 
        ///     int64 count, 
        ///     float64 *t0, 
        ///     float64 *dt, 
        ///     NIComplexNumber waveform[], 
        ///     int32 waveformSize,
        ///     int32 *actualArraySize,
        ///     int32 *eof);
        /// Purpose
        /// Reads a waveform from the file saved using the WLAN Analysis Soft Front Panel, located at Start&#187;All Programs&#187;National Instruments&#187;NI WLAN Analysis Toolkit.
        /// This function returns waveform data that you can use with the niWLANA_AnalyzeIQComplexF64 or niWLANA_AnalyzeMIMOIQComplexF64 functions. If you use the technical data management streaming (TDMS) file format, the file may have more than one waveform depending on the Number of Averages attributes used for measurements.
        /// Use the following string format for the waveformName parameter when reading a specific acquisition waveform.
        ///                                     NIWLANA_STANDARD attribute
        ///                     String Format
        ///                     Example
        ///                                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM
        ///                     "IQwfmy" 
        ///                     IQwfm0 for a waveform with index 0
        ///                                     NIWLANA_VAL_STANDARD_80211BG_DSSS
        ///                     "IQwfmy" 
        ///                     IQwfm0 for a waveform with index 0
        ///                                     NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "IQwfmy" 
        ///                     IQwfm0 for a waveform with index 0
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx::IQwfmy" 
        ///                     channel1::IQwfm2 for a waveform with index 2 of channel with index 1
        ///                                         NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     "[segmentz::]channelx::IQwfmy" 
        ///                     segment0::channel2::IQwfm3 for a waveform with index 3 of channel with index 2 of segment with index 0. "segment0::" is optional if the segment index is 0.
        /// where x represents an identified number for the channel index, y represents an identified number for the waveform index, and z represents an identified number for the segment index.
        /// 
        ///</returns>
        public int ReadWaveformFromFile(string filePath, string waveformName, int offset, int count, out double t0, out double dt, out niComplexNumber waveform, int waveformSize, out int actualSize, out int eOF)
        {
            int pInvokeResult = PInvoke.niWLANA_ReadWaveformFromFile(filePath, waveformName, offset, count, out t0, out dt, out waveform, waveformSize, out actualSize, out eOF);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Calculates the carrier frequency according to the numbering scheme by converting a set of input parameters including the channel number for IEEE 802.11a/b/g/p/n,  IEEE 802.11ac, IEEE P802.11ah/D1.3, IEEE 802.11af, and IEEE P802.11ax/D1.2 standards.
        /// 
        /// </summary>
        ///<param name = "frequencyBand">
        /// Specifies the frequency band to use. The default value is NIWLANA_VAL_FREQUENCY_BAND_2p4GHZ. 
        /// NIWLANA_VAL_FREQUENCY_BAND_2p4GHZ (0)
        /// Specifies a frequency band of 2.4 GHz.
        /// NIWLANA_VAL_FREQUENCY_BAND_5GHZ (1)
        /// Specifies a frequency band of 5 GHz.
        /// 
        ///</param>
        ///<param name = "channelBandwidth">
        /// Specifies the channel bandwidth You can choose a 5 MHz, 10 MHz, 20 MHz, or 40 MHz channel.
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelNumber">
        /// Specifies the offset of the center frequency, in increments of 5 MHz, above the starting frequency of the channel. 
        /// When you set the channelBandwidth parameter to 40 MHz, the channelNumber parameter is the primary channel number and the corresponding channel center frequency is the primary channel center frequency. 
        /// 
        ///</param>
        ///<param name = "secondaryFactor">
        /// Specifies whether the secondary channel is above or below the primary channel when you set the
        /// channelBandwidth parameter to 40 MHz.
        /// The toolkit creates a 40 MHz channel by combining the primary channel and the secondary channel, each with a 20 MHz bandwidth.
        /// The secondary channel number is given by the following formula:
        /// secondary channel number = primary channel number + (4&#160;*&#160;secondaryFactor)
        /// The toolkit calculates the secondary channel center frequency is given by the following formula:
        /// secondary channel center frequency (Hz) = channel starting frequency (Hz) + (secondary channel number * 5&#160;MHz)
        /// Valid values are -1 and +1.
        /// 
        ///</param>
        ///<param name = "channelStartingFactor">
        /// Specifies the value used to define the baseline frequency.
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Returns the carrier frequency. This function calculates the carrier frequency using the following formula:
        /// Carrier frequency (Hz) = channel starting frequency (Hz) + (channel number * 5 MHz). 
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_ChannelNumberToCarrierFrequency
        /// int32 __stdcall niWLANA_ChannelNumberToCarrierFrequency (int32 frequencyBand,
        ///     float64 channelBandwidth,
        ///     int32 channelNumber,
        ///     int32 secondaryFactor, 
        ///     float64 channelStartingFactor,
        ///     float64 *carrierFrequency);
        /// Purpose
        /// Calculates the carrier frequency according to the numbering scheme by converting a set of input parameters including the channel number for IEEE 802.11a/b/g/p/n,  IEEE 802.11ac, IEEE P802.11ah/D1.3, IEEE 802.11af, and IEEE P802.11ax/D1.2 standards.
        /// 
        ///</returns>
        public int ChannelNumberToCarrierFrequency(int frequencyBand, double channelBandwidth, int channelNumber, int secondaryFactor, double channelStartingFactor, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANA_ChannelNumberToCarrierFrequency(frequencyBand, channelBandwidth, channelNumber, secondaryFactor, channelStartingFactor, out carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the estimated carrier frequency offset of the transmitting device under test (DUT). This value is expressed in Hz. For example, if during acquisition you set the NI-RFSA IQ Carrier Frequency attribute to 2.412 GHz and the toolkit measures the carrier frequency of the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz. This measurement follows section 17.3.9.4 of IEEE Standard 802.11a-1999 and section 20.3.21.4 of IEEE Standard 802.11n-2009.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "carrierFrequencyOffset">
        /// Returns the estimated carrier frequency offset of the transmitting DUT. This value is expressed in Hz.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetDSSSDemodCarrierFrequencyOffset
        /// int32 __stdcall niWLANA_GetDSSSDemodCarrierFrequencyOffset (niWLANA session,
        ///     char channelString[],
        ///     float64 *carrierFrequencyOffset);
        /// Purpose
        /// Returns the estimated carrier frequency offset of the transmitting device under test (DUT). This value is expressed in Hz. For example, if during acquisition you set the NI-RFSA IQ Carrier Frequency attribute to 2.412 GHz and the toolkit measures the carrier frequency of the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz. This measurement follows section 17.3.9.4 of IEEE Standard 802.11a-1999 and section 20.3.21.4 of IEEE Standard 802.11n-2009.
        /// 
        ///</returns>
        public int GetDSSSDemodCarrierFrequencyOffset(string channelString, out double carrierFrequencyOffset)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierFrequencyOffset, channelString,out carrierFrequencyOffset);
        }
        /// <summary>
        /// Configures NI-RFSAs for either I/Q acquisition or spectral acquisition depending on the type of WLAN measurement you specify.
        /// Before setting the attributes in this section, the niWLANA_RFSAConfigureHardware function sets the NIWLANA_DEVICE_INSTANTANEOUS_BANDWIDTH attribute according the device in use as listed below: 
        /// 200 MHz if you are using NI PXIe-5646R
        /// 80 MHz if you are using NI PXIe-5644R/NI PXIe-5645R
        /// 1 GHz if you are using NI PXIe-5840
        /// If you are using NI PXIe-5668R,NI-RFSA IQ Carrier Frequency
        /// Bandwidth Option
        /// Acquisition Bitfile
        /// Device Instantaneous Bandwidth
        /// Entire range
        /// 80 MHz
        /// 400 MHz/800 MHz
        /// 80 MHz
        /// Entire range
        /// 200 MHz
        /// 400 MHz/800 MHz
        /// 200 MHz
        /// = 3.6 GHz
        /// 320 MHz/765 MHz
        /// 400 MHz/800 MHz
        /// 320 MHz
        /// > 3.6 GHz
        /// 320 MHz/765 MHz
        /// 400 MHz
        /// 400 MHz
        /// > 3.6 GHz
        /// 320 MHz/765 MHz
        /// 800 MHz
        /// 765 MHz
        /// 50 MHz if you are using any other NI-RFSA device
        /// If the NIWLANA_RECOMMENDED_ACQUISITION_TYPE attribute returns NIWLANA_VAL_ACQUISITION_TYPE_IQ, this function configures NI-RFSA device to acquire I/Q samples and performs the following actions:  
        /// Sets the NIRFSA_ATTR_ACQUISITION_TYPE attribute to NIRFSA_VAL_IQ.
        /// Sets the NIRFSA_ATTR_IQ_RATE attribute to the value of the NIWLANA_RECOMMENDED_IQ_SAMPLING_RATE attribute value.
        /// Sets the NIRFSA_ATTR_NUMBER_OF_SAMPLES_IS_FINITE attribute to VI_TRUE.
        /// Retrieves the coerced NIRFSA_ATTR_IQ_RATE attribute, multiplies this value by the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute, and sets the NIRFSA_ATTR_NUMBER_OF_SAMPLES attribute to the result.
        /// Sets the NIRFSA_ATTR_NUMBER_OF_RECORDS_IS_FINITE attribute to VI_TRUE.
        /// Sets the NIRFSA_ATTR_NUMBER_OF_RECORDS attribute to the value of the NIWLANA_RECOMMENDED_NUMBER_OF_RECORDS attribute value.
        /// Retrieves the coerced NIRFSA_ATTR_IQ_RATE attribute, multiplies this value by the value of the NIWLANA_RECOMMENDED_IQ_PRE_TRIGGER_DELAY attribute, and sets the NIRFSA_ATTR_REF_TRIGGER_PRETRIGGER_SAMPLES attribute to the result.
        /// If you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to NIRFSA_VAL_IQ_POWER_EDGE, this function sets the NIRFSA_ATTR_REF_TRIGGER_MINIMUM_QUIET_TIME attribute to the value of the NIWLANA_RECOMMENDED_MINIMUM_QUIET_TIME attribute. If you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to any other value, this function sets the NIRFSA_ATTR_REF_TRIGGER_MINIMUM_QUIET_TIME attribute to 0.
        /// Sets the NIRFSA_ALLOW_MORE_RECORDS_THAN_MEMORY attribute to VI_TRUE.
        /// If the NIWLANA_RECOMMENDED_ACQUISITION_TYPE attribute returns NIWLANA_VAL_ACQUISITION_TYPE_SPECTRUM and you set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE, this function configures NI-RFSA device to acquire I/Q samples and performs the following actions: 
        /// Sets the NIRFSA_ATTR_ACQUISITION_TYPE attribute to NIRFSA_VAL_IQ.
        /// If you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to NIRFSA_VAL_IQ_POWER_EDGE, this function sets the NIRFSA_ATTR_REF_TRIGGER_MINIMUM_QUIET_TIME attribute to the value of the NIWLANA_RECOMMENDED_MINIMUM_QUIET_TIME attribute. If you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to any other value, this function sets the NIRFSA_ATTR_REF_TRIGGER_MINIMUM_QUIET_TIME attribute to 0.
        /// Sets the NIRFSA_ATTR_NUMBER_OF_RECORDS_IS_FINITE attribute to VI_TRUE.
        /// Sets the NIRFSA_ATTR_NUMBER_OF_RECORDS attribute to the value of the NIWLANA_RECOMMENDED_NUMBER_OF_RECORDS attribute.
        /// Sets the NIRFSA_ALLOW_MORE_RECORDS_THAN_MEMORY attribute to VI_TRUE.
        /// Sets the NIRFSA_ATTR_REF_TRIGGER_PRETRIGGER_SAMPLES attribute to 0.
        /// If the NIWLANA_RECOMMENDED_ACQUISITION_TYPE attribute returns NIWLANA_VAL_ACQUISITION_TYPE_SPECTRUM and you set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_FALSE, this function configures NI-RFSA to compute a power spectrum and performs the following actions: 
        /// Sets the NIRFSA_ATTR_ACQUISITION_TYPE attribute to NIRFSA_VAL_SPECTRUM.
        /// Sets the NIRFSA_ATTR_SPECTRUM_SPAN attribute to the value of the NIWLANA_RECOMMENDED_SPECTRUM_SPAN attribute.
        /// Sets the NIRFSA_ATTR_POWER_SPECTRUM_UNITS attribute to NIRFSA_VAL_VOLTS_SQUARED.
        /// Sets the NIRFSA_ATTR_RESOLUTION_BANDWIDTH_TYPE attribute to NIRFSA_VAL_RBW_3DB, NIRFSA_VAL_RBW_6DB, NIRFSA_VAL_RBW_BIN_WIDTH, or NIRFSA_VAL_RBW_ENBW depending on the NIWLANA_RECOMMENDED_SPECTRUM_RBW_DEFINITION attribute.
        /// Sets the NIRFSA_ATTR_RESOLUTION_BANDWIDTH attribute to the value of the NIWLANA_RECOMMENDED_SPECTRUM_RBW attribute.
        /// Sets the NIRFSA_ATTR_SPECTRUM_AVERAGING_MODE attribute to NIRFSA_VAL_RMS_AVERAGING.
        /// Sets the NIRFSA_ATTR_SPECTRUM_NUMBER_OF_AVERAGES attribute to the value of the NIWLANA_RECOMMENDED_NUMBER_OF_RECORDS attribute.
        /// Sets the NIRFSA_ATTR_FFT_WINDOW_TYPE attribute to the value returned by the NIWLANA_RECOMMENDED_SPECTRUM_FFT_WINDOW_TYPE attribute.
        /// Retrieves the spectrumInfo cluster using the niRFSA_GetSpectralInfoForSMT function and sets the NIWLANA_FFT_WINDOW_SIZE attribute and the niRFSA_GetSpectralInfoForSMT function and sets the NIWLANA_FFT_SIZE attribute, respectively, to the window size and FFT size elements of the spectralInfo cluster.
        /// This function calls the niWLANA_RFSAConfigureExternalGain function to configure the NIRFSA_ATTR_EXTERNAL_GAIN attribute according to the specified amplitude correction table for the NI RF vector signal analyzer.
        /// This function calls the niWLANA_RFSAReadDeviceState function read the state of the NI RF vector signal analyzer like model name, LO frequency, temperature, etc., if you set the NIWLANA_NOISE_COMPENSATION_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// 
        /// </summary>
        ///<param name = "rFSASession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSA_init function or niRFSA_InitWithOptions function. 
        /// 
        ///</param>
        ///<param name = "hardwareChannelString">
        /// Specifies the RFSA device channel. Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "samplesPerRecord">
        /// Returns the number of samples per record configured for the NI-RFSA session.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAConfigureHardware
        /// int32 __stdcall niWLANA_RFSAConfigureHardware (niWLANA session, ViSession rfsaSession, char hwChannelString[], int64 *samplesPerRecord);
        /// Purpose
        /// Configures NI-RFSAs for either I/Q acquisition or spectral acquisition depending on the type of WLAN measurement you specify.
        /// Before setting the attributes in this section, the niWLANA_RFSAConfigureHardware function sets the NIWLANA_DEVICE_INSTANTANEOUS_BANDWIDTH attribute according the device in use as listed below: 
        /// 200 MHz if you are using NI PXIe-5646R
        /// 80 MHz if you are using NI PXIe-5644R/NI PXIe-5645R
        /// 1 GHz if you are using NI PXIe-5840
        /// If you are using NI PXIe-5668R,NI-RFSA IQ Carrier Frequency
        /// Bandwidth Option
        /// Acquisition Bitfile
        /// Device Instantaneous Bandwidth
        /// Entire range
        /// 80 MHz
        /// 400 MHz/800 MHz
        /// 80 MHz
        /// Entire range
        /// 200 MHz
        /// 400 MHz/800 MHz
        /// 200 MHz
        /// = 3.6 GHz
        /// 320 MHz/765 MHz
        /// 400 MHz/800 MHz
        /// 320 MHz
        /// > 3.6 GHz
        /// 320 MHz/765 MHz
        /// 400 MHz
        /// 400 MHz
        /// > 3.6 GHz
        /// 320 MHz/765 MHz
        /// 800 MHz
        /// 765 MHz
        /// 50 MHz if you are using any other NI-RFSA device
        /// If the NIWLANA_RECOMMENDED_ACQUISITION_TYPE attribute returns NIWLANA_VAL_ACQUISITION_TYPE_IQ, this function configures NI-RFSA device to acquire I/Q samples and performs the following actions:  
        /// Sets the NIRFSA_ATTR_ACQUISITION_TYPE attribute to NIRFSA_VAL_IQ.
        /// Sets the NIRFSA_ATTR_IQ_RATE attribute to the value of the NIWLANA_RECOMMENDED_IQ_SAMPLING_RATE attribute value.
        /// Sets the NIRFSA_ATTR_NUMBER_OF_SAMPLES_IS_FINITE attribute to VI_TRUE.
        /// Retrieves the coerced NIRFSA_ATTR_IQ_RATE attribute, multiplies this value by the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute, and sets the NIRFSA_ATTR_NUMBER_OF_SAMPLES attribute to the result.
        /// Sets the NIRFSA_ATTR_NUMBER_OF_RECORDS_IS_FINITE attribute to VI_TRUE.
        /// Sets the NIRFSA_ATTR_NUMBER_OF_RECORDS attribute to the value of the NIWLANA_RECOMMENDED_NUMBER_OF_RECORDS attribute value.
        /// Retrieves the coerced NIRFSA_ATTR_IQ_RATE attribute, multiplies this value by the value of the NIWLANA_RECOMMENDED_IQ_PRE_TRIGGER_DELAY attribute, and sets the NIRFSA_ATTR_REF_TRIGGER_PRETRIGGER_SAMPLES attribute to the result.
        /// If you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to NIRFSA_VAL_IQ_POWER_EDGE, this function sets the NIRFSA_ATTR_REF_TRIGGER_MINIMUM_QUIET_TIME attribute to the value of the NIWLANA_RECOMMENDED_MINIMUM_QUIET_TIME attribute. If you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to any other value, this function sets the NIRFSA_ATTR_REF_TRIGGER_MINIMUM_QUIET_TIME attribute to 0.
        /// Sets the NIRFSA_ALLOW_MORE_RECORDS_THAN_MEMORY attribute to VI_TRUE.
        /// If the NIWLANA_RECOMMENDED_ACQUISITION_TYPE attribute returns NIWLANA_VAL_ACQUISITION_TYPE_SPECTRUM and you set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE, this function configures NI-RFSA device to acquire I/Q samples and performs the following actions: 
        /// Sets the NIRFSA_ATTR_ACQUISITION_TYPE attribute to NIRFSA_VAL_IQ.
        /// If you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to NIRFSA_VAL_IQ_POWER_EDGE, this function sets the NIRFSA_ATTR_REF_TRIGGER_MINIMUM_QUIET_TIME attribute to the value of the NIWLANA_RECOMMENDED_MINIMUM_QUIET_TIME attribute. If you set the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to any other value, this function sets the NIRFSA_ATTR_REF_TRIGGER_MINIMUM_QUIET_TIME attribute to 0.
        /// Sets the NIRFSA_ATTR_NUMBER_OF_RECORDS_IS_FINITE attribute to VI_TRUE.
        /// Sets the NIRFSA_ATTR_NUMBER_OF_RECORDS attribute to the value of the NIWLANA_RECOMMENDED_NUMBER_OF_RECORDS attribute.
        /// Sets the NIRFSA_ALLOW_MORE_RECORDS_THAN_MEMORY attribute to VI_TRUE.
        /// Sets the NIRFSA_ATTR_REF_TRIGGER_PRETRIGGER_SAMPLES attribute to 0.
        /// If the NIWLANA_RECOMMENDED_ACQUISITION_TYPE attribute returns NIWLANA_VAL_ACQUISITION_TYPE_SPECTRUM and you set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_FALSE, this function configures NI-RFSA to compute a power spectrum and performs the following actions: 
        /// Sets the NIRFSA_ATTR_ACQUISITION_TYPE attribute to NIRFSA_VAL_SPECTRUM.
        /// Sets the NIRFSA_ATTR_SPECTRUM_SPAN attribute to the value of the NIWLANA_RECOMMENDED_SPECTRUM_SPAN attribute.
        /// Sets the NIRFSA_ATTR_POWER_SPECTRUM_UNITS attribute to NIRFSA_VAL_VOLTS_SQUARED.
        /// Sets the NIRFSA_ATTR_RESOLUTION_BANDWIDTH_TYPE attribute to NIRFSA_VAL_RBW_3DB, NIRFSA_VAL_RBW_6DB, NIRFSA_VAL_RBW_BIN_WIDTH, or NIRFSA_VAL_RBW_ENBW depending on the NIWLANA_RECOMMENDED_SPECTRUM_RBW_DEFINITION attribute.
        /// Sets the NIRFSA_ATTR_RESOLUTION_BANDWIDTH attribute to the value of the NIWLANA_RECOMMENDED_SPECTRUM_RBW attribute.
        /// Sets the NIRFSA_ATTR_SPECTRUM_AVERAGING_MODE attribute to NIRFSA_VAL_RMS_AVERAGING.
        /// Sets the NIRFSA_ATTR_SPECTRUM_NUMBER_OF_AVERAGES attribute to the value of the NIWLANA_RECOMMENDED_NUMBER_OF_RECORDS attribute.
        /// Sets the NIRFSA_ATTR_FFT_WINDOW_TYPE attribute to the value returned by the NIWLANA_RECOMMENDED_SPECTRUM_FFT_WINDOW_TYPE attribute.
        /// Retrieves the spectrumInfo cluster using the niRFSA_GetSpectralInfoForSMT function and sets the NIWLANA_FFT_WINDOW_SIZE attribute and the niRFSA_GetSpectralInfoForSMT function and sets the NIWLANA_FFT_SIZE attribute, respectively, to the window size and FFT size elements of the spectralInfo cluster.
        /// This function calls the niWLANA_RFSAConfigureExternalGain function to configure the NIRFSA_ATTR_EXTERNAL_GAIN attribute according to the specified amplitude correction table for the NI RF vector signal analyzer.
        /// This function calls the niWLANA_RFSAReadDeviceState function read the state of the NI RF vector signal analyzer like model name, LO frequency, temperature, etc., if you set the NIWLANA_NOISE_COMPENSATION_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// 
        ///</returns>
        public int RFSAConfigureHardware(HandleRef rFSASession, string hardwareChannelString, out long samplesPerRecord)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAConfigureHardware(Handle, rFSASession, hardwareChannelString, out samplesPerRecord);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Specifies the reference I/Q waveform generated at the RF signal generator to be used for AMPM analysis. You can set the t0, dt and Y parameters when the NIWLANA_AMPM_MEASUREMENTS_ENABLED attribute is set to NIWLANA_VAL_TRUE. 
        /// </summary>
        ///<param name = "t0">
        /// t0
        /// float64
        /// Specifies the trigger (start) time of the data array.
        /// 
        ///</param>
        ///<param name = "dt">
        /// dt
        /// float64
        /// Specifies the time interval between data points in the data array.
        /// 
        ///</param>
        ///<param name = "data">
        /// waveform
        /// niComplexNumber[]
        /// Specifies the acquired complex-valued signal. The real and imaginary parts of this complex array correspond to the in-phase (I) and quadrature-phase (Q) data, respectively.
        /// 
        ///</param>
        ///<param name = "lenOfY">
        /// lenOfY
        /// int32
        /// Specifies the array size of Y parameter.
        /// </param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        [Obsolete]
        public int SetAMPMReferenceWaveform(double t0, double dt, niComplexNumber[] data, int lenOfY)
        {
            int pInvokeResult = PInvoke.niWLANA_SetAMPMReferenceWaveform(Handle, t0, dt, data, lenOfY);

            TestForError(pInvokeResult);

            return pInvokeResult;
        }

        /// <summary>
        /// Returns the lowest margin which is the minimum difference between the spectral mask and the acquired PSD, as defined in section 17.3.9.2 of IEEE Standard 802.11a-1999, section 18.4.7.3 of IEEE Standard 802.11b-1999, and section 20.3.21.1 of IEEE Standard 802.11n-2009. If the test fails, the spectral mask margin is negative. The toolkit computes the spectral mask margin excluding the reference channel if you set the NIWLANA_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE attribute to NIWLANA_VAL_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE_PEAK_SIGNAL_POWER.
        /// To understand which  active channel strings are required to configure this function, refer to the NIWLANA_RESULT_SPECTRAL_MASK_MARGIN attribute.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "value">
        /// Returns the worst margin by which the spectral mask test fails.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetSpectralMaskMargin
        /// int32 __stdcall niWLANA_GetSpectralMaskMargin (niWLANA session,
        ///     char channelString[],
        ///     float64 *spectralMaskMargin);
        /// Purpose
        /// Returns the lowest margin which is the minimum difference between the spectral mask and the acquired PSD, as defined in section 17.3.9.2 of IEEE Standard 802.11a-1999, section 18.4.7.3 of IEEE Standard 802.11b-1999, and section 20.3.21.1 of IEEE Standard 802.11n-2009. If the test fails, the spectral mask margin is negative. The toolkit computes the spectral mask margin excluding the reference channel if you set the NIWLANA_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE attribute to NIWLANA_VAL_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE_PEAK_SIGNAL_POWER.
        /// To understand which  active channel strings are required to configure this function, refer to the NIWLANA_RESULT_SPECTRAL_MASK_MARGIN attribute.
        /// 
        ///</returns>
        public int GetSpectralMaskMargin(string channelString, out double value)
        {
           return GetDouble(niWLANAProperties.ResultSpectralMaskMargin, channelString, out value);
        }

        #region Missing Functions

        /// <summary>
        ///Indicates the compatibilityVersion parameter of the niWLANA_OpenSession function.
        ///    Get Function: niWLANA_GetToolkitCompatibilityVersion
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetToolkitCompatibilityVersion(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.CompatibilityVersion, channelString, out value);
        }

        #endregion

        #region Version 4.0
        /// <summary>
        ///Returns the array of frequencies at the lowest margins for each linear segment of the spectral emission mask. This value is expressed in Hz.   Each element of this array corresponds to an element of the NIWLANA_RESULT_SPECTRAL_MASK_MARGIN_VECTOR    and NIWLANA_RESULT_SPECTRAL_MASK_MARGIN_POWER_SPECTRAL_DENSITY_VECTOR attributes.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use    'channelx' as the active channel string format when you set the NIWLANA_SPECTRAL_MASK_COMBINED_MASK_ENABLED    to NIWLANA_VAL_TRUE. 
        ///    If you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetSpectralMaskMarginFrequencyVector
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetSpectralMaskMarginFrequencyVector(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultSpectralMaskMarginFrequencyVector, dataArray, dataArraySize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the array of power spectral densities which correspond to the lowest margins for each linear segment of    the spectral emission mask. This value is expressed in dBm/Hz. Each element of this array    corresponds to an element of the NIWLANA_RESULT_SPECTRAL_MASK_MARGIN_VECTOR    and NIWLANA_RESULT_SPECTRAL_MASK_MARGIN_FREQUENCY_VECTOR attributes.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, you must use    'channelx' as the active channel string format when you set the NIWLANA_SPECTRAL_MASK_COMBINED_MASK_ENABLED    to NIWLANA_VAL_TRUE. 
        ///    If you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetSpectralMaskMarginPowerSpectralDensityVector
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetSpectralMaskMarginPowerSpectralDensityVector(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultSpectralMaskMarginPowerSpectralDensityVector, dataArray, dataArraySize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the frequency offsets of the spectral emission mask used for spectral mask margin measurements. This value is expressed in Hz.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or    NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'segmentx' as the active channel string format to query    this attribute. 'segment0' is optional if you set the NIWLANA_NUMBER_OF_SEGMENTS attribute to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, you must use    an empty string to query this attribute when you set the NIWLANA_SPECTRAL_MASK_COMBINED_MASK_ENABLED    to NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetSpectralMaskFrequencyOffsetsUsed
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetSpectralMaskFrequencyOffsetsUsed(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultSpectralMaskFrequencyOffsetsUsed, dataArray, dataArraySize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the power offsets of the spectral emission mask used for the spectral mask margin measurements. This value is expressed in dB.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or    NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'segmentx' as the active channel string format to query    this attribute. 'segment0' is optional if you set the NIWLANA_NUMBER_OF_SEGMENTS attribute to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, you must use    an empty string to query this attribute when you set the NIWLANA_SPECTRAL_MASK_COMBINED_MASK_ENABLED    to NIWLANA_VAL_TRUE. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetSpectralMaskPowerOffsetsUsed
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetSpectralMaskPowerOffsetsUsed(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultSpectralMaskPowerOffsetsUsed, dataArray, dataArraySize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the ratio of the number of points of the signal PSD that are above the applied spectral emission mask    to the total number of points in the signal PSD. This value is expressd as a percentage.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use    'channelx' as the active channel string format when you set the NIWLANA_SPECTRAL_MASK_COMBINED_MASK_ENABLED    to NIWLANA_VAL_TRUE. 
        ///    If you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetResultSpectralMaskViolation
        /// 
        /// </summary>
        public int GetResultSpectralMaskViolation(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultSpectralMaskViolation, channelString, out value);
        }

        /// <summary>
        ///Returns the absolute time corresponding to the detected start of the analyzed burst. This value is expressed in seconds.    This time is computed with respect to the t0 value of the acquired waveform.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use an empty string    to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use    '[segmentx/]channely' as the active channel string format to query this    attribute. 'segment0/' is optional    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    '[segmentx]' as the active channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetOFDMDemodBurstStartTime
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodBurstStartTime(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodBurstStartTime, channelString, out value);
        }

        /// <summary>
        ///Returns the absolute time corresponding to the detected start of the analyzed burst. This value is expressed in seconds.    This time is computed with respect to the t0 value of the acquired waveform.
        ///    Get Function: niWLANA_GetDSSSDemodBurstStartTime
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSDemodBurstStartTime(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodBurstStartTime, channelString, out value);
        }

        /********************------------------Version 4.0----------------------------********************/
        /// <summary>
        ///Returns the lowest margin for each linear segment of the spectral emission mask, as defined in section    17.3.9.2 of IEEE Standard 802.11a-1999, section 18.4.7.3 of IEEE Standard 802.11b-1999, and section    20.3.21.1 of IEEE Standard 802.11n-2009. The resulting lowest margin indicates the minimum difference between the    acquired PSD spectrum and the spectral mask.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use    'channelx' as the active channel string format when you set the NIWLANA_SPECTRAL_MASK_COMBINED_MASK_ENABLED    to NIWLANA_VAL_TRUE. 
        ///    If you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetSpectralMaskMarginVector
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetSpectralMaskMarginVector(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
              return GetVectorDouble(channelString, niWLANAProperties.ResultSpectralMaskMarginVector, dataArray, dataArraySize, out actualNumDataArrayElements);
        }
        /// <summary>
        /// Returns the preamble frequency error trace for signals containing an OFDM payload. Preamble frequency
        /// error computes the variations, across time, of the frequency error over the short training field (STF) and long training field (LTF) symbols.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_PREAMBLE_FREQUENCY_ERROR_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        ///  You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM  
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "time">
        /// Returns the time. This value is expressed in seconds.
        /// 
        ///</param>
        ///<param name = "preambleFrequencyError">
        /// Returns the preamble frequency error.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the time and preambleFrequencyError arrays. If the arrays are not large enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output arrays. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodPreambleFrequencyErrorTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodPreambleFrequencyErrorTrace(
        ///     niWLANA session,
        ///     char channelString[], 
        ///     float64 time[], 
        ///     float64 preambleFrequencyError[], 
        ///     int32 dataArraySize, 
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the preamble frequency error trace for signals containing an OFDM payload. Preamble frequency
        /// error computes the variations, across time, of the frequency error over the short training field (STF) and long training field (LTF) symbols.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_PREAMBLE_FREQUENCY_ERROR_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        ///  You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM  
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.)
        /// 
        ///</returns>
        public int GetCurrentIterationOFDMDemodPreambleFrequencyErrorTrace(string channelString, double[] time, double[] preambleFrequencyError, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodPreambleFrequencyErrorTrace(Handle, channelString, time, preambleFrequencyError, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the common pilot error (CPE) trace for signals containing an OFDM payload. CPE is computed as the ratio of the received pilot subcarrier values and the ideal pilot subcarrier values.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_COMMON_PILOT_ERROR_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        ///                     "" (empty string)
        ///                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     "segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///                      "" (empty string)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "index">
        /// Returns the indices of the OFDM symbols.
        /// 
        ///</param>
        ///<param name = "CPEMagnitude">
        /// Returns the magnitude of the CPE. 
        /// 
        ///</param>
        ///<param name = "CPEPhase">
        /// Returns the phase of the CPE.  This value is expressed in degrees.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the CPEMagnitude and CPEPhase arrays. If the arrays are not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output arrays. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodCommonPilotErrorTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodCommonPilotErrorTrace(
        ///     niWLANA session,
        ///     char channelString[], 
        ///     int32 index[], 
        ///     float64 CPEMagnitude[],
        ///     float64 CPEPhase[], 
        ///     int32 dataArraySize, 
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the common pilot error (CPE) trace for signals containing an OFDM payload. CPE is computed as the ratio of the received pilot subcarrier values and the ideal pilot subcarrier values.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_COMMON_PILOT_ERROR_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM 
        ///                     "" (empty string)
        ///                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        ///                     "segmentx"
        ///                      NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///                      "" (empty string)
        /// 
        ///</returns>
        public int GetCurrentIterationOFDMDemodCommonPilotErrorTrace(string channelString, int[] index, double[] CPEMagnitude, double[] CPEPhase, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodCommonPilotErrorTrace(Handle, channelString, index, CPEMagnitude, CPEPhase, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the phase noise PSD trace for signals containing an 
        /// OFDM payload. Phase noise estimates are derived from the common pilot error estimates. This trace is averaged across multiple iterations.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_PHASE_NOISE_PSD_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"segmentx"
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "f0">
        /// Indicates the start frequency of the phase noise PSD trace.  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "df">
        /// Indicates the frequency intervals between data points in the phase noise PSD. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "phaseNoisePSD">
        /// Returns the PSD of the phase noise. This value is expressed in dBc/Hz.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the phaseNoisePSD array. If the array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationOFDMDemodPhaseNoisePSDTrace
        /// int32 __stdcall niWLANA_GetCurrentIterationOFDMDemodPhaseNoisePSDTrace(
        ///     niWLANA session, 
        ///     char channelString[], 
        ///     float64 *f0, 
        ///     float64 *df, 
        ///     float64 phaseNoisePSD[], 
        ///     int32 dataArraySize, 
        ///     int32 *actualDataArraySize);
        /// Purpose
        /// Returns the phase noise PSD trace for signals containing an 
        /// OFDM payload. Phase noise estimates are derived from the common pilot error estimates. This trace is averaged across multiple iterations.
        /// To use this function, you must set the NIWLANA_OFDM_DEMOD_PHASE_NOISE_PSD_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                                     NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,  NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM 
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"segmentx"
        /// 
        ///</returns>
        public int GetCurrentIterationOFDMDemodPhaseNoisePSDTrace(string channelString, out double f0, out double df, double[] phaseNoisePSD, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOFDMDemodPhaseNoisePSDTrace(Handle, channelString, out f0, out df, phaseNoisePSD, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///Specifies whether the incoming 802.11ac packet has a PPDU that contains an Aggregated-MAC Protocol Data Unit (A-MPDU).
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_Get80211ACAMPDUEnabled
        ///    Set Function: niWLANA_Set80211ACAMPDUEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int Get80211AcAmpduEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.Property80211acAmpduEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies whether the incoming 802.11ac packet has a PPDU that contains an Aggregated-MAC Protocol Data Unit (A-MPDU).
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_Get80211ACAMPDUEnabled
        ///    Set Function: niWLANA_Set80211ACAMPDUEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int Set80211AcAmpduEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.Property80211acAmpduEnabled, channelString, value);
        }

        /*- OFDM Demod:Impairments Estimation Enabled -------------------------*/

        /********************************************/
        /// <summary>
        ///Specifies whether to estimate carrier frequency offset. 
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetOFDMDemodCarrierFrequencyOffsetEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCarrierFrequencyOffsetEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodCarrierFrequencyOffsetEstimationEnabled(string channelString, out int value)
        {   
            return GetInt(niWLANAProperties.OfdmDemodCarrierFrequencyOffsetEstimationEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to estimate carrier frequency offset. 
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetOFDMDemodCarrierFrequencyOffsetEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCarrierFrequencyOffsetEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodCarrierFrequencyOffsetEstimationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodCarrierFrequencyOffsetEstimationEnabled, channelString,value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to estimate sample clock offset.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodSampleClockOffsetEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodSampleClockOffsetEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodSampleClockOffsetEstimationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodSampleClockOffsetEstimationEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to estimate sample clock offset.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodSampleClockOffsetEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodSampleClockOffsetEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodSampleClockOffsetEstimationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodSampleClockOffsetEstimationEnabled, channelString,value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to estimate I/Q gain imbalance.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodIQGainImbalanceEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodIQGainImbalanceEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodIQGainImbalanceEstimationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodIqGainImbalanceEstimationEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to estimate I/Q gain imbalance.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodIQGainImbalanceEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodIQGainImbalanceEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodIQGainImbalanceEstimationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodIqGainImbalanceEstimationEnabled, channelString, value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to estimate quadrature skew.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodQuadratureSkewEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodQuadratureSkewEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodQuadratureSkewEstimationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodQuadratureSkewEstimationEnabled, channelString, out value);
        }
        /// <summary>
        ///Specifies whether to estimate quadrature skew.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodQuadratureSkewEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodQuadratureSkewEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodQuadratureSkewEstimationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodQuadratureSkewEstimationEnabled, channelString, value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to estimate timing skew.
        ///    When you set the NIWLANA_OFDM_DEMOD_IQ_MISMATCH_SIGNAL_MODEL attribute to NIWLANA_VAL_OFDM_IQ_MISMATCH_SIGNAL_MODEL_RX, the    toolkit does not support timing skew estimation.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodTimingSkewEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodTimingSkewEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodTimingSkewEstimationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodTimingSkewEstimationEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to estimate timing skew.
        ///    When you set the NIWLANA_OFDM_DEMOD_IQ_MISMATCH_SIGNAL_MODEL attribute to NIWLANA_VAL_OFDM_IQ_MISMATCH_SIGNAL_MODEL_RX, the    toolkit does not support timing skew estimation.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodTimingSkewEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodTimingSkewEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodTimingSkewEstimationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodTimingSkewEstimationEnabled, channelString, value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to estimate carrier frequency leakage (CFL).
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodCarrierFrequencyLeakageEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCarrierFrequencyLeakageEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodCarrierFrequencyLeakageEstimationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodCarrierFrequencyLeakageEstimationEnabled, channelString,out value);
        }


        /// <summary>
        ///Specifies whether to estimate carrier frequency leakage (CFL).
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodCarrierFrequencyLeakageEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCarrierFrequencyLeakageEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodCarrierFrequencyLeakageEstimationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodCarrierFrequencyLeakageEstimationEnabled, channelString, value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to estimate common pilot error (CPE).
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodCommonPilotErrorEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCommonPilotErrorEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodCommonPilotErrorEstimationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodCommonPilotErrorEstimationEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to estimate common pilot error (CPE).
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodCommonPilotErrorEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCommonPilotErrorEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodCommonPilotErrorEstimationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodCommonPilotErrorEstimationEnabled, channelString,value);
        }


        /* - OFDM Demod:Impairments Compensation Enabled------------------------------------------- */

        /********************************************/
        /// <summary>
        ///Specifies whether to compensate for I/Q gain imbalance.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodIQGainImbalanceCompensationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodIQGainImbalanceCompensationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodIQGainImbalanceCompensationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodIqGainImbalanceCompensationEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies whether to compensate for I/Q gain imbalance.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodIQGainImbalanceCompensationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodIQGainImbalanceCompensationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodIQGainImbalanceCompensationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodIqGainImbalanceCompensationEnabled, channelString, value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to compensate for quadrature skew.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodQuadratureSkewCompensationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodQuadratureSkewCompensationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodQuadratureSkewCompensationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodQuadratureSkewCompensationEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies whether to compensate for quadrature skew.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodQuadratureSkewCompensationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodQuadratureSkewCompensationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodQuadratureSkewCompensationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodQuadratureSkewCompensationEnabled, channelString, value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to compensate for timing skew.
        ///    When you set the NIWLANA_OFDM_DEMOD_IQ_MISMATCH_SIGNAL_MODEL attribute to NIWLANA_VAL_OFDM_IQ_MISMATCH_SIGNAL_MODEL_RX, the    toolkit does not support timing skew compensation.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodTimingSkewCompensationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodTimingSkewCompensationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodTimingSkewCompensationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodTimingSkewCompensationEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to compensate for timing skew.
        ///    When you set the NIWLANA_OFDM_DEMOD_IQ_MISMATCH_SIGNAL_MODEL attribute to NIWLANA_VAL_OFDM_IQ_MISMATCH_SIGNAL_MODEL_RX, the    toolkit does not support timing skew compensation.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodTimingSkewCompensationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodTimingSkewCompensationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodTimingSkewCompensationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodTimingSkewCompensationEnabled, channelString,value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to enable demodulation of the signal that is formed by combining signals from multiple transmitter chains.
        ///    This attribute can be set to NIWLANA_VAL_TRUE only if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM    or NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodCombinedSignalDemodulationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCombinedSignalDemodulationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodCombinedSignalDemodulationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodCombinedSignalDemodulationEnabled, out value);
        }

        /// <summary>
        ///Specifies whether to enable demodulation of the signal that is formed by combining signals from multiple transmitter chains.
        ///    This attribute can be set to NIWLANA_VAL_TRUE only if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM    or NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodCombinedSignalDemodulationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCombinedSignalDemodulationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodCombinedSignalDemodulationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodCombinedSignalDemodulationEnabled, value);
        }


        /********************************************/
        /// <summary>
        ///Specifies the signal model to use for estimation and correction of the I/Q mismatch    components - I/Q gain imbalance, quadrature skew, and timing skew.
        ///    The default value is NIWLANA_VAL_OFDM_IQ_MISMATCH_SIGNAL_MODEL_TX.
        ///    Get Function: niWLANA_GetOFDMDemodIQMismatchSignalModel
        ///    Set Function: niWLANA_SetOFDMDemodIQMismatchSignalModel
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodIQMismatchSignalModel(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodIqMismatchSignalModel, channelString,out value);
        }

        /// <summary>
        ///Specifies the signal model to use for estimation and correction of the I/Q mismatch    components - I/Q gain imbalance, quadrature skew, and timing skew.
        ///    The default value is NIWLANA_VAL_OFDM_IQ_MISMATCH_SIGNAL_MODEL_TX.
        ///    Get Function: niWLANA_GetOFDMDemodIQMismatchSignalModel
        ///    Set Function: niWLANA_SetOFDMDemodIQMismatchSignalModel
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodIQMismatchSignalModel(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodIqMismatchSignalModel, channelString,value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to detect the start of a burst for signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodBurstStartDetectionEnabled
        ///    Set Function: niWLANA_SetOFDMDemodBurstStartDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodBurstStartDetectionEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodBurstStartDetectionEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies whether to detect the start of a burst for signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodBurstStartDetectionEnabled
        ///    Set Function: niWLANA_SetOFDMDemodBurstStartDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodBurstStartDetectionEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodBurstStartDetectionEnabled, channelString, value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to enable the preamble frequency error trace for signals containing an    OFDM payload. Preamble frequency error computes the variations, across time, of frequency error over the short training field    (STF) and long training field (LTF) symbols.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodPreambleFrequencyErrorTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodPreambleFrequencyErrorTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodPreambleFrequencyErrorTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodPreambleFrequencyErrorTraceEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to enable the preamble frequency error trace for signals containing an    OFDM payload. Preamble frequency error computes the variations, across time, of frequency error over the short training field    (STF) and long training field (LTF) symbols.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodPreambleFrequencyErrorTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodPreambleFrequencyErrorTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodPreambleFrequencyErrorTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodPreambleFrequencyErrorTraceEnabled, channelString,value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to enable the common pilot error trace for signals containing    an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodCommonPilotErrorTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCommonPilotErrorTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodCommonPilotErrorTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodCommonPilotErrorTraceEnabled, channelString, out  value);
        }


        /// <summary>
        ///Specifies whether to enable the common pilot error trace for signals containing    an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodCommonPilotErrorTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCommonPilotErrorTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodCommonPilotErrorTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodCommonPilotErrorTraceEnabled, channelString, value);
        }


        /********************************************/
        /// <summary>
        ///Specifies whether to enable the phase noise PSD trace for signals containing an OFDM payload.    For computation of this trace, the number of available OFDM symbols must be greater than 2.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodPhaseNoisePSDTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodPhaseNoisePSDTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodPhaseNoisePSDTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodPhaseNoisePsdTraceEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to enable the phase noise PSD trace for signals containing an OFDM payload.    For computation of this trace, the number of available OFDM symbols must be greater than 2.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodPhaseNoisePSDTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodPhaseNoisePSDTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodPhaseNoisePSDTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodPhaseNoisePsdTraceEnabled, channelString, value);
        }



        /********************************************/
        /// <summary>
        ///Specifies the averaging type for gated spectrum measurements.
        ///    The default value is NIWLANA_VAL_GATED_SPECTRUM_AVERAGING_TYPE_RMS.
        ///     Note: Set this attribute to NIWLANA_VAL_GATED_SPECTRUM_AVERAGING_TYPE_PEAK_HOLD only when you set    the NIWLANA_ETSI_IBE_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetGatedSpectrumAveragingType
        ///    Set Function: niWLANA_SetGatedSpectrumAveragingType
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetGatedSpectrumAveragingType(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.GatedSpectrumAveragingType, channelString,out value);
        }

        /// <summary>
        ///Specifies the averaging type for gated spectrum measurements.
        ///    The default value is NIWLANA_VAL_GATED_SPECTRUM_AVERAGING_TYPE_RMS.
        ///     Note: Set this attribute to NIWLANA_VAL_GATED_SPECTRUM_AVERAGING_TYPE_PEAK_HOLD only when you set    the NIWLANA_ETSI_IBE_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetGatedSpectrumAveragingType
        ///    Set Function: niWLANA_SetGatedSpectrumAveragingType
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetGatedSpectrumAveragingType(string channelString, int value)
        {
            return SetInt(niWLANAProperties.GatedSpectrumAveragingType, channelString, value);
        }


        /********************************************/
        /// <summary>
        ///Specifies the number of frequency segments for 802.11ac and 802.11ax signals.
        ///    The default value is 1. For 80+80 MHz signals, set this attribute to 2    and set the NIWLANA_CHANNEL_BANDWIDTH    attribute to 80 MHz.
        ///    Get Function: niWLANA_GetNumberOfSegments
        ///    Set Function: niWLANA_SetNumberOfSegments
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNumberOfSegments(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.NumberOfSegments, channelString,out value);
        }

        /// <summary>
        ///Specifies the number of frequency segments for 802.11ac and 802.11ax signals.
        ///    The default value is 1. For 80+80 MHz signals, set this attribute to 2    and set the NIWLANA_CHANNEL_BANDWIDTH    attribute to 80 MHz.
        ///    Get Function: niWLANA_GetNumberOfSegments
        ///    Set Function: niWLANA_SetNumberOfSegments
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNumberOfSegments(string channelString, int value)
        {
            return SetInt(niWLANAProperties.NumberOfSegments, channelString,value);
        }


        /********************************************/
        /// <summary>
        ///Specifies the value of the Length field of the L-SIG field.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetOFDMLSIGPayloadLength
        ///    Set Function: niWLANA_SetOFDMLSIGPayloadLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMLSIGPayloadLength(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmLSigPayloadLength, channelString,out value);
        }

        /// <summary>
        ///Specifies the value of the Length field of the L-SIG field.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetOFDMLSIGPayloadLength
        ///    Set Function: niWLANA_SetOFDMLSIGPayloadLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMLSIGPayloadLength(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmLSigPayloadLength, channelString, value);
        }

        /********************************************/
        /// <summary>
        ///Specifies whether space-time block coding (STBC) was performed at the transmitter for    incoming 802.11ac, 802.11af signals, or 802.11ax signals. Whenever STBC is    performed, the number    of space-time streams is equal to two times the number of spatial streams.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSTBCAllStreamsEnabled
        ///    Set Function: niWLANA_SetSTBCAllStreamsEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSTBCAllStreamsEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.StbcAllStreamsEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether space-time block coding (STBC) was performed at the transmitter for    incoming 802.11ac, 802.11af signals, or 802.11ax signals. Whenever STBC is    performed, the number    of space-time streams is equal to two times the number of spatial streams.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSTBCAllStreamsEnabled
        ///    Set Function: niWLANA_SetSTBCAllStreamsEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSTBCAllStreamsEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.StbcAllStreamsEnabled, channelString, value);
        }

        /********************************************/
        /// <summary>
        ///Specifies the number of space time streams if you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. This attribute    is ignored if the NIWLANA_STANDARD attribute is set    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute is set to NIWLANA_VAL_FALSE.
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must    use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use an empty string as the active    channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use userx as    the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you must use an empty string as the active    channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use userx as    the active channel string format to set this attribute. 
        ///    The default value is 1. If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, the    valid values are 1 to 4, inclusive. If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, the valid values are 1 to 8, inclusive. If    you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, the    valid values are 1 to 4, inclusive. If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, the valid value is 1 to 2,    inclusive. If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, the valid values are 1 to 4, inclusive.
        ///    Get Function: niWLANA_GetNumberOfSpaceTimeStreams
        ///    Set Function: niWLANA_SetNumberOfSpaceTimeStreams
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNumberOfSpaceTimeStreams(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.NumberOfSpaceTimeStreams, channelString,out value);
        }


        /// <summary>
        ///Specifies the number of space time streams if you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. This attribute    is ignored if the NIWLANA_STANDARD attribute is set    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute is set to NIWLANA_VAL_FALSE.
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must    use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use an empty string as the active    channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use userx as    the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you must use an empty string as the active    channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use userx as    the active channel string format to set this attribute. 
        ///    The default value is 1. If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, the    valid values are 1 to 4, inclusive. If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, the valid values are 1 to 8, inclusive. If    you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, the    valid values are 1 to 4, inclusive. If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, the valid value is 1 to 2,    inclusive. If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, the valid values are 1 to 4, inclusive.
        ///    Get Function: niWLANA_GetNumberOfSpaceTimeStreams
        ///    Set Function: niWLANA_SetNumberOfSpaceTimeStreams
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNumberOfSpaceTimeStreams(string channelString, int value)
        {
            return SetInt(niWLANAProperties.NumberOfSpaceTimeStreams, channelString,value);
        }

        /********************************************/
        /// <summary>
        ///Specifies the Short GI NSYM Disambiguation bit of the VHT-SIG-A2 or TVHT-SIG-A2 header.
        ///    The toolkit uses this attribute to calculate the number of OFDM symbols if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute    to NIWLANA_VAL_FALSE.
        ///    The default value is 0. Valid values are 0 and 1.
        ///    Get Function: niWLANA_GetShortGuardIntervalB1Bit
        ///    Set Function: niWLANA_SetShortGuardIntervalB1Bit
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetShortGuardIntervalB1Bit(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ShortGuardIntervalB1Bit, channelString,out value);
        }

        /// <summary>
        ///Specifies the Short GI NSYM Disambiguation bit of the VHT-SIG-A2 or TVHT-SIG-A2 header.
        ///    The toolkit uses this attribute to calculate the number of OFDM symbols if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute    to NIWLANA_VAL_FALSE.
        ///    The default value is 0. Valid values are 0 and 1.
        ///    Get Function: niWLANA_GetShortGuardIntervalB1Bit
        ///    Set Function: niWLANA_SetShortGuardIntervalB1Bit
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetShortGuardIntervalB1Bit(string channelString, int value)
        {
            return SetInt(niWLANAProperties.ShortGuardIntervalB1Bit, channelString,value);
        }

        /********************************************/
        /// <summary>
        ///Specifies the Aggregation bit of the high-throughput signal (HT-SIG) field.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetAggregationBit
        ///    Set Function: niWLANA_SetAggregationBit
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAggregationBit(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AggregationBit, channelString, out value);
        }

        /// <summary>
        ///Specifies the Aggregation bit of the high-throughput signal (HT-SIG) field.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetAggregationBit
        ///    Set Function: niWLANA_SetAggregationBit
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetAggregationBit(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AggregationBit, channelString, value);
        }

        /********************************************/
        /// <summary>
        ///Specifies whether to swap the data in the I and Q streams.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSwapIAndQEnabled
        ///    Set Function: niWLANA_SetSwapIAndQEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSwapIAndQEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.SwapIAndQEnabled, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to swap the data in the I and Q streams.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSwapIAndQEnabled
        ///    Set Function: niWLANA_SetSwapIAndQEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSwapIAndQEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.SwapIAndQEnabled, channelString, value);
        }

        /********************************************/
        /// <summary>
        ///Specifies the factor by which the Sample clock rate was multiplied at the transmitter to generate a    signal, which is compressed in the frequency domain and expanded in the time domain.
        ///    For example, a 40 MHz 802.11n signal can be compressed in the frequency domain to 20 MHz, if    the Sample clock rate is reduced to half at the transmitter. In this case, you must set this attribute to 0.5 to demodulate the signal.
        ///    The default value is 1. Valid values are 0.001 and 1, inclusive.
        ///    Get Function: niWLANA_GetSampleClockRateFactor
        ///    Set Function: niWLANA_SetSampleClockRateFactor
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSampleClockRateFactor(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.SampleClockRateFactor, channelString,out value);
        }

        /// <summary>
        ///Specifies the factor by which the Sample clock rate was multiplied at the transmitter to generate a    signal, which is compressed in the frequency domain and expanded in the time domain.
        ///    For example, a 40 MHz 802.11n signal can be compressed in the frequency domain to 20 MHz, if    the Sample clock rate is reduced to half at the transmitter. In this case, you must set this attribute to 0.5 to demodulate the signal.
        ///    The default value is 1. Valid values are 0.001 and 1, inclusive.
        ///    Get Function: niWLANA_GetSampleClockRateFactor
        ///    Set Function: niWLANA_SetSampleClockRateFactor
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSampleClockRateFactor(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.SampleClockRateFactor, channelString, value);
        }

        /********************************************/
        /// <summary>
        ///Returns the value of the Length field as decoded from the L-SIG field. If you set    the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the value    you specify in the NIWLANA_RESULT_OFDM_DEMOD_L_SIG_PAYLOAD_LENGTH attribute specifies the L-SIG payload length.
        ///    Get Function: niWLANA_GetOFDMDemodLSIGPayloadLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodLSIGPayloadLength(string channelString, out  int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodLSigPayloadLength, channelString,out value);
        }

        /********************************************/
        /// <summary>
        ///Returns the value of the space-time block coding (STBC) field, as decoded    from the VHT-SIG-A field of 802.11ac signal, the S1G-SIG/SIG-A field of 802.11ah signal, TVHT-SIG-A field of 802.11af signals    and HE-SIG-A field of 802.11ax signals. If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED    attribute to NIWLANA_VAL_FALSE, the value you specify in the NIWLANA_RESULT_OFDM_DEMOD_STBC_ALL_STREAMS_ENABLED    attribute specifies whether to perform STBC.
        ///    Get Function: niWLANA_GetOFDMDemodSTBCAllStreamsEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodSTBCAllStreamsEnabled(string channelString, out  int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodStbcAllStreamsEnabled, channelString, out value);
        }


        /********************************************/

        /// <summary>
        ///Returns the number of space-time streams for an 802.11ac, 802.11ah or an 802.11ax signal. When you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, this value is derived from    the MCS Index value decoded from the HT-SIG field. When you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, for a packet of SU PPDU format, this    value is derived by adding 1 to the value of SU NSTS field, as decoded from    the VHT-SIG-A field and for a packet with MU PPDU format, the value of number of    space-time streams is decoded for each user from the respective MU NSTS    field (MU[0] NSTS, MU[1] NSTS, MU[2] NSTS or MU[3] NSTS) within the VHT-SIG-A field. When you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, this value is decoded from S1G-SIG/SIG-A field. When you    set theNIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, this value is decoded from TVHT-SIG-A field. 
        ///    When you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, for a packet    of SU PPDU format or Extended Range SU PPDU format, this    value is derived from NSTS field, as decoded from the HE-SIG-A field and for a packet    with MU PPDU format, this value is decoded for each    user from the HE-SIG-B field. 
        ///    If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the    value you specify in the NIWLANA_RESULT_OFDM_DEMOD_NUMBER_OF_SPACE_TIME_STREAMS attribute    specifies the number of space-time streams.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM you must use an    empty string to query this attribute. 
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active channel string syntax to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///     Get Function: niWLANA_GetOFDMDemodNumberOfSpaceTimeStreams
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodNumberOfSpaceTimeStreams(string channelString, out  int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodNumberOfSpaceTimeStreams, channelString, out value);
        }

        /********************************************/
        /// <summary>
        ///Indicates whether the cyclic redundancy check (CRC) has passed for the VHT-SIG-A field.
        ///    Get Function: niWLANA_GetOFDMDemodVHTSIGACRCPassed
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodVHTSIGACRCPassed(string channelString, out  int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodVhtSigACrcPassed, channelString, out value);
        }

        /********************************************/
        /// <summary>
        ///Indicates whether the cyclic redundancy check (CRC) has passed for the VHT-SIG-B field.
        ///    Get Function: niWLANA_GetOFDMDemodVHTSIGBCRCPassed
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodVHTSIGBCRCPassed(string channelString, out  int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodVhtSigBCrcPassed, channelString, out value);
        }

        /********************************************/
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodTimingSkew(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodTimingSkew, channelString, out value);
        }


        /********************************************/
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodRmsPhaseError(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemodRmsPhaseError, channelString, out value);
        }

        /********************************************/
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodCommonPilotErrorRMS(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommonPilotErrorRms, channelString, out value);
        }

        /********************************************/
        /// <summary>
        ///Returns the index of the subcarrier for which the minimum spectral flatness margin was observed across iterations.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211BG_DSSS,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use 'streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]streamy' as the active channel string format to    query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetOFDMDemodSpectralFlatnessMarginSubcarrierIndex
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodSpectralFlatnessMarginSubcarrierIndex(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodSpectralFlatnessMarginSubcarrierIndex, channelString, out value);
        }

        /********************************************/
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodNumberOfOFDMSymbols(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodNumberOfOfdmSymbols, channelString, out value);
        }

        /// <summary>
        ///Returns the number of OFDM symbols used for EVM calculation.
        ///    Get Function: niWLANA_GetOFDMDemodNumberOfSymbolsUsed
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodNumberOfSymbolsUsed(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodNumberOfSymbolsUsed, channelString, out value);
        }

        /********************************************/
        /// <summary>
        ///Returns the value of the Aggregation field as decoded from the high-throughput signal (HT-SIG) field    of the 802.11n signal and the S1G-SIG/SIG-A field of 802.11ah signal. If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to    NIWLANA_VAL_FALSE, the value you specify in the NIWLANA_RESULT_OFDM_DEMOD_AGGREGATION attribute    specifies the aggregation bit of the high-throughput signal (HT-SIG) field.
        ///    Get Function: niWLANA_GetOFDMDemodAggregation
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodAggregation(string channelString, out  int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodAggregation, channelString, out value);
        }

        /********************************************/
        /// <summary>
        ///Returns the value of the Short GI NSYM Disambiguation field as decoded from the VHT-SIG-A field.
        ///       If you set    the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the value you    specify in the NIWLANA_RESULT_OFDM_DEMOD_SHORT_GUARD_INTERVAL_B1_BIT attribute specifies    the Short GI NSYM Disambiguation bit of the VHT-SIG-A2 header.
        ///    Get Function: niWLANA_GetOFDMDemodShortGuardIntervalB1Bit
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodShortGuardIntervalB1Bit(string channelString, out  int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodShortGuardIntervalB1Bit, channelString, out value);
        }


        #endregion

        #region Missing Properties Added
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMaskCenterFrequency(string channel, double value)
        {
            return SetDouble(niWLANAProperties.SpectralMaskCenterFrequency, channel, value);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMaskCenterFrequency(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.SpectralMaskCenterFrequency, channel, out value);
        }


        /// <summary>
        ///Specifies whether to combine the spectrums of two 80 MHz 802.11ac or 802.11ax segments into a single transmit spectral mask measurement.
        ///    Set this attribute to NIWLANA_VAL_TRUE only if you set the NIWLANA_NUMBER_OF_SEGMENTS attribute to 2.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSpectralMaskCombinedMaskEnabled
        ///    Set Function: niWLANA_SetSpectralMaskCombinedMaskEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMaskCombinedMaskEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.SpectralMaskCombinedMaskEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to combine the spectrums of two 80 MHz 802.11ac or 802.11ax segments into a single transmit spectral mask measurement.
        ///    Set this attribute to NIWLANA_VAL_TRUE only if you set the NIWLANA_NUMBER_OF_SEGMENTS attribute to 2.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSpectralMaskCombinedMaskEnabled
        ///    Set Function: niWLANA_SetSpectralMaskCombinedMaskEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMaskCombinedMaskEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMaskCombinedMaskEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the mode for transmit power computation.
        ///    The default value is NIWLANA_VAL_TXPOWER_MEASUREMENTS_MODE_FIRST_PACKET.
        ///    Get Function: niWLANA_GetTxPowerMeasurementMode
        ///    Set Function: niWLANA_SetTxPowerMeasurementMode
        ///
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetTxpowerMeasurementsMode(string channel, int value)
        {
            return SetInt(niWLANAProperties.TxpowerMeasurementsMode, channel, value);
        }


        /// <summary>
        ///Specifies the mode for transmit power computation.
        ///    The default value is NIWLANA_VAL_TXPOWER_MEASUREMENTS_MODE_FIRST_PACKET.
        ///    Get Function: niWLANA_GetTxPowerMeasurementMode
        ///    Set Function: niWLANA_SetTxPowerMeasurementMode
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetTxpowerMeasurementsMode(string channel, out int value)
        {
            return GetInt(niWLANAProperties.TxpowerMeasurementsMode, channel, out value);
        }


        /// <summary>
        ///Returns the maximum peak power of the acquired bursts. This value is expressed in dBm. Peak power is measured for one burst.    Maximum Peak power is the maximum of peak power values across iterations.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpPeakPowerMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpPeakPowerMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of average power of the acquired burst. This value is expressed in dBm. 
        ///    You can use this measurement to verify that the device under test (DUT) conforms to section 17.3.9.1 of IEEE Standard 802.11a-1999,    section 18.4.7.1 of IEEE Standard 802.11b-1999, or section 20.3.21.3 of IEEE Standard 802.11n-2009, all of which specify maximum    output power in certain cases. This value is expressed in mW. 
        ///    Use the following equation to convert from dBm to mW: 1 mW=10^(1 dBm/10)
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpAveragePowerAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpAveragePowerAverage, channel, out value);
        }

        /// <summary>
        ///Returns the mean square residual error, in dB, of the curve obtained by doing a polynomial fit on measured AM-AM distortion values of the acquired waveform
        ///
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetResultAmpmMeasurementsAmamResidual(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAmpmMeasurementsAmamResidual, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable the reference constellation trace for signals containing an OFDM payload.    The reference constellation corresponds to ideal QAM symbols obtained after performing hard-decision on    received symbols.
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodReferenceConstellationTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodReferenceConstellationTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodReferenceConstellationTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodReferenceConstellationTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable the reference constellation trace for signals containing an OFDM payload.    The reference constellation corresponds to ideal QAM symbols obtained after performing hard-decision on    received symbols.
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodReferenceConstellationTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodReferenceConstellationTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodReferenceConstellationTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodReferenceConstellationTraceEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable the group delay trace for signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodGroupDelayTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodGroupDelayTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodGroupDelayTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodGroupDelayTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable the group delay trace for signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodGroupDelayTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodGroupDelayTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodGroupDelayTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodGroupDelayTraceEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the mode of display of the channel frequency response trace for signals containing an    OFDM payload.
        ///    The default value is NIWLANA_VAL_OFDM_DEMOD_CFR_TRACE_MODE_WITH_LINEAR_PHASE.
        ///    Get Function: niWLANA_GetOFDMDemodChannelFrequencyResponseTraceMode
        ///    Set Function: niWLANA_SetOFDMDemodChannelFrequencyResponseTraceMode
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodChannelFrequencyResponseTraceMode(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodChannelFrequencyResponseTraceMode, channel, value);
        }

        /// <summary>
        ///Specifies the mode of display of the channel frequency response trace for signals containing an    OFDM payload.
        ///    The default value is NIWLANA_VAL_OFDM_DEMOD_CFR_TRACE_MODE_WITH_LINEAR_PHASE.
        ///    Get Function: niWLANA_GetOFDMDemodChannelFrequencyResponseTraceMode
        ///    Set Function: niWLANA_SetOFDMDemodChannelFrequencyResponseTraceMode
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodChannelFrequencyResponseTraceMode(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodChannelFrequencyResponseTraceMode, channel, out value);
        }


        /// <summary>
        ///Specifies the mode of display of the group delay trace for signals containing an OFDM payload.
        ///    The default value is NIWLANA_OFDM_DEMOD_GROUP_DELAY_TRACE_MODE_WITH_AVERAGE_GROUP_DELAY.
        ///    Get Function: niWLANA_GetOFDMDemodGroupDelayTraceMode
        ///    Set Function: niWLANA_SetOFDMDemodGroupDelayTraceMode
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodGroupDelayTraceMode(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodGroupDelayTraceMode, channel, value);
        }

        /// <summary>
        ///Specifies the mode of display of the group delay trace for signals containing an OFDM payload.
        ///    The default value is NIWLANA_OFDM_DEMOD_GROUP_DELAY_TRACE_MODE_WITH_AVERAGE_GROUP_DELAY.
        ///    Get Function: niWLANA_GetOFDMDemodGroupDelayTraceMode
        ///    Set Function: niWLANA_SetOFDMDemodGroupDelayTraceMode
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodGroupDelayTraceMode(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodGroupDelayTraceMode, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable the EVM per subcarrier per symbol trace for signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodEVMPerSubcarrierPerSymbolTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodEVMPerSubcarrierPerSymbolTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodEvmPerSubcarrierPerSymbolTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodEvmPerSubcarrierPerSymbolTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable the EVM per subcarrier per symbol trace for signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodEVMPerSubcarrierPerSymbolTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodEVMPerSubcarrierPerSymbolTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodEvmPerSubcarrierPerSymbolTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodEvmPerSubcarrierPerSymbolTraceEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable power measurement over a user-defined gate. The start and stop time of the user-defined gate can be specified by    configuring the NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_START_TIME and NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_STOP_TIME attributes respectively.
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodUserDefinedGatePowerEnabled
        ///    Set Function: niWLANA_SetOFDMDemodUserDefinedGatePowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodUserDefinedGatePowerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodUserDefinedGatePowerEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable power measurement over a user-defined gate. The start and stop time of the user-defined gate can be specified by    configuring the NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_START_TIME and NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_STOP_TIME attributes respectively.
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodUserDefinedGatePowerEnabled
        ///    Set Function: niWLANA_SetOFDMDemodUserDefinedGatePowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodUserDefinedGatePowerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodUserDefinedGatePowerEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the start time of the user-defined gate. This value is expressed in seconds. A value of 0    indicates that the start time is the start of the payload.
        ///    A negative value indicates a position in the preamble or header. 
        ///    Refer to the Gated Power Measurement topic for more information about computing gated power.
        ///    The default value is 0.
        ///    Get Function: niWLANA_SetOFDMDemodUserDefinedGateStartTime
        ///    Set Function: niWLANA_GetOFDMDemodUserDefinedGateStartTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodUserDefinedGateStartTime(string channel, double value)
        {
            return SetDouble(niWLANAProperties.OfdmDemodUserDefinedGateStartTime, channel, value);
        }

        /// <summary>
        ///Specifies the start time of the user-defined gate. This value is expressed in seconds. A value of 0    indicates that the start time is the start of the payload.
        ///    A negative value indicates a position in the preamble or header. 
        ///    Refer to the Gated Power Measurement topic for more information about computing gated power.
        ///    The default value is 0.
        ///    Get Function: niWLANA_SetOFDMDemodUserDefinedGateStartTime
        ///    Set Function: niWLANA_GetOFDMDemodUserDefinedGateStartTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodUserDefinedGateStartTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemodUserDefinedGateStartTime, channel, out value);
        }


        /// <summary>
        ///Specifies the end time of the user-defined gate. This value is expressed in seconds. A value of 0    indicates that the stop time is the start of the payload.
        ///    A negative value indicates a position in the preamble or header.    Refer to the Gated Power Measurement topic for more information about computing gated power.
        ///    The default value is 6.4 &#181;s.
        ///    Get Function: niWLANA_SetOFDMDemodUserDefinedGateStopTime
        ///    Set Function: niWLANA_GetOFDMDemodUserDefinedGateStopTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodUserDefinedGateStopTime(string channel, double value)
        {
            return SetDouble(niWLANAProperties.OfdmDemodUserDefinedGateStopTime, channel, value);
        }

        /// <summary>
        ///Specifies the end time of the user-defined gate. This value is expressed in seconds. A value of 0    indicates that the stop time is the start of the payload.
        ///    A negative value indicates a position in the preamble or header.    Refer to the Gated Power Measurement topic for more information about computing gated power.
        ///    The default value is 6.4 &#181;s.
        ///    Get Function: niWLANA_SetOFDMDemodUserDefinedGateStopTime
        ///    Set Function: niWLANA_GetOFDMDemodUserDefinedGateStopTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodUserDefinedGateStopTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemodUserDefinedGateStopTime, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable total packet power measurement.
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodGatedPowerTotalPacketPowerEnabled
        ///    Set Function: niWLANA_SetOFDMDemodGatedPowerTotalPacketPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodGatedPowerTotalPacketPowerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodGatedPowerTotalPacketPowerEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable total packet power measurement.
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodGatedPowerTotalPacketPowerEnabled
        ///    Set Function: niWLANA_SetOFDMDemodGatedPowerTotalPacketPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodGatedPowerTotalPacketPowerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodGatedPowerTotalPacketPowerEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable preamble and header power measurements.
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodGatedPowerPreambleAndHeaderPowerEnabled
        ///    Set Function: niWLANA_SetOFDMDemodGatedPowerPreambleAndHeaderPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodGatedPowerPreambleAndHeaderPowerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodGatedPowerPreambleAndHeaderPowerEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable preamble and header power measurements.
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodGatedPowerPreambleAndHeaderPowerEnabled
        ///    Set Function: niWLANA_SetOFDMDemodGatedPowerPreambleAndHeaderPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodGatedPowerPreambleAndHeaderPowerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodGatedPowerPreambleAndHeaderPowerEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable data power measurements.
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodGatedPowerDataPowerEnabled
        ///    Set Function: niWLANA_SetOFDMDemodGatedPowerDataPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodGatedPowerDataPowerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodGatedPowerDataPowerEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable data power measurements.
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodGatedPowerDataPowerEnabled
        ///    Set Function: niWLANA_SetOFDMDemodGatedPowerDataPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodGatedPowerDataPowerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodGatedPowerDataPowerEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to check for the validity of the cyclic redundancy check (CRC) of VHT-SIG-B field in 802.11ac signal.    The toolkit calculates CRC over the decoded VHT-SIG-B bits and compares this value with the CRC value in the    received Service field, which is represented by the last 8 bits of the Service field.
        ///    This attribute is applicable only when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodVHTSIGBCRCCheckEnabled
        ///    Set Function: niWLANA_SetOFDMDemodVHTSIGBCRCCheckEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodVhtSigBCrcCheckEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodVhtSigBCrcCheckEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to check for the validity of the cyclic redundancy check (CRC) of VHT-SIG-B field in 802.11ac signal.    The toolkit calculates CRC over the decoded VHT-SIG-B bits and compares this value with the CRC value in the    received Service field, which is represented by the last 8 bits of the Service field.
        ///    This attribute is applicable only when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodVHTSIGBCRCCheckEnabled
        ///    Set Function: niWLANA_SetOFDMDemodVHTSIGBCRCCheckEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodVhtSigBCrcCheckEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodVhtSigBCrcCheckEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether the transmitter uses a common clock to generate carrier and sample clock frequencies for    the OFDM signals.
        ///    If you set this attribute to NIWLANA_VAL_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED_TRUE, you must    configure the NIWLANA_CARRIER_FREQUENCY attribute using the niWLANA_RFSAConfigureFrequencySingleLO    or niWLANA_RFSAConfigureFrequencyMultipleLO functions.
        ///    The default value is NIWLANA_VAL_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED_FALSE if you set    the compatibilityVersion parameter of the niWLANA_OpenSession function to a value other than NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        ///    The default value is NIWLANA_VAL_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED_TRUE, 
        ///    Get Function: niWLANA_GetOFDMDemodCommonClockSourceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCommonClockSourceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodCommonClockSourceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodCommonClockSourceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether the transmitter uses a common clock to generate carrier and sample clock frequencies for    the OFDM signals.
        ///    If you set this attribute to NIWLANA_VAL_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED_TRUE, you must    configure the NIWLANA_CARRIER_FREQUENCY attribute using the niWLANA_RFSAConfigureFrequencySingleLO    or niWLANA_RFSAConfigureFrequencyMultipleLO functions.
        ///    The default value is NIWLANA_VAL_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED_FALSE if you set    the compatibilityVersion parameter of the niWLANA_OpenSession function to a value other than NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        ///    The default value is NIWLANA_VAL_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED_TRUE, 
        ///    Get Function: niWLANA_GetOFDMDemodCommonClockSourceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCommonClockSourceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodCommonClockSourceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodCommonClockSourceEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to apply a low-pass filter before initial frequency and time synchronization.
        ///    To enable this attribute, you must set the NIWLANA_CHANNEL_BANDWIDTH attribute to 80 MHz.
        ///    Note: You can use this attribute to eliminate any strong components that are outside the signal bandwidth but are very close to the signal of    interest. You can also use this attribute to analyze a 160 MHz 802.11ac or 802.11ax signal as a signal containing    two segments, each with 80 MHz bandwidth.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemod80Plus80FilterBeforeSyncEnabled
        ///    Set Function: niWLANA_SetOFDMDemod80Plus80FilterBeforeSyncEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemod80Plus80FilterBeforeSyncEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemod80Plus80FilterBeforeSyncEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to apply a low-pass filter before initial frequency and time synchronization.
        ///    To enable this attribute, you must set the NIWLANA_CHANNEL_BANDWIDTH attribute to 80 MHz.
        ///    Note: You can use this attribute to eliminate any strong components that are outside the signal bandwidth but are very close to the signal of    interest. You can also use this attribute to analyze a 160 MHz 802.11ac or 802.11ax signal as a signal containing    two segments, each with 80 MHz bandwidth.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemod80Plus80FilterBeforeSyncEnabled
        ///    Set Function: niWLANA_SetOFDMDemod80Plus80FilterBeforeSyncEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemod80Plus80FilterBeforeSyncEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemod80Plus80FilterBeforeSyncEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the oversampling factor to be used to analyze an 80 MHz 802.11ac or 802.11ax signals.    The oversampling factor determines the size of IFFT that is used to convert time-domain    samples of each OFDM symbol    to corresponding frequency-domain values.
        ///    If you set this attribute to a value greater than or equal to 1, the toolkit resamples the acquired signal to a value equal    to the specified channel bandwidth (80 MHz) times the oversampling factor. You must set this attribute to -1 to use the same sample rate    of the acquired waveform. You can set this attribute to a value other than 1 only if you set the channel bandwidth to 80 MHz.
        ///    Note: You must set this attribute to -1 or a value greater than 1 to avoid aliasing effects while analyzing a 160 MHz 802.11ac or 802.11ax signal as a    signal with two segments, each having a bandwidth of 80 MHz.
        ///    The default value is 1. Valid values are -1 and 1 to 10, inclusive.
        ///    Get Function: niWLANA_GetOFDMDemod80Plus80OversamplingFactor
        ///    Set Function: niWLANA_SetOFDMDemod80Plus80OversamplingFactor
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemod80Plus80OversamplingFactor(string channel, double value)
        {
            return SetDouble(niWLANAProperties.OfdmDemod80Plus80OversamplingFactor, channel, value);
        }

        /// <summary>
        ///Specifies the oversampling factor to be used to analyze an 80 MHz 802.11ac or 802.11ax signals.    The oversampling factor determines the size of IFFT that is used to convert time-domain    samples of each OFDM symbol    to corresponding frequency-domain values.
        ///    If you set this attribute to a value greater than or equal to 1, the toolkit resamples the acquired signal to a value equal    to the specified channel bandwidth (80 MHz) times the oversampling factor. You must set this attribute to -1 to use the same sample rate    of the acquired waveform. You can set this attribute to a value other than 1 only if you set the channel bandwidth to 80 MHz.
        ///    Note: You must set this attribute to -1 or a value greater than 1 to avoid aliasing effects while analyzing a 160 MHz 802.11ac or 802.11ax signal as a    signal with two segments, each having a bandwidth of 80 MHz.
        ///    The default value is 1. Valid values are -1 and 1 to 10, inclusive.
        ///    Get Function: niWLANA_GetOFDMDemod80Plus80OversamplingFactor
        ///    Set Function: niWLANA_SetOFDMDemod80Plus80OversamplingFactor
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemod80Plus80OversamplingFactor(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemod80Plus80OversamplingFactor, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of RMS EVM measurements. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999, section 20.3.21.7.4 of    IEEE Standard 802.11n-2009, section 24.3.16.4.4 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM    or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodRmsEvmAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodRmsEvmAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of RMS EVM measurements. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999, section 20.3.21.7.4    of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.4 of IEEE P802.11ah/D1.3, and    section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodRmsEvmMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodRmsEvmMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of RMS EVM measurements. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999, section    20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.4 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2..    The method of computation is discussed in    section 17.3.9.7 of IEEE Standard 802.11a-1999 section 20.3.21.7.4 of IEEE Standard 802.11n-2009,    section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodRmsEvmMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodRmsEvmMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of RMS EVM measurements. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999, section 20.3.21.7.4 of IEEE Standard 802.11n-2009,    section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed in    section 17.3.9.7 of IEEE Standard 802.11a-1999, section 20.3.21.7.4 of IEEE Standard 802.11n-2009,    section 24.3.16.4.4 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodRmsEvmStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodRmsEvmStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of RMS EVM measurements of data subcarriers. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and    section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodDataRmsEvmAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodDataRmsEvmAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of RMS EVM measurements of data subcarriers. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed    in section 17.3.9.7 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3,and section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodDataRmsEvmMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodDataRmsEvmMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of RMS EVM measurements of data subcarriers. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and    section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodDataRmsEvmMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodDataRmsEvmMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of RMS EVM measurements of data subcarriers. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999 section 20.3.21.7.4 of IEEE Standard 802.11n-2009,    section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and    section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodDataRmsEvmStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodDataRmsEvmStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of RMS EVM measurements of pilot subcarriers. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999, section 20.3.21.7.4 of IEEE Standard 802.11n-2009,    section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and    section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodPilotRmsEvmAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodPilotRmsEvmAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of RMS EVM measurements of pilot subcarriers. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999, section 20.3.21.7.4 of IEEE Standard 802.11n-2009,    section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and    section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodPilotRmsEvmMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodPilotRmsEvmMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of RMS EVM measurements of pilot subcarriers. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999 and section 20.3.21.7.4 of IEEE Standard 802.11n-2009,    section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and    section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodPilotRmsEvmMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodPilotRmsEvmMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of RMS EVM measurements of pilot subcarriers. This value is expressed in dB.
        ///    Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999 and section 20.3.21.7.4 of IEEE Standard 802.11n-2009,    section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and section 28.3.18.4 of IEEE P802.11ax/D1.2.    The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999,    section 20.3.21.7.4 of IEEE Standard 802.11n-2009, section 24.3.16.4.3 of IEEE P802.11ah/D1.3, and    section 28.3.18.4 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and if the NIWLANA_RESULT_OFDM_DEMOD_HE_LTF_SIZE    is 2x, then the EVM computation is performed on the subcarriers corresponding to those which are occupied in the HE-LTF field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for channel EVM. 
        ///     'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across    segments, if the channel bandwidth is 80 MHz and the number of segments is 2. 
        ///     '[segmentx/]channely' for channel EVM per    segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the    channel bandwidth is 80 MHz and the number of segments is 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU across segments, if the channel bandwidth    is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment    of NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPD in all other cases. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use 'segment x'    to query this attribute. You must use an empty string to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM. 
        ///    'streamx' for stream EVM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE you must use the    following active channel string formats to query this attribute: 
        ///    'segmentx/channely' for channel EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'segmentx/streamy' for stream EVM. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    'channelx' for average channel EVM across segments, if the channel bandwidth is 80 MHz and    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]channely' for channel EVM per segment in all other cases. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'streamx' for average stream EVM across segments, if the channel bandwidth is 80 MHz    and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    '[segmentx/]streamy' for stream EVM per segment in all other cases.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userx/streamy' for average stream EVM per user of MU PPDU across segments, if the channel bandwidth is 80 MHz and the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    'userx/[segmenty/]streamz' for stream EVM per user per segment of MU PPDU in all other cases. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodPilotRmsEvmStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodPilotRmsEvmStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of average gated power. This value is expressed in dBm. The gated power    is the average power of the portion of the signal defined    by the interval between the NIWLANA_PFD_DEMOD_USER_DEFINED_GATE_START_TIME and    the NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_STOP_TIME attributes.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must    use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the    active channel string format to query this attribute. You must use an empty string as the active channel    string format to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, the active channel string syntax is 'channelx'. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, the active channel string syntax is    '[segmentx/]channely'. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodAverageGatedPowerAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodAverageGatedPowerAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of average gated power. This value is expressed in dBm. The gated    power is the average power of the portion of the signal defined    by the interval between the NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_START_TIME and    the NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_STOP_TIME attributes.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must    use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the    active channel string format to query this attribute. You must use an empty string as the active channel    string format to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, the active channel string syntax is 'channelx'. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, the active channel string syntax is    '[segmentx/]channely'. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodAverageGatedPowerMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodAverageGatedPowerMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of average gated power. This value is expressed in dBm. The gated power is    the average power of the portion of the signal defined    by the interval between the NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_START_TIME and    the NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_STOP_TIME attributes.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must    use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the    active channel string format to query this attribute. You must use an empty string as the active channel    string format to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, the active channel string syntax is 'channelx'. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, the active channel string syntax is    '[segmentx/]channely'. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodAverageGatedPowerMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodAverageGatedPowerMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of average gated power. This value is expressed in dBm. The gated power    is the average power of the portion of the signal defined    by the interval between the NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_START_TIME and    the NIWLANA_OFDM_DEMOD_USER_DEFINED_GATE_STOP_TIME attributes.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must    use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the    active channel string format to query this attribute. You must use an empty string as the active channel    string format to query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, the active channel string syntax is 'channelx'. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, the active channel string syntax is    '[segmentx/]channely'. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodAverageGatedPowerStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodAverageGatedPowerStandardDeviation, channel, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCrossPowerAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCrossPowerAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of cross power measurements. This value is expressed in dB.    The cross power for 'channelx' is the contribution of the power from streams other than 'streamx' in 'channelx'.    To get the individual contributions of each stream, use the format 'channelx/streamy' for the active channel, where x is not equal to y.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx' and 'channelx/streamy' as the active channel string formats to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' and '[segmentx/]channely/streamz' as the active channel    string formats to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx' and 'channelx/streamy' as the active channel    string formats to query this attribute.
        ///    Note: The result of the NIWLANA_RESULT_OFDM_DEMOD_CHANNEL_MATRIX_CROSS_POWER_AVERAGE attribute is invalid    if you set the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodChannelMatrixCrossPowerMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodChannelMatrixCrossPowerMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of cross power measurements. This value is expressed in dB.    The cross power for 'channelx' is the contribution of the power from streams other than 'streamx' in 'channelx'.    To get the individual contributions of each stream, use the format 'channelx/streamy' for the active channel, where x is not equal to y.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx' and 'channelx/streamy' as the active channel string formats to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' and '[segmentx/]channely/streamz' as the active channel    string formats to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx' and 'channelx/streamy' as the active channel    string formats to query this attribute.
        ///    Note: The result of the NIWLANA_RESULT_OFDM_DEMOD_CHANNEL_MATRIX_CROSS_POWER_AVERAGE attribute is invalid    if you set the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodChannelMatrixCrossPowerMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodChannelMatrixCrossPowerMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of cross power measurements. This value is expressed in dB.    The cross power for 'channelx' is the contribution of the power from streams other than 'streamx' in 'channelx'.    To get the individual contributions of each stream, use the format 'channelx/streamy' for the active channel, where x is not equal to y.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx' and 'channelx/streamy' as the active channel string formats to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' and '[segmentx/]channely/streamz' as the active channel    string formats to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx' and 'channelx/streamy' as the active channel    string formats to query this attribute.
        ///    Note: The result of the NIWLANA_RESULT_OFDM_DEMOD_CHANNEL_MATRIX_CROSS_POWER_AVERAGE attribute is invalid    if you set the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodChannelMatrixCrossPowerStdDev(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodChannelMatrixCrossPowerStdDev, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of spectral flatness margin. This value is expressed in dB. Spectral flatness    margin is the minimum margin of the upper and lower spectral flatness margins. 
        ///    Refer to the OFDM Spectral Flatness Margin help topic for more information about spectral flatness margin.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211BG_DSSS,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use 'streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]streamy' as the active channel string format to    query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSpectralFlatnessMarginAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodSpectralFlatnessMarginAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of spectral flatness margin. This value is expressed in dB. Spectral flatness    margin is the minimum margin of the upper and lower spectral flatness margins.  
        ///    Refer to the OFDM Spectral Flatness Margin help topic for more information about spectral flatness margin.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211BG_DSSS,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use 'streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]streamy' as the active channel string format to    query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSpectralFlatnessMarginMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodSpectralFlatnessMarginMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of spectral flatness margin. This value is expressed in dB. Spectral flatness    margin is the minimum margin of the upper and lower spectral flatness margins. 
        ///    Refer to the OFDM Spectral Flatness Margin help topic for more information about spectral flatness margin.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211BG_DSSS,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use 'streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]streamy' as the active channel string format to    query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSpectralFlatnessMarginMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodSpectralFlatnessMarginMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of spectral flatness margin. This value is expressed in dB. Spectral flatness margin    is the minimum margin of the upper and lower spectral flatness margins.
        ///    Refer to the OFDM Spectral Flatness Margin help topic for more information about spectral flatness margin.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211BG_DSSS,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use 'streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]streamy' as the active channel string format to    query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSpectralFlatnessMarginStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodSpectralFlatnessMarginStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the index of the subcarrier for which the minimum spectral flatness margin was observed across iterations.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211BG_DSSS,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use 'streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use 'channelx/streamy' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]streamy' as the active channel string format to    query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely/streamz' as the active channel string format to query    this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetOFDMDemodSpectralFlatnessMarginSubcarrierIndex
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSpectralFlatnessMarginSubcarrierIndex(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodSpectralFlatnessMarginSubcarrierIndex, channel, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodNumberOfOfdmSymbols(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodNumberOfOfdmSymbols, channel, out value);
        }


        /// <summary>
        ///Returns the value of the Aggregation field as decoded from the high-throughput signal (HT-SIG) field    of the 802.11n signal and the S1G-SIG/SIG-A field of 802.11ah signal. If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to    NIWLANA_VAL_FALSE, the value you specify in the NIWLANA_RESULT_OFDM_DEMOD_AGGREGATION attribute    specifies the aggregation bit of the high-throughput signal (HT-SIG) field.
        ///    Get Function: niWLANA_GetOFDMDemodAggregation
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodAggregation(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodAggregation, channel, out value);
        }


        /// <summary>
        ///Returns the number of OFDM symbols used for EVM calculation.
        ///    Get Function: niWLANA_GetOFDMDemodNumberOfSymbolsUsed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodNumberOfSymbolsUsed(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodNumberOfSymbolsUsed, channel, out value);
        }


        /// <summary>
        ///Returns the absolute time corresponding to the detected start of the analyzed burst. This value is expressed in seconds.    This time is computed with respect to the t0 value of the acquired waveform.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use an empty string    to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use    '[segmentx/]channely' as the active channel string format to query this    attribute. 'segment0/' is optional    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    '[segmentx]' as the active channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetOFDMDemodBurstStartTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodBurstStartTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodBurstStartTime, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of absolute power measurements in the frequency domain. This value is expressed in dBm.    Absolute power is the frequency domain power measured from estimated channel matrix.
        ///    You can query total power of each stream and each channel, power of each stream in each channel, and total power of channel matrix.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    'channelx' for total power of channelx. 
        ///    'streamx' for total power of streamx. 
        ///     'channelx/streamy' for power of streamy in channelx. 
        ///     An empty string for total power. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use the following active channel string formats to query this attribute: 
        ///    An empty string for total power. 
        ///    'streamx' for total power of streamx. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of 'channely' in 'segmentx'. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of 'streamy' in 'segmentx'. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///     '[segmentx/]channely/streamz' for power of streamz in channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx]' for total power. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use the following active channel string formats to query this attribute: 
        ///    'segmentx' for total power. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    'channelx' for total power of channelx. 
        ///    'streamx' for total power of streamx. 
        ///     'channelx/streamy' for power of streamy in channelx. 
        ///    An empty string for total power. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///     '[segmentx/]channely/streamy' for power of streamz in channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx]' for total power. An empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of channely in segmentx.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]channely/streamz' for power of streamz in channely in segmentx.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]' for total power. Empty string, if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]channely' for total power of channely in segmentx of userw in MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]streamy' for total power of streamy in segmentx of userw in MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]channely/streamz' for power of streamz in channely in segmentx of  userw    in MU PPDU signals. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]' for total power of userw in segmentx of MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodChannelMatrixAbsolutePowerAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodChannelMatrixAbsolutePowerAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of absolute power measurements in the frequency domain. This value is expressed in dBm.    Absolute power is the frequency domain power measured from estimated channel matrix.
        ///    You can query total power of each stream and each channel, power of each stream in each channel, and total power of channel matrix.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    'channelx' for total power of channelx. 
        ///    'streamx' for total power of streamx. 
        ///     'channelx/streamy' for power of streamy in channelx. 
        ///     An empty string for total power. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use the following active channel string formats to query this attribute: 
        ///    An empty string for total power. 
        ///    'streamx' for total power of streamx. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of 'channely' in 'segmentx'. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of 'streamy' in 'segmentx'. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///     '[segmentx/]channely/streamz' for power of streamz in channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx]' for total power. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use the following active channel string formats to query this attribute: 
        ///    'segmentx' for total power. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    'channelx' for total power of channelx. 
        ///    'streamx' for total power of streamx. 
        ///     'channelx/streamy' for power of streamy in channelx. 
        ///    An empty string for total power. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///     '[segmentx/]channely/streamy' for power of streamz in channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx]' for total power. An empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of channely in segmentx.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]channely/streamz' for power of streamz in channely in segmentx.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]' for total power. Empty string, if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]channely' for total power of channely in segmentx of userw in MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]streamy' for total power of streamy in segmentx of userw in MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]channely/streamz' for power of streamz in channely in segmentx of  userw    in MU PPDU signals. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]' for total power of userw in segmentx of MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodChannelMatrixAbsolutePowerMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodChannelMatrixAbsolutePowerMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of absolute power measurements in the frequency domain. This value is expressed in dBm. Absolute power is the    frequency domain power measured from estimated channel matrix.
        ///    You can query total power of each stream and each channel, power of each stream in each channel, and total power of channel matrix.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    'channelx' for total power of channelx. 
        ///    'streamx' for total power of streamx. 
        ///     'channelx/streamy' for power of streamy in channelx. 
        ///     An empty string for total power. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use the following active channel string formats to query this attribute: 
        ///    An empty string for total power. 
        ///    'streamx' for total power of streamx. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of 'channely' in 'segmentx'. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of 'streamy' in 'segmentx'. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///     '[segmentx/]channely/streamz' for power of streamz in channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx]' for total power. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use the following active channel string formats to query this attribute: 
        ///    'segmentx' for total power. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    'channelx' for total power of channelx. 
        ///    'streamx' for total power of streamx. 
        ///     'channelx/streamy' for power of streamy in channelx. 
        ///    An empty string for total power. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///     '[segmentx/]channely/streamy' for power of streamz in channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx]' for total power. An empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of channely in segmentx.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]channely/streamz' for power of streamz in channely in segmentx.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]' for total power. Empty string, if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]channely' for total power of channely in segmentx of userw in MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]streamy' for total power of streamy in segmentx of userw in MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]channely/streamz' for power of streamz in channely in segmentx of  userw    in MU PPDU signals. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]' for total power of userw in segmentx of MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodChannelMatrixAbsolutePowerMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodChannelMatrixAbsolutePowerMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of absolute power measurements in the frequency domain. This value is expressed in dBm. Absolute power is the    frequency domain power measured from estimated channel matrix.
        ///    You can query total power of each stream and each channel, power of each stream in each channel, and total power of channel matrix.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    'channelx' for total power of channelx. 
        ///    'streamx' for total power of streamx. 
        ///     'channelx/streamy' for power of streamy in channelx. 
        ///     An empty string for total power. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use the following active channel string formats to query this attribute: 
        ///    An empty string for total power. 
        ///    'streamx' for total power of streamx. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of 'channely' in 'segmentx'. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of 'streamy' in 'segmentx'. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///     '[segmentx/]channely/streamz' for power of streamz in channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx]' for total power. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use the following active channel string formats to query this attribute: 
        ///    'segmentx' for total power. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    'channelx' for total power of channelx. 
        ///    'streamx' for total power of streamx. 
        ///     'channelx/streamy' for power of streamy in channelx. 
        ///    An empty string for total power. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must use the following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///     '[segmentx/]channely/streamy' for power of streamz in channely in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx]' for total power. An empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use the    following active channel string formats to query this attribute: 
        ///    '[segmentx/]channely' for total power of channely in segmentx.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]streamy' for total power of streamy in segmentx. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]channely/streamz' for power of streamz in channely in segmentx.    'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    '[segmentx/]' for total power. Empty string, if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]channely' for total power of channely in segmentx of userw in MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]streamy' for total power of streamy in segmentx of userw in MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]channely/streamz' for power of streamz in channely in segmentx of  userw    in MU PPDU signals. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    'userw/[segmentx/]' for total power of userw in segmentx of MU PPDU signals. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodChannelMatrixAbsolutePowerStdDev(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodChannelMatrixAbsolutePowerStdDev, channel, out value);
        }


        /// <summary>
        ///Returns the array of average of the mean power values obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit performs this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for more information about the order of elements in this array.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the active channel string format to query this attribute. Use an    empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodGatedPowerMeanPowerAverage(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultOfdmDemodGatedPowerMeanPowerAverage, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the array of minimum of the mean power values obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit performs this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for more information about the order of elements in this array.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the active channel string format to query this attribute. Use an    empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodGatedPowerMeanPowerMinimum(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultOfdmDemodGatedPowerMeanPowerMinimum, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the array of maximum of the mean power values obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit performs this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for more information about the order of elements in this array.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the active channel string format to query this attribute. Use an    empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodGatedPowerMeanPowerMaximum(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultOfdmDemodGatedPowerMeanPowerMaximum, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the array of standard deviation of the mean power values obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit performs this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for more information about the order of elements in this array.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the active channel string format to query this attribute. Use an    empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodGatedPowerMeanPowerStandardDeviation(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultOfdmDemodGatedPowerMeanPowerStandardDeviation, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the array of average of the peak power values obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit performs this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for more information about the order of elements in this array.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the active channel string format to query this attribute. Use an    empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodGatedPowerPeakPowerAverage(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultOfdmDemodGatedPowerPeakPowerAverage, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the array of minimum of the peak power values obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit performs this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for more information about the order of elements in this array.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the active channel string format to query this attribute. Use an    empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodGatedPowerPeakPowerMinimum(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultOfdmDemodGatedPowerPeakPowerMinimum, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the array of maximum of the peak power values obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit performs this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for more information about the order of elements in this array.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the active channel string format to query this attribute. Use an    empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodGatedPowerPeakPowerMaximum(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultOfdmDemodGatedPowerPeakPowerMaximum, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the array of standard deviation of the peak power values obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit performs this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for more information about the order of elements in this array.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx]' as the active channel string format to query this attribute. Use an    empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use 'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_FALSE, you must    use '[segmentx/]channelx' as the active channel string format to query this attribute. 'segment0/' is optional if the    NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodGatedPowerPeakPowerStandardDeviation(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultOfdmDemodGatedPowerPeakPowerStandardDeviation, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the average across iterations of carrier frequency offset estimates of the transmitting device under test (DUT). This value is expressed in Hz.
        ///    For example, during acquisition, if you set the I/Q carrier frequency to 2.412 GHz, and the toolkit measures the carrier frequency of    the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz. This measurement follows section 17.3.9.4 of IEEE Standard 802.11a-1999,    section 20.3.21.4 of IEEE Standard 802.11n-2009, section 22.3.18.3 of IEEE Standard 802.11ac-2013, section 24.3.16.3 of    IEEE P802.11ah/D1.3, and section 28.3.14.3 and section 28.3.18.3 of  IEEE P802.11ax/D1.2. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCarrierFrequencyOffsetAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyOffsetAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of carrier frequency offset estimates of the transmitting device under test (DUT). This value is expressed in Hz.
        ///    For example, during acquisition, if you set the I/Q carrier frequency to 2.412 GHz, and the toolkit measures the carrier frequency of    the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz. This measurement follows section 17.3.9.4 of IEEE Standard 802.11a-1999,    section 20.3.21.4 of IEEE Standard 802.11n-2009, section 22.3.18.3 of IEEE Standard 802.11ac-2013, section 24.3.16.3 of    IEEE P802.11ah/D1.3, and section 28.3.14.3 and section 28.3.18.3 of  IEEE P802.11ax/D1.2. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCarrierFrequencyOffsetMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyOffsetMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of carrier frequency offset estimates of the transmitting device under test (DUT). This value is expressed in Hz.
        ///    For example, during acquisition, if you set the I/Q carrier frequency to 2.412 GHz, and the toolkit measures the carrier frequency of    the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz. This measurement follows section 17.3.9.4 of IEEE Standard 802.11a-1999,    section 20.3.21.4 of IEEE Standard 802.11n-2009, section 22.3.18.3 of IEEE Standard 802.11ac-2013, section 24.3.16.3 of    IEEE P802.11ah/D1.3, and section 28.3.14.3 and section 28.3.18.3 of  IEEE P802.11ax/D1.2. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCarrierFrequencyOffsetMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyOffsetMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of carrier frequency offset estimates of the transmitting device under test (DUT). This value is expressed in Hz.
        ///    For example, during acquisition, if you set the I/Q carrier frequency to 2.412 GHz, and the toolkit measures the carrier frequency of    the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz. This measurement follows section 17.3.9.4 of IEEE Standard 802.11a-1999,    section 20.3.21.4 of IEEE Standard 802.11n-2009, section 22.3.18.3 of IEEE Standard 802.11ac-2013, section 24.3.16.3 of    IEEE P802.11ah/D1.3, and section 28.3.14.3 and section 28.3.18.3 of  IEEE P802.11ax/D1.2. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCarrierFrequencyOffsetStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyOffsetStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the minimum of carrier frequency leakage. This value is expressed in dB. Carrier frequency leakage is the ratio of the    energy in the DC subcarrier to the total energy of all the subcarriers.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use    'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use 'channelx' as the    active channel string format to query this format. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCarrierFrequencyLeakageMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyLeakageMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum of carrier frequency leakage. This value is expressed in dB. Carrier frequency leakage is the ratio of the energy    in the DC subcarrier to the total energy of all the subcarriers.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use    'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use 'channelx' as the    active channel string format to query this format. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCarrierFrequencyLeakageMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyLeakageMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of carrier frequency leakage. This value is expressed in dB. Carrier frequency leakage is the ratio of the energy    in the DC subcarrier to the total energy of all the subcarriers.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use    'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use 'channelx' as the    active channel string format to query this format. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCarrierFrequencyLeakageStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyLeakageStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of sample clock offset estimates. This value is expressed in parts per million (ppm).    The sample clock offset is the difference between the sample clocks at the digital-to-analog converter (DAC) of the transmitting    device under test (DUT) and the digitizer.
        ///    If the clock offset is more than 25 ppm, the estimated value may be inaccurate. The clock offset      measurement follows section 17.3.9.5 of IEEE Standard 802.11a-1999, section 20.3.21.6 of    IEEE Standard 802.11n-2009, section 22.3.18.3 of IEEE Standard 802.11ac-2013 and section 24.3.16.3 of IEEE P802.11ah/D1.3, and    section 28.3.18.3 of IEEE P802.11ax/D1.2.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSampleClockOffsetAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodSampleClockOffsetAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of sample clock offset estimates. This value is expressed in parts per million (ppm).    The sample clock offset is the difference between the sample clocks at the digital-to-analog converter (DAC) of the transmitting    device under test (DUT) and the digitizer.
        ///    If the clock offset is more than 25 ppm, the estimated value may be inaccurate. The clock offset      measurement follows section 17.3.9.5 of IEEE Standard 802.11a-1999, section 20.3.21.6 of    IEEE Standard 802.11n-2009, section 22.3.18.3 of IEEE Standard 802.11ac-2013, section 24.3.16.3 of    IEEE P802.11ah/D1.3, and section 28.3.18.3 of IEEE P802.11ax/D1.2. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSampleClockOffsetMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodSampleClockOffsetMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of sample clock offset estimates. This value is expressed in parts per million (ppm).    The sample clock offset is the difference between the sample clocks at the digital-to-analog converter (DAC) of the transmitting    device under test (DUT) and the digitizer.
        ///    If the clock offset is more than 25 ppm, the estimated value may be inaccurate. The clock offset      measurement follows section 17.3.9.5 of IEEE Standard 802.11a-1999, section 20.3.21.6 of    IEEE Standard 802.11n-2009, section 22.3.18.3 of IEEE Standard 802.11ac-2013, section 24.3.16.3 of    IEEE P802.11ah/D1.3, and section 28.3.18.3 of IEEE P802.11ax/D1.2. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSampleClockOffsetMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodSampleClockOffsetMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of sample clock offset estimates. This value is expressed in parts per million (ppm).    The sample clock offset is the difference between the sample clocks at the digital-to-analog converter (DAC) of the transmitting    device under test (DUT) and the digitizer.
        ///    If the clock offset is more than 25 ppm, the estimated value may be inaccurate. The clock offset      measurement follows section 17.3.9.5 of IEEE Standard 802.11a-1999, section 20.3.21.6 of    IEEE Standard 802.11n-2009, section 22.3.18.3 of IEEE Standard 802.11ac-2013, section 24.3.16.3 of    IEEE P802.11ah/D1.3, and section 28.3.18.3 of IEEE P802.11ax/D1.2. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_80211G_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSampleClockOffsetStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodSampleClockOffsetStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of I/Q gain imbalance estimates. I/Q gain imbalance is the    ratio of the mean amplitude of the in-phase (I) signal to the mean amplitude of the quadrature-phase (Q) signal. This value is expressed in dB.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Note: The result of this attribute is invalid if you set    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    Note: The result of this attribute is invalid if you set the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE. 
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments might be inaccurate.
        ///    Note: If the cable connecting the device under test (DUT) and the NI-RFSA    has significant low-pass characteristics or in-band ripple, measuring OFDM I/Q gain imbalance and quadrature skew may be adversely affected.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodIqGainImbalanceAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodIqGainImbalanceAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of I/Q gain imbalance estimates. This value is expressed in dB. I/Q gain imbalance is the ratio,    of the mean amplitude of the in-phase (I) signal to the mean amplitude of the quadrature-phase (Q) signal.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Note: The result of this attribute is invalid if you set    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments might be inaccurate.
        ///    Note: If the cable connecting the device under test (DUT) and the NI-RFSA    has significant low-pass characteristics or in-band ripple, measuring OFDM I/Q gain imbalance and quadrature skew may be adversely affected.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodIqGainImbalanceMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodIqGainImbalanceMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of I/Q gain imbalance estimates. This value is expressed in dB. I/Q gain imbalance is the ratio    of the mean amplitude of the in-phase (I) signal to the mean amplitude of the quadrature-phase (Q) signal.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Note: The result of this attribute is invalid if you set    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments might be inaccurate.
        ///    Note: If the cable connecting the device under test (DUT) and the NI-RFSA    has significant low-pass characteristics or in-band ripple, measuring OFDM I/Q gain imbalance and quadrature skew may be adversely affected.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodIqGainImbalanceMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodIqGainImbalanceMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of I/Q gain imbalance estimates. This value is expressed in dB. I/Q gain imbalance is the ratio    of the mean amplitude of the in-phase (I) signal to the mean amplitude of the quadrature-phase (Q) signal.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Note: The result of this attribute is invalid if you set    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments might be inaccurate.
        ///    Note: If the cable connecting the device under test (DUT) and the NI-RFSA    has significant low-pass characteristics or in-band ripple, measuring OFDM I/Q gain imbalance    and quadrature skew may be adversely affected.
        /// 
        /// </summary>        
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodIqGainImbalanceStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodIqGainImbalanceStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of quadrature skew estimates. This value is expressed in degrees.    Quadrature skew is the deviation in angle from 90 degrees between the in-phase (I) and quadrature-phase (Q) signals.
        ///    Refer to the Quadrature Skew help topic for a graphical representation of the quadrature skew.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Note: The result of this attribute is invalid if you set    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments may be inaccurate.
        ///    Note: If the cable connecting the device under test (DUT) and the NI-RFSA    has significant low-pass characteristics or in-band ripple, measuring OFDM I/Q gain    imbalance and quadrature skew may be adversely affected.
        ///    Get Function: niWLANA_GetOFDMDemodQuadratureSkew
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodQuadratureSkewAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodQuadratureSkewAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of quadrature skew estimates. This value is expressed in degrees.    Quadrature skew is the deviation in angle from 90 degrees between the in-phase (I) and quadrature-phase (Q) signals.
        ///    Refer to the Quadrature Skew help topic for a graphical representation of the quadrature skew.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Note: The result of this attribute is invalid if you set    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments may be inaccurate.
        ///    Note: If the cable connecting the device under test (DUT) and the NI-RFSA    has significant low-pass characteristics or in-band ripple, measuring OFDM I/Q    gain imbalance and quadrature skew may be adversely affected.
        ///    Get Function: niWLANA_GetOFDMDemodQuadratureSkew
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodQuadratureSkewMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodQuadratureSkewMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of quadrature skew estimates. This value is expressed in degrees.    Quadrature skew is the deviation in angle from 90 degrees between the in-phase (I) and quadrature-phase (Q) signals.
        ///    Refer to the Quadrature Skew help topic for a graphical representation of the quadrature skew.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Note: The result of this attribute is invalid if you set    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments may be inaccurate.
        ///    Note: If the cable connecting the device under test (DUT) and the NI-RFSA    has significant low-pass characteristics or in-band ripple, measuring OFDM I/Q gain    imbalance and quadrature skew may be adversely affected.
        ///    Get Function: niWLANA_GetOFDMDemodQuadratureSkew
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodQuadratureSkewMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodQuadratureSkewMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of quadrature skew estimates. This value is expressed in degrees.    Quadrature skew is the deviation in angle from 90 degrees between the in-phase (I) and quadrature-phase (Q) signals.
        ///    Refer to the Quadrature Skew help topic for a graphical representation of the quadrature skew.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Note: The result of this attribute is invalid if you set    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    Note: The result of this attribute is invalid if you set the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE. 
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments may be inaccurate.
        ///    Note: If the cable connecting the device under test (DUT) and the NI-RFSA    has significant low-pass characteristics or in-band ripple, measuring OFDM I/Q gain    imbalance and quadrature skew may be adversely affected.
        ///    Get Function: niWLANA_GetOFDMDemodQuadratureSkew
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodQuadratureSkewStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodQuadratureSkewStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of timing skew estimates. This value is expressed in seconds.    Timing skew is the difference between the sampling instants of in-phase (I) and quadrature (Q) components of the complex baseband signal.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Note: The result of this attribute is invalid if you set the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodTimingSkewAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodTimingSkewAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of timing skew estimates. This value is expressed in seconds. Timing skew is the difference between the    sampling instants of in-phase (I) and quadrature (Q) components of the complex baseband signal.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Note: The result of this attribute is invalid if you set the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodTimingSkewMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodTimingSkewMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of timing skew estimates. This value is expressed in seconds. Timing skew is the difference between the    sampling instants of in-phase (I) and quadrature (Q) components of the complex baseband signal.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Note: The result of this attribute is invalid if you set the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodTimingSkewMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodTimingSkewMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of timing skew estimates. This value is expressed in seconds. Timing skew is the difference between the    sampling instants of in-phase (I) and quadrature (Q) components of the complex baseband signal.
        ///   If you set the NIWLANA_STANDARD attribute   to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use 'channelx' as the active    channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the active    channel string format to query this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodTimingSkewStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodTimingSkewStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of common pilot error (CPE) RMS measurements, as a    percentage of ideal pilot subcarrier values.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,     NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you    must use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommonPilotErrorRmsAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommonPilotErrorRmsAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of common pilot error (CPE) RMS measurements, as    a percentage of ideal pilot subcarrier values.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you    must use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommonPilotErrorRmsMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommonPilotErrorRmsMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of common pilot error (CPE) RMS measurements,    as a percentage of ideal pilot subcarrier values.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you    must use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommonPilotErrorRmsMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommonPilotErrorRmsMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of common pilot error (CPE) RMS measurements, as a percentage of    ideal pilot subcarrier values.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM,    or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you    must use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommonPilotErrorRmsStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommonPilotErrorRmsStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average across iterations of RMS phase error measurement. This value is expressed in degrees. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you    must use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommonPhaseErrorAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommonPhaseErrorAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of RMS phase error measurement. This value is expressed in degrees. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you    must use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommonPhaseErrorMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommonPhaseErrorMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of RMS phase error measurement. This value is expressed in degrees. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you    must use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommonPhaseErrorMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommonPhaseErrorMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation across iterations of RMS phase error measurement. This value is expressed in degrees. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you    must use '[segmentx]' as the active    channel string format to query this attribute. Use an empty string if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommonPhaseErrorStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommonPhaseErrorStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable power measurement over a user-defined gate. The start and    stop time of the user-defined gate can be specified by    configuring the NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_START_TIME and NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_STOP_TIME    attributes respectively.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodUserDefinedGatePowerEnabled
        ///    Set Function: niWLANA_SetDSSSDemodUserDefinedGatePowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodUserDefinedGatePowerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodUserDefinedGatePowerEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable power measurement over a user-defined gate. The start and    stop time of the user-defined gate can be specified by    configuring the NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_START_TIME and NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_STOP_TIME    attributes respectively.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodUserDefinedGatePowerEnabled
        ///    Set Function: niWLANA_SetDSSSDemodUserDefinedGatePowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodUserDefinedGatePowerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodUserDefinedGatePowerEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the start time of the user-defined gate. This value is expressed in seconds. A value of 0 indicates that the start time    is the start of the payload.
        ///    A negative value indicates a position in the preamble or header. 
        ///    Refer to the Gated Power Measurement help topic for more information about computing gated power.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetDSSSDemodUserDefinedGateStartTime
        ///    Set Function: niWLANA_SetDSSSDemodUserDefinedGateStartTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodUserDefinedGateStartTime(string channel, double value)
        {
            return SetDouble(niWLANAProperties.DsssDemodUserDefinedGateStartTime, channel, value);
        }

        /// <summary>
        ///Specifies the start time of the user-defined gate. This value is expressed in seconds. A value of 0 indicates that the start time    is the start of the payload.
        ///    A negative value indicates a position in the preamble or header. 
        ///    Refer to the Gated Power Measurement help topic for more information about computing gated power.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetDSSSDemodUserDefinedGateStartTime
        ///    Set Function: niWLANA_SetDSSSDemodUserDefinedGateStartTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodUserDefinedGateStartTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DsssDemodUserDefinedGateStartTime, channel, out value);
        }


        /// <summary>
        ///Specifies the end time of the user-defined gate. This value is expressed in seconds. A value of 0 indicates that the stop time    is the start of the payload.
        ///    A negative value indicates a position in the preamble or header. 
        ///    Refer to the Gated Power Measurement help topic for more information about computing gated power.
        ///    The default value is 6.4 &#181;s.
        ///    Get Function: niWLANA_GetDSSSDemodUserDefinedGateStopTime
        ///    Set Function: niWLANA_SetDSSSDemodUserDefinedGateStopTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodUserDefinedGateStopTime(string channel, double value)
        {
            return SetDouble(niWLANAProperties.DsssDemodUserDefinedGateStopTime, channel, value);
        }

        /// <summary>
        ///Specifies the end time of the user-defined gate. This value is expressed in seconds. A value of 0 indicates that the stop time    is the start of the payload.
        ///    A negative value indicates a position in the preamble or header. 
        ///    Refer to the Gated Power Measurement help topic for more information about computing gated power.
        ///    The default value is 6.4 &#181;s.
        ///    Get Function: niWLANA_GetDSSSDemodUserDefinedGateStopTime
        ///    Set Function: niWLANA_SetDSSSDemodUserDefinedGateStopTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodUserDefinedGateStopTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DsssDemodUserDefinedGateStopTime, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable total packet power measurements.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodGatedPowerTotalPacketPowerEnabled
        ///    Set Function: niWLANA_SetDSSSDemodGatedPowerTotalPacketPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodGatedPowerTotalPacketPowerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodGatedPowerTotalPacketPowerEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable total packet power measurements.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodGatedPowerTotalPacketPowerEnabled
        ///    Set Function: niWLANA_SetDSSSDemodGatedPowerTotalPacketPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodGatedPowerTotalPacketPowerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodGatedPowerTotalPacketPowerEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable preamble and header power measurements.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodGatedPowerPreambleAndHeaderPowerEnabled
        ///    Set Function: niWLANA_SetDSSSDemodGatedPowerPreambleAndHeaderPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodGatedPowerPreambleAndHeaderPowerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodGatedPowerPreambleAndHeaderPowerEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable preamble and header power measurements.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodGatedPowerPreambleAndHeaderPowerEnabled
        ///    Set Function: niWLANA_SetDSSSDemodGatedPowerPreambleAndHeaderPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodGatedPowerPreambleAndHeaderPowerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodGatedPowerPreambleAndHeaderPowerEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable data power measurements.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodGatedPowerDataPowerEnabled
        ///    Set Function: niWLANA_SetDSSSDemodGatedPowerDataPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodGatedPowerDataPowerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodGatedPowerDataPowerEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable data power measurements.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodGatedPowerDataPowerEnabled
        ///    Set Function: niWLANA_SetDSSSDemodGatedPowerDataPowerEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodGatedPowerDataPowerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodGatedPowerDataPowerEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to detect the start of a burst.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodBurstStartDetectionEnabled
        ///    Set Function: niWLANA_SetDSSSDemodBurstStartDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDSSSDemodBurstStartDetectionEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodBurstStartDetectionEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to detect the start of a burst.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodBurstStartDetectionEnabled
        ///    Set Function: niWLANA_SetDSSSDemodBurstStartDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSDemodBurstStartDetectionEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodBurstStartDetectionEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to estimate carrier frequency offset.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodCarrierFrequencyOffsetEstimationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodCarrierFrequencyOffsetEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDSSSDemodCarrierFrequencyOffsetEstimationEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodCarrierFrequencyOffsetEstimationEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to estimate carrier frequency offset.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodCarrierFrequencyOffsetEstimationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodCarrierFrequencyOffsetEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSDemodCarrierFrequencyOffsetEstimationEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodCarrierFrequencyOffsetEstimationEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to estimate sample clock offset.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodSampleClockOffsetEstimationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodSampleClockOffsetEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDSSSDemodSampleClockOffsetEstimationEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodSampleClockOffsetEstimationEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to estimate sample clock offset.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodSampleClockOffsetEstimationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodSampleClockOffsetEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSDemodSampleClockOffsetEstimationEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodSampleClockOffsetEstimationEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to estimate I/Q gain imbalance.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodIQGainImbalanceEstimationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodIQGainImbalanceEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDSSSDemodIQGainImbalanceEstimationEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodIqGainImbalanceEstimationEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to estimate I/Q gain imbalance.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodIQGainImbalanceEstimationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodIQGainImbalanceEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSDemodIQGainImbalanceEstimationEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodIqGainImbalanceEstimationEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to estimate quadrature skew.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodQuadratureSkewEstimationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodQuadratureSkewEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDSSSDemodQuadratureSkewEstimationEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodQuadratureSkewEstimationEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to estimate quadrature skew.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodQuadratureSkewEstimationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodQuadratureSkewEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSDemodQuadratureSkewEstimationEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodQuadratureSkewEstimationEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to estimate carrier suppression.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetDSSSDemodCarrierSuppressionEstimationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodCarrierSuppressionEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDSSSDemodCarrierSuppressionEstimationEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodCarrierSuppressionEstimationEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to estimate carrier suppression.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetDSSSDemodCarrierSuppressionEstimationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodCarrierSuppressionEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSDemodCarrierSuppressionEstimationEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodCarrierSuppressionEstimationEnabled, channel, out value);
        }


        /// <summary>
        ///Returns the average of RMS EVM measurements. This value is expressd as a percentage.
        ///    Note: For direct sequence spread spectrum (DSSS) demodulation, if you set the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute    to NIWLANA_VAL_FALSE, and the reference pulse-shaping filter type    and filter coefficients do not match the filter configuration of the device under test (DUT) or    generator, you may notice EVM degradation. 
        ///    Ensure that the pulse-shaping type and pulse-shaping coefficient settings match the input signal settings.
        ///    Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM may show degradation.
        ///    Refer to the EVM Computation for DSSS Signals help topic for more information about EVM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodRmsEvmAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodRmsEvmAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum of RMS EVM measurements. This value is expressd as a percentage.
        ///    Note: For direct sequence spread spectrum (DSSS) demodulation, if you set the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute    to NIWLANA_VAL_FALSE, and the reference pulse-shaping filter type    and filter coefficients do not match the filter configuration of the device under test (DUT) or generator, you may notice EVM degradation.    Ensure that the pulse-shaping type and pulse-shaping coefficient settings match the input signal settings.
        ///    Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM may show degradation.
        ///    Refer to the EVM Computation for DSSS Signals help topic for more information about EVM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodRmsEvmMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodRmsEvmMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum of RMS EVM measurements. This value is expressd as a percentage.
        ///    Note: For direct sequence spread spectrum (DSSS) demodulation, if you set the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute    to NIWLANA_VAL_FALSE, and the reference pulse-shaping filter type    and filter coefficients do not match the filter configuration of the device under test (DUT) or generator, you may notice EVM degradation.    Ensure that the pulse-shaping type and pulse-shaping coefficient settings match the input signal settings.
        ///    Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM may show degradation.
        ///    Refer to the EVM Computation for DSSS Signals help topic for more information about EVM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodRmsEvmMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodRmsEvmMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of RMS EVM measurements. This value is expressd as a percentage.
        ///    Note: For direct sequence spread spectrum (DSSS) demodulation, if you set the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute    to NIWLANA_VAL_FALSE, and the reference pulse-shaping filter type    and filter coefficients do not match the filter configuration of the device under test (DUT) or generator, you may notice EVM degradation.    Ensure that the pulse-shaping type and pulse-shaping coefficient settings match the input signal settings.
        ///    Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM may show degradation.
        ///    Refer to the EVM Computation for DSSS Signals help topic for more information about EVM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodRmsEvmStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodRmsEvmStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the maximum of peak EVM measurements. This value is expressd as a percentage.
        ///    Note: For direct sequence spread spectrum (DSSS) demodulation, if you set the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute    to NIWLANA_VAL_FALSE, and the reference pulse-shaping filter type and filter coefficients    do not match the filter configuration of the device under test (DUT) or generator, you may notice EVM degradation.    Ensure that the pulse-shaping type and pulse-shaping coefficient settings match the input signal settings.
        ///    Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM may show degradation.
        ///    Refer to the EVM Computation for DSSS Signals help topic for more information about EVM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodPeakEvmMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodPeakEvmMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the minimum of peak EVM measurements. This value is expressd as a percentage.
        ///    Note: For direct sequence spread spectrum (DSSS) demodulation, if you set the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute    to NIWLANA_VAL_FALSE, and the reference pulse-shaping filter type and filter coefficients    do not match the filter configuration of the device under test (DUT) or generator, you may notice EVM degradation.    Ensure that the pulse-shaping type and pulse-shaping coefficient settings match the input signal settings.
        ///    Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM may show degradation.
        ///    Refer to the EVM Computation for DSSS Signals help topic for more information about EVM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodPeakEvmMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodPeakEvmMinimum, channel, out value);
        }

        /// <summary>
        ///Returns the maximum of 80211b peak EVM measurements. This value is expressd as a percentage.
        ///    Note: If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED attribute to a value less    than 1,000, the NIWLANA_RESULT_DSSS_DEMOD_80211B_PEAK_EVM_MAXIMUM attribute returns NaN.   If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED    attribute to -1 and the actual number of chips present in the signal is    less than 1,000, the NIWLANA_RESULT_DSSS_DEMOD_80211B_PEAK_EVM_MAXIMUM attribute returns NaN.
        ///    Note: For direct sequence spread spectrum (DSSS) demodulation, if you set    the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute to NIWLANA_VAL_FALSE, and the reference pulse-shaping filter    type and filter coefficients do not match the filter    configuration of the device under test (DUT) or generator, you may notice EVM degradation.    Ensure the pulse-shaping type and pulse-shaping coefficient settings match    the input signal settings.
        ///    Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM might show degradation.
        ///    Refer to the EVM Computation for DSSS Signals help topic for more information about EVM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemod80211bPeakEvmMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemod80211bPeakEvmMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the minimum of 80211b peak EVM measurements. This value is expressd as a percentage.
        ///    Note: If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED attribute to a value less    than 1,000, the NIWLANA_RESULT_DSSS_DEMOD_80211B_PEAK_EVM_MINIMUM attribute returns NaN.    If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED    attribute to -1 and the actual number of chips present in the signal is less than 1,000,    the NIWLANA_RESULT_DSSS_DEMOD_80211B_PEAK_EVM_MINIMUM attribute returns NaN.
        ///    Note: For direct sequence spread spectrum (DSSS) demodulation, if you set the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute    to NIWLANA_VAL_FALSE, and the reference pulse-shaping filter    type and filter coefficients do not match the filter    configuration of the device under test (DUT) or generator, you may notice EVM degradation.    Ensure the pulse-shaping type and pulse-shaping coefficient settings match    the input signal settings.
        ///    Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM might show degradation.
        ///    Refer to the EVM Computation for DSSS Signals help topic for more information about EVM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemod80211bPeakEvmMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemod80211bPeakEvmMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum of 80211b peak EVM measurements. This value is expressd as a percentage.
        ///    Note: If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED attribute to a value less than 1,000, the toolkit returns a value of NaN.    If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED    attribute to -1, and the actual number of chips present in the signal is less than 1,000, the toolkit returns a value of NaN.
        ///    Note: For direct sequence spread spectrum (DSSS) demodulation, if you set the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute is set    to NIWLANA_VAL_FALSE, and the reference pulse-shaping filter    type and filter coefficients do not match the filter    configuration of the device under test (DUT) or generator, you might notice EVM degradation.    Ensure the pulse-shaping type and pulse-shaping coefficient settings match    the input signal settings.
        ///    Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM might show degradation.
        ///    Refer to the EVM Computation for DSSS Signals help topic for more information about EVM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemod80211bPeakEvm2007Maximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemod80211bPeakEvm2007Maximum, channel, out value);
        }


        /// <summary>
        ///Returns the minimum of 80211b peak EVM measurements. This value is expressd as a percentage.
        ///    Note: If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED attribute to a value less than 1,000, NaN is returned.    If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED    attribute to -1 and the actual number of chips present in the signal is less than 1,000, NaN is returned.
        ///    Note: For direct sequence spread spectrum (DSSS) demodulation, if you set the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute    to NIWLANA_VAL_FALSE, and the reference pulse-shaping filter    type and filter coefficients do not match the filter    configuration of the device under test (DUT) or generator, you might notice EVM degradation.    Ensure the pulse-shaping type and pulse-shaping coefficient settings match    the input signal settings.
        ///    Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM might show degradation.
        ///    Refer to the EVM Computation for DSSS Signals help topic for more information about EVM.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemod80211bPeakEvm2007Minimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemod80211bPeakEvm2007Minimum, channel, out value);
        }


        /// <summary>
        ///Returns the average of average gated power. This value is expressed in dBm. 
        ///    Average gated power is defined by the measurement interval between the values of the NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_START_TIME and    the NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_STOP_TIME attributes.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodAverageGatedPowerAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodAverageGatedPowerAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum of average gated power. This value is expressed in dBm. 
        ///    Average gated power is defined by the measurement interval between the values of the NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_START_TIME and    the NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_STOP_TIME attributes.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodAverageGatedPowerMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodAverageGatedPowerMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum of average gated power. This value is expressed in dBm. 
        ///    Average gated power is defined by the measurement interval between the values of the NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_START_TIME and    the NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_STOP_TIME attributes.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodAverageGatedPowerMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodAverageGatedPowerMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of average gated power. This value is expressed in dBm. 
        ///    Average gated power is defined by the measurement interval between the values of the NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_START_TIME and    the NIWLANA_DSSS_DEMOD_USER_DEFINED_GATE_STOP_TIME attributes.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodAverageGatedPowerStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodAverageGatedPowerStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the absolute time corresponding to the detected start of the analyzed burst. This value is expressed in seconds.    This time is computed with respect to the t0 value of the acquired waveform.
        ///    Get Function: niWLANA_GetDSSSDemodBurstStartTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodBurstStartTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodBurstStartTime, channel, out value);
        }


        /// <summary>
        ///Returns the average of the mean power obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit uses this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for the order of elements in this array.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultDsssDemodGatedPowerMeanPowerAverage(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultDsssDemodGatedPowerMeanPowerAverage, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the minimum of the mean power obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit uses this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for the order of elements in this array.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultDsssDemodGatedPowerMeanPowerMinimum(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultDsssDemodGatedPowerMeanPowerMinimum, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the maximum of the mean power obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit uses this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for the order of elements in this array.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultDsssDemodGatedPowerMeanPowerMaximum(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultDsssDemodGatedPowerMeanPowerMaximum, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the standard deviation of the mean power obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit uses this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for the order of elements in this array.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultDsssDemodGatedPowerMeanPowerStandardDeviation(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultDsssDemodGatedPowerMeanPowerStandardDeviation, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the average of the peak power obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit uses this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for the order of elements in this array.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultDsssDemodGatedPowerPeakPowerAverage(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultDsssDemodGatedPowerPeakPowerAverage, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the minimum of the peak power obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit uses this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for the order of elements in this array.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultDsssDemodGatedPowerPeakPowerMinimum(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultDsssDemodGatedPowerPeakPowerMinimum, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the maximum of the peak power obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit uses this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for the order of elements in this array.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultDsssDemodGatedPowerPeakPowerMaximum(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultDsssDemodGatedPowerPeakPowerMaximum, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the standard deviation of the peak power obtained from gated power measurements on the acquired burst. This value is expressed in dBm.    The toolkit uses this measurement across specified number of iterations.
        ///    Refer to the Gated Power Results topic for the order of elements in this array.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultDsssDemodGatedPowerPeakPowerStandardDeviation(string channel, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultDsssDemodGatedPowerPeakPowerStandardDeviation, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the average across iterations of carrier frequency offset estimates of the transmitting device under test (DUT). This value is expressed in Hz.
        ///    For example, during acquisition, if you set the I/Q carrier frequency to 2.412 GHz, and the toolkit measures the carrier frequency of    the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodCarrierFrequencyOffsetAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierFrequencyOffsetAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of carrier frequency offset estimates of the transmitting device under test (DUT). This value is expressed in Hz.
        ///    For example, during acquisition, if you set the I/Q carrier frequency to 2.412 GHz, and the toolkit measures the carrier frequency of    the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodCarrierFrequencyOffsetMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierFrequencyOffsetMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of carrier frequency offset estimates of the transmitting device under test (DUT). This value is expressed in Hz.
        ///    For example, during acquisition, if you set the I/Q carrier frequency to 2.412 GHz, and the toolkit measures the carrier frequency of    the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodCarrierFrequencyOffsetMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierFrequencyOffsetMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of carrier frequency offset estimates of the transmitting device under test (DUT). This value is expressed in Hz.
        ///    For example, during acquisition, if you set the I/Q carrier frequency to 2.412 GHz, and the toolkit measures the carrier frequency of    the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodCarrierFrequencyOffsetStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierFrequencyOffsetStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average of I/Q gain imbalance estimates across iterations.    I/Q gain imbalance is the ratio of the mean amplitude    of the in-phase (I) signal to the mean amplitude of the quadrature-phase (Q) signal. This value is expressed in dB.
        ///    Note: If the magnitude of the carrier or the sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments might not be accurate. 
        ///    Note: I/Q gain imbalance cannot be measured for signals with differential binary phase-shift keying (DBPSK) modulation.    The DBPSK modulation corresponds to a data rate of 1 Mbps. The I/Q gain imbalance measurement may fail for other modulation schemes,    for example, differential quadrature phase-shift keying (DQPSK) and 8-PSK, if there are not enough constellation    points in all quadrants of the I/Q phase plane. The DQPSK modulation corresponds to data rates of 2 Mbps, 5.5 Mbps, and 11 Mbps,    and the 8-PSK modulation corresponds to data rates of 22 Mbps and 33 Mbps.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodIqGainImbalanceAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodIqGainImbalanceAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum of I/Q gain imbalance estimates across iterations.    I/Q gain imbalance is the ratio of the mean amplitude of the in-phase (I) signal    to the mean amplitude of the quadrature-phase (Q) signal. This value is expressed in dB.
        ///    Note: If the magnitude of the carrier or the sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments might not be accurate. 
        ///    Note: I/Q gain imbalance cannot be measured for signals with differential binary phase-shift keying (DBPSK) modulation.    The DBPSK modulation corresponds to a data rate of 1 Mbps. The I/Q gain imbalance measurement may fail for other modulation schemes,    for example, differential quadrature phase-shift keying (DQPSK) and 8-PSK, if there are not enough constellation    points in all quadrants of the I/Q phase plane. The DQPSK modulation corresponds to data rates of 2 Mbps, 5.5 Mbps, and 11 Mbps,    and the 8-PSK modulation corresponds to data rates of 22 Mbps and 33 Mbps.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodIqGainImbalanceMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodIqGainImbalanceMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum of I/Q gain imbalance estimates across iterations.    I/Q gain imbalance is the ratio of the mean amplitude of the in-phase (I) signal    to the mean amplitude of the quadrature-phase (Q) signal. This value is expressed in dB.
        ///    Note: If the magnitude of the carrier or the sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments might not be accurate. 
        ///    Note: I/Q gain imbalance cannot be measured for signals with differential binary phase-shift keying (DBPSK) modulation.    The DBPSK modulation corresponds to a data rate of 1 Mbps. The I/Q gain imbalance measurement may fail for other modulation schemes,    for example, differential quadrature phase-shift keying (DQPSK) and 8-PSK, if there are not enough constellation    points in all quadrants of the I/Q phase plane. The DQPSK modulation corresponds to data rates of 2 Mbps, 5.5 Mbps, and 11 Mbps,    and the 8-PSK modulation corresponds to data rates of 22 Mbps and 33 Mbps.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodIqGainImbalanceMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodIqGainImbalanceMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of I/Q gain imbalance estimates.    I/Q gain imbalance is the ratio of the mean amplitude of the in-phase (I) signal to the mean amplitude    of the quadrature-phase (Q) signal. This value is expressed in dB.
        ///    Note: If the magnitude of the carrier or the sample clock frequency offset is greater than 25 ppm,    I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,    the estimates of these impairments might not be accurate. 
        ///    Note: I/Q gain imbalance cannot be measured for signals with differential binary phase-shift keying (DBPSK) modulation.    The DBPSK modulation corresponds to a data rate of 1 Mbps. The I/Q gain imbalance measurement may fail for other modulation schemes,    for example, differential quadrature phase-shift keying (DQPSK) and 8-PSK, if there are not enough constellation    points in all quadrants of the I/Q phase plane. The DQPSK modulation corresponds to data rates of 2 Mbps, 5.5 Mbps, and 11 Mbps,    and the 8-PSK modulation corresponds to data rates of 22 Mbps and 33 Mbps.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodIqGainImbalanceStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodIqGainImbalanceStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average of quadrature skew estimates across iterations. This value is expressed in degrees.    Quadrature skew is the deviation in angle from 90 degrees between the in-phase (I) and quadrature-phase (Q) signals.
        ///    Refer to the Quadrature Skew help topic for a graphical representation of the quadrature skew.
        ///    Note: If the magnitude of the carrier or the sample clock frequency offset is greater than 25 ppm, I/Q gain imbalance magnitude is    greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees, the estimates of these impairments may be inaccurate. 
        ///    Note: Quadrature skew cannot be measured for signals with differential binary phase-shift keying (DBPSK) modulation.    The DBPSK modulation corresponds to a data rate of 1 Mbps. The Quadrature skew measurement may fail for other modulation schemes,    for example, differential quadrature phase-shift keying (DQPSK) and 8-PSK, if    there are not enough constellation points in all    quadrants of the I/Q phase plane. The DQPSK modulation corresponds to data rates of 2 Mbps, 5.5 Mbps, and 11 Mbps, and the 8-PSK modulation    corresponds to data rates of 22 Mbps and 33 Mbps.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodQuadratureSkewAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodQuadratureSkewAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum of quadrature skew estimates across iterations. This value is expressed in degrees.    Quadrature skew is the deviation in angle from 90 degrees between the in-phase (I) and quadrature-phase (Q) signals.
        ///    Refer to the Quadrature Skew help topic for a graphical representation of the quadrature skew.
        ///    Note: If the magnitude of the carrier or the sample clock frequency offset is greater than 25 ppm, I/Q gain imbalance magnitude is    greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees, the estimates of these impairments may be inaccurate. 
        ///    Note: Quadrature skew cannot be measured for signals with differential binary phase-shift keying (DBPSK) modulation.    The DBPSK modulation corresponds to a data rate of 1 Mbps. The Quadrature skew measurement may fail for other modulation schemes,    for example, differential quadrature phase-shift keying (DQPSK)    and 8-PSK, if there are not enough constellation points in all    quadrants of the I/Q phase plane. The DQPSK modulation corresponds to data rates of 2 Mbps, 5.5 Mbps, and 11 Mbps, and the 8-PSK modulation    corresponds to data rates of 22 Mbps and 33 Mbps.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodQuadratureSkewMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodQuadratureSkewMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum of quadrature skew estimates across iterations. This value is expressed in degrees.    Quadrature skew is the deviation in angle from 90 degrees between the in-phase (I) and quadrature-phase (Q) signals.
        ///    Refer to the Quadrature Skew help topic for a graphical representation of the quadrature skew.
        ///    Note: If the magnitude of the carrier or the sample clock frequency offset is greater than 25 ppm, I/Q gain imbalance magnitude is    greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees, the estimates of these impairments may be inaccurate. 
        ///    Note: Quadrature skew cannot be measured for signals with differential binary phase-shift keying (DBPSK) modulation.    The DBPSK modulation corresponds to a data rate of 1 Mbps. The Quadrature skew measurement may fail for other modulation schemes,    for example, differential quadrature phase-shift keying (DQPSK) and 8-PSK, if there are    not enough constellation points in all    quadrants of the I/Q phase plane. The DQPSK modulation corresponds to data rates of 2 Mbps, 5.5 Mbps, and 11 Mbps, and the 8-PSK modulation    corresponds to data rates of 22 Mbps and 33 Mbps.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodQuadratureSkewMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodQuadratureSkewMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of quadrature skew estimates. This value is expressed in degrees.    Quadrature skew is the deviation in angle from 90 degrees between the in-phase (I) and quadrature-phase (Q) signals.
        ///    Refer to the Quadrature Skew help topic for a graphical representation of the quadrature skew.
        ///    Note: If the magnitude of the carrier or the sample clock frequency offset is greater than 25 ppm, I/Q gain imbalance magnitude is    greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees, the estimates of these impairments may be inaccurate. 
        ///    Note: Quadrature skew cannot be measured for signals with differential binary phase-shift keying (DBPSK) modulation.    The DBPSK modulation corresponds to a data rate of 1 Mbps. The Quadrature skew measurement may fail for other modulation schemes,    for example, differential quadrature phase-shift keying (DQPSK) and 8-PSK, if    there are not enough constellation points in all    quadrants of the I/Q phase plane. The DQPSK modulation corresponds to data rates of 2 Mbps, 5.5 Mbps, and 11 Mbps, and the 8-PSK modulation    corresponds to data rates of 22 Mbps and 33 Mbps.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodQuadratureSkewStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodQuadratureSkewStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average of carrier suppression estimates across iterations. This value is expressed in dB.
        ///    The toolkit does not compute the carrier suppression according to section 18.4.7.7 of IEEE Standard 802.11b-1999, where    the measurement is specified to be done on the spectrum of the signal. The toolkit computes the carrier    suppression as the normalized DC offset, which is a ratio of the DC power to the power of the signal.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodCarrierSuppressionAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierSuppressionAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum of carrier suppression estimates across iterations. This value is expressed in dB.
        ///    The toolkit does not compute the carrier suppression according to section 18.4.7.7 of IEEE Standard 802.11b-1999, where    the measurement is specified to be done on the spectrum of the signal. The toolkit computes the carrier suppression    as the normalized DC offset, which is a ratio of the DC power to the power of the signal.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodCarrierSuppressionMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierSuppressionMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum of carrier suppression estimates across iterations. This value is expressed in dB.
        ///    The toolkit does not compute the carrier suppression according to section 18.4.7.7 of IEEE Standard 802.11b-1999, where    the measurement is specified to be done on the spectrum of the signal. The toolkit computes the    carrier suppression as the normalized DC offset, which is a ratio of the DC power to the power of the signal.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodCarrierSuppressionMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierSuppressionMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of carrier suppression estimates. This value is expressed in dB.
        ///    The toolkit does not compute the carrier suppression according to section 18.4.7.7 of IEEE Standard 802.11b-1999, where the    measurement is specified to be done on the spectrum of the signal. The toolkit computes the carrier    suppression as the normalized DC offset, which is a ratio of the DC power to the power of the signal.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodCarrierSuppressionStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierSuppressionStandardDeviation, channel, out value);
        }


        /// <summary>
        ///Returns the average of sample clock offset estimates across iterations. This value is expressed in parts per million (ppm).    The sample clock offset is the difference between the sample clocks at the digital-to-analog converter (DAC) of    the transmitting device under test (DUT) and the digitizer.
        ///    If the clock offset is more than 25 ppm, the estimated value may be inaccurate.    Use the estimated offset to verify whether the DUT corresponds to section 18.4.7.5 of IEEE Standard 802.11b-1999 and section 20.3.21.6 of    IEEE Standard 802.11n-2009.
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm, I/Q gain imbalance    magnitude is greater than 3 dB,    and quadrature skew magnitude is greater than 15 degrees, the estimates of these impairments may be inaccurate.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodSampleClockOffsetAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodSampleClockOffsetAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum of sample clock offset estimates across iterations. This value is expressed in parts per million (ppm).    The sample clock offset is the difference between the sample clocks at the digital-to-analog converter (DAC) of    the transmitting device under test (DUT) and the digitizer. 
        ///    If the clock offset is more than 25 ppm, the estimated value may be inaccurate.    Use the estimated offset to verify whether the DUT corresponds to section 18.4.7.5 of IEEE Standard 802.11b-1999 and section 20.3.21.6 of    IEEE Standard 802.11n-2009.
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm, I/Q gain imbalance    magnitude is greater than 3 dB,    and quadrature skew magnitude is greater than 15 degrees, the estimates of these impairments may be inaccurate.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodSampleClockOffsetMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodSampleClockOffsetMinimum, channel, out value);
        }


        /// <summary>
        ///Returns the maximum of sample clock offset estimates across iterations. This value is expressed in parts per million (ppm).    The sample clock offset is the difference between the sample clocks at the digital-to-analog converter (DAC) of    the transmitting device under test (DUT) and the digitizer. 
        ///    If the clock offset is more than 25 ppm, the estimated value may be inaccurate.    Use the estimated offset to verify whether the DUT corresponds to section 18.4.7.5 of IEEE Standard 802.11b-1999 and section 20.3.21.6 of    IEEE Standard 802.11n-2009.
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm, I/Q gain imbalance    magnitude is greater than 3 dB,    and quadrature skew magnitude is greater than 15 degrees, the estimates of these impairments may be inaccurate.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodSampleClockOffsetMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodSampleClockOffsetMaximum, channel, out value);
        }


        /// <summary>
        ///Returns the standard deviation of sample clock offset estimates. This value is expressed in parts per million (ppm).    The sample clock offset is the difference between the sample clocks at the digital-to-analog converter (DAC) of    the transmitting device under test (DUT) and the digitizer. 
        ///    If the clock offset is more than 25 ppm, the estimated value may be inaccurate.    Use the estimated offset to verify whether the DUT corresponds to section 18.4.7.5 of IEEE Standard 802.11b-1999 and section 20.3.21.6 of    IEEE Standard 802.11n-2009.
        ///    Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm, I/Q gain imbalance    magnitude is greater than 3 dB,    and quadrature skew magnitude is greater than 15 degrees, the estimates of these impairments may be inaccurate.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodSampleClockOffsetStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodSampleClockOffsetStandardDeviation, channel, out value);
        }


        #endregion

        #region Missing Set/Get Added

        /// <summary>
        ///Specifies whether the toolkit needs to set measurement bandwidth equal to channel bandwidth for channel    power measurements. If you want to specify the measurement bandwidth, set    the NIWLANA_SPECTRAL_MEASUREMENTS_CHANNEL_POWER_AUTO_MEASURE_BW_ENABLED attribute to NIWLANA_VAL_FALSE.
        ///     The default value is NIWLANA_VAL_TRUE. 
        /// 	   Get Function: niWLANA_GetSpectralMeasurementsChPowerAutoMeasureBWEnabled
        ///    Set Function: niWLANA_SetSpectralMeasurementsChPowerAutoMeasureBWEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMeasurementsChannelPowerAutoMeasureBwEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.SpectralMeasurementsChannelPowerAutoMeasureBWEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether the toolkit needs to set measurement bandwidth equal to channel bandwidth for channel    power measurements. If you want to specify the measurement bandwidth, set    the NIWLANA_SPECTRAL_MEASUREMENTS_CHANNEL_POWER_AUTO_MEASURE_BW_ENABLED attribute to NIWLANA_VAL_FALSE.
        ///     The default value is NIWLANA_VAL_TRUE. 
        /// 	   Get Function: niWLANA_GetSpectralMeasurementsChPowerAutoMeasureBWEnabled
        ///    Set Function: niWLANA_SetSpectralMeasurementsChPowerAutoMeasureBWEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMeasurementsChannelPowerAutoMeasureBwEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMeasurementsChannelPowerAutoMeasureBWEnabled, channelString, out value);
        }


        /// <summary>
        ///Specifies whether to enable the service bits trace. The trace returns decoded bit sequence from the Service field of the signal. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMServiceBitsTraceEnabled
        ///    Set Function: niWLANA_SetOFDMServiceBitsTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodServiceBitsTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodServiceBitsTraceEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether to enable the service bits trace. The trace returns decoded bit sequence from the Service field of the signal. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMServiceBitsTraceEnabled
        ///    Set Function: niWLANA_SetOFDMServiceBitsTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodServiceBitsTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodServiceBitsTraceEnabled, channelString, out value);
        }


        /// <summary>
        ///Specifies whether to enable stream power measurement on combined signal. 
        ///    You must set NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE to perform stream power measurement. 
        ///    The default value is  NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMStreamPowerEnabled
        ///    Set Function: niWLANA_SetOFDMStreamPowerEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodStreamPowerEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodStreamPowerEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether to enable stream power measurement on combined signal. 
        ///    You must set NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE to perform stream power measurement. 
        ///    The default value is  NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMStreamPowerEnabled
        ///    Set Function: niWLANA_SetOFDMStreamPowerEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodStreamPowerEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodStreamPowerEnabled, channelString, out value);
        }


        /// <summary>
        ///Specifies whether to estimate common phase error. 
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetOFDMPhaseErrorEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMPhaseErrorEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodCommonPhaseErrorEstimationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodCommonPhaseErrorEstimationEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether to estimate common phase error. 
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetOFDMPhaseErrorEstimationEnabled
        ///    Set Function: niWLANA_SetOFDMPhaseErrorEstimationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodCommonPhaseErrorEstimationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodCommonPhaseErrorEstimationEnabled, channelString, out value);
        }


        /// <summary>
        ///Specifies the measurement bandwidth. This value is expressed in Hz. The toolkit ignores this attribute if you set    the NIWLANA_SPECTRAL_MEASUREMENTS_CHANNEL_POWER_AUTO_MEASURE_BW_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    The default value is 20 MHz. 
        ///    Get Function: niWLANA_GetSpectralMeasurementChannelPowerMeasurementBandwidth
        ///    Set Function: niWLANA_SetSpectralMeasurementChannelPowerMeasurementBandwidth
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMeasurementsChannelPowerMeasurementBandwidth(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.SpectralMeasurementsChannelPowerMeasurementBandwidth, channelString, value);
        }

        /// <summary>
        ///Specifies the measurement bandwidth. This value is expressed in Hz. The toolkit ignores this attribute if you set    the NIWLANA_SPECTRAL_MEASUREMENTS_CHANNEL_POWER_AUTO_MEASURE_BW_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    The default value is 20 MHz. 
        ///    Get Function: niWLANA_GetSpectralMeasurementChannelPowerMeasurementBandwidth
        ///    Set Function: niWLANA_SetSpectralMeasurementChannelPowerMeasurementBandwidth
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMeasurementsChannelPowerMeasurementBandwidth(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.SpectralMeasurementsChannelPowerMeasurementBandwidth, channelString, out value);
        }


        /// <summary>
        /// Specifies the duration, in seconds, of the portion of the acquired waveform, from the beginning, that the toolkit uses for AMPM measurement
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAmpmMeasurementsMeasurementInterval(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.AmpmMeasurementsMeasurementInterval, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAmpmMeasurementsMeasurementInterval(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.AmpmMeasurementsMeasurementInterval, channelString, out value);
        }


        /// <summary>
        ///Returns the channel power over    the bandwidth defined by the NIWLANA_SPECTRAL_MEASUREMENTS_CHANNEL_POWER_MEASUREMENT_BANDWIDTH and    NIWLANA_SPECTRAL_MEASUREMENTS_CHANNEL_POWER_AUTO_MEASURE_BW_ENABLED attributes. This value is expressed in dBm. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Get Function: niWLANA_GetSpectralMeasurementChannelPower
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultSpectralMeasurementsChannelPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultSpectralMeasurementsChannelPower, channelString, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of average power of the acquired burst. This value is expressed in dBm. 
        ///    You can use this measurement to verify that the device under test (DUT) conforms to section 17.3.9.1 of IEEE Standard 802.11a-1999,    section 18.4.7.1 of IEEE Standard 802.11b-1999, or section 20.3.21.3 of IEEE Standard 802.11n-2009, all of which specify maximum    output power in certain cases. This value is expressed in mW. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpAveragePowerMinimum(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpAveragePowerMinimum, channelString, out value);
        }


        /// <summary>
        /// Returns an array of the coefficients of the 7th order polynomial, which is used to fit a curve to measured AMPM characteristics
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetResultAmpmMeasurementsAmpmPolynomialCoefficients(string channelString, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultAmpmMeasurementsAmpmPolynomialCoefficients, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        /// Returns an array of the coefficients of the 7th order polynomial which is used to fit a curve to measured AMAM characteristics
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetResultAmpmMeasurementsAmamPolynomialCoefficients(string channelString, double[] value, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultAmpmMeasurementsAmamPolynomialCoefficients, value, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns average stream power  across iterations for combined signal demod. This value is expressed in dBm. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use 'streamx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]streamy' as the active channel string format    to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodStreamPowerAverage(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodStreamPowerAverage, channelString, out value);
        }


        /// <summary>
        ///Returns minimum stream power across iterations for combined signal demod. This value is expressed in dBm. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use 'streamx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]streamy' as the active channel string format    to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodStreamPowerMinimum(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodStreamPowerMinimum, channelString, out value);
        }


        /// <summary>
        ///Returns maximum stream power across iterations for combined signal demod. This value is expressed in dBm. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use 'streamx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]streamy' as the active channel string format    to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodStreamPowerMaximum(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodStreamPowerMaximum, channelString, out value);
        }


        /// <summary>
        ///Returns standard deviation stream power across iterations for combined signal demod. This value is expressed in dBm. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use 'streamx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED    attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]streamy' as the active channel string format    to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodStreamPowerStandardDeviation(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodStreamPowerStandardDeviation, channelString, out value);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodRmsPhaseError(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodRmsPhaseError, channelString, out value);
        }


        /// <summary>
        ///Returns the number of space-time streams for an 802.11ac, 802.11ah or an 802.11ax signal. When you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, this value is derived from    the MCS Index value decoded from the HT-SIG field. When you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, for a packet of SU PPDU format, this    value is derived by adding 1 to the value of SU NSTS field, as decoded from    the VHT-SIG-A field and for a packet with MU PPDU format, the value of number of    space-time streams is decoded for each user from the respective MU NSTS    field (MU[0] NSTS, MU[1] NSTS, MU[2] NSTS or MU[3] NSTS) within the VHT-SIG-A field. When you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, this value is decoded from S1G-SIG/SIG-A field. When you    set theNIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, this value is decoded from TVHT-SIG-A field. 
        ///    When you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, for a packet    of SU PPDU format or Extended Range SU PPDU format, this    value is derived from NSTS field, as decoded from the HE-SIG-A field and for a packet    with MU PPDU format, this value is decoded for each    user from the HE-SIG-B field. 
        ///    If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the    value you specify in the NIWLANA_RESULT_OFDM_DEMOD_NUMBER_OF_SPACE_TIME_STREAMS attribute    specifies the number of space-time streams.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM you must use an    empty string to query this attribute. 
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active channel string syntax to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///     Get Function: niWLANA_GetOFDMDemodNumberOfSpaceTimeStreams
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodNumberOfSpaceTimeStreams(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodNumberOfSpaceTimeStreams, channelString, out value);
        }


        /// <summary>
        ///Returns the average across iterations of RMS phase error measurement. This value is expressed in degrees. 
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodPhaseErrorRmsAverage(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodPhaseErrorRmsAverage, channelString, out value);
        }


        /// <summary>
        ///Returns the minimum across iterations of RMS phase error measurement. This value is expressed in degrees.   
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodPhaseErrorRmsMinimum(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodPhaseErrorRmsMinimum, channelString, out value);
        }


        /// <summary>
        ///Returns the maximum across iterations of RMS phase error measurement. This value is expressed in degrees. 
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodPhaseErrorRmsMaximum(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodPhaseErrorRmsMaximum, channelString, out value);
        }


        /// <summary>
        ///Returns the standard deviation across iterations of RMS phase error measurement. This value is expressed in degrees.   
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodPhaseErrorRmsStandardDeviation(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodPhaseErrorRmsStandardDeviation, channelString, out value);
        }


        #endregion

        #region Version 4.1

        /// <summary>
        ///Specifies the measurement length of the waveform to be used for direct sequence spread    spectrum (DSSS) Power Ramp Measurements. This value is expressed in seconds.
        ///     If you enable the DSSS Power Ramp measurement along with other measurements and set this attribute to -1, the measurement    length used for DSSS Power Ramp measurement is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. 
        ///    The default value is 1 ms. 
        ///    Get Function: niWLANA_GetDSSSPowerRampMeasurementLength
        ///    Set Function: niWLANA_SetDSSSPowerRampMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDSSSPowerRampMeasurementLength(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.DsssPowerRampMeasurementLength, channelString, value);
        }

        /// <summary>
        ///Specifies whether the toolkit automatically computes the measurement length based on the NIWLANA_OFDM_DEMOD_MAXIMUM_SYMBOLS_USED    and NIWLANA_OFDM_DEMOD_MEASUREMENT_START_LOCATION attributes. 
        ///    You can query the value of the automatically computed measurement length by using the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute.
        ///    Note: The upper limits of the measurement length depend on the NIWLANA_CHANNEL_BANDWIDTH attribute as shown below. 
        ///    If the NIWLANA_CHANNEL_BANDWIDTH attribute is set to 1, 2, 4, 8, or 16 MHz, the upper limit for the measurement length is 21.2 ms. 
        ///    If the NIWLANA_CHANNEL_BANDWIDTH attribute is set to 5, 10 or 20 MHz, the upper limit for the measurement length is 10 ms. 
        ///    If the NIWLANA_CHANNEL_BANDWIDTH attribute is set to 40 MHz, the upper limit for the measurement length is 8 ms. 
        ///    If the NIWLANA_CHANNEL_BANDWIDTH attribute is set to 80 or 160 MHz, the upper limit for the measurement length is 5.5 ms. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodAutoComputeMeasurementLengthEnabled
        ///    Set Function: niWLANA_SetOFDMDemodAutoComputeMeasurementLengthEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodAutoComputeMeasurementLengthEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodAutoComputeMeasurementLengthEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether the toolkit automatically computes the measurement length based on the NIWLANA_OFDM_DEMOD_MAXIMUM_SYMBOLS_USED    and NIWLANA_OFDM_DEMOD_MEASUREMENT_START_LOCATION attributes. 
        ///    You can query the value of the automatically computed measurement length by using the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute.
        ///    Note: The upper limits of the measurement length depend on the NIWLANA_CHANNEL_BANDWIDTH attribute as shown below. 
        ///    If the NIWLANA_CHANNEL_BANDWIDTH attribute is set to 1, 2, 4, 8, or 16 MHz, the upper limit for the measurement length is 21.2 ms. 
        ///    If the NIWLANA_CHANNEL_BANDWIDTH attribute is set to 5, 10 or 20 MHz, the upper limit for the measurement length is 10 ms. 
        ///    If the NIWLANA_CHANNEL_BANDWIDTH attribute is set to 40 MHz, the upper limit for the measurement length is 8 ms. 
        ///    If the NIWLANA_CHANNEL_BANDWIDTH attribute is set to 80 or 160 MHz, the upper limit for the measurement length is 5.5 ms. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodAutoComputeMeasurementLengthEnabled
        ///    Set Function: niWLANA_SetOFDMDemodAutoComputeMeasurementLengthEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodAutoComputeMeasurementLengthEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodAutoComputeMeasurementLengthEnabled, channelString, out value);
        }


        /// <summary>
        /// Specifies whether to enable measurement of AM-PM and AM-AM distortions in the acquired signal. The toolkit calculates the AM-AM and AM-PM response of a power amplifier (PA) device under test (DUT) using the reference waveform input to the DUT.  The toolkit fits a 7th order polynomial to the measured AM-AM and AM-PM responses. 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmpmMeasurementsEnabled, channelString, value);
        }


        /// <summary>
        /// Specifies whether to enable measurement of AM-PM and AM-AM distortions in the acquired signal. The toolkit calculates the AM-AM and AM-PM response of a power amplifier (PA) device under test (DUT) using the reference waveform input to the DUT.  The toolkit fits a 7th order polynomial to the measured AM-AM and AM-PM responses. 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmpmMeasurementsEnabled, channelString,out value);
        }


        /// <summary>
        /// Specifies the type of waveform averaging to be done on the acquired waveform before performing AMPM measurements. 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsAveragingMode(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmpmMeasurementsAveragingMode, channelString,value);
        }


        /// <summary>
        /// Specifies the type of waveform averaging to be done on the acquired waveform before performing AMPM measurements. 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsAveragingMode(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmpmMeasurementsAveragingMode, channelString,out value);
        }


        /// <summary>
        /// Specifies the number of iterations over which the toolkit averages the acquired waveform.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsNumberOfAverages(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmpmMeasurementsNumberOfAverages, channelString, value);
        }


        /// <summary>
        /// Specifies the number of iterations over which the toolkit averages the acquired waveform.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsNumberOfAverages(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmpmMeasurementsNumberOfAverages, channelString,out value);
        }


        /// <summary>
        /// Specifies the average power level, in dBm, of the signal at the input of the power amplifier (PA) device under test (DUT). You must set this property if the <a href="attr270.html">AMPM Measurement Interval</a> property is set to <format type="bold">True</format>; otherwise, the toolkit returns an error.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsDUTInputPowerLevel(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.AmpmMeasurementsDutInputPowerLevel, channelString,value);
        }


        /// <summary>
        /// Specifies the average power level, in dBm, of the signal at the input of the power amplifier (PA) device under test (DUT). You must set this property if the <a href="attr270.html">AMPM Measurement Interval</a> property is set to <format type="bold">True</format>; otherwise, the toolkit returns an error.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsDUTInputPowerLevel(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.AmpmMeasurementsDutInputPowerLevel, channelString, out value);
        }



        /// <summary>
        /// Specifies the measurement length, in seconds, of the waveform to be used for AMPM measurements.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsMeasurementLength(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.AmpmMeasurementsMeasurementLength, channelString, value);
        }



        /// <summary>
        /// Specifies the measurement length, in seconds, of the waveform to be used for AMPM measurements.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsMeasurementLength(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.AmpmMeasurementsMeasurementLength, channelString,out value);
        }


        /// <summary>
        /// Specifies whether to enable all traces of AM-PM measurements.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsAllTracesEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmpmMeasurementsAllTracesEnabled, channelString, value);
        }


        /// <summary>
        /// Specifies whether to enable all traces of AM-PM measurements.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsAllTracesEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmpmMeasurementsAllTracesEnabled, channelString,out value);
        }


        /// <summary>
        /// Specifies whether to enable the trace of measured AM-AM distortion of the acquired waveform. The AM-AM trace is a plot of the measured AM-AM gain (dB) versus instantaneous input power (dBm) of every sample in the acquired signal, which is 17.5 dB below the peak power of the signal.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsAMAMTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmpmMeasurementsAmamTraceEnabled, channelString, value);
        }


        /// <summary>
        /// Specifies whether to enable the trace of measured AM-AM distortion of the acquired waveform. The AM-AM trace is a plot of the measured AM-AM gain (dB) versus instantaneous input power (dBm) of every sample in the acquired signal, which is 17.5 dB below the peak power of the signal.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsAMAMTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmpmMeasurementsAmamTraceEnabled, channelString, out value);
        }


        /// <summary>
        /// Specifies whether to enable the trace of measured AM-PM distortion of the acquired waveform. The AM-PM trace is a plot of measured phase error, in degrees, versus instantaneous input power, in dBm, of every sample in the acquired signal, which is 17.5 dB below the peak power of the signal.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsAMPMTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmpmMeasurementsAmpmTraceEnabled, channelString, value);
        }


        /// <summary>
        /// Specifies whether to enable the trace of measured AM-PM distortion of the acquired waveform. The AM-PM trace is a plot of measured phase error, in degrees, versus instantaneous input power, in dBm, of every sample in the acquired signal, which is 17.5 dB below the peak power of the signal.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsAMPMTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmpmMeasurementsAmpmTraceEnabled, channelString,out value);
        }


        /// <summary>
        /// Specifies whether to enable the trace of the curve obtained by doing a polynomial fit on measured AM-AM distortion values of the acquired waveform.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsAMAMCurveFitTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmpmMeasurementsAmamCurveFitTraceEnabled, channelString, value);
        }


        /// <summary>
        /// Specifies whether to enable the trace of the curve obtained by doing a polynomial fit on measured AM-AM distortion values of the acquired waveform.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsAMAMCurveFitTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmpmMeasurementsAmamCurveFitTraceEnabled, channelString, out value);
        }


        /// <summary>
        /// Specifies whether to enable the trace of the curve obtained by doing a polynomial fit on measured AM-PM distortion values of the acquired waveform.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsAMPMCurveFitTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmpmMeasurementsAmpmCurveFitTraceEnabled, channelString,value);
        }



        /// <summary>
        /// Specifies whether to enable the trace of the curve obtained by doing a polynomial fit on measured AM-PM distortion values of the acquired waveform.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsAMPMCurveFitTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmpmMeasurementsAmpmCurveFitTraceEnabled, channelString, out value);
        }

        /// <summary>
        /// Specifies whether to enable the mean acquired waveform trace.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsMeanAcquiredWaveformTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmpmMeasurementsMeanAcquiredWaveformTraceEnabled, channelString, value);
        }

        /// <summary>
        /// Specifies whether to enable the mean acquired waveform trace.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsMeanAcquiredWaveformTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmpmMeasurementsMeanAcquiredWaveformTraceEnabled, channelString,out value);
        }


        /// <summary>
        /// Specifies whether to enable the processed reference waveform trace.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetAMPMMeasurementsProcessedReferenceWaveformTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmpmMeasurementsProcessedReferenceWaveformTraceEnabled, channelString, value);
        }


        /// <summary>
        /// Specifies whether to enable the processed reference waveform trace.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsProcessedReferenceWaveformTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmpmMeasurementsProcessedReferenceWaveformTraceEnabled, channelString,out value);
        }


        /// <summary>
        /// Returns an array of the coefficients of the 7th order polynomial, which is used to fit a curve to measured AMPM characteristics.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMPolynomialCoefficients(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            int pInvokeResult = PInvoke.niWLANA_GetAMPMPolynomialCoefficients(Handle, channelString, dataArray, dataArraySize, out actualNumDataArrayElements);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns an array of the coefficients of the 7th order polynomial, which is used to fit a curve to measured AMAM characteristics.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetAMAMPolynomialCoefficients(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            int pInvokeResult = PInvoke.niWLANA_GetAMAMPolynomialCoefficients(Handle, channelString, dataArray, dataArraySize, out actualNumDataArrayElements);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns the power, in dBm, corresponding to a 1 dB compression point of the AM-AM curve.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurements1dbCompressionPoint(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAmpmMeasurements1DbCompressionPoint, channelString, out value);
        }

        /// <summary>
        /// Returns the peak-to-peak variation of phase error, in degrees, in AMPM measurement.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsPhaseErrorRange(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAmpmMeasurementsPhaseErrorRange, channelString, out value);
        }
    

        /// <summary>
        /// Returns the peak-to-peak variation of gain, in dB, in AMAM measurement.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsGainErrorRange(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAmpmMeasurementsGainErrorRange, channelString, out value);
        }


        /// <summary>
        /// Returns the mean square residual error, in degrees, of the curve obtained by doing a polynomial fit on measured AM-PM distortion values of the acquired waveform.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsAMPMResidual(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAmpmMeasurementsAmpmResidual, channelString, out value);
        }


        /// <summary>
        /// Returns the mean square residual error, in dB, of the curve obtained by doing a polynomial fit on measured AM-AM distortion values of the acquired waveform.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsAMAMResidual(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAmpmMeasurementsAmamResidual, channelString, out value);
        }

        /// <summary>
        /// Returns the mean, in dB, of the curve fit to AM-PM response.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsAveragePhaseError(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAmpmMeasurementsAveragePhaseError, channelString, out value);
        }


        /// <summary>
        /// Returns the mean, in dB, of the curve fit to AM-AM response.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsAverageGain(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAmpmMeasurementsAverageGain, channelString, out value);
        }


        /// <summary>
        /// Returns the actual minimum power (threshold), in dB, of the PA input signal, used in AMPM measurement.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsMinimumInputPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAmpmMeasurementsMinimumInputPower, channelString, out value);
        }


        /// <summary>
        /// Returns the actual peak power, in dB, of the PA input signal, used in AMPM measurement.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetAMPMMeasurementsMaximumInputPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAmpmMeasurementsMaximumInputPower, channelString, out value);
        }


        /// <summary>
        /// Configures the toolkit for an EVM measurement such that the measurement is optimized for speed. Use this function in a power amplifier (PA) test setup consisting of an NI RF vector signal generator feeding an RF signal to a PA device-under-test (DUT) in which the RF output signal is being analyzed by the signal analyzer. The niWLANA_ConfigureFastEVM function assumes that there is no carrier frequency offset and sample clock offset between the generator and the analyzer.
        /// If you set the standard parameter to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM the function disables impairments estimation, header detection, burst start detection, channel EVM measurement, channel matrix power measurement, spectral flatness margin measurement, MAC FCS check, VHT-SIG-B CRC check, and 80211n PLCP frame format detection. 
        /// If you set the standard parameter to NIWLANA_VAL_STANDARD_80211BG_DSSS, the function disables impairments estimation, burst start detection, header detection, and MAC FCS check.
        /// If you set the standard parameter to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM the following tasks are  applicable.
        /// The function completes the following tasks:
        /// Sets the NIWLANA_OFDM_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// Sets the NIWLANA_OFDM_DEMOD_CFO_ESTIMATION_METHOD attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_OFDM_DEMOD_SAMPLE_CLOCK_OFFSET_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_IQ_GAIN_IMBALANCE_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_QUADRATURE_SKEW_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_TIMING_SKEW_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.  
        /// Sets the NIWLANA_OFDM_DEMOD_CARRIER_FREQUENCY_LEAKAGE_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_COMMON_PILOT_ERROR_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_COMMON_PHASE_ERROR_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_BURST_START_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_OFDM_DEMOD_CHANNEL_EVM_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_CHANNEL_MATRIX_POWER_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_SPECTRAL_FLATNESS_MARGIN_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_MAC_FRAME_CHECK_SEQUENCE_CHECK_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_OFDM_DEMOD_VHT_SIG_B_CRC_CHECK_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_80211N_PLCP_FRAME_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Because the niWLANA_ConfigureFastEVM function configures the above attributes, you must configure the following attributes:
        /// NIWLANA_OFDM_DEMOD_MAXIMUM_SYMBOLS_USED
        /// NIWLANA_OFDM_PPDU_TYPE 
        /// NIWLANA_OFDM_PAYLOAD_LENGTH
        /// NIWLANA_OFDM_L_SIG_PAYLOAD_LENGTH
        /// NIWLANA_OFDM_DATA_RATE
        /// NIWLANA_MCS_INDEX
        /// NIWLANA_GUARD_INTERVAL TYPE
        /// NIWLANA_STBC_INDEX
        /// NIWLANA_NUMBER_OF_SPACE_TIME_STREAMS
        /// NIWLANA_80211N_PLCP_FRAME_FORMAT
        /// If the standard parameter is set to 80211B/G DSSS, the following is applicable.
        /// The function completes the following tasks:
        /// Sets the NIWLANA_DSSS_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// Sets the NIWLANA_DSSS_DEMOD_CARRIER_FREQUENCY_OFFSET_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_SAMPLE_CLOCK_OFFSET_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_IQ_GAIN_IMBALANCE_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_QUADRATURE_SKEW_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_CARRIER_SUPPRESSION_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_BURST_START_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_DSSS_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_MAC_FRAME_CHECK_SEQUENCE_CHECK_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Because the function configures the above attributes, you must configure the following attributes:
        /// NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED
        /// NIWLANA_DSSS_PAYLOAD_LENGTH
        /// NIWLANA_DSSS_DATA_RATE
        /// 
        /// </summary>
        ///<param name = "standard">
        /// Specifies the IEEE 802.11 standard, which includes the type of physical layer, for signal analysis. The default value is NIWLANA_VAL_STANDARD_80211AG_OFDM.
        /// NIWLANA_VAL_STANDARD_80211AG_OFDM (0), NIWLANA_VAL_STANDARD_80211J_OFDM (7), NIWLANA_VAL_STANDARD_80211P_OFDM (8)
        /// Corresponds to the OFDM mode defined in the IEEE Standard 802.11a-1999, IEEE Standard 802.11j-2004, and IEEE Standard 802.11p-2010, and the extended rate physical layer-OFDM (ERP-OFDM) mode, as defined in IEEE Standard 802.11g-2003.
        /// NIWLANA_VAL_STANDARD_80211BG_DSSS (1)
        /// Corresponds to all the compulsory and optional modes defined in IEEE Standard 802.11b-1999 and the ERP-packet binary convolutional coding (ERP-PBCC) mode in IEEE Standard 802.11g-2003.
        /// NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM (2)
        /// Corresponds to the optional DSSS-OFDM mode defined in IEEE Standard 802.11g-2003.
        /// NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM (3)
        /// Corresponds to IEEE Standard 802.11n-2009.
        /// NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM (4)
        /// Corresponds to IEEE Standard 802.11ac-2013. 
        /// NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM (5)
        /// Corresponds to IEEE Standard 802.11af-2013. 
        /// NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM (6)
        /// Corresponds to IEEE Standard IEEE P802.11ax/D1.2. 
        /// 
        ///</param>
        ///<param name = "channelBandwidth">
        /// Specifies the channel bandwidth. 
        /// The default value is 20 MHz.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_ConfigureFastEVM
        /// int32 __stdcall niWLANA_ConfigureFastEVM (niWLANA session, int32 standard, float64 channelBandwidth[]);
        /// Purpose
        /// Configures the toolkit for an EVM measurement such that the measurement is optimized for speed. Use this function in a power amplifier (PA) test setup consisting of an NI RF vector signal generator feeding an RF signal to a PA device-under-test (DUT) in which the RF output signal is being analyzed by the signal analyzer. The niWLANA_ConfigureFastEVM function assumes that there is no carrier frequency offset and sample clock offset between the generator and the analyzer.
        /// If you set the standard parameter to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM the function disables impairments estimation, header detection, burst start detection, channel EVM measurement, channel matrix power measurement, spectral flatness margin measurement, MAC FCS check, VHT-SIG-B CRC check, and 80211n PLCP frame format detection. 
        /// If you set the standard parameter to NIWLANA_VAL_STANDARD_80211BG_DSSS, the function disables impairments estimation, burst start detection, header detection, and MAC FCS check.
        /// If you set the standard parameter to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM the following tasks are  applicable.
        /// The function completes the following tasks:
        /// Sets the NIWLANA_OFDM_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// Sets the NIWLANA_OFDM_DEMOD_CFO_ESTIMATION_METHOD attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_OFDM_DEMOD_SAMPLE_CLOCK_OFFSET_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_IQ_GAIN_IMBALANCE_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_QUADRATURE_SKEW_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_TIMING_SKEW_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.  
        /// Sets the NIWLANA_OFDM_DEMOD_CARRIER_FREQUENCY_LEAKAGE_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_COMMON_PILOT_ERROR_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_COMMON_PHASE_ERROR_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_BURST_START_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_OFDM_DEMOD_CHANNEL_EVM_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_CHANNEL_MATRIX_POWER_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_SPECTRAL_FLATNESS_MARGIN_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_MAC_FRAME_CHECK_SEQUENCE_CHECK_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_OFDM_DEMOD_VHT_SIG_B_CRC_CHECK_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_OFDM_DEMOD_80211N_PLCP_FRAME_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Because the niWLANA_ConfigureFastEVM function configures the above attributes, you must configure the following attributes:
        /// NIWLANA_OFDM_DEMOD_MAXIMUM_SYMBOLS_USED
        /// NIWLANA_OFDM_PPDU_TYPE 
        /// NIWLANA_OFDM_PAYLOAD_LENGTH
        /// NIWLANA_OFDM_L_SIG_PAYLOAD_LENGTH
        /// NIWLANA_OFDM_DATA_RATE
        /// NIWLANA_MCS_INDEX
        /// NIWLANA_GUARD_INTERVAL TYPE
        /// NIWLANA_STBC_INDEX
        /// NIWLANA_NUMBER_OF_SPACE_TIME_STREAMS
        /// NIWLANA_80211N_PLCP_FRAME_FORMAT
        /// If the standard parameter is set to 80211B/G DSSS, the following is applicable.
        /// The function completes the following tasks:
        /// Sets the NIWLANA_DSSS_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// Sets the NIWLANA_DSSS_DEMOD_CARRIER_FREQUENCY_OFFSET_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_SAMPLE_CLOCK_OFFSET_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_IQ_GAIN_IMBALANCE_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_QUADRATURE_SKEW_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_CARRIER_SUPPRESSION_ESTIMATION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_BURST_START_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE. 
        /// Sets the NIWLANA_DSSS_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Sets the NIWLANA_DSSS_DEMOD_MAC_FRAME_CHECK_SEQUENCE_CHECK_ENABLED attribute to NIWLANA_VAL_FALSE.
        /// Because the function configures the above attributes, you must configure the following attributes:
        /// NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED
        /// NIWLANA_DSSS_PAYLOAD_LENGTH
        /// NIWLANA_DSSS_DATA_RATE
        /// 
        ///</returns>
        public int ConfigureFastEVM(int standard, double channelBandwidth)
        {
            int pInvokeResult = PInvoke.niWLANA_ConfigureFastEVM(Handle, standard, channelBandwidth);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns the CCDF trace of the time domain signal power when you set the NIWLANA_CCDF_TRACE_ENABLED attribute to NIWLANA_VAL_CCDF_TRACE_ENABLED_TRUE. The CCDF plot shows the probability that the power of signal is above a specific level versus the relative power level above average. This function also returns a CCDF trace for Gaussian noise with equivalent average and peak power.
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "signalCcdfMinBin">
        /// Indicates the bin centered at the minimum power value.
        /// 
        ///</param>
        ///<param name = "signalCcdfBinSize">
        /// Indicates the size of each bin. 
        /// 
        ///</param>
        ///<param name = "signalCcdf">
        /// Indicates the CCDF values of the signal.
        /// 
        ///</param>
        ///<param name = "signalCcdfDataArraySize">
        /// Specifies the size of the signalCCDF array.
        /// 
        ///</param>
        ///<param name = "signalCcdfActualArraySize">
        /// Returns the number of elements in the signalCCDF array. If the signalCCDF array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the signalCCDF array.
        /// 
        ///</param>
        ///<param name = "guassianCcdfBinSize">
        /// Indicates the size of each bin.
        /// 
        ///</param>
        ///<param name = "guassianCcdfMinSize">
        /// Indicates the bin centered at the minimum power value.
        /// 
        ///</param>
        ///<param name = "gaussianCcdf">
        /// Indicates the CCDF values of the signal.
        /// 
        ///</param>
        ///<param name = "gaussianCcdfDataArraySize">
        /// Specifies the size of the gaussianCCDF array.
        /// 
        ///</param>
        ///<param name = "gaussianCcdfActualArraySize">
        /// Returns the number of elements in the gaussianCCDF array. If the gaussianCCDF array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the gaussianCCDF array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCCDFTrace
        /// int32 __stdcall niWLANA_GetCCDFTrace(
        ///     niWLANA session, 
        ///     char activeChannel[], 
        ///     double *signalCCDFMinBin, 
        ///     double *signalCCDFBinSize, 
        ///     double signalCCDF[], 
        ///     int32 signalCCDFDataArraySize, 
        ///     int32 *signalCCDFActualArraySize, 
        ///     double *gaussianCCDFBinSize, 
        ///     double *gaussianCCDFMinBin, 
        ///     double gaussianCCDF[], 
        ///     int32 gaussianCCDFDataArraySize, 
        ///     int32 *gaussianCCDFActualArraySize);    
        /// Purpose
        /// Returns the CCDF trace of the time domain signal power when you set the NIWLANA_CCDF_TRACE_ENABLED attribute to NIWLANA_VAL_CCDF_TRACE_ENABLED_TRUE. The CCDF plot shows the probability that the power of signal is above a specific level versus the relative power level above average. This function also returns a CCDF trace for Gaussian noise with equivalent average and peak power.
        /// 
        ///</returns>
        public int GetCCDFTrace(string channelString, out double signalCcdfMinBin, out  double signalCcdfBinSize, double[] signalCcdf, int signalCcdfDataArraySize, out int signalCcdfActualArraySize, out double guassianCcdfBinSize, out double guassianCcdfMinSize, double[] gaussianCcdf, int gaussianCcdfDataArraySize, out int gaussianCcdfActualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCCDFTrace(Handle, channelString, out signalCcdfMinBin, out signalCcdfBinSize, signalCcdf, signalCcdfDataArraySize, out signalCcdfActualArraySize, out guassianCcdfBinSize, out guassianCcdfMinSize, gaussianCcdf, gaussianCcdfDataArraySize, out gaussianCcdfActualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        ///Specifies whether I/Q power-edge Reference trigger is used for acquisition for the first (master)    device when multiple device synchronization is needed. 
        ///    When you set this attribute to NIWLANA_VAL_TRUE, the NIRFSA_ATTR_SYNC_REF_TRIGGER_DELAY_ENABLED attribute    is set to NIRFSA_VAL_DISABLED in the niWLANA_RFSAConfigureMultipleDeviceSynchronization function. This attribute    is valid only if you use NI 5644R, NI 5645R, NI 5646R RF vector signal analyzers. 
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetIQPowerEdgeReferenceTriggerEnabled
        ///    Set Function: niWLANA_SetIQPowerEdgeReferenceTriggerEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        /// SetIqPowerEdgeReferenceTriggerEnabled
        public int SetIQPowerEdgeReferenceTriggerEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.IqPowerEdgeReferenceTriggerEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether I/Q power-edge Reference trigger is used for acquisition for the first (master)    device when multiple device synchronization is needed. 
        ///    When you set this attribute to NIWLANA_VAL_TRUE, the NIRFSA_ATTR_SYNC_REF_TRIGGER_DELAY_ENABLED attribute    is set to NIRFSA_VAL_DISABLED in the niWLANA_RFSAConfigureMultipleDeviceSynchronization function. This attribute    is valid only if you use NI 5644R, NI 5645R, NI 5646R RF vector signal analyzers. 
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetIQPowerEdgeReferenceTriggerEnabled
        ///    Set Function: niWLANA_SetIQPowerEdgeReferenceTriggerEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetIQPowerEdgeReferenceTriggerEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.IqPowerEdgeReferenceTriggerEnabled, channelString, out value);
        }


        /// <summary>
        ///Specifies whether to enable TClk synchronized acquisition, when the toolkit is configured for multiple NI-RFSAs. 
        ///    For synchronized acquisition, set this attribute to NIWLANA_VAL_TCLK_SYNCHRONIZATION_ENABLED_TRUE using the     niTClk_ConfigureForHomogeneousTriggers function, niTClk_Synchronize function, and niTClk_Initiate function.  
        ///    The toolkit ignores this attribute if you use the NI 5644R, NI 5645R, or NI 5646R RF vector signal transceiver devices. 
        ///    For additional information, refer to the NI-TClk Synchronization Help topic in NI RF Vector Signal Analyzer Help. 
        ///    The default value is NIWLANA_VAL_TCLK_SYNCHRONIZATION_ENABLED_FALSE.
        ///    Get Function: niWLANA_GetTClkSynchronizationEnabled
        ///    Set Function: niWLANA_SetTClkSynchronizationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetTClkSynchronizationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.TclkSynchronisationEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether to enable TClk synchronized acquisition, when the toolkit is configured for multiple NI-RFSAs. 
        ///    For synchronized acquisition, set this attribute to NIWLANA_VAL_TCLK_SYNCHRONIZATION_ENABLED_TRUE using the     niTClk_ConfigureForHomogeneousTriggers function, niTClk_Synchronize function, and niTClk_Initiate function.  
        ///    The toolkit ignores this attribute if you use the NI 5644R, NI 5645R, or NI 5646R RF vector signal transceiver devices. 
        ///    For additional information, refer to the NI-TClk Synchronization Help topic in NI RF Vector Signal Analyzer Help. 
        ///    The default value is NIWLANA_VAL_TCLK_SYNCHRONIZATION_ENABLED_FALSE.
        ///    Get Function: niWLANA_GetTClkSynchronizationEnabled
        ///    Set Function: niWLANA_SetTClkSynchronizationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetTClkSynchronizationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.TclkSynchronisationEnabled, channelString,out value);
        }


        /// <summary>
        ///Specifies whether to enable configuration for sharing of local oscillator (LO) signal for multiple NI RF vector signal    analyzers or vector signal transceivers. 
        ///    The niWLANA_RFSAConfigureMultipleDeviceSynchronization function reads this attribute. 
        ///    The default value is NIWLANA_VAL_LO_SHARING_ENABLED_TRUE if the compatibilityVersion parameter    of the niWLANA_OpenSession function is set to a value other    than NIWLANA_VAL_COMPATIBILITY_VERSION_050000, and NIWLANA_VAL_LO_SHARING_ENABLED_FALSE otherwise.
        ///    Get Function: niWLANA_GetLOSharingEnabled
        ///    Set Function: niWLANA_SetLOSharingEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetLOSharingEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.LoSharingEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether to enable configuration for sharing of local oscillator (LO) signal for multiple NI RF vector signal    analyzers or vector signal transceivers. 
        ///    The niWLANA_RFSAConfigureMultipleDeviceSynchronization function reads this attribute. 
        ///    The default value is NIWLANA_VAL_LO_SHARING_ENABLED_TRUE if the compatibilityVersion parameter    of the niWLANA_OpenSession function is set to a value other    than NIWLANA_VAL_COMPATIBILITY_VERSION_050000, and NIWLANA_VAL_LO_SHARING_ENABLED_FALSE otherwise.
        ///    Get Function: niWLANA_GetLOSharingEnabled
        ///    Set Function: niWLANA_SetLOSharingEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetLOSharingEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.LoSharingEnabled, channelString,out value);
        }


        /// <summary>
        ///Specifies the type of physical layer convergence procedure (PLCP) protocol data unit (PPDU) if you set the NIWLANA_STANDARD attribute to     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. The toolkit    ignores this attribute if the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute    is set to NIWLANA_VAL_TRUE.   The default value is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU. 
        ///    Get Function: niWLANA_GetOFDMPPDUType
        ///    Set Function: niWLANA_SetOFDMPPDUType
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMPPDUType(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmPpduType, channelString, value);
        }

        /// <summary>
        ///Specifies the type of physical layer convergence procedure (PLCP) protocol data unit (PPDU) if you set the NIWLANA_STANDARD attribute to     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. The toolkit    ignores this attribute if the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute    is set to NIWLANA_VAL_TRUE.   The default value is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU. 
        ///    Get Function: niWLANA_GetOFDMPPDUType
        ///    Set Function: niWLANA_SetOFDMPPDUType
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMPPDUType(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmPpduType, channelString, out value);
        }


        /// <summary>
        ///Specifies the number of users in a multi-user (MU) physical layer convergence procedure (PLCP) protocol data unit (PPDU). This    attribute is applicable only when you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute to    NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, and    the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    The default value is 1.
        ///    Get Function: niWLANA_GetOFDMNumberOfUsers
        ///    Set Function: niWLANA_SetOFDMNumberOfUsers
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMNumberOfUsers(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmNumberOfUsers, channelString, value);
        }


        /// <summary>
        ///Specifies the number of users in a multi-user (MU) physical layer convergence procedure (PLCP) protocol data unit (PPDU). This    attribute is applicable only when you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute to    NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, and    the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    The default value is 1.
        ///    Get Function: niWLANA_GetOFDMNumberOfUsers
        ///    Set Function: niWLANA_SetOFDMNumberOfUsers
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMNumberOfUsers(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmNumberOfUsers, channelString,out value);
        }


        /// <summary>
        ///Specifies the gate length to be used for the gated spectrum acquisition. This value is expressed in seconds.
        ///     If any of the spectrum measurements is enabled along with other measurements and this attribute is set to -1, the    measurement length used for Spectrum Acquisition is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. You cannot set    the NIWLANA_GATED_SPECTRUM_MEASUREMENT_LENGTH attribute along with the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. If you    set the NIWLANA_GATED_SPECTRUM_MODE attribute to NIWLANA_VAL_GATED_SPECTRUM_MODE_MEASUREMENT_LENGTH    or NIWLANA_VAL_GATED_SPECTRUM_MODE_RBW_AND_MEASUREMENT_LENGTH, you must configure the    NIWLANA_GATED_SPECTRUM_MEASUREMENT_LENGTH attribute before    calling the niWLANA_RFSAReadGatedPowerSpectrum function    or the niWLANA_RFSAMeasure function. 
        ///    The default value is 1 ms. 
        ///    Get Function: niWLANA_GetGatedSpectrumMeasurementLength
        ///    Set Function: niWLANA_SetGatedSpectrumMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetGatedSpectrumMeasurementLength(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.GatedSpectrumMeasurementLength, channelString, value);
        }


        /// <summary>
        ///Specifies the gate length to be used for the gated spectrum acquisition. This value is expressed in seconds.
        ///     If any of the spectrum measurements is enabled along with other measurements and this attribute is set to -1, the    measurement length used for Spectrum Acquisition is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. You cannot set    the NIWLANA_GATED_SPECTRUM_MEASUREMENT_LENGTH attribute along with the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. If you    set the NIWLANA_GATED_SPECTRUM_MODE attribute to NIWLANA_VAL_GATED_SPECTRUM_MODE_MEASUREMENT_LENGTH    or NIWLANA_VAL_GATED_SPECTRUM_MODE_RBW_AND_MEASUREMENT_LENGTH, you must configure the    NIWLANA_GATED_SPECTRUM_MEASUREMENT_LENGTH attribute before    calling the niWLANA_RFSAReadGatedPowerSpectrum function    or the niWLANA_RFSAMeasure function. 
        ///    The default value is 1 ms. 
        ///    Get Function: niWLANA_GetGatedSpectrumMeasurementLength
        ///    Set Function: niWLANA_SetGatedSpectrumMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetGatedSpectrumMeasurementLength(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.GatedSpectrumMeasurementLength, channelString,out value);
        }

        /// <summary>
        ///Specifies the type of transmit power class. This attribute is valid only if you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM. Use this attribute for performing    transmit spectral mask measurement on 802.11p signals.
        ///    The default value is NIWLANA_VAL_SPECTRAL_MASK_TRANSMIT_POWER_CLASS_A. 
        ///    Get Function: niWLANA_GetSpectralMaskTransmitPowerClass
        ///    Set Function: niWLANA_SetSpectralMaskTransmitPowerClass
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMaskTransmitPowerClass(string channelString, int value)
        {
            return SetInt(niWLANAProperties.SpectralMaskTransmitPowerClass, channelString, value);
        }


        /// <summary>
        ///Specifies the type of transmit power class. This attribute is valid only if you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM. Use this attribute for performing    transmit spectral mask measurement on 802.11p signals.
        ///    The default value is NIWLANA_VAL_SPECTRAL_MASK_TRANSMIT_POWER_CLASS_A. 
        ///    Get Function: niWLANA_GetSpectralMaskTransmitPowerClass
        ///    Set Function: niWLANA_SetSpectralMaskTransmitPowerClass
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMaskTransmitPowerClass(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMaskTransmitPowerClass, channelString,out value);
        }

        /// <summary>
        ///Specifies whether to enable the channel power measurement. This measurement computes the power in a specified    measurement bandwidth of power spectrum data. 
        ///    Get Function: niWLANA_GetSpectralMeasurementsChannelPowerEnabled
        ///    Set Function: niWLANA_SetSpectralMeasurementsChannelPowerEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMeasurementsChannelPowerEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.SpectralMeasurementsChannelPowerEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether to enable the channel power measurement. This measurement computes the power in a specified    measurement bandwidth of power spectrum data. 
        ///    Get Function: niWLANA_GetSpectralMeasurementsChannelPowerEnabled
        ///    Set Function: niWLANA_SetSpectralMeasurementsChannelPowerEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMeasurementsChannelPowerEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMeasurementsChannelPowerEnabled, channelString,out value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages the PSD. 
        ///    The default value is 10. Valid values are 1 to 1,000, inclusive. 
        ///    Get Function: niWLANA_GetSpectralMeasurementsChannelPowerNumberOfAverages
        ///    Set Function: niWLANA_SetSpectralMeasurementsChannelPowerNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMeasurementsChannelPowerNumberOfAverages(string channelString, int value)
        {
            return SetInt(niWLANAProperties.SpectralMeasurementsChannelPowerNumberOfAverages, channelString, value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages the PSD. 
        ///    The default value is 10. Valid values are 1 to 1,000, inclusive. 
        ///    Get Function: niWLANA_GetSpectralMeasurementsChannelPowerNumberOfAverages
        ///    Set Function: niWLANA_SetSpectralMeasurementsChannelPowerNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMeasurementsChannelPowerNumberOfAverages(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMeasurementsChannelPowerNumberOfAverages, channelString,out value);
        }


        /// <summary>
        /// Specifies whether the toolkit needs to set measurement bandwidth equal to channel bandwidth for channel power measurements. If you want to specify the measurement bandwidth, set the <a href="attr30c.html">Channel Power Auto Measurement Bandwidth Enabled</a> property to <format type="bold">False</format>.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMeasurementsChPowerAutoMeasureBWEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.SpectralMeasurementsChannelPowerAutoMeasureBWEnabled, channelString,value);
        }


        /// <summary>
        /// Specifies whether the toolkit needs to set measurement bandwidth equal to channel bandwidth for channel power measurements. If you want to specify the measurement bandwidth, set the <a href="attr30c.html">Channel Power Auto Measurement Bandwidth Enabled</a> property to <format type="bold">False</format>.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMeasurementsChPowerAutoMeasureBWEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMeasurementsChannelPowerAutoMeasureBWEnabled, channelString,out value);
        }



        /// <summary>
        /// Specifies the measurement bandwidth, in hertz (Hz). The toolkit ignores this property if you set the <a href="attr30c.html">Channel Power Auto Measurement Bandwidth Enabled</a> property <format type="bold">True</format>.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMeasurementChannelPowerMeasuremntBW(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.SpectralMeasurementsChannelPowerMeasurementBandwidth, channelString, value);
        }


        /// <summary>
        /// Specifies the measurement bandwidth, in hertz (Hz). The toolkit ignores this property if you set the <a href="attr30c.html">Channel Power Auto Measurement Bandwidth Enabled</a> property <format type="bold">True</format>.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMeasurementChannelPowerMeasuremntBW(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.SpectralMeasurementsChannelPowerMeasurementBandwidth, channelString, out value);
        }


        /// <summary>
        /// Returns the maximum total power, in W/MHz, over any 1 MHz portion of the spectrum
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMeasurementChannelPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultSpectralMeasurementsChannelPower, channelString, out value);
        }


        /// <summary>
        ///Specifies the measurement length of the waveform to use for TxPower measurements. This value is expressed in seconds.
        ///     If you enable the TxPower measurements along with other measurements and set this attribute to -1, the measurement    length used for TxPower measurements is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. You cannot    set this attribute along with the NIWLANA_ACQUISITION_LENGTH attribute. n
        ///    The default value is 1 ms. 
        ///    Get Function: niWLANA_GetTxPowerMeasurementLength
        ///    Set Function: niWLANA_SetTxPowerMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetTxPowerMeasurementLength(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.TxPowerMeasurementLength, channelString, value);
        }


        /// <summary>
        ///Specifies the measurement length of the waveform to use for TxPower measurements. This value is expressed in seconds.
        ///     If you enable the TxPower measurements along with other measurements and set this attribute to -1, the measurement    length used for TxPower measurements is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. You cannot    set this attribute along with the NIWLANA_ACQUISITION_LENGTH attribute. n
        ///    The default value is 1 ms. 
        ///    Get Function: niWLANA_GetTxPowerMeasurementLength
        ///    Set Function: niWLANA_SetTxPowerMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetTxPowerMeasurementLength(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.TxPowerMeasurementLength, channelString,out value);
        }


        /// <summary>
        ///Specifies whether to enable power CCDF measurements from a time    domain signal. The CCDF curve shows the probability that the signal power will be above the average power level. 
        ///    The default value is NIWLANA_VAL_CCDF_ENABLED_FALSE. 
        ///    Get Function: niWLANA_GetCCDFEnabled
        ///    Set Function: niWLANA_SetCCDFEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetCCDFEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.CcdfEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether to enable power CCDF measurements from a time    domain signal. The CCDF curve shows the probability that the signal power will be above the average power level. 
        ///    The default value is NIWLANA_VAL_CCDF_ENABLED_FALSE. 
        ///    Get Function: niWLANA_GetCCDFEnabled
        ///    Set Function: niWLANA_SetCCDFEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDFEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.CcdfEnabled, channelString,out value);
        }


        /// <summary>
        ///Specifies whether to enable the CCDF trace. 
        ///    The default value is NIWLANA_VAL_CCDF_TRACE_ENABLED_FALSE. 
        ///    Get Function: niWLANA_GetCCDFTraceEnabled
        ///    Set Function: niWLANA_SetCCDFTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetCCDFTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.CcdfTraceEnabled, channelString,value);
        }


        /// <summary>
        ///Specifies whether to enable the CCDF trace. 
        ///    The default value is NIWLANA_VAL_CCDF_TRACE_ENABLED_FALSE. 
        ///    Get Function: niWLANA_GetCCDFTraceEnabled
        ///    Set Function: niWLANA_SetCCDFTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDFTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.CcdfTraceEnabled, channelString,out value);
        }


        /// <summary>
        ///Specifies whether to remove dead time in the input waveform. 
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///      Get Function: niWLANA_GetCCDFRemoveDeadTime
        ///    Set Function: niWLANA_SetCCDFRemoveDeadTime
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetCCDFRemoveDeadTime(string channelString, int value)
        {
            return SetInt(niWLANAProperties.CcdfRemoveDeadTime, channelString, value);
        }


        /// <summary>
        ///Specifies whether to remove dead time in the input waveform. 
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///      Get Function: niWLANA_GetCCDFRemoveDeadTime
        ///    Set Function: niWLANA_SetCCDFRemoveDeadTime
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDFRemoveDeadTime(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.CcdfRemoveDeadTime, channelString,out value);
        }


        /// <summary>
        ///Specifies the measurement length of the waveform to be used for CCDF measurements. This value is expressed in seconds. 
        ///    If CCDF measurements are enabled along with other measurements and this attribute is    set to -1, the measurement length used for CCDF measurements is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute.
        ///    You cannot set this attribute along with the NIWLANA_RESULT_AUTORANGE_ACQUISITION_LENGTH attribute. 
        ///    The default value is 1 ms.
        ///      Get Function: niWLANA_GetCCDFMeasurementLength
        ///    Set Function: niWLANA_SetCCDFMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetCCDFMeasurementLength(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.CcdfMeasurementLength, channelString, value);
        }


        /// <summary>
        ///Specifies the measurement length of the waveform to be used for CCDF measurements. This value is expressed in seconds. 
        ///    If CCDF measurements are enabled along with other measurements and this attribute is    set to -1, the measurement length used for CCDF measurements is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute.
        ///    You cannot set this attribute along with the NIWLANA_RESULT_AUTORANGE_ACQUISITION_LENGTH attribute. 
        ///    The default value is 1 ms.
        ///      Get Function: niWLANA_GetCCDFMeasurementLength
        ///    Set Function: niWLANA_SetCCDFMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDFMeasurementLength(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.CcdfMeasurementLength, channelString,out value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages CCDF measurements. 
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values. 
        ///    The default value is 1. Valid values are 1 to 1,000, inclusive. 
        ///      Get Function: niWLANA_GetCCDFNumberOfRecords
        ///    Set Function: niWLANA_SetCCDFNumberOfRecords
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetCCDFNumberOfRecords(string channelString, int value)
        {
            return SetInt(niWLANAProperties.CcdfNumberOfRecords, channelString, value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages CCDF measurements. 
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values. 
        ///    The default value is 1. Valid values are 1 to 1,000, inclusive. 
        ///      Get Function: niWLANA_GetCCDFNumberOfRecords
        ///    Set Function: niWLANA_SetCCDFNumberOfRecords
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDFNumberOfRecords(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.CcdfNumberOfRecords, channelString,out value);
        }


        /// <summary>
        /// Returns the average across iterations of average power, in dBm, of the acquired waveform. If you set the <a href="attr253.html">CCDF Remove Dead Time</a> property to <format type="bold">False</format>, it returns the average power of the entire waveform. If you set the CCDF Remove Dead Time property to <format type="bold">True</format>, it returns the average power of the waveform after excluding the dead time (gaps) within the waveform.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDFAveragePower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultCcdfAveragePower, channelString, out value);
        }


        /// <summary>
        /// Returns the number of samples for which the instantaneous power is the same as the average power of the signal, as a percentage of the total number of samples, used for CCDF computation.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDFAveragePowerPercentile(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultCcdfAveragePowerPercentile, channelString, out value);
        }


        /// <summary>
        /// >Returns the power above the average power, in dB, over which 10% of the total samples in the signal are present.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDF10PercentPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultCcdf10PercentPower, channelString, out value);
        }


        /// <summary>
        /// Returns the power above the average power, in dB, over which 1% of the total samples in the signal are present.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDF1PercentPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultCcdf1PercentPower, channelString, out value);
        }


        /// <summary>
        /// Returns the power above the average power, in dB, over which 0.1% of the total samples in the signal are present.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDF1By10PercentPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultCcdf1By10PercentPower, channelString, out value);
        }


        /// <summary>
        /// Returns the power above the average power, in dB, over which 0.01% of the total samples in the signal are present.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDF1By100PercentPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultCcdf1By100PercentPower, channelString, out value);
        }


        /// <summary>
        /// Returns the power above the average power, in dB, over which 0.001% of the total samples in the signal are present.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDF1By1000PercentPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultCcdf1By1000PercentPower, channelString, out value);
        }


        /// <summary>
        /// Returns the power above the average power, in dB, over which 0.0001% of the total samples in the signal are present.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDF1By10000PercentPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultCcdf1By10000PercentPower, channelString, out value);
        }



        /// <summary>
        /// Returns the peak-to-average power ratio (PAPR), in dB, of the signal.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDFPeakToAveragePowerRatio(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultCcdfPeakToAveragePowerRatio, channelString, out value);
        }


        /// <summary>
        /// Returns the actual number of data samples, used for complementary cumulative distribution function (CCDF) measurement.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCCDFResultantCount(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultCcdfResultantCount, channelString, out value);
        }


        /// <summary>
        ///Specifies the measurement length of the waveform to be used for direct sequence spread    spectrum (DSSS) Power Ramp Measurements. This value is expressed in seconds.
        ///     If you enable the DSSS Power Ramp measurement along with other measurements and set this attribute to -1, the measurement    length used for DSSS Power Ramp measurement is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. 
        ///    The default value is 1 ms. 
        ///    Get Function: niWLANA_GetDSSSPowerRampMeasurementLength
        ///    Set Function: niWLANA_SetDSSSPowerRampMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSPowerRampMeasurementLength(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.DsssPowerRampMeasurementLength, channelString, out value);
        }


        /// <summary>
        ///Specifies the measurement length of the waveform to be used for OFDM Demod. This value is expressed in seconds. 
        ///    This attribute is ignored if you set the NIWLANA_OFDM_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    If the OFDM Demod measurement is enabled along with other measurements and this attribute is    set to -1, the measurement length used for OFDM Demod measurement is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. 
        ///    You cannot set this attribute along with the NIWLANA_ACQUISITION_LENGTH attribute. 
        ///    The default value is 1 ms.
        ///     Get Function: niWLANA_GetOFDMDemodMeasurementLength
        ///    Set Function: niWLANA_SetOFDMDemodMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodMeasurementLength(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.OfdmDemodMeasurementLength, channelString, value);
        }


        /// <summary>
        ///Specifies the measurement length of the waveform to be used for OFDM Demod. This value is expressed in seconds. 
        ///    This attribute is ignored if you set the NIWLANA_OFDM_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    If the OFDM Demod measurement is enabled along with other measurements and this attribute is    set to -1, the measurement length used for OFDM Demod measurement is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. 
        ///    You cannot set this attribute along with the NIWLANA_ACQUISITION_LENGTH attribute. 
        ///    The default value is 1 ms.
        ///     Get Function: niWLANA_GetOFDMDemodMeasurementLength
        ///    Set Function: niWLANA_SetOFDMDemodMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodMeasurementLength(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemodMeasurementLength, channelString,out value);
        }


        /// <summary>
        ///Specifies whether to enable computation of the channel EVM. 
        ///    IEEE standard documents specify that the EVM limits be applied on stream EVM. Therefore if you do not    require channel EVM measurement, you must set this attribute to NIWLANA_VAL_FALSE to improve measurement    speed. This value is expressed in your application. The    niWLANA_ConfigureFastEVM function sets this attribute to NIWLANA_VAL_FALSE. 
        ///    The attribute is applicable only when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or    NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetOFDMDemodChannelEVMEnabled
        ///    Set Function: niWLANA_SetOFDMDemodChannelEVMEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodChannelEVMEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodChannelEvmEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether to enable computation of the channel EVM. 
        ///    IEEE standard documents specify that the EVM limits be applied on stream EVM. Therefore if you do not    require channel EVM measurement, you must set this attribute to NIWLANA_VAL_FALSE to improve measurement    speed. This value is expressed in your application. The    niWLANA_ConfigureFastEVM function sets this attribute to NIWLANA_VAL_FALSE. 
        ///    The attribute is applicable only when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or    NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetOFDMDemodChannelEVMEnabled
        ///    Set Function: niWLANA_SetOFDMDemodChannelEVMEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodChannelEVMEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodChannelEvmEnabled, channelString,out value);
        }


        /// <summary>
        ///Specifies whether to enable computation of the channel matrix power results which is frequency domain power measured from estimated channel matrix. 
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetOFDMDemodChannelMatrixPowerEnabled
        ///    Set Function: niWLANA_SetOFDMDemodChannelMatrixPowerEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodChannelMatrixPowerEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodChannelMatrixPowerEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether to enable computation of the channel matrix power results which is frequency domain power measured from estimated channel matrix. 
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetOFDMDemodChannelMatrixPowerEnabled
        ///    Set Function: niWLANA_SetOFDMDemodChannelMatrixPowerEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodChannelMatrixPowerEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodChannelMatrixPowerEnabled, channelString,out value);
        }


        /// <summary>
        /// Specifies whether to enable stream power measurement for combined signal demod.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMStreamPowerEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodStreamPowerEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether to enable computation of the spectral flatness margin measurement. 
        ///    Refer to the OFDM spectral flatness margin topic for more information about spectral flatness margin. 
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetOFDMDemodSpectralFlatnessMarginEnabled
        ///    Set Function: niWLANA_SetOFDMDemodSpectralFlatnessMarginEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodSpectralFlatnessMarginEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodSpectralFlatnessMarginEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether to enable computation of the spectral flatness margin measurement. 
        ///    Refer to the OFDM spectral flatness margin topic for more information about spectral flatness margin. 
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetOFDMDemodSpectralFlatnessMarginEnabled
        ///    Set Function: niWLANA_SetOFDMDemodSpectralFlatnessMarginEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodSpectralFlatnessMarginEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodSpectralFlatnessMarginEnabled, channelString,out value);
        }


        /// <summary>
        ///Specifies whether to use reference data constellation for EVM computation. You can    specify the reference data constellation using the niWLANA_SetReferenceDataConstellation function. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodReferenceDataConstellationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodReferenceDataConstellationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodReferenceDataConstellationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodReferenceDataConstellationEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether to use reference data constellation for EVM computation. You can    specify the reference data constellation using the niWLANA_SetReferenceDataConstellation function. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodReferenceDataConstellationEnabled
        ///    Set Function: niWLANA_SetOFDMDemodReferenceDataConstellationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodReferenceDataConstellationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodReferenceDataConstellationEnabled, channelString,out value);
        }


        /// <summary>
        /// Specifies whether to estimate common phase error.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMPhaseErrorEstimationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodCommonPhaseErrorEstimationEnabled, channelString,value);
        }
		
		
        /// <summary>
        /// Specifies whether to estimate common phase error.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMPhaseErrorEstimationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodCommonPhaseErrorEstimationEnabled, channelString,out value);
        }


        /// <summary>
        /// Specifies the type of physical layer convergence procedure (PLCP) protocol data unit (PPDU) if you set the <a href="attr1F.html">Standard</a> property to <format type="bold">80211AC MIMOOFDM</format>. This property is ignored if the <a href="attr2D.html">OFDM Demod Header Detection Enabled</a> property is set to <format type="bold">True</format>.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodPPDUType(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodPpduType, channelString, out value);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodNumberOfUsers(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodNumberOfUsers, channelString, out value);
        }


        /// <summary>
        /// Returns the detected initial state of the scrambler, which is used to scramble the data bits in the device under test (DUT). The toolkit uses the same seed to descramble the received bit-sequence.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodScramblerSeed(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodScramblerSeed, channelString, out value);
        }


        /// <summary>
        ///Specifies the measurement length of the waveform to be used for direct sequence    spread spectrum (DSSS) Demod. This value is expressed in seconds. This attribute    is ignored if you set the NIWLANA_DSSS_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    If DSSS Demod is enabled along with other measurements and this attribute is set to -1, the measurement    length used for DSSS Demod is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. 
        ///    You cannot set this attribute along with the NIWLANA_ACQUISITION_LENGTH attribute. 
        ///    The default value is 1 ms.
        ///     Get Function: niWLANA_GetDSSSDemodMeasurementLength
        ///    Set Function: niWLANA_SetDSSSDemodMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDSSSDemodMeasurementLength(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.DsssDemodMeasurementLength, channelString, value);
        }


        /// <summary>
        ///Specifies the measurement length of the waveform to be used for direct sequence    spread spectrum (DSSS) Demod. This value is expressed in seconds. This attribute    is ignored if you set the NIWLANA_DSSS_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    If DSSS Demod is enabled along with other measurements and this attribute is set to -1, the measurement    length used for DSSS Demod is equal to the maximum value among all measurement lengths. 
        ///    This attribute is used to derive the value of the NIWLANA_RECOMMENDED_ACQUISITION_LENGTH attribute. 
        ///    You cannot set this attribute along with the NIWLANA_ACQUISITION_LENGTH attribute. 
        ///    The default value is 1 ms.
        ///     Get Function: niWLANA_GetDSSSDemodMeasurementLength
        ///    Set Function: niWLANA_SetDSSSDemodMeasurementLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSDemodMeasurementLength(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.DsssDemodMeasurementLength, channelString,out value);
        }


        /// <summary>
        ///Specifies whether the toolkit automatically computes the measurement length    of the waveform based on the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED attribute.
        ///    Note: The toolkit assumes a Long Preamble and a chip rate of 11 Mcps rate to compute    the measurement length by using the value of NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED    attribute. If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED attribute to -1, the toolkit coerces the measurement length to 3 ms.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodAutoComputeMeasurementLengthEnabled
        ///    Set Function: niWLANA_SetDSSSDemodAutoComputeMeasurementLengthEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDSSSDemodAutoComputeMeasurementLengthEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodAutoComputeMeasurementLengthEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether the toolkit automatically computes the measurement length    of the waveform based on the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED attribute.
        ///    Note: The toolkit assumes a Long Preamble and a chip rate of 11 Mcps rate to compute    the measurement length by using the value of NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED    attribute. If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED attribute to -1, the toolkit coerces the measurement length to 3 ms.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodAutoComputeMeasurementLengthEnabled
        ///    Set Function: niWLANA_SetDSSSDemodAutoComputeMeasurementLengthEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSDemodAutoComputeMeasurementLengthEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodAutoComputeMeasurementLengthEnabled, channelString,out value);
        }


        /// <summary>
        /// Specifies that the FEC coding type is binary convolutional code (BCC).
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodFECCodingType(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodFecCodingType, channelString, out value);
        }

        /// <summary>
        /// Configures multiple NI-RFSAs for Local Oscillator (LO) sharing, Reference Clock and multiple device synchronization.
        /// For NI 5663/5663E, NI 5665 and NI 5840 RF vector signal analyzers, this function configures LO sharing  and Reference Clock settings in daisy chained manner. 
        /// For NI 5644R, NI 5645R and NI 5646R RF vector signal transceiver (VST) devices, this function configures daisy-chained  LO Sharing and low-level attributes for multiple device synchronization. VSTs do not support daisy-chained Reference Clocks for synchronization. You must set the master Reference Clock source to PXI_CLK for these devices. For additional information, refer to Synchronization using NI-RFSA and NI-RFSG topic appropriate to your device in the NI RF Vector Signal Analyzers Help.
        /// This function assumes that the devices are interconnected in the order of elements in the instrument handles array. In time synchronization, the first device is assumed to be the master device and the remaining devices are assumed to be slave devices. The devices are divided into two sets when the number of segments are two. In LO sharing, the first device in the each set is assumed to be the master device, and the remaining devices in the set are assumed to be slave devices. To interconnect multiple devices, refer to the following topics appropriate to your device in the NI RF Vector Signal Analyzers Help:
        /// Interconnecting Multiple NI 5663/5663E Devices
        /// Using Internal and External Clock Signals with Multiple NI 5665 Devices
        /// Interconnecting Multiple NI 5644R RF Channels (Homogeneous Channel Types)
        /// Interconnecting Multiple NI 5645R RF Channels (Homogeneous Channel Types)
        /// Interconnecting Multiple NI 5646R RF Channels (Homogeneous Channel Types)
        /// Interconnecting Multiple NI 5840 RF Channels (Homogeneous Channel Types)
        /// If you use NI 5644R, NI 5645R or NI 5646R, the function completes the following steps:
        /// Sets the NIRFSA_ATTR_REF_CLOCK_SOURCE to the value you specify in the MasterReferenceClockSource parameter.
        /// If you set the NIWLANA_LO_SHARING_ENABLED attribute to NIWLANA_VAL_TRUE, the function completes the following steps.
        /// For the master device, the function sets the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE. It also reads the NIRFSA_ATTR_LO_FREQUENCY attribute so that the value can be set on slave devices. 
        /// For the slave devices, the function sets the NIRFSA_ATTR_LO_SOURCE attribute to NIRFSA_VAL_LO_IN_STR and the NIRFSA_ATTR_LO_FREQUENCY attribute to the value read from the master device. With the exception of the last slave device, the function also exports the LO to the next device in the daisy chain by setting the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE.
        /// Configures the trigger synchronization for the master and slave devices.
        /// For the master device, the function completes the following steps:
        /// The function sets the NIRFSA_ATTR_SYNC_START_TRIGGER_MASTER attribute and the NIRFSA_ATTR_SYNC_REF_TRIGGER_MASTER attribute to VI_TRUE. For NI 5646R it sets NIRFSA_ATTR_SYNC_SAMPLE_CLOCK_MASTER attribute to VI_TRUE.
        /// Sets the NIRFSA_ATTR_SYNC_START_TRIGGER_DIST_LINE attribute and the NIRFSA_ATTR_SYNC_REF_TRIGGER_DIST_LINE attribute to the first and second element of the TriggerLines array, respectively. For NI 5646R, it sets the NIRFSA_ATTR_SYNC_SAMPLE_CLOCK_DIST_LINE attribute to the third element of the TriggerLines array.
        /// Calls the niRFSA_Commit function to commit the synchronization settings to the device.
        /// For the slave devices, the function completes the following steps:
        /// Sets the NIRFSA_ATTR_SYNC_START_TRIGGER_MASTER attribute and NIRFSA_ATTR_SYNC_REF_TRIGGER_MASTER attribute to VI_FALSE. For NI 5646R, it sets NIRFSA_ATTR_SYNC_SAMPLE_CLOCK_MASTER attribute to VI_FALSE.
        /// Sets the NIRFSA_ATTR_SYNC_START_TRIGGER_DIST_LINE attribute and the NIRFSA_ATTR_SYNC_REF_TRIGGER_DIST_LINE attribute to the first and second element of the TriggerLines array, respectively. For NI 5646R, it sets the NIRFSA_ATTR_SYNC_START_TRIGGER_DIST_LINE attribute to the third element of the TriggerLines array.
        /// Sets the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to NIRFSA_VAL_DIGITAL_EDGE, the NIRFSA_ATTR_DIGITAL_EDGE_REF_TRIGGER_SOURCE attribute to NIRFSA_VAL_SYNC_REF_TRIGGER_STR, and the NIRFSA_ATTR_DIGITAL_EDGE_START_TRIGGER_SOURCE attribute to NIRFSA_VAL_SYNC_START_TRIGGER_STR.
        /// If you use NI 5663/5663E or NI 5665 RF vector signal analyzers, the function configures the devices for daisy-chained reference clock synchronization:
        /// For the master device, the function sets the NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to the value you specify in master Reference Clock source and the NIRFSA_ATTR_EXPORTED_REF_CLOCK_OUTPUT_TERMINAL attribute to NIRFSA_VAL_CLK_OUT_STR.
        /// For the slave devices, the function sets the NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to NIRFSA_VAL_CLK_IN_STR and the NIRFSA_ATTR_EXPORTED_REF_CLOCK_OUTPUT_TERMINAL attribute to NIRFSA_VAL_CLK_OUT_STR. It also sets the NIRFSA_ATTR_REF_CLOCK_RATE attribute according to the device model.
        /// If NIWLANA_LO_SHARING_ENABLED attribute is set to NIWLANA_VAL_TRUE, 
        /// For the master device, the function exports the LO by setting the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE. It also reads the NIRFSA_ATTR_LO_FREQUENCY attribute so that the value can be set on slave devices.
        /// For the slave devices, the function sets the NIRFSA_ATTR_LO_SOURCE attribute to NIRFSA_VAL_LO_IN_STR, the NIRFSA_ATTR_LO_FREQUENCY attribute to the value read from the master and exports the LO to the next device in the daisy chain by setting the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE.
        /// If you use NI 5840 RF vector signal analyzers, the function completes the following actions:
        /// For reference clock synchronization:
        /// The function configures all the devices to use PXI_CLK as reference clock if you set the NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to NIRFSA_VAL_PXI_CLK_STR.
        /// The function configures the devices for daisy-chained reference clock synchronization, if you set the NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to a value other than NIRFSA_VAL_PXI_CLK_STR.
        /// For the master device, the function sets the NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to the value you specify in the MasterReferenceClockSource parameter and sets the NIRFSA_ATTR_EXPORTED_REF_CLOCK_OUTPUT_TERMINAL attribute to NIRFSA_VAL_IF_COND_REF_OUT.
        /// For the slave devices, the function sets the  NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to NIRFSA_VAL_REF_IN_STR. Except for the last slave device, this function also sets the NIRFSA_ATTR_EXPORTED_REF_CLOCK_OUTPUT_TERMINAL attribute to NIRFSA_VAL_IF_COND_REF_OUT. 
        /// If you set the NIWLANA_LO_SHARING_ENABLED attribute to NIWLANA_VAL_LO_SHARING_ENABLED_TRUE, the function completes the following actions: 
        /// For the master device, the function exports the LO by setting the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE. The function also reads the NIRFSA_ATTR_LO_FREQUENCY attribute  so that the value can be set on slave devices. 
        /// For the slave devices, the function sets the NIRFSA_ATTR_LO_SOURCE attribute to  NIRFSA_VAL_LO_IN_STR and the NIRFSA_ATTR_LO_FREQUENCY attribute to the value read from the master device. Except for the last slave device, this function also exports the LO to the next device in the daisy chain by setting the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE. 
        /// 
        /// </summary>
        ///<param name = "rFSASessions">
        /// Specifies an array of references to multiple NI-RFSA instrument sessions. This parameter is obtained from the niRFSA_init or niRFSA_InitWithOptions function and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "noOfChannels">
        /// Specifies the number of channels (waveforms) to process during analysis measurements. The number of received channels must be less than or equal to the number of channels acquired.
        /// 
        ///</param>
        ///<param name = "MasterReferenceClockSource">
        /// Specifies the device reference clock to configure on the master NI-RFSA.
        /// 
        ///</param>
        ///<param name = "TriggerLines">
        /// Specifies trigger lines used for distribution of synchronized trigger signals.
        /// 
        ///</param>
        ///<param name = "noOfTriggerLines">
        ///  Specifies the actual number of elements populated in the TriggerLines array. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAConfigureMultipleDeviceSynchronization
        /// int32 __stdcall niWLANA_RFSAConfigureMultipleDeviceSynchronization (niWLANA session, ViSession rfsaSessions[], int32 noOfChannels, char MasterReferenceClockSource[], int32 TriggerLines[], int32 noOfTriggerLines);
        /// Purpose
        /// Configures multiple NI-RFSAs for Local Oscillator (LO) sharing, Reference Clock and multiple device synchronization.
        /// For NI 5663/5663E, NI 5665 and NI 5840 RF vector signal analyzers, this function configures LO sharing  and Reference Clock settings in daisy chained manner. 
        /// For NI 5644R, NI 5645R and NI 5646R RF vector signal transceiver (VST) devices, this function configures daisy-chained  LO Sharing and low-level attributes for multiple device synchronization. VSTs do not support daisy-chained Reference Clocks for synchronization. You must set the master Reference Clock source to PXI_CLK for these devices. For additional information, refer to Synchronization using NI-RFSA and NI-RFSG topic appropriate to your device in the NI RF Vector Signal Analyzers Help.
        /// This function assumes that the devices are interconnected in the order of elements in the instrument handles array. In time synchronization, the first device is assumed to be the master device and the remaining devices are assumed to be slave devices. The devices are divided into two sets when the number of segments are two. In LO sharing, the first device in the each set is assumed to be the master device, and the remaining devices in the set are assumed to be slave devices. To interconnect multiple devices, refer to the following topics appropriate to your device in the NI RF Vector Signal Analyzers Help:
        /// Interconnecting Multiple NI 5663/5663E Devices
        /// Using Internal and External Clock Signals with Multiple NI 5665 Devices
        /// Interconnecting Multiple NI 5644R RF Channels (Homogeneous Channel Types)
        /// Interconnecting Multiple NI 5645R RF Channels (Homogeneous Channel Types)
        /// Interconnecting Multiple NI 5646R RF Channels (Homogeneous Channel Types)
        /// Interconnecting Multiple NI 5840 RF Channels (Homogeneous Channel Types)
        /// If you use NI 5644R, NI 5645R or NI 5646R, the function completes the following steps:
        /// Sets the NIRFSA_ATTR_REF_CLOCK_SOURCE to the value you specify in the MasterReferenceClockSource parameter.
        /// If you set the NIWLANA_LO_SHARING_ENABLED attribute to NIWLANA_VAL_TRUE, the function completes the following steps.
        /// For the master device, the function sets the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE. It also reads the NIRFSA_ATTR_LO_FREQUENCY attribute so that the value can be set on slave devices. 
        /// For the slave devices, the function sets the NIRFSA_ATTR_LO_SOURCE attribute to NIRFSA_VAL_LO_IN_STR and the NIRFSA_ATTR_LO_FREQUENCY attribute to the value read from the master device. With the exception of the last slave device, the function also exports the LO to the next device in the daisy chain by setting the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE.
        /// Configures the trigger synchronization for the master and slave devices.
        /// For the master device, the function completes the following steps:
        /// The function sets the NIRFSA_ATTR_SYNC_START_TRIGGER_MASTER attribute and the NIRFSA_ATTR_SYNC_REF_TRIGGER_MASTER attribute to VI_TRUE. For NI 5646R it sets NIRFSA_ATTR_SYNC_SAMPLE_CLOCK_MASTER attribute to VI_TRUE.
        /// Sets the NIRFSA_ATTR_SYNC_START_TRIGGER_DIST_LINE attribute and the NIRFSA_ATTR_SYNC_REF_TRIGGER_DIST_LINE attribute to the first and second element of the TriggerLines array, respectively. For NI 5646R, it sets the NIRFSA_ATTR_SYNC_SAMPLE_CLOCK_DIST_LINE attribute to the third element of the TriggerLines array.
        /// Calls the niRFSA_Commit function to commit the synchronization settings to the device.
        /// For the slave devices, the function completes the following steps:
        /// Sets the NIRFSA_ATTR_SYNC_START_TRIGGER_MASTER attribute and NIRFSA_ATTR_SYNC_REF_TRIGGER_MASTER attribute to VI_FALSE. For NI 5646R, it sets NIRFSA_ATTR_SYNC_SAMPLE_CLOCK_MASTER attribute to VI_FALSE.
        /// Sets the NIRFSA_ATTR_SYNC_START_TRIGGER_DIST_LINE attribute and the NIRFSA_ATTR_SYNC_REF_TRIGGER_DIST_LINE attribute to the first and second element of the TriggerLines array, respectively. For NI 5646R, it sets the NIRFSA_ATTR_SYNC_START_TRIGGER_DIST_LINE attribute to the third element of the TriggerLines array.
        /// Sets the NIRFSA_ATTR_REF_TRIGGER_TYPE attribute to NIRFSA_VAL_DIGITAL_EDGE, the NIRFSA_ATTR_DIGITAL_EDGE_REF_TRIGGER_SOURCE attribute to NIRFSA_VAL_SYNC_REF_TRIGGER_STR, and the NIRFSA_ATTR_DIGITAL_EDGE_START_TRIGGER_SOURCE attribute to NIRFSA_VAL_SYNC_START_TRIGGER_STR.
        /// If you use NI 5663/5663E or NI 5665 RF vector signal analyzers, the function configures the devices for daisy-chained reference clock synchronization:
        /// For the master device, the function sets the NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to the value you specify in master Reference Clock source and the NIRFSA_ATTR_EXPORTED_REF_CLOCK_OUTPUT_TERMINAL attribute to NIRFSA_VAL_CLK_OUT_STR.
        /// For the slave devices, the function sets the NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to NIRFSA_VAL_CLK_IN_STR and the NIRFSA_ATTR_EXPORTED_REF_CLOCK_OUTPUT_TERMINAL attribute to NIRFSA_VAL_CLK_OUT_STR. It also sets the NIRFSA_ATTR_REF_CLOCK_RATE attribute according to the device model.
        /// If NIWLANA_LO_SHARING_ENABLED attribute is set to NIWLANA_VAL_TRUE, 
        /// For the master device, the function exports the LO by setting the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE. It also reads the NIRFSA_ATTR_LO_FREQUENCY attribute so that the value can be set on slave devices.
        /// For the slave devices, the function sets the NIRFSA_ATTR_LO_SOURCE attribute to NIRFSA_VAL_LO_IN_STR, the NIRFSA_ATTR_LO_FREQUENCY attribute to the value read from the master and exports the LO to the next device in the daisy chain by setting the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE.
        /// If you use NI 5840 RF vector signal analyzers, the function completes the following actions:
        /// For reference clock synchronization:
        /// The function configures all the devices to use PXI_CLK as reference clock if you set the NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to NIRFSA_VAL_PXI_CLK_STR.
        /// The function configures the devices for daisy-chained reference clock synchronization, if you set the NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to a value other than NIRFSA_VAL_PXI_CLK_STR.
        /// For the master device, the function sets the NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to the value you specify in the MasterReferenceClockSource parameter and sets the NIRFSA_ATTR_EXPORTED_REF_CLOCK_OUTPUT_TERMINAL attribute to NIRFSA_VAL_IF_COND_REF_OUT.
        /// For the slave devices, the function sets the  NIRFSA_ATTR_REF_CLOCK_SOURCE attribute to NIRFSA_VAL_REF_IN_STR. Except for the last slave device, this function also sets the NIRFSA_ATTR_EXPORTED_REF_CLOCK_OUTPUT_TERMINAL attribute to NIRFSA_VAL_IF_COND_REF_OUT. 
        /// If you set the NIWLANA_LO_SHARING_ENABLED attribute to NIWLANA_VAL_LO_SHARING_ENABLED_TRUE, the function completes the following actions: 
        /// For the master device, the function exports the LO by setting the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE. The function also reads the NIRFSA_ATTR_LO_FREQUENCY attribute  so that the value can be set on slave devices. 
        /// For the slave devices, the function sets the NIRFSA_ATTR_LO_SOURCE attribute to  NIRFSA_VAL_LO_IN_STR and the NIRFSA_ATTR_LO_FREQUENCY attribute to the value read from the master device. Except for the last slave device, this function also exports the LO to the next device in the daisy chain by setting the NIRFSA_ATTR_LO_EXPORT_ENABLED attribute to VI_TRUE. 
        /// 
        ///</returns>
        public int RFSAConfigureMultipleDeviceSynchronization(System.Runtime.InteropServices.HandleRef[] rFSASessions, int noOfChannels, string MasterReferenceClockSource, int[] TriggerLines, int noOfTriggerLines)
        {
            System.Int32[] handles = new Int32[rFSASessions.Length];
            for (int i = 0; i < handles.Length; i++)
                handles[i] = rFSASessions[i].Handle.ToInt32();
            int pInvokeResult = PInvoke.niWLANA_RFSAConfigureMultipleDeviceSynchronization(Handle, handles, noOfChannels, MasterReferenceClockSource, TriggerLines, noOfTriggerLines);
            TestForError(pInvokeResult, rFSASessions);
            return pInvokeResult;
        }

        /// <summary>
        /// Commits settings to hardware, waits for hardware settling, and starts multi-device synchronized acquisition. This function is called by the niWLANA_RFSAMIMOMeasure function.If you use NI 5644R, NI 5645R or NI 5646R RF vector signal transceiver devices, the function performs the following steps:
        /// It commits the device settings to the master device by calling the niRFSA_Commit function. 
        /// It then initializes acquisition for slave devices first and then for the master device by calling the niRFSA_Initiate function in a loop.
        /// If you use NI 5663/5663E, NI 5665, NI 5668R, or NI 5840, the function performs the following steps:
        /// If NIWLANA_TCLK_SYNCHRONIZATION_ENABLED attribute is set to NIWLANA_VAL_TCLK_SYNCHRONIZATION_ENABLED_TRUE, this function uses niTClk functions: niTClk_ConfigureForHomogeneousTriggers function, niTClk_Synchronize function and niTClk_Initiate function. For additional information, refer to NI-TClk Synchronization Help section of NI RF Vector Signal Analyzers Help.
        /// If NIWLANA_TCLK_SYNCHRONIZATION_ENABLED attribute is set to NIWLANA_VAL_TCLK_SYNCHRONIZATION_ENABLED_FALSE, then it calls niRFSA_Initiate function in a loop for non-synchronized acquisition.
        /// 
        /// </summary>
        ///<param name = "rFSASessions">
        /// Specifies an array of references to multiple NI-RFSA instrument sessions. This parameter is obtained from the niRFSA_init or niRFSA_InitWithOptions function and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "numberofChannels">
        /// Specifies the number of channels (waveforms) to process during analysis measurements. The number of received channels must be less than or equal to the number of channels acquired.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAMultipleDeviceInitiate
        /// int32 __stdcall niWLANA_RFSAMultipleDeviceInitiate (niWLANA session, 
        ///     ViSession rfsaSessions[],
        ///     int32 noOfChannels);
        /// Purpose
        /// Commits settings to hardware, waits for hardware settling, and starts multi-device synchronized acquisition. This function is called by the niWLANA_RFSAMIMOMeasure function.
        /// If you use NI 5644R, NI 5645R or NI 5646R RF vector signal transceiver devices, the function performs the following steps:
        /// It commits the device settings to the master device by calling the niRFSA_Commit function. 
        /// It then initializes acquisition for slave devices first and then for the master device by calling the niRFSA_Initiate function in a loop.
        /// If you use NI 5663/5663E, NI 5665, NI 5668R, or NI 5840, the function performs the following steps:
        /// If NIWLANA_TCLK_SYNCHRONIZATION_ENABLED attribute is set to NIWLANA_VAL_TCLK_SYNCHRONIZATION_ENABLED_TRUE, this function uses niTClk functions: niTClk_ConfigureForHomogeneousTriggers function, niTClk_Synchronize function and niTClk_Initiate function. For additional information, refer to NI-TClk Synchronization Help section of NI RF Vector Signal Analyzers Help.
        /// If NIWLANA_TCLK_SYNCHRONIZATION_ENABLED attribute is set to NIWLANA_VAL_TCLK_SYNCHRONIZATION_ENABLED_FALSE, then it calls niRFSA_Initiate function in a loop for non-synchronized acquisition.
        /// 
        ///</returns>
        public int RFSAMultipleDeviceInitiate(System.Runtime.InteropServices.HandleRef[] rFSASessions, int numberofChannels)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAMultipleDeviceInitiate(Handle, rFSASessions, numberofChannels);
            TestForError(pInvokeResult, rFSASessions);
            return pInvokeResult;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="rFSASession"></param>
        /// <param name="noOfChannels"></param>
        /// <param name="triggerLine0"></param>
        /// <param name="lenOfTrig0"></param>
        /// <param name="triggerLine1"></param>
        /// <param name="lenOfTrig1"></param>
        /// <param name="reference"></param>
        /// <param name="lenOfReference"></param>
        /// <param name="isInSameBus"></param>
        /// <param name="busNumber"></param>
        /// <param name="sizeOfBusNo"></param>
        /// <param name="isDefaultLineSelected"></param>
        /// <returns></returns>
        public static int WLANA_RFSAAutoTriggerRoute(System.Runtime.InteropServices.HandleRef rFSASession, int noOfChannels, string triggerLine0, int lenOfTrig0, string triggerLine1, int lenOfTrig1, string reference, int lenOfReference, out int isInSameBus, int[] busNumber, int sizeOfBusNo, out int isDefaultLineSelected)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAAutoTriggerRoute(rFSASession, noOfChannels, triggerLine0, lenOfTrig0, triggerLine1, lenOfTrig1, reference, lenOfReference, out isInSameBus, busNumber, sizeOfBusNo, out isDefaultLineSelected);
            StaticTestForError(pInvokeResult, rFSASession);
            return pInvokeResult;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="triggerLine0"></param>
        /// <param name="triggerLine1"></param>
        /// <param name="reference"></param>
        /// <param name="isInSameBus"></param>
        /// <param name="busNumber"></param>
        /// <param name="sizeOfBusNo"></param>
        /// <param name="isDefaultLineSelected"></param>
        /// <returns></returns>
        public static int WLANA_RFSATriggerUnroute(string triggerLine0, string triggerLine1, string reference, int isInSameBus, int[] busNumber, int sizeOfBusNo, int isDefaultLineSelected)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSATriggerUnroute(triggerLine0, triggerLine1, reference, isInSameBus, busNumber, sizeOfBusNo, isDefaultLineSelected);
            StaticTestForError(pInvokeResult, null);
            return pInvokeResult;
        }


        /// <summary>
        ///Returns the standard deviation of average power with idle time of the acquired burst. This value is expressed in dB.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpAveragePowerWithIdleTimeStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpAveragePowerWithIdleTimeStandardDeviation, channel, out value);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommmonPhaseErrorAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommmonPhaseErrorAverage, channel, out value);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommmonPhaseErrorMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommmonPhaseErrorMinimum, channel, out value);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommmonPhaseErrorMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommmonPhaseErrorMaximum, channel, out value);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommmonPhaseErrorStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommmonPhaseErrorStandardDeviation, channel, out value);
        }

        #endregion

        /// <summary>
        /// Returns the detected modulation and coding scheme (MCS) index, which determines the modulation and coding scheme used. For 802.11n signals, the toolkit detects the MCS index from the high-throughput SIGNAL (HT-SIG) field, which is defined in sections 20.3.9.4.3 and 20.6 of the <format type="italic">IEEE Standard 802.11n-2009</format>. For 802.11ac signals, the toolkit detects the MCS index from the VHT-SIG-A field for a packet of SU PPDU format, and from the VHT-SIG-B field for a packet of MU PPDU format. If you set the <a href="attr2D.html">OFDM Header Detection Enabled</a> property to <format type="bold">False</format>, the value you specify in the MCS Index property specifies the modulation and coding scheme.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodMCSIndex(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodMcsIndex, channelString, out value);
        }


        /// <summary>
        ///Specifies the type of forward error correction (FEC) coding used if you set the NIWLANA_OFDM_NON_HT_MODULATION_MODE attribute    to NIWLANA_VAL_OFDM_NON_HT_MODULATION_MODE_OFF, and the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM    as defined in section 20.3.11.3 of the IEEE Standard 802.11n-2009,    section 22.3.10.5 of the IEEE Standard 80211.ac-2013,    section 23.3.10.5 of the IEEE Standard 802.11af-2013 and section 28.3.11.5 of IEEE P802.11ax/D1.2. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED    attribute to NIWLANA_VAL_TRUE for the PPDU types other than Trigger-Based PPDU.
        ///    The toolkit uses the value of the NIWLANA_MCS_INDEX attribute as the MCS index for performing OFDM demodulation measurements. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active channel    string syntax to query this attribute.
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU    or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU    or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active channel    string syntax to query this attribute.
        ///     The default value is NIWLANA_VAL_FEC_CODING_TYPE_BCC.
        ///    Get Function: niWLANA_GetFECCodingType
        ///    Set Function: niWLANA_SetFECCodingType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetFecCodingType(string channel, int value)
        {
            return SetInt(niWLANAProperties.FecCodingType, channel, value);
        }

        /// <summary>
        ///Specifies the type of forward error correction (FEC) coding used if you set the NIWLANA_OFDM_NON_HT_MODULATION_MODE attribute    to NIWLANA_VAL_OFDM_NON_HT_MODULATION_MODE_OFF, and the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM    as defined in section 20.3.11.3 of the IEEE Standard 802.11n-2009,    section 22.3.10.5 of the IEEE Standard 80211.ac-2013,    section 23.3.10.5 of the IEEE Standard 802.11af-2013 and section 28.3.11.5 of IEEE P802.11ax/D1.2. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED    attribute to NIWLANA_VAL_TRUE for the PPDU types other than Trigger-Based PPDU.
        ///    The toolkit uses the value of the NIWLANA_MCS_INDEX attribute as the MCS index for performing OFDM demodulation measurements. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active channel    string syntax to query this attribute.
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU    or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU    or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active channel    string syntax to query this attribute.
        ///     The default value is NIWLANA_VAL_FEC_CODING_TYPE_BCC.
        ///    Get Function: niWLANA_GetFECCodingType
        ///    Set Function: niWLANA_SetFECCodingType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetFecCodingType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.FecCodingType, channel, out value);
        }

        /// <summary>
        ///Specifies the difference between the number of space-time streams and the number of spatial streams,    as defined in section 20.3.9.4.3 of the IEEE Standard 802.11n-2009. 
        ///    The number of spatial streams is derived from the NIWLANA_MCS_INDEX attribute. Different space-time coding schemes are defined    in section 20.3.11.8.1 of the IEEE Standard 802.11n-2009. If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute    to NIWLANA_VAL_FALSE, the toolkit uses the value    of the NIWLANA_STBC_INDEX attribute as the difference between the number of space-time streams    and the number of spatial streams for performing OFDM    demodulation measurements.
        ///    The default value is 0. Valid values are 0 to 2, inclusive.
        ///    Get Function: niWLANA_GetSTBCIndex
        ///    Set Function: niWLANA_SetSTBCIndex
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetStbcIndex(string channel, int value)
        {
            return SetInt(niWLANAProperties.StbcIndex, channel, value);
        }

        /// <summary>
        ///Specifies the difference between the number of space-time streams and the number of spatial streams,    as defined in section 20.3.9.4.3 of the IEEE Standard 802.11n-2009. 
        ///    The number of spatial streams is derived from the NIWLANA_MCS_INDEX attribute. Different space-time coding schemes are defined    in section 20.3.11.8.1 of the IEEE Standard 802.11n-2009. If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute    to NIWLANA_VAL_FALSE, the toolkit uses the value    of the NIWLANA_STBC_INDEX attribute as the difference between the number of space-time streams    and the number of spatial streams for performing OFDM    demodulation measurements.
        ///    The default value is 0. Valid values are 0 to 2, inclusive.
        ///    Get Function: niWLANA_GetSTBCIndex
        ///    Set Function: niWLANA_SetSTBCIndex
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetStbcIndex(string channel, out int value)
        {
            return GetInt(niWLANAProperties.StbcIndex, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable all traces of OFDM demodulation.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodAllTracesEnabled
        ///    Set Function: niWLANA_SetOFDMDemodAllTracesEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodAllTracesEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodAllTracesEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable all traces of OFDM demodulation.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodAllTracesEnabled
        ///    Set Function: niWLANA_SetOFDMDemodAllTracesEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodAllTracesEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodAllTracesEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable the channel frequency response trace for signals containing    an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodChannelFrequencyResponseTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodChannelFrequencyResponseTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodChannelFrequencyResponseTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodChannelFrequencyResponseTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable the channel frequency response trace for signals containing    an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodChannelFrequencyResponseTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodChannelFrequencyResponseTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodChannelFrequencyResponseTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodChannelFrequencyResponseTraceEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable the spectral flatness trace for signals containing an    OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodSpectralFlatnessTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodSpectralFlatnessTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodSpectralFlatnessTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodSpectralFlatnessTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable the spectral flatness trace for signals containing an    OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodSpectralFlatnessTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodSpectralFlatnessTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodSpectralFlatnessTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodSpectralFlatnessTraceEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable the decoded bits trace for signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodDecodedBitsTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodDecodedBitsTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodDecodedBitsTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodDecodedBitsTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable the decoded bits trace for signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodDecodedBitsTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodDecodedBitsTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodDecodedBitsTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodDecodedBitsTraceEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies the duration by which the toolkit adjusts symbol timing relative    to the start of the useful portion of an OFDM symbol. This value is expressed in seconds.
        ///    The toolkit sets this attribute to -1 in the niWLANA_RFSAConfigureHardware function or the niWLANA_RFSAConfigureMIMOHardware function.    The toolkit ignores this attribute if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.   If you set this attribute to -1, the toolkit auto computes    the symbol timing adjustment value according to the following.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, the    symbol timing adjustment value is -800 ns if channel bandwidth is set to 5MHz, -400 ns if    channel bandwidth is set to 10MHz, -200 ns if channel bandwidth is set to 20MHz. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, the symbol timing adjustment value is -200 ns. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, the symbol timing adjustment value is -2 &#181;s. 
        ///    The default value is -200 ns.
        ///    Get Function: niWLANA_GetOFDMDemodSymbolTimingAdjustment
        ///    Set Function: niWLANA_SetOFDMDemodSymbolTimingAdjustment
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodSymbolTimingAdjustment(string channel, double value)
        {
            return SetDouble(niWLANAProperties.OfdmDemodSymbolTimingAdjustment, channel, value);
        }

        /// <summary>
        ///Specifies the duration by which the toolkit adjusts symbol timing relative    to the start of the useful portion of an OFDM symbol. This value is expressed in seconds.
        ///    The toolkit sets this attribute to -1 in the niWLANA_RFSAConfigureHardware function or the niWLANA_RFSAConfigureMIMOHardware function.    The toolkit ignores this attribute if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.   If you set this attribute to -1, the toolkit auto computes    the symbol timing adjustment value according to the following.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, the    symbol timing adjustment value is -800 ns if channel bandwidth is set to 5MHz, -400 ns if    channel bandwidth is set to 10MHz, -200 ns if channel bandwidth is set to 20MHz. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, the symbol timing adjustment value is -200 ns. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, the symbol timing adjustment value is -2 &#181;s. 
        ///    The default value is -200 ns.
        ///    Get Function: niWLANA_GetOFDMDemodSymbolTimingAdjustment
        ///    Set Function: niWLANA_SetOFDMDemodSymbolTimingAdjustment
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodSymbolTimingAdjustment(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemodSymbolTimingAdjustment, channel, out value);
        }

        /// <summary>
        ///Specifies whether to estimate carrier frequency offset using only preamble or both preamble and data.
        ///    Note: In NI WLAN Toolkit version 2.0.0 and earlier, the toolkit used NIWLANA_VAL_CFO_ESTIMATION_METHOD_PREAMBLE_ONLY    for carrier frequency offset estimation when you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM. 
        ///    If you want to preserve the results you obtained with these toolkit versions, you    must set the NIWLANA_OFDM_DEMOD_CFO_ESTIMATION_METHOD attribute to    NIWLANA_VAL_CFO_ESTIMATION_METHOD_PREAMBLE_ONLY.
        ///    The default value is NIWLANA_VAL_CFO_ESTIMATION_METHOD_PREAMBLE_AND_PILOT.
        ///    Get Function: niWLANA_GetOFDMDemodCFOEstimationMethod
        ///    Set Function: niWLANA_SetOFDMDemodCFOEstimationMethod
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodCfoEstimationMethod(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodCfoEstimationMethod, channel, value);
        }

        /// <summary>
        ///Specifies whether to estimate carrier frequency offset using only preamble or both preamble and data.
        ///    Note: In NI WLAN Toolkit version 2.0.0 and earlier, the toolkit used NIWLANA_VAL_CFO_ESTIMATION_METHOD_PREAMBLE_ONLY    for carrier frequency offset estimation when you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM. 
        ///    If you want to preserve the results you obtained with these toolkit versions, you    must set the NIWLANA_OFDM_DEMOD_CFO_ESTIMATION_METHOD attribute to    NIWLANA_VAL_CFO_ESTIMATION_METHOD_PREAMBLE_ONLY.
        ///    The default value is NIWLANA_VAL_CFO_ESTIMATION_METHOD_PREAMBLE_AND_PILOT.
        ///    Get Function: niWLANA_GetOFDMDemodCFOEstimationMethod
        ///    Set Function: niWLANA_SetOFDMDemodCFOEstimationMethod
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodCfoEstimationMethod(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodCfoEstimationMethod, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable the decoded bits trace for the payload portion of the IEEE 802.11b    or 802.11g direct sequence spread spectrum (DSSS) signals.
        ///    Note: The toolkit does not support decoding of received bits for direct sequence spread spectrum (DSSS)    signals that have a data rate of 33 Mbps. In this case, the toolkit cannot return the decoded bits trace.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodDecodedBitsTraceEnabled
        ///    Set Function: niWLANA_SetDSSSDemodDecodedBitsTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodDecodedBitsTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodDecodedBitsTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable the decoded bits trace for the payload portion of the IEEE 802.11b    or 802.11g direct sequence spread spectrum (DSSS) signals.
        ///    Note: The toolkit does not support decoding of received bits for direct sequence spread spectrum (DSSS)    signals that have a data rate of 33 Mbps. In this case, the toolkit cannot return the decoded bits trace.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodDecodedBitsTraceEnabled
        ///    Set Function: niWLANA_SetDSSSDemodDecodedBitsTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodDecodedBitsTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodDecodedBitsTraceEnabled, channel, out value);
        }


        /// <summary>
        ///Returns, as a percentage, the peak value of the chip error vector magnitude (EVM) for the first 1,000 chips in the    payload computed according to section 18.4.7.8 of IEEE Standard 802.11-2007.
        ///     Note: If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED attribute to a value less than 1,000, NaN is returned. If you set the NIWLANA_DSSS_DEMOD_MAXIMUM_CHIPS_USED     attribute to &#8211;1 and the actual number of chips present in the signal is less than 1,000, NaN is returned.
        ///     Note: For DSSS demodulation, if equalization is not enabled and the reference pulse-shaping filter     type and filter coefficients do not match the filter    configuration of the DUT or generator, you might notice EVM degradation.     Ensure the pulse-shaping type and pulse-shaping coefficient settings match    the input signal settings.
        ///     Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM might show degradation.
        ///     The toolkit broadly follows section 18.4.7.8 of IEEE Standard 802.11b-1999 and section 18.4.7.8 of IEEE Standard 802.11-2007 to compute the    EVM. The standard calls for EVM computation only on the differential quadrature phase-shift keying (DQPSK) signal.    However, the toolkit computes EVM for all compulsory and optional data rates and modulation schemes defined    for IEEE Standard 802.11b-1999, as well as the extended rate physical layer-packet binary convolutional coding (ERP-PBCC) modes defined in IEEE Standard 802.11g.    Refer to the EVM Differentiation for DSSS Signals help topic for an explanation of    the difference between RMS EVM, peak EVM, 802.11b-1999 peak EVM, and 802.11-2007 peak EVM.
        ///    
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemod80211bPeakEvm2007(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemod80211bPeakEvm2007, channel, out value);
        }


        /// <summary>
        ///Returns the type of forward error correction (FEC) coding detected from the high-throughput SIGNAL (HT-SIG) field, for 802.11n signals,    as defined in section 20.3.9.4.3 of the IEEE Standard 802.11n-2009.    For 802.11ac signals, it is detected from the VHT-SIG-A field. For 802.11ah signals, it is detected    from the S1G-SIG/SIG-A field. For 80211af signals it is detected from TVHT-SIG-A field. 
        ///    For 802.11ax signals, the toolkit detects the FEC coding type from the HE-SIG-A field for a packet    of SU PPDU format or Extended Range SU PPDU format, and from the HE-SIG-B field for a packet of MU PPDU format. If you set    the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the value you    specify in the NIWLANA_RESULT_OFDM_DEMOD_FEC_CODING_TYPE attribute specifies the specifies the FEC type. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM you must use an    empty string to query this attribute. 
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active channel string syntax to query this attribute. 
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///     Get Function: niWLANA_GetOFDMDemodFECCodingType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodFecCodingType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodFecCodingType, channel, out value);
        }


        /// <summary>
        ///Returns the Not Sounding bit detected from the high-throughput SIGNAL (HT-SIG) field, of 802.11n signal,    as defined in section 20.3.9.4.3 of the IEEE Standard 802.11n-2009.
        ///    Get Function: niWLANA_GetOFDMDemodNotSoundingBit
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodNotSoundingBit(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodNotSoundingBit, channel, out value);
        }


        /// <summary>
        ///Returns the value of space-time block coding (STBC) field detected from the    high-throughput SIGNAL (HT-SIG) field, of 802.11n signal, as defined in    section 20.3.9.4.3 of the IEEE Standard 802.11n-2009. If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED    attribute to NIWLANA_VAL_FALSE, the value you specify in the NIWLANA_STBC_INDEX attribute specifies the STBC index.
        ///    Get Function: niWLANA_GetOFDMDemodSTBCIndex
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodStbcIndex(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodStbcIndex, channel, out value);
        }


        /// <summary>
        ///Indicates whether the parity check has passed for the SIGNAL field of the     OFDM waveforms conforming to the IEEE standard 802.11-2007, the non-HT SIGNAL (L-SIG) field of    the MIMO OFDM waveforms conforming to the IEEE Standard 802.11n-2009,    the non-VHT SIGNAL (L-SIG) field of the MIMO OFDM waveforms conforming to the IEEE Standard 802.11ac-2013, the    non-TVHT SIGNAL (L-SIG) field of the MIMO OFDM waveforms conforming to the IEEE Standard 802.11af-2013, or    the non-HE SIGNAL (L-SIG) field of the MIMO OFDM waveforms conforming to the IEEE P802.11ax/D1.2 standard.
        ///    Get Function: niWLANA_GetOFDMDemodHeaderParityPassed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodHeaderParityPassed(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodHeaderParityPassed, channel, out value);
        }


        /// <summary>
        ///Indicates whether the cyclic redundancy check (CRC) has passed for the DSSS-OFDM physical layer convergence procedure (PLCP)    header field, as defined in section 19.3.2 of the IEEE Standard 802.11-2007.
        ///    Get Function: niWLANA_GetOFDMDemodDSSSOFDMHeaderCRCPassed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodDsssofdmHeaderCrcPassed(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodDsssofdmHeaderCrcPassed, channel, out value);
        }


        /// <summary>
        ///Returns the data rate of the NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM signals    after incorporating the channel bandwidth. This value is expressed in Mbps.
        ///    A lower bandwidth, for example 10 MHz, uses a lower clocking scheme and reduces the data rate.
        ///    This attribute is valid only if you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM.
        ///    Get Function: niWLANA_GetOFDMDemodEffectiveDataRate
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodEffectiveDataRate(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodEffectiveDataRate, channel, out value);
        }


        /// <summary>
        ///Indicates whether the frame check sequence (FCS) of the received decoded medium access control (MAC) protocol data unit (MPDU) has passed.    The toolkit calculates the checksum over the decoded bits, excluding the    last 32 bits. The toolkit then compares this value with the checksum value    in the received payload, which is represented by the last 32 bits of the MPDU.
        ///    Note: The toolkit returns an error if you query this attribute after performing demodulation measurements on direct    sequence spread spectrum (DSSS) signals with a data rate of 33 Mbps.
        ///    Get Function: niWLANA_GetOFDMDemodMACFrameCheckSequencePassed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodMacFrameCheckSequencePassed(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodMacFrameCheckSequencePassed, channel, out value);
        }


        /// <summary>
        ///Indicates whether the frame check sequence (FCS) of the received decoded medium access control (MAC) protocol data unit (MPDU) has passed. 
        ///    The toolkit calculates the checksum over the decoded bits, excluding the last 32 bits. The toolkit    then compares this value with the checksum value    in the received payload, which is represented by the last 32 bits of the MPDU.
        ///    Note: Decoding of received bits is not supported for direct sequence spread spectrum (DSSS)    signals with a data rate of 33 Mbps, and the toolkit cannot compute MAC FCS. 
        ///    The toolkit returns an error if you query this attribute after performing demodulation    measurements on DSSS signals with a data rate of 33 Mbps.
        ///    Get Function: niWLANA_GetDSSSDemodMACFrameCheckSequencePassed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodMacFrameCheckSequencePassed(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultDsssDemodMacFrameCheckSequencePassed, channel, out value);
        }

        /// <summary>
        ///Specifies the physical layer convergence procedure (PLCP) frame format used when you set the NIWLANA_OFDM_DEMOD_80211N_PLCP_FRAME_DETECTION_ENABLED    attribute to NIWLANA_VAL_FALSE. The PLCP frame format determines sequence of preambles,    header, and payload in a frame. If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the    toolkit uses the value    of the NIWLANA_80211N_PLCP_FRAME_FORMAT attribute as the PLCP frame format for performing    OFDM demodulation measurements.
        ///    The default value is NIWLANA_VAL_80211N_PLCP_FRAME_FORMAT_MIXED.
        ///    Get Function: niWLANA_Get80211nPLCPFrameFormat
        ///    Set Function: niWLANA_Set80211nPLCPFrameFormat
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int Set_80211nPlcpFrameFormat(string channel, int value)
        {
            return SetInt(niWLANAProperties._80211nPlcpFrameFormat, channel, value);
        }


        /// <summary>
        ///Specifies the physical layer convergence procedure (PLCP) frame format used when you set the NIWLANA_OFDM_DEMOD_80211N_PLCP_FRAME_DETECTION_ENABLED    attribute to NIWLANA_VAL_FALSE. The PLCP frame format determines sequence of preambles,    header, and payload in a frame. If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the    toolkit uses the value    of the NIWLANA_80211N_PLCP_FRAME_FORMAT attribute as the PLCP frame format for performing    OFDM demodulation measurements.
        ///    The default value is NIWLANA_VAL_80211N_PLCP_FRAME_FORMAT_MIXED.
        ///    Get Function: niWLANA_Get80211nPLCPFrameFormat
        ///    Set Function: niWLANA_Set80211nPLCPFrameFormat
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int Get_80211nPlcpFrameFormat(string channel, out int value)
        {
            return GetInt(niWLANAProperties._80211nPlcpFrameFormat, channel, out value);
        }


        /// <summary>
        ///Specifies the minimum duration of the waveform to be acquired by the NI-RFSA. This value is expressed in seconds. 
        ///    If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to NIWLANA_VAL_ADS_MODE_OFF, the    NIWLANA_ACQUISITION_LENGTH attribute specifies a  common measurement length for all measurements    that are enabled. However, if you enable more than one measurement, NI recommends that you set the    following attributes instead, if the corresponding measurement is enabled.
        ///    NIWLANA_TXPOWER_MEASUREMENT_LENGTH
        ///    NIWLANA_CCDF_MEASUREMENT_LENGTH
        ///    NIWLANA_GATED_SPECTRUM_MEASUREMENT_LENGTH
        ///    NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_LENGTH
        ///    NIWLANA_OFDM_DEMOD_MEASUREMENT_LENGTH
        ///    NIWLANA_DSSS_DEMOD_MEASUREMENT_LENGTH
        ///    You cannot set the NIWLANA_ACQUISITION_LENGTH attribute along with any of the previous attributes. This attribute    is ignored in the following cases:
        ///    NIWLANA_OFDM_DEMOD_ENABLED and NIWLANA_OFDM_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attributes    are set to NIWLANA_VAL_TRUE, and no other measurement is enabled.
        ///    The NIWLANA_DSSS_DEMOD_ENABLED and NIWLANA_DSSS_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attributes are    set to NIWLANA_VAL_TRUE, and no other measurement is enabled.
        ///    If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to NIWLANA_VAL_ADS_MODE_PACKET_FILTER, the    NIWLANA_ACQUISITION_LENGTH attribute specifies the waveform length to be acquired by    the NI-RFSA. This attribute does not specify the measurement lengths    for the measurements that are enabled. You must set the individual measurement lengths. 
        ///    The default value is 10 ms if you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute    to NIWLANA_VAL_ADS_MODE_PACKET_FILTER, and 1 ms if you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE    attribute to NIWLANA_VAL_ADS_MODE_OFF.
        ///    Get Function: niWLANA_GetAcquisitionLength
        ///    Set Function: niWLANA_SetAcquisitionLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAcquisitionLength(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.AcquisitionLength, channel, out value);
        }


        /// <summary>
        ///Specifies the maximum duration of the signal to acquire while    performing autorange operation using the niWLANA_RFSAAutoRange function. This value is expressed in seconds.
        ///    The default value is 30 ms. 
        ///    Get Function: niWLANA_GetAutoRangeMaxAcquisitionLength
        ///    Set Function: niWLANA_SetAutoRangeMaxAcquisitionLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetAutorangeMaxAcquisitionLength(string channel, double value)
        {
            return SetDouble(niWLANAProperties.AutorangeMaxAcquisitionLength, channel, value);
        }


        /// <summary>
        ///Specifies the maximum duration of the signal to acquire while    performing autorange operation using the niWLANA_RFSAAutoRange function. This value is expressed in seconds.
        ///    The default value is 30 ms. 
        ///    Get Function: niWLANA_GetAutoRangeMaxAcquisitionLength
        ///    Set Function: niWLANA_SetAutoRangeMaxAcquisitionLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAutorangeMaxAcquisitionLength(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.AutorangeMaxAcquisitionLength, channel, out value);
        }


        /// <summary>
        ///Specifies the maximum expected idle interval between the signal bursts to acquire    while performing auto-range using the niWLANA_RFSAAutoRange function. This value is expressed in seconds.
        ///    The default value is 100 &#181;s. 
        ///    Get Function: niWLANA_GetAutoRangeMaxIdleTime
        ///    Set Function: niWLANA_SetAutoRangeMaxIdleTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetAutorangeMaxIdleTime(string channel, double value)
        {
            return SetDouble(niWLANAProperties.AutorangeMaxIdleTime, channel, value);
        }


        /// <summary>
        ///Specifies the maximum expected idle interval between the signal bursts to acquire    while performing auto-range using the niWLANA_RFSAAutoRange function. This value is expressed in seconds.
        ///    The default value is 100 &#181;s. 
        ///    Get Function: niWLANA_GetAutoRangeMaxIdleTime
        ///    Set Function: niWLANA_SetAutoRangeMaxIdleTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAutorangeMaxIdleTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.AutorangeMaxIdleTime, channel, out value);
        }


        /// <summary>
        ///Specifies the carrier frequency which you configure on the NI-RFSA to acquire a WLAN signal. This value is expressed in Hz.    Set this value equal to the carrier frequency of the transmitting device under test (DUT).
        ///    Note: You must configure this attribute if you set the    NIWLANA_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED attribute    to NIWLANA_VAL_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED_TRUE using the niWLANA_RFSAConfigureFrequencySingleLO or    the niWLANA_RFSAConfigureFrequencyMultipleLO functions. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED attribute    to NIWLANA_VAL_OFDM_DEMOD_COMMON_CLOCK_SOURCE_ENABLED_FALSE. 
        ///    Note: You must configure this attribute if you enable any TxPower, DSSS Power Ramp, DSSS Demod, or OFDM Demod    attribute along with spectrum measurements. 
        ///    Refer to Simultaneous Measurements for more information about compatible simultaneous measurements. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211G_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM,    or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx]' as the active channel string syntax to query this attribute. You can use an empty string to    query this attribute if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///      The default value is 2.412 GHz.
        ///    Get Function: niWLANA_GetCarrierFrequency
        ///    Set Function: niWLANA_SetCarrierFrequency
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCarrierFrequency(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.CarrierFrequency, channel, out value);
        }


        /// <summary>
        ///Specifies the bandwidth of the OFDM    signal to be analyzed. This value is expressed in Hz. The toolkit uses this value to determine the NIWLANA_RECOMMENDED_SAMPLING_RATE attribute    and symbol structure for demodulation purposes. Configure this attribute only when you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        ///    The default value is 20MHz. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, the channel bandwidth must    be equal to 20 MHz. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211J_OFDM, the channel bandwidth must be equal to 10 MHz or 20 MHz. 
        ///    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, the    channel bandwidth must be equal to 5 MHz,    10 MHz, or 20 MHz.
        ///    If you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, the channel bandwidth must be either 20 MHz or 40 MHz.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM    or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, the channel bandwidth must be equal    to 20 MHz, 40 MHz, 80 MHz, 160 MHz.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, the    channel bandwidth must be equal to 1MHz, 2 MHz, 4 MHz, 8 MHz, or 16 MHz. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMOOFDM, the channel    bandwidth must be equal to 6 MHz, 7 MHz or 8 MHz.
        ///    Get Function: niWLANA_GetChannelBandwidth
        ///    Set Function: niWLANA_SetChannelBandwidth
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetChannelBandwidth(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ChannelBandwidth, channel, out value);
        }


        /// <summary>
        /// Indicates the WLAN Analysis Toolkit version in use.   
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetCompatibilityVersion(string channel, int value)
        {
            return SetInt(niWLANAProperties.CompatibilityVersion, channel, value);
        }


        /// <summary>
        ///Indicates the compatibilityVersion parameter of the niWLANA_OpenSession function.
        ///    Get Function: niWLANA_GetToolkitCompatibilityVersion   
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetCompatibilityVersion(string channel, out int value)
        {
            return GetInt(niWLANAProperties.CompatibilityVersion, channel, out value);
        }


        /// <summary>
        ///Specifies the payload data rate of the expected incoming signal. This value is expressed in Mbps. If you set the    NIWLANA_DSSS_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the value of the NIWLANA_DSSS_DATA_RATE    attribute as the data rate for    performing direct sequence spread spectrum (DSSS) demodulation measurements.
        ///    The default value is NIWLANA_VAL_DSSS_DATA_RATE_1.
        ///    Get Function: niWLANA_GetDSSSDataRate
        ///    Set Function: niWLANA_SetDSSSDataRate
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDataRate(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDataRate, channel, value);
        }


        /// <summary>
        ///Specifies the payload data rate of the expected incoming signal. This value is expressed in Mbps. If you set the    NIWLANA_DSSS_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the value of the NIWLANA_DSSS_DATA_RATE    attribute as the data rate for    performing direct sequence spread spectrum (DSSS) demodulation measurements.
        ///    The default value is NIWLANA_VAL_DSSS_DATA_RATE_1.
        ///    Get Function: niWLANA_GetDSSSDataRate
        ///    Set Function: niWLANA_SetDSSSDataRate
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDataRate(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDataRate, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable the constellation trace for the payload portion    of IEEE 802.11b or 802.11g direct sequence spread spectrum (DSSS) signals.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodConstellationTraceEnabled
        ///    Set Function: niWLANA_SetDSSSDemodConstellationTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodConstellationTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodConstellationTraceEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable the constellation trace for the payload portion    of IEEE 802.11b or 802.11g direct sequence spread spectrum (DSSS) signals.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodConstellationTraceEnabled
        ///    Set Function: niWLANA_SetDSSSDemodConstellationTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodConstellationTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodConstellationTraceEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable demodulation-based measurements if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211BG_DSSS.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodEnabled
        ///    Set Function: niWLANA_SetDSSSDemodEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable equalization. The IEEE Standard 802.11-2007 does not allow equalization before computing    EVM.
        ///    Note: If you enable equalization, the toolkit does not support measurement of I/Q impairments and decoding of bits.
        ///    Note: Equalization is not supported for signals with data rates of 22 Mbps and 33 Mbps. Do not set this attribute to NIWLANA_VAL_TRUE    when performing demodulation measurements on signals with data rates of 22 Mbps and 33 Mbps.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodEqualizationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodEqualizationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodEqualizationEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodEqualizationEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable equalization. The IEEE Standard 802.11-2007 does not allow equalization before computing    EVM.
        ///    Note: If you enable equalization, the toolkit does not support measurement of I/Q impairments and decoding of bits.
        ///    Note: Equalization is not supported for signals with data rates of 22 Mbps and 33 Mbps. Do not set this attribute to NIWLANA_VAL_TRUE    when performing demodulation measurements on signals with data rates of 22 Mbps and 33 Mbps.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodEqualizationEnabled
        ///    Set Function: niWLANA_SetDSSSDemodEqualizationEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodEqualizationEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodEqualizationEnabled, channel, out value);
        }

        /// <summary>
        /// Specifies whether to enable EVM per symbol trace for 802.11b and 802.11g direct sequence spread spectrum (DSSS) signals.
        ///     The default value is NIWLANA_VAL_FALSE. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetDsssDemodEvmPerSymbolTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodEvmPerSymbolTraceEnabled, channel, value);
        }

        /// <summary>
        /// Specifies whether to enable EVM per symbol trace for 802.11b and 802.11g direct sequence spread spectrum (DSSS) signals.
        ///     The default value is NIWLANA_VAL_FALSE. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetDsssDemodEvmPerSymbolTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodEvmPerSymbolTraceEnabled, channel, out value);
        }

        /// <summary>
        /// Specifies whether to enable computation of time-gated power.
        ///     The default value is NIWLANA_VAL_FALSE.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodGatedPowerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodGatedPowerEnabled, channel, value);
        }


        /// <summary>
        /// Specifies whether to enable computation of time-gated power.
        ///     The default value is NIWLANA_VAL_FALSE.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodGatedPowerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodGatedPowerEnabled, channel, out value);
        }


        /// <summary>
        /// Specifies the start time for computing gated power in seconds. The value 0 indicates the start time    is the start of the payload.
        ///     A negative value indicates a position in the preamble or header.    Refer to the Gated Power topic for more information.
        ///     The default value is 0.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodGatedPowerStartTime(string channel, double value)
        {
            return SetDouble(niWLANAProperties.DsssDemodGatedPowerStartTime, channel, value);
        }


        /// <summary>
        /// Specifies the start time for computing gated power in seconds. The value 0 indicates the start time    is the start of the payload.
        ///     A negative value indicates a position in the preamble or header.    Refer to the Gated Power topic for more information.
        ///     The default value is 0.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodGatedPowerStartTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DsssDemodGatedPowerStartTime, channel, out value);
        }


        /// <summary>
        /// Specifies the stop time for computing gated power in seconds. The value 0 indicates the stop time    is the start of the payload.
        ///     A negative value indicates a position in the preamble or header.    Refer to the Gated Power topic for more information.
        ///     The default value is 64 microseconds.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodGatedPowerStopTime(string channel, double value)
        {
            return SetDouble(niWLANAProperties.DsssDemodGatedPowerStopTime, channel, value);
        }


        /// <summary>
        /// Specifies the stop time for computing gated power in seconds. The value 0 indicates the stop time    is the start of the payload.
        ///     A negative value indicates a position in the preamble or header.    Refer to the Gated Power topic for more information.
        ///     The default value is 64 microseconds.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodGatedPowerStopTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DsssDemodGatedPowerStopTime, channel, out value);
        }


        /// <summary>
        ///Specifies whether to automatically detect the physical layer convergence procedure (PLCP) header.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetDSSSDemodHeaderDetectionEnabled
        ///    Set Function: niWLANA_SetDSSSDemodHeaderDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodHeaderDetectionEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodHeaderDetectionEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to automatically detect the physical layer convergence procedure (PLCP) header.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetDSSSDemodHeaderDetectionEnabled
        ///    Set Function: niWLANA_SetDSSSDemodHeaderDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodHeaderDetectionEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodHeaderDetectionEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to perform lowpass filtering after acquiring the baseband signal to remove out-of-band noise.
        ///    Note: EVM measurement quality may be affected by out-of-band spurious    signals if the NI-RFSA bandwidth    (defined as 0.8 * I/Q rate) is significantly greater than the channel bandwidth. Enable the    software low-pass filter to reject the out-of-channel noise.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodLowPassFilteringEnabled
        ///    Set Function: niWLANA_SetDSSSDemodLowPassFilteringEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodLowpassFilteringEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodLowpassFilteringEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to perform lowpass filtering after acquiring the baseband signal to remove out-of-band noise.
        ///    Note: EVM measurement quality may be affected by out-of-band spurious    signals if the NI-RFSA bandwidth    (defined as 0.8 * I/Q rate) is significantly greater than the channel bandwidth. Enable the    software low-pass filter to reject the out-of-channel noise.
        ///    The default value is NIWLANA_VAL_TRUE. 
        ///    Get Function: niWLANA_GetDSSSDemodLowPassFilteringEnabled
        ///    Set Function: niWLANA_SetDSSSDemodLowPassFilteringEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodLowpassFilteringEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodLowpassFilteringEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the maximum number of chips (q) that the toolkit uses to compute EVM. If you specify (p) as the number    of available chips in the payload, and &#124;p-q&#124; is greater than or equal    to 300, the toolkit ignores (p-q) chips from the end of the payload    and computes EVM on q chips. If &#124;p-q&#124; is less than 300, the toolkit ignores the    last 300 chips and computes EVM on &#124;p-300&#124; chips.
        ///    Note: If you set this attribute to -1, the toolkit measures EVM on &#124;p-300&#124; chips.
        ///    The default value is 1,000. Decrease this value to significantly increase measurement speed.
        ///    Get Function: niWLANA_GetDSSSDemodMaximumChipsUsed
        ///    Set Function: niWLANA_SetDSSSDemodMaximumChipsUsed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodMaximumChipsUsed(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodMaximumChipsUsed, channel, value);
        }


        /// <summary>
        ///Specifies the maximum number of chips (q) that the toolkit uses to compute EVM. If you specify (p) as the number    of available chips in the payload, and &#124;p-q&#124; is greater than or equal    to 300, the toolkit ignores (p-q) chips from the end of the payload    and computes EVM on q chips. If &#124;p-q&#124; is less than 300, the toolkit ignores the    last 300 chips and computes EVM on &#124;p-300&#124; chips.
        ///    Note: If you set this attribute to -1, the toolkit measures EVM on &#124;p-300&#124; chips.
        ///    The default value is 1,000. Decrease this value to significantly increase measurement speed.
        ///    Get Function: niWLANA_GetDSSSDemodMaximumChipsUsed
        ///    Set Function: niWLANA_SetDSSSDemodMaximumChipsUsed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodMaximumChipsUsed(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodMaximumChipsUsed, channel, out value);
        }


        /// <summary>
        ///Specifies the number of payload chips to remove before starting the EVM    computation. If the number of available payload chips (n) is greater than the value that you specify    (m), the toolkit ignores (n-m) chips from the end of the payload.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetDSSSDemodMeasurementStartLocation
        ///    Set Function: niWLANA_SetDSSSDemodMeasurementStartLocation
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodMeasurementStartLocation(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodMeasurementStartLocation, channel, value);
        }


        /// <summary>
        ///Specifies the number of payload chips to remove before starting the EVM    computation. If the number of available payload chips (n) is greater than the value that you specify    (m), the toolkit ignores (n-m) chips from the end of the payload.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetDSSSDemodMeasurementStartLocation
        ///    Set Function: niWLANA_SetDSSSDemodMeasurementStartLocation
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodMeasurementStartLocation(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodMeasurementStartLocation, channel, out value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages direct sequence spread spectrum (DSSS) demodulation-based measurements.
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes a longer time to compute the values.
        ///      The default value is 1. Valid values are 1 to 1,000, inclusive.
        ///    Get Function: niWLANA_GetDSSSDemodNumberOfAverages
        ///    Set Function: niWLANA_SetDSSSDemodNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodNumberOfAverages(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodNumberOfAverages, channel, out value);
        }


        /// <summary>
        ///Specifies the method of phase tracking to enable. Phase tracking is useful for tracking the phase    variations caused by residual frequency offset and phase noise.
        ///    The default value is NIWLAN_VAL_DSSS_PHASE_TRACKING_STANDARD.
        ///    Get Function: niWLANA_GetDSSSDemodPhaseTracking
        ///    Set Function: niWLANA_SetDSSSDemodPhaseTracking
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodPhaseTracking(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodPhaseTracking, channel, value);
        }


        /// <summary>
        ///Specifies the method of phase tracking to enable. Phase tracking is useful for tracking the phase    variations caused by residual frequency offset and phase noise.
        ///    The default value is NIWLAN_VAL_DSSS_PHASE_TRACKING_STANDARD.
        ///    Get Function: niWLANA_GetDSSSDemodPhaseTracking
        ///    Set Function: niWLANA_SetDSSSDemodPhaseTracking
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodPhaseTracking(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodPhaseTracking, channel, out value);
        }


        /// <summary>
        /// Specifies the value of alpha if you set the NIWLANA_DSSS_DEMOD_REFERENCE_PULSE_SHAPING_FILTER_TYPE attribute to NIWLANA_VAL_FILTER_RAISED_COSINE or NIWLANA_VAL_FILTER_ROOT_RAISED_COSINE. If you set the NIWLANA_DSSS_DEMOD_REFERENCE_PULSE_SHAPING_FILTER_TYPE attribute to NIWLANA_VAL_FILTER_GAUSSIAN in the non-equalization mode, the filterCoefficient parameter specifies the value of B * T, where B is the 3 dB filter bandwidth and T is time. The toolkit ignores this function in other cases.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodReferencePulseShapingFilterCoefficient(string channel, double value)
        {
            return SetDouble(niWLANAProperties.DsssDemodReferencePulseShapingFilterCoefficient, channel, value);
        }


        /// <summary>
        ///Specifies the value of alpha if you set the NIWLANA_DSSS_DEMOD_REFERENCE_PULSE_SHAPING_FILTER_TYPE attribute    to NIWLANA_VAL_RAISED_COSINE or NIWLANA_VAL_ROOT_RAISED_COSINE. 
        ///    If you set the NIWLANA_DSSS_DEMOD_REFERENCE_PULSE_SHAPING_FILTER_TYPE attribute    to NIWLANA_VAL_GAUSSIAN in the non-equalization mode,    the NIWLANA_DSSS_DEMOD_REFERENCE_PULSE_SHAPING_FILTER_COEFFICIENT attribute specifies the value of B * T, where B is the 3 dB filter    bandwidth and T is symbol time. 
        ///    The toolkit ignores the NIWLANA_DSSS_DEMOD_REFERENCE_PULSE_SHAPING_FILTER_COEFFICIENT attribute if    the NIWLANA_DSSS_DEMOD_REFERENCE_PULSE_SHAPING_FILTER_TYPE attribute is NIWLANA_VAL_FILTER_RECTANGULAR.
        ///    The default value is 0.5.
        ///    Get Function: niWLANA_GetDSSSDemodReferencePulseShapingFilterCoefficient
        ///    Set Function: niWLANA_SetDSSSDemodReferencePulseShapingFilterCoefficient
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodReferencePulseShapingFilterCoefficient(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DsssDemodReferencePulseShapingFilterCoefficient, channel, out value);
        }


        /// <summary>
        /// Specifies the pulse-shaping filter for generation of matched-filter coefficients. In most cases, you must set the NIWLANA_DSSS_DEMOD_REFERENCE_PULSE_SHAPING_FILTER_TYPE attribute to the option that is used for the unit under test (UUT).
        /// The toolkit ignores this function if you set the  NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodReferencePulseShapingFilterType(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodReferencePulseShapingFilterType, channel, value);
        }


        /// <summary>
        ///Specifies the pulse-shaping filter for generation of matched-filter coefficients. In most cases,    you must set this attribute to the option that is used for the unit under test (UUT). 
        ///    The toolkit ignores this attribute if you set the NIWLANA_DSSS_DEMOD_EQUALIZATION_ENABLED attribute to NIWLANA_VAL_TRUE.
        ///    The default value is NIWLANA_VAL_ROOT_RAISED_COSINE.
        ///    Get Function: niWLANA_GetDSSSDemodReferencePulseShapingFilterType
        ///    Set Function: niWLANA_SetDSSSDemodReferencePulseShapingFilterType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodReferencePulseShapingFilterType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodReferencePulseShapingFilterType, channel, out value);
        }


        /// <summary>
        ///Specifies the payload length of the expected incoming signal. This value is expressed in bytes. If you set the    NIWLANA_DSSS_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the value of the NIWLANA_DSSS_PAYLOAD_LENGTH    attribute as the payload length for performing direct sequence spread spectrum (DSSS) demodulation measurements.
        ///    The default value is 1,024.
        ///    Get Function: niWLANA_GetDSSSPayloadLength
        ///    Set Function: niWLANA_SetDSSSPayloadLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssPayloadLength(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssPayloadLength, channel, value);
        }


        /// <summary>
        ///Specifies the payload length of the expected incoming signal. This value is expressed in bytes. If you set the    NIWLANA_DSSS_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the value of the NIWLANA_DSSS_PAYLOAD_LENGTH    attribute as the payload length for performing direct sequence spread spectrum (DSSS) demodulation measurements.
        ///    The default value is 1,024.
        ///    Get Function: niWLANA_GetDSSSPayloadLength
        ///    Set Function: niWLANA_SetDSSSPayloadLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssPayloadLength(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssPayloadLength, channel, out value);
        }


        /// <summary>
        ///Specifies the percentage of the maximum windowed burst power at which the power ramp-down    in the burst is assumed to start.
        ///    The default value is 90.
        ///    Get Function: niWLANA_GetDSSSPowerRampDownHighThreshold
        ///    Set Function: niWLANA_SetDSSSPowerRampDownHighThreshold
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssPowerRampDownHighThreshold(string channel, double value)
        {
            return SetDouble(niWLANAProperties.DsssPowerRampDownHighThreshold, channel, value);
        }


        /// <summary>
        ///Specifies the percentage of the maximum windowed burst power at which the power ramp-down    in the burst is assumed to start.
        ///    The default value is 90.
        ///    Get Function: niWLANA_GetDSSSPowerRampDownHighThreshold
        ///    Set Function: niWLANA_SetDSSSPowerRampDownHighThreshold
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssPowerRampDownHighThreshold(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DsssPowerRampDownHighThreshold, channel, out value);
        }


        /// <summary>
        ///Specifies the percentage of the maximum windowed burst power at which the power ramp-down    in the burst is assumed to end.
        ///    The default value is 10.
        ///    Get Function: niWLANA_GetDSSSPowerRampDownLowThreshold
        ///    Set Function: niWLANA_SetDSSSPowerRampDownLowThreshold
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssPowerRampDownLowThreshold(string channel, double value)
        {
            return SetDouble(niWLANAProperties.DsssPowerRampDownLowThreshold, channel, value);
        }


        /// <summary>
        ///Specifies the percentage of the maximum windowed burst power at which the power ramp-down    in the burst is assumed to end.
        ///    The default value is 10.
        ///    Get Function: niWLANA_GetDSSSPowerRampDownLowThreshold
        ///    Set Function: niWLANA_SetDSSSPowerRampDownLowThreshold
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssPowerRampDownLowThreshold(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DsssPowerRampDownLowThreshold, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable measurement of the power ramp-up or ramp-down time for    802.11b and 802.11g direct sequence spread spectrum (DSSS) signals.
        ///    To use the NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_ENABLED attribute, you must set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211BG_DSSS.    If you set the NIWLANA_STANDARD attribute to any other value and configure the NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_ENABLED    attribute, the toolkit returns an error.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSPowerRampMeasurementEnabled
        ///    Set Function: niWLANA_SetDSSSPowerRampMeasurementEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssPowerRampMeasurementEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssPowerRampMeasurementEnabled, channel, out value);
        }




        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages direct sequence spread spectrum (DSSS) power ramp measurements.
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values.
        ///    The default value is 1. Valid values are 1 to 1,000, inclusive.
        ///    Get Function: niWLANA_GetDSSSPowerRampMeasurementNumberOfAverages
        ///    Set Function: niWLANA_SetDSSSPowerRampMeasurementNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssPowerRampMeasurementNumberOfAverages(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssPowerRampMeasurementNumberOfAverages, channel, out value);
        }


        /// <summary>
        ///Specifies the percentage of the maximum windowed burst power at which the power ramp-up    in the burst is assumed to end.
        ///    The default value is 90.
        ///    Get Function: niWLANA_GetDSSSPowerRampUpHighThreshold
        ///    Set Function: niWLANA_SetDSSSPowerRampUpHighThreshold
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssPowerRampUpHighThreshold(string channel, double value)
        {
            return SetDouble(niWLANAProperties.DsssPowerRampUpHighThreshold, channel, value);
        }


        /// <summary>
        ///Specifies the percentage of the maximum windowed burst power at which the power ramp-up    in the burst is assumed to end.
        ///    The default value is 90.
        ///    Get Function: niWLANA_GetDSSSPowerRampUpHighThreshold
        ///    Set Function: niWLANA_SetDSSSPowerRampUpHighThreshold
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssPowerRampUpHighThreshold(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DsssPowerRampUpHighThreshold, channel, out value);
        }


        /// <summary>
        ///Specifies the percentage of the maximum windowed burst power at which the power ramp-up    in the burst is assumed to start.
        ///    The default value is 10.
        ///    Get Function: niWLANA_GetDSSSPowerRampUpLowThreshold
        ///    Set Function: niWLANA_SetDSSSPowerRampUpLowThreshold
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssPowerRampUpLowThreshold(string channel, double value)
        {
            return SetDouble(niWLANAProperties.DsssPowerRampUpLowThreshold, channel, value);
        }


        /// <summary>
        ///Specifies the percentage of the maximum windowed burst power at which the power ramp-up    in the burst is assumed to start.
        ///    The default value is 10.
        ///    Get Function: niWLANA_GetDSSSPowerRampUpLowThreshold
        ///    Set Function: niWLANA_SetDSSSPowerRampUpLowThreshold
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssPowerRampUpLowThreshold(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DsssPowerRampUpLowThreshold, channel, out value);
        }


        /// <summary>
        ///Specifies the FFT length used to compute the acquired I/Q data spectrum. This value is expressed in samples. 
        ///    If you use the niWLANA_ConfigureRFSA function,    the toolkit ignores this attribute.    If you set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE or use    niWLANA_RFSAConfigureHardware or niWLANA_RFSAConfigureMIMOHardware functions    with NIWLANA_GATED_SPECTRUM_ENABLED attribute set to NIWLANA_VAL_FALSE, the    toolkit ignores this attribute.    If you configure NI-RFSA independently or use other hardware, you must specify the correct FFT length.
        ///    The default value is 222.
        ///    Get Function: niWLANA_GetFFTSize
        ///    Set Function: niWLANA_SetFFTSize
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetFftSize(string channel, int value)
        {
            return SetInt(niWLANAProperties.FftSize, channel, value);
        }


        /// <summary>
        ///Specifies the FFT length used to compute the acquired I/Q data spectrum. This value is expressed in samples. 
        ///    If you use the niWLANA_ConfigureRFSA function,    the toolkit ignores this attribute.    If you set the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE or use    niWLANA_RFSAConfigureHardware or niWLANA_RFSAConfigureMIMOHardware functions    with NIWLANA_GATED_SPECTRUM_ENABLED attribute set to NIWLANA_VAL_FALSE, the    toolkit ignores this attribute.    If you configure NI-RFSA independently or use other hardware, you must specify the correct FFT length.
        ///    The default value is 222.
        ///    Get Function: niWLANA_GetFFTSize
        ///    Set Function: niWLANA_SetFFTSize
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetFftSize(string channel, out int value)
        {
            return GetInt(niWLANAProperties.FftSize, channel, out value);
        }


        /// <summary>
        ///Specifies the size of the window used in the FFT computation of the acquired I/Q data spectrum. This value is expressed in samples. If you set    the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE or if you use the    niWLANA_RFSAConfigureHardware function or the niWLANA_RFSAConfigureMIMOHardware function with    the NIWLANA_GATED_SPECTRUM_ENABLED attribute set to NIWLANA_VAL_FALSE the    toolkit ignores this attribute. If you configure the NI-RFSA independently or use other hardware, you must    specify the correct window size.
        ///    The default value is 222.
        ///    Get Function: niWLANA_GetFFTWindowSize
        ///    Set Function: niWLANA_SetFFTWindowSize
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetFftWindowSize(string channel, int value)
        {
            return SetInt(niWLANAProperties.FftWindowSize, channel, value);
        }


        /// <summary>
        ///Specifies the size of the window used in the FFT computation of the acquired I/Q data spectrum. This value is expressed in samples. If you set    the NIWLANA_GATED_SPECTRUM_ENABLED attribute to NIWLANA_VAL_TRUE or if you use the    niWLANA_RFSAConfigureHardware function or the niWLANA_RFSAConfigureMIMOHardware function with    the NIWLANA_GATED_SPECTRUM_ENABLED attribute set to NIWLANA_VAL_FALSE the    toolkit ignores this attribute. If you configure the NI-RFSA independently or use other hardware, you must    specify the correct window size.
        ///    The default value is 222.
        ///    Get Function: niWLANA_GetFFTWindowSize
        ///    Set Function: niWLANA_SetFFTWindowSize
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetFftWindowSize(string channel, out int value)
        {
            return GetInt(niWLANAProperties.FftWindowSize, channel, out value);
        }


        /// <summary>
        ///Specifies the time-domain window type to use for smoothing the spectrum.
        ///    Note: For this attribute's valid value descriptions, refer to the FFT Window Type Values help topic in    the NI LabWindows/CVI WLAN Analysis Toolkit Reference Help.
        ///    The default value is NIWLANA_VAL_WINDOW_7_TERM_BLACKMAN_HARRIS.
        ///    Get Function: niWLANA_GetFFTWindowType
        ///    Set Function: niWLANA_SetFFTWindowType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetFftWindowType(string channel, int value)
        {
            return SetInt(niWLANAProperties.FftWindowType, channel, value);
        }


        /// <summary>
        ///Specifies the time-domain window type to use for smoothing the spectrum.
        ///    Note: For this attribute's valid value descriptions, refer to the FFT Window Type Values help topic in    the NI LabWindows/CVI WLAN Analysis Toolkit Reference Help.
        ///    The default value is NIWLANA_VAL_WINDOW_7_TERM_BLACKMAN_HARRIS.
        ///    Get Function: niWLANA_GetFFTWindowType
        ///    Set Function: niWLANA_SetFFTWindowType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetFftWindowType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.FftWindowType, channel, out value);
        }


        /// <summary>
        /// Specifies whether to enable gated spectrum acquisition for spectral measurements.
        /// Note&#160;&#160;The default value is NIWLANA_VAL_FALSE if you set the compatibilityVersion parameter of the niWLANA_OpenSession function to a value other than NIWLANA_VAL_COMPATIBILITY_VERSION_040000 or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetGatedSpectrumEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.GatedSpectrumEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable gated spectrum acquisition for spectral measurements.
        ///    Note: The default value is NIWLANA_VAL_FALSE if you set the compatibilityVersion    parameter of the niWLANA_OpenSession function to values other    than NIWLANA_VAL_COMPATIBILITY_VERSION_040000 or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetGatedSpectrumEnabled
        ///    Set Function: niWLANA_SetGatedSpectrumEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetGatedSpectrumEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.GatedSpectrumEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the mode for computing gated spectrum.
        ///    Note: The default value is NIWLANA_VAL_GATED_SPECTRUM_MODE_RBW if you set the compatibilityVersion    parameter of the niWLANA_OpenSession function to a value other    than NIWLANA_VAL_COMPATIBILITY_VERSION_040000 or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        ///    The default value is NIWLANA_VAL_GATED_SPECTRUM_MODE_RBW_AND_MEASUREMENT_LENGTH.
        ///     Get Function: niWLANA_GetGatedSpectrumMode
        ///    Set Function: niWLANA_SetGatedSpectrumMode
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetGatedSpectrumMode(string channel, int value)
        {
            return SetInt(niWLANAProperties.GatedSpectrumMode, channel, value);
        }


        /// <summary>
        ///Specifies the mode for computing gated spectrum.
        ///    Note: The default value is NIWLANA_VAL_GATED_SPECTRUM_MODE_RBW if you set the compatibilityVersion    parameter of the niWLANA_OpenSession function to a value other    than NIWLANA_VAL_COMPATIBILITY_VERSION_040000 or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        ///    The default value is NIWLANA_VAL_GATED_SPECTRUM_MODE_RBW_AND_MEASUREMENT_LENGTH.
        ///     Get Function: niWLANA_GetGatedSpectrumMode
        ///    Set Function: niWLANA_SetGatedSpectrumMode
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetGatedSpectrumMode(string channel, out int value)
        {
            return GetInt(niWLANAProperties.GatedSpectrumMode, channel, out value);
        }

        /// <summary>
        /// Specifies the guard interval, in seconds, which is used in manual header detection and acquisition length calculation.     If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the value of the NIWLANA_GUARD_INTERVAL attribute as the guard     interval for performing orthogonal frequency division multiplexing (OFDM) demodulation measurements.
        ///      Note: To use this attribute, you must have the NI WLAN Analysis Toolkit for IEEE 802.11a/b/g/n     license and set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 800n. Valid values are 800n and 400n. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete("Use SetGuardIntervalType()")]
        public int SetGuardInterval(string channel, double value)
        {
            return SetDouble(niWLANAProperties.GuardInterval, channel, value);
        }

        /// <summary>
        /// Specifies the guard interval, in seconds, which is used in manual header detection and acquisition length calculation.     If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the value of the NIWLANA_GUARD_INTERVAL attribute as the guard     interval for performing orthogonal frequency division multiplexing (OFDM) demodulation measurements.
        ///      Note: To use this attribute, you must have the NI WLAN Analysis Toolkit for IEEE 802.11a/b/g/n     license and set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 800n. Valid values are 800n and 400n. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete("Use GetGuardIntervalType()")]
        public int GetGuardInterval(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.GuardInterval, channel, out value);
        }

        /// <summary>
        /// Specifies whether to use an I/Q power-edge reference trigger. If you use another mechanism to    determine when to acquire the data, such as a digital signal exported by a device under test (DUT) at the start of    the packet, set this attribute to NIWLANA_VAL_FALSE and configure the appropriate triggering in NI-RFSA.    If you enable any spectral measurements, NI-RFSA performs spectral acquisition    and ignores this attribute.
        ///     The default value is NIWLANA_VAL_TRUE.        
        /// 
        /// </summary>
        [Obsolete]
        public int SetIqPowerEdgeReferenceTriggerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.IqPowerEdgeReferenceTriggerEnabled, channel, value);
        }

        /// <summary>
        /// Specifies whether to use an I/Q power-edge reference trigger. If you use another mechanism to    determine when to acquire the data, such as a digital signal exported by a device under test (DUT) at the start of    the packet, set this attribute to NIWLANA_VAL_FALSE and configure the appropriate triggering in NI-RFSA.    If you enable any spectral measurements, NI-RFSA performs spectral acquisition    and ignores this attribute.
        ///     The default value is NIWLANA_VAL_TRUE.        
        /// 
        /// </summary>
        [Obsolete]
        public int GetIqPowerEdgeReferenceTriggerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.IqPowerEdgeReferenceTriggerEnabled, channel, out value);
        }

        /// <summary>
        /// Specifies the expected average power level, in dBm, of the incoming signal at the input of the RF    signal analyzer excluding any interframe spacing. Set this attribute equal to the     sum of the average transmission power of the waveform and the maximum expected     peak-to-average power ratio (PAPR) of the incoming signal.
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must     use an active channel string to configure this attribute.
        ///     Note: If you do not know what power level to set, use the niWLANA_RFSAAutoRange function.
        ///     Tip: Measurements might not be accurate if the incoming burst has an average     power of less than -30 dBm. Consider using a preamplifier to better use the dynamic range of the signal analyzer.
        ///     The default value is 0.          
        /// 
        /// </summary>
        [Obsolete]
        public int SetMaxInputPower(string channel, double value)
        {
            return SetDouble(niWLANAProperties.MaxInputPower, channel, value);
        }

        /// <summary>
        /// Specifies the expected average power level, in dBm, of the incoming signal at the input of the RF    signal analyzer excluding any interframe spacing. Set this attribute equal to the     sum of the average transmission power of the waveform and the maximum expected     peak-to-average power ratio (PAPR) of the incoming signal.
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must     use an active channel string to configure this attribute.
        ///     Note: If you do not know what power level to set, use the niWLANA_RFSAAutoRange function.
        ///     Tip: Measurements might not be accurate if the incoming burst has an average     power of less than -30 dBm. Consider using a preamplifier to better use the dynamic range of the signal analyzer.
        ///     The default value is 0.          
        /// 
        /// </summary>
        [Obsolete]
        public int GetMaxInputPower(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.MaxInputPower, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable measurement of the maximum spectral density of the acquired    power spectrum. This value is expressed in W/MHz. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetMaxSpectralDensityMeasurementEnabled
        ///    Set Function: niWLANA_SetMaxSpectralDensityMeasurementEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetMaxSpectralDensityEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.MaxSpectralDensityEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable measurement of the maximum spectral density of the acquired    power spectrum. This value is expressed in W/MHz. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetMaxSpectralDensityMeasurementEnabled
        ///    Set Function: niWLANA_SetMaxSpectralDensityMeasurementEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetMaxSpectralDensityEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.MaxSpectralDensityEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages the maximum spectral    density measurements.
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values.
        ///      The default value is 10. Valid values are 1 to 1,000, inclusive.
        ///    Get Function: niWLANA_GetMaxSpectralDensityNumberOfAverages
        ///    Set Function: niWLANA_SetMaxSpectralDensityNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetMaxSpectralDensityNumberOfAverages(string channel, int value)
        {
            return SetInt(niWLANAProperties.MaxSpectralDensityNumberOfAverages, channel, value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages the maximum spectral    density measurements.
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values.
        ///      The default value is 10. Valid values are 1 to 1,000, inclusive.
        ///    Get Function: niWLANA_GetMaxSpectralDensityNumberOfAverages
        ///    Set Function: niWLANA_SetMaxSpectralDensityNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetMaxSpectralDensityNumberOfAverages(string channel, out int value)
        {
            return GetInt(niWLANAProperties.MaxSpectralDensityNumberOfAverages, channel, out value);
        }


        /// <summary>
        ///Specifies the modulation and coding scheme (MCS) index if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_NON_HT_MODULATION_MODE attribute    to NIWLANA_VAL_OFDM_NON_HT_MODULATION_MODE_OFF. Each index represents the modulation and coding    used on the payload according to section 20.6 of IEEE Standard 802.11n-2009, section 22.5 of IEEE Standard 802.11ac-2013, section 23.5    of IEEE Standard 802.11af-2013 and section 28.5 of IEEE P802.11ax/D1.2. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED    attribute to NIWLANA_VAL_TRUE for the PPDU types other than Trigger-Based PPDU.
        ///    The toolkit uses the value of the NIWLANA_MCS_INDEX attribute as the MCS index for performing OFDM demodulation measurements. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use an empty string to query this attribute. 
        ///    If you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active channel string syntax to query this attribute.
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you    must use an empty string to query this attribute. 
        ///    If you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must    use 'userx' as the active channel string syntax to query this attribute.
        ///     The default value is 0. Valid values are 0 to 31, inclusive, for NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM; 0 to 11, inclusive for    NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM; and 0 to 9,    inclusive, for NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM.
        ///    Get Function: niWLANA_GetMCSIndex
        ///    Set Function: niWLANA_SetMCSIndex
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetMcsIndex(string channel, int value)
        {
            return SetInt(niWLANAProperties.McsIndex, channel, value);
        }


        /// <summary>
        ///Specifies the modulation and coding scheme (MCS) index if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_NON_HT_MODULATION_MODE attribute    to NIWLANA_VAL_OFDM_NON_HT_MODULATION_MODE_OFF. Each index represents the modulation and coding    used on the payload according to section 20.6 of IEEE Standard 802.11n-2009, section 22.5 of IEEE Standard 802.11ac-2013, section 23.5    of IEEE Standard 802.11af-2013 and section 28.5 of IEEE P802.11ax/D1.2. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED    attribute to NIWLANA_VAL_TRUE for the PPDU types other than Trigger-Based PPDU.
        ///    The toolkit uses the value of the NIWLANA_MCS_INDEX attribute as the MCS index for performing OFDM demodulation measurements. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use an empty string to query this attribute. 
        ///    If you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active channel string syntax to query this attribute.
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you    must use an empty string to query this attribute. 
        ///    If you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must    use 'userx' as the active channel string syntax to query this attribute.
        ///     The default value is 0. Valid values are 0 to 31, inclusive, for NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM; 0 to 11, inclusive for    NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM; and 0 to 9,    inclusive, for NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM.
        ///    Get Function: niWLANA_GetMCSIndex
        ///    Set Function: niWLANA_SetMCSIndex
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetMcsIndex(string channel, out int value)
        {
            return GetInt(niWLANAProperties.McsIndex, channel, out value);
        }


        /// <summary>
        ///Specifies the number of extension spatial streams.    If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the value    of the NIWLANA_NUMBER_OF_EXTENSION_SPATIAL_STREAMS attribute as the number of extension spatial streams for performing    OFDM demodulation measurements.
        ///    The default value is 0. Valid values are 0 to 3, inclusive.
        ///    Get Function: niWLANA_GetNumberOfExtensionSpatialStreams
        ///    Set Function: niWLANA_SetNumberOfExtensionSpatialStreams
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNumberOfExtensionSpatialStreams(string channel, int value)
        {
            return SetInt(niWLANAProperties.NumberOfExtensionSpatialStreams, channel, value);
        }


        /// <summary>
        ///Specifies the number of extension spatial streams.    If you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the value    of the NIWLANA_NUMBER_OF_EXTENSION_SPATIAL_STREAMS attribute as the number of extension spatial streams for performing    OFDM demodulation measurements.
        ///    The default value is 0. Valid values are 0 to 3, inclusive.
        ///    Get Function: niWLANA_GetNumberOfExtensionSpatialStreams
        ///    Set Function: niWLANA_SetNumberOfExtensionSpatialStreams
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNumberOfExtensionSpatialStreams(string channel, out int value)
        {
            return GetInt(niWLANAProperties.NumberOfExtensionSpatialStreams, channel, out value);
        }


        /// <summary>
        /// For I/Q measurements, this attribute returns the maximum of the    NIWLANA_SPECTRAL_MASK_NUMBER_OF_AVERAGES attribute for all enabled measurements.    For spectral measurements, this attribute returns 1, which indicates the number of    times the measurement loop must run for all enabled measurements.
        /// 
        /// </summary>
        [Obsolete]
        public int GetNumberOfIterations(string channel, out int value)
        {
            return GetInt(niWLANAProperties.NumberOfIterations, channel, out value);
        }


        /// <summary>
        ///Specifies the number of channels (waveforms) to process during analysis measurements.    The number of received channels must be less than or equal to the number of channels acquired.    Use this attribute to process fewer number of waveforms than acquired waveforms.
        ///    Tip: Set the NIWLANA_NUMBER_OF_RECEIVE_CHANNELS attribute equal to the number of transmission antennas of the device under test (DUT).
        ///    The default value is 1. If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, the valid values    are 1 to 4, inclusive. If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, the    valid values are 1 to 8, inclusive.
        ///    Get Function: niWLANA_GetNumberOfReceiveChannels
        ///    Set Function: niWLANA_SetNumberOfReceiveChannels
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNumberOfReceiveChannels(string channel, out int value)
        {
            return GetInt(niWLANAProperties.NumberOfReceiveChannels, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable OBW measurements.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOBWMeasurementEnabled
        ///    Set Function: niWLANA_SetOBWMeasurementEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetObwEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.ObwEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable OBW measurements.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOBWMeasurementEnabled
        ///    Set Function: niWLANA_SetOBWMeasurementEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetObwEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ObwEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages    OBW measurements.
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values.
        ///    The default value is 10. Valid values are 1 to 1,000, inclusive.
        ///    Get Function: niWLANA_GetOBWNumberOfAverages
        ///    Set Function: niWLANA_SetOBWNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetObwNumberOfAverages(string channel, int value)
        {
            return SetInt(niWLANAProperties.ObwNumberOfAverages, channel, value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages    OBW measurements.
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values.
        ///    The default value is 10. Valid values are 1 to 1,000, inclusive.
        ///    Get Function: niWLANA_GetOBWNumberOfAverages
        ///    Set Function: niWLANA_SetOBWNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetObwNumberOfAverages(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ObwNumberOfAverages, channel, out value);
        }


        /// <summary>
        ///Specifies the payload data rate of the expected incoming signal for channel bandwidths of 5 MHz, 10 MHz, and 20 MHz    when you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and the NIWLANA_OFDM_NON_HT_MODULATION_MODE attribute    to NIWLANA_VAL_OFDM_NON_HT_MODULATION_MODE_ON. This value is expressed in Mbps. 
        ///    If you set the NIWLANA_OFDM_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the value of the NIWLANA_OFDM_DATA_RATE    attribute as the data rate for performing OFDM demodulation measurements.
        ///    The default value is NIWLANA_VAL_OFDM_DATA_RATE_6.
        ///    Get Function: niWLANA_GetOFDMDataRate
        ///    Set Function: niWLANA_SetOFDMDataRate
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDataRate(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDataRate, channel, value);
        }


        /// <summary>
        ///Specifies the payload data rate of the expected incoming signal for channel bandwidths of 5 MHz, 10 MHz, and 20 MHz    when you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and the NIWLANA_OFDM_NON_HT_MODULATION_MODE attribute    to NIWLANA_VAL_OFDM_NON_HT_MODULATION_MODE_ON. This value is expressed in Mbps. 
        ///    If you set the NIWLANA_OFDM_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the value of the NIWLANA_OFDM_DATA_RATE    attribute as the data rate for performing OFDM demodulation measurements.
        ///    The default value is NIWLANA_VAL_OFDM_DATA_RATE_6.
        ///    Get Function: niWLANA_GetOFDMDataRate
        ///    Set Function: niWLANA_SetOFDMDataRate
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDataRate(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDataRate, channel, out value);
        }


        /// <summary>
        ///Specifies whether to automatically detect the frame format of the 802.11n burst. 
        ///    If this attribute is disabled, you must set the frame format using the NIWLANA_80211N_PLCP_FRAME_FORMAT attribute.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemod80211nPLCPFrameDetectionEnabled
        ///    Set Function: niWLANA_SetOFDMDemod80211nPLCPFrameDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemod80211nPlcpFrameDetectionEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemod80211nPlcpFrameDetectionEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to automatically detect the frame format of the 802.11n burst. 
        ///    If this attribute is disabled, you must set the frame format using the NIWLANA_80211N_PLCP_FRAME_FORMAT attribute.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemod80211nPLCPFrameDetectionEnabled
        ///    Set Function: niWLANA_SetOFDMDemod80211nPLCPFrameDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemod80211nPlcpFrameDetectionEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemod80211nPlcpFrameDetectionEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable pilot-based mean amplitude tracking. 
        ///    Amplitude tracking is useful    if the mean amplitude of the OFDM symbol varies over time. However, enabling tracking may    degrade EVM values by approximately 1 dB to 2 dB because of attempts to    track random amplitude distortions caused by noise and residual intercarrier interference from    symbol to symbol.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodAmplitudeTrackingEnabled
        ///    Set Function: niWLANA_SetOFDMDemodAmplitudeTrackingEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodAmplitudeTrackingEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodAmplitudeTrackingEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable pilot-based mean amplitude tracking. 
        ///    Amplitude tracking is useful    if the mean amplitude of the OFDM symbol varies over time. However, enabling tracking may    degrade EVM values by approximately 1 dB to 2 dB because of attempts to    track random amplitude distortions caused by noise and residual intercarrier interference from    symbol to symbol.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodAmplitudeTrackingEnabled
        ///    Set Function: niWLANA_SetOFDMDemodAmplitudeTrackingEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodAmplitudeTrackingEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodAmplitudeTrackingEnabled, channel, out value);
        }

        /// <summary>
        /// Specifies how the toolkit estimates the channel frequency response.    When a user disables channel tracking, toolkit estimates the channel     response only over the long training sequence and uses this as channel estimate over the entire packet.     When a user enables channel tracking, toolkit estimates the channel response over preamble and data     and uses this as the channel estimate for the entire packet.
        ///     Note: In either case, toolkit does not track the instanteneous channel.
        ///     The default value is NIWLANA_VAL_FALSE.          
        /// 
        /// </summary>
        [Obsolete("Use  SetOFDMDemodChannelEstimationMethod")]
        public int SetOfdmDemodChannelTrackingEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodChannelTrackingEnabled, channel, value);
        }

        /// <summary>
        /// Specifies how the toolkit estimates the channel frequency response.    When a user disables channel tracking, toolkit estimates the channel     response only over the long training sequence and uses this as channel estimate over the entire packet.     When a user enables channel tracking, toolkit estimates the channel response over preamble and data     and uses this as the channel estimate for the entire packet.
        ///     Note: In either case, toolkit does not track the instanteneous channel.
        ///     The default value is NIWLANA_VAL_FALSE.          
        /// 
        /// </summary>
        [Obsolete("Use  GetOFDMDemodChannelEstimationMethod")]
        public int GetOfdmDemodChannelTrackingEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodChannelTrackingEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable the constellation trace for signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodConstellationTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodConstellationTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodConstellationTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodConstellationTraceEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable the constellation trace for signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodConstellationTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodConstellationTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodConstellationTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodConstellationTraceEnabled, channel, out value);
        }


        /// <summary>
        /// Specifies whether to enable demodulation-based measurements if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// 
        /// </summary>
        ///<param name = "channel">
        /// Set this parameter to "" (empty string) or NULL.
        ///</param>
        ///<param name = "value">
        /// Specifies whether to enable demodulation-based measurements if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. The default value is NIWLANA_VAL_FALSE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetOFDMDemodEnabled
        /// int32 __stdcall niWLANA_SetOFDMDemodEnabled (niWLANA session,
        ///     char channelString[],
        ///     int32 enable);
        /// Purpose
        /// Specifies whether to enable demodulation-based measurements if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,  NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        /// 
        ///</returns>
        public int SetOfdmDemodEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable demodulation-based measurements if you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,     NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodEnabled
        ///    Set Function: niWLANA_SetOFDMDemodEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable the EVM per subcarrier trace for signals containing    an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodEVMPerSubcarrierTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodEVMPerSubcarrierTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodEvmPerSubcarrierTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodEvmPerSubcarrierTraceEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable the EVM per subcarrier trace for signals containing    an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodEVMPerSubcarrierTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodEVMPerSubcarrierTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodEvmPerSubcarrierTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodEvmPerSubcarrierTraceEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable the EVM per symbol per subcarrier trace for    signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodEVMPerSymbolPerSubcarrierTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodEVMPerSymbolPerSubcarrierTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodEvmPerSymbolPerSubcarrierTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodEvmPerSymbolPerSubcarrierTraceEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable the EVM per symbol per subcarrier trace for    signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodEVMPerSymbolPerSubcarrierTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodEVMPerSymbolPerSubcarrierTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodEvmPerSymbolPerSubcarrierTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodEvmPerSymbolPerSubcarrierTraceEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable the EVM per symbol trace for signals containing an    OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodEVMPerSymbolTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodEVMPerSymbolTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodEvmPerSymbolTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodEvmPerSymbolTraceEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable the EVM per symbol trace for signals containing an    OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodEVMPerSymbolTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodEVMPerSymbolTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodEvmPerSymbolTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodEvmPerSymbolTraceEnabled, channel, out value);
        }


        /// <summary>
        /// Specifies whether to enable time-gated power measurements.
        ///     If you set the standard parameter of the niWLANA_SetStandard function to     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use an channelx active channel string to configure this attribute.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodGatedPowerEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodGatedPowerEnabled, channel, value);
        }


        /// <summary>
        /// Specifies whether to enable time-gated power measurements.
        ///     If you set the standard parameter of the niWLANA_SetStandard function to     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use an channelx active channel string to configure this attribute.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodGatedPowerEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodGatedPowerEnabled, channel, out value);
        }


        /// <summary>
        /// Specifies the start time for computing gated power, in seconds. The value of 0    indicates the start time is the start of the payload.
        ///     A negative value indicates a position in the preamble or header.    Refer to the Gated Power topic for more information.
        ///     The default value is 0.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodGatedPowerStartTime(string channel, double value)
        {
            return SetDouble(niWLANAProperties.OfdmDemodGatedPowerStartTime, channel, value);
        }


        /// <summary>
        /// Specifies the start time for computing gated power, in seconds. The value of 0    indicates the start time is the start of the payload.
        ///     A negative value indicates a position in the preamble or header.    Refer to the Gated Power topic for more information.
        ///     The default value is 0.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodGatedPowerStartTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemodGatedPowerStartTime, channel, out value);
        }


        /// <summary>
        /// Specifies the end time for computing gated power, in seconds. The value of 0    indicates the stop time is the start of the payload.
        ///     A negative value indicates a position in the preamble or header.    Refer to the Gated Power topic for more information.
        ///     The default value is 64 microseconds.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodGatedPowerStopTime(string channel, double value)
        {
            return SetDouble(niWLANAProperties.OfdmDemodGatedPowerStopTime, channel, value);
        }


        /// <summary>
        /// Specifies the end time for computing gated power, in seconds. The value of 0    indicates the stop time is the start of the payload.
        ///     A negative value indicates a position in the preamble or header.    Refer to the Gated Power topic for more information.
        ///     The default value is 64 microseconds.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodGatedPowerStopTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemodGatedPowerStopTime, channel, out value);
        }


        /// <summary>
        ///Specifies whether to automatically detect the physical layer convergence procedure (PLCP) header or SIGNAL fields for    signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodHeaderDetectionEnabled
        ///    Set Function: niWLANA_SetOFDMDemodHeaderDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodHeaderDetectionEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodHeaderDetectionEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to automatically detect the physical layer convergence procedure (PLCP) header or SIGNAL fields for    signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodHeaderDetectionEnabled
        ///    Set Function: niWLANA_SetOFDMDemodHeaderDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodHeaderDetectionEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodHeaderDetectionEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to perform low-pass filtering, to remove out-of-band noise, after acquiring the baseband signal.
        ///    Note: EVM measurement quality may be affected by out-of-band spurious    signals if the NI-RFSA bandwidth    (defined as 0.8 * I/Q rate) is significantly greater than the channel bandwidth. Enable the software    low-pass filter to reject the out-of-channel noise.
        ///    Note: This attribute is not applicable if you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        ///     The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodLowPassFilteringEnabled
        ///    Set Function: niWLANA_SetOFDMDemodLowPassFilteringEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodLowpassFilteringEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodLowpassFilteringEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to perform low-pass filtering, to remove out-of-band noise, after acquiring the baseband signal.
        ///    Note: EVM measurement quality may be affected by out-of-band spurious    signals if the NI-RFSA bandwidth    (defined as 0.8 * I/Q rate) is significantly greater than the channel bandwidth. Enable the software    low-pass filter to reject the out-of-channel noise.
        ///    Note: This attribute is not applicable if you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM.
        ///     The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodLowPassFilteringEnabled
        ///    Set Function: niWLANA_SetOFDMDemodLowPassFilteringEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodLowpassFilteringEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodLowpassFilteringEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the maximum number of symbols that the toolkit uses to compute EVM    computation. You must set this attribute to the correct value to optimize measurement speed. 
        ///    If the number of available payload symbols (n) is greater than the value    that you specify (m), the toolkit ignores (n-m) symbols from the end of the packet.
        ///    Note: If you set this attribute to -1, the toolkit uses all symbols in the signal for measurement.
        ///    The default value is 16.
        ///    Get Function: niWLANA_GetOFDMDemodMaximumSymbolsUsed
        ///    Set Function: niWLANA_SetOFDMDemodMaximumSymbolsUsed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodMaximumSymbolsUsed(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodMaximumSymbolsUsed, channel, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodAutoComputeAcquisitionLengthEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodAutoComputeMeasurementLengthEnabled, channel, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodAutoComputeAcquisitionLengthEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodAutoComputeMeasurementLengthEnabled, channel, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDSSSDemodAutoComputeAcquisitionLengthEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodAutoComputeAcquisitionLengthEnabled, channel, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDSSSDemodAutoComputeAcquisitionLengthEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodAutoComputeAcquisitionLengthEnabled, channel, value);
        }

        /// <summary>
        ///Specifies the maximum number of symbols that the toolkit uses to compute EVM    computation. You must set this attribute to the correct value to optimize measurement speed. 
        ///    If the number of available payload symbols (n) is greater than the value    that you specify (m), the toolkit ignores (n-m) symbols from the end of the packet.
        ///    Note: If you set this attribute to -1, the toolkit uses all symbols in the signal for measurement.
        ///    The default value is 16.
        ///    Get Function: niWLANA_GetOFDMDemodMaximumSymbolsUsed
        ///    Set Function: niWLANA_SetOFDMDemodMaximumSymbolsUsed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodMaximumSymbolsUsed(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodMaximumSymbolsUsed, channel, out value);
        }


        /// <summary>
        ///Specifies the number of OFDM symbols from the beginning of the payload    to ignore for EVM computation.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetOFDMDemodMeasurementStartLocation
        ///    Set Function: niWLANA_SetOFDMDemodMeasurementStartLocation
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodMeasurementStartLocation(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodMeasurementStartLocation, channel, value);
        }


        /// <summary>
        ///Specifies the number of OFDM symbols from the beginning of the payload    to ignore for EVM computation.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetOFDMDemodMeasurementStartLocation
        ///    Set Function: niWLANA_SetOFDMDemodMeasurementStartLocation
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodMeasurementStartLocation(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodMeasurementStartLocation, channel, out value);
        }

        /// <summary>
        /// Specifies the number of iterations over which the toolkit averages 
        /// OFDM demodulation-based measurements.
        /// If you increase the number of averages, the toolkit provides smoother values but takes longer to compute the values.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodNumberOfAverages(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodNumberOfAverages, channel, value);
        }

        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages OFDM    demodulation-based measurements.
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values.
        ///    The default value is 1. Valid values are 1 to 1,000, inclusive.
        ///    Get Function: niWLANA_GetOFDMDemodNumberOfAverages
        ///    Set Function: niWLANA_SetOFDMDemodNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodNumberOfAverages(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodNumberOfAverages, channel, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetAutoDetectionOfStandardMode(string channel, int value)
        {
            return SetInt(niWLANAProperties.AutoDetectionStandardMode, channel, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAutoDetectionOfStandardMode(string channel, out int value)
        {
            return GetInt(niWLANAProperties.AutoDetectionStandardMode, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable burst detection when performing TxPower measurements. This attribute does not affect    the measurement of average power if idle time is present in the input waveform.
        ///     The default value is NIWLANA_VAL_TRUE.
        ///     Get Function: niWLANA_GetTxPowerBurstDetectionEnabled
        ///    Set Function: niWLANA_SetTxPowerBurstDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetTxPowerBurstDetectionEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.TxPowerBurstDetectionEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable burst detection when performing TxPower measurements. This attribute does not affect    the measurement of average power if idle time is present in the input waveform.
        ///     The default value is NIWLANA_VAL_TRUE.
        ///     Get Function: niWLANA_GetTxPowerBurstDetectionEnabled
        ///    Set Function: niWLANA_SetTxPowerBurstDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetTxPowerBurstDetectionEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.TxPowerBurstDetectionEnabled, channel, out value);
        }

        /// <summary>
        /// 
        /// Specifies the number of iterations over which the toolkit averages orthogonal frequency division multiplexing (OFDM) demodulation-based measurements.
        /// If you increase the number of averages, the toolkit provides smoother values but takes a longer time to compute the values.
        /// The default value is 1. Valid values are 1 to 1,000 (inclusive).
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// channelString
        /// char[]
        /// Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "numberofAverages">
        /// numberOfAverages
        /// int32
        /// Specifies the number of iterations over which the toolkit averages OFDM demodulation-based measurements.
        /// 
        ///</param>
        ///<returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        ///
        /// </returns>
        [Obsolete("Use function SetOfdmDemodNumberOfAverages")]
        public int SetOFDMDemodNumberOfAverages(string channelString, int numberofAverages)
        {
            return SetInt(niWLANAProperties.OfdmDemodNumberOfAverages, channelString, numberofAverages);
        }

        /// <summary>
        ///Specifies the method of phase tracking to use. Phase tracking is useful for tracking the phase    variation over the modulation symbol caused by residual frequency offset and phase noise.
        ///    The default value is NIWLAN_VAL_OFDM_PHASE_TRACKING_STANDARD.
        ///    Get Function: niWLANA_GetOFDMDemodPhaseTracking
        ///    Set Function: niWLANA_SetOFDMDemodPhaseTracking
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodPhaseTracking(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodPhaseTracking, channel, value);
        }


        /// <summary>
        ///Specifies the method of phase tracking to use. Phase tracking is useful for tracking the phase    variation over the modulation symbol caused by residual frequency offset and phase noise.
        ///    The default value is NIWLAN_VAL_OFDM_PHASE_TRACKING_STANDARD.
        ///    Get Function: niWLANA_GetOFDMDemodPhaseTracking
        ///    Set Function: niWLANA_SetOFDMDemodPhaseTracking
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodPhaseTracking(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodPhaseTracking, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable compensation for sample clock frequency offset.
        ///    Although the    estimation of the Sample clock offset occurs over a maximum 100 OFDM symbols in the frequency  domain, the toolkit    compensates for this offset in the time domain to ensure that clock cycle slips can be adjusted. 
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodTimeTrackingEnabled
        ///    Set Function: niWLANA_SetOFDMDemodTimeTrackingEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodTimeTrackingEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodTimeTrackingEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable compensation for sample clock frequency offset.
        ///    Although the    estimation of the Sample clock offset occurs over a maximum 100 OFDM symbols in the frequency  domain, the toolkit    compensates for this offset in the time domain to ensure that clock cycle slips can be adjusted. 
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemodTimeTrackingEnabled
        ///    Set Function: niWLANA_SetOFDMDemodTimeTrackingEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodTimeTrackingEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodTimeTrackingEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the payload length of the expected incoming signal. This value is expressed in bytes.     If you set the NIWLANA_OFDM_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE,    the toolkit uses the value of NIWLANA_OFDM_PAYLOAD_LENGTH attribute    as the payload length for performing OFDM demodulation measurements. The toolkit ignores the NIWLANA_OFDM_PAYLOAD_LENGTH attribute     if you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, the default    value is 1,024. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, the default value is 4,096.
        ///    Get Function: niWLANA_GetOFDMPayloadLength
        ///    Set Function: niWLANA_SetOFDMPayloadLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmPayloadLength(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmPayloadLength, channel, value);
        }


        /// <summary>
        ///Specifies the payload length of the expected incoming signal. This value is expressed in bytes.     If you set the NIWLANA_OFDM_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE,    the toolkit uses the value of NIWLANA_OFDM_PAYLOAD_LENGTH attribute    as the payload length for performing OFDM demodulation measurements. The toolkit ignores the NIWLANA_OFDM_PAYLOAD_LENGTH attribute     if you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, the default    value is 1,024. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, the default value is 4,096.
        ///    Get Function: niWLANA_GetOFDMPayloadLength
        ///    Set Function: niWLANA_SetOFDMPayloadLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmPayloadLength(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmPayloadLength, channel, out value);
        }


        /// <summary>
        ///Specifies the RBW for spectral acquisition. This value is expressed in Hz.
        ///    The IEEE Standards 802.11a-1999, 802.11n-2009, 802.11ac-2013 and 802.11af-2013 specify an RBW of 100 kHz    and a VBW of 30 kHz for spectral mask measurement.    The IEEE P802.11ax/D1.2 specifies an RBW of 100 kHz and a VBW of 7.5 kHz for spectral mask measurement.   To emulate this effect, if you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or    NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, the toolkit multiplies the number of averages for spectral measurements by three.
        ///    The IEEE P802.11ah/D1.3 specifies an RBW of 10 kHz and a VBW of 100 Hz for spectral mask    measurement. To emulate this effect, the toolkit multiplies the number of averages for spectral measurements by hundred, if you set the    NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM. 
        ///    The default value is 100 kHz if you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. 
        ///    The default value is 10 kHz if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM or    the NIWLANA_ETSI_IBE_ENABLED attribute to NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetRBW
        ///    Set Function: niWLANA_SetRBW
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetRbw(string channel, double value)
        {
            return SetDouble(niWLANAProperties.Rbw, channel, value);
        }


        /// <summary>
        ///Specifies the RBW for spectral acquisition. This value is expressed in Hz.
        ///    The IEEE Standards 802.11a-1999, 802.11n-2009, 802.11ac-2013 and 802.11af-2013 specify an RBW of 100 kHz    and a VBW of 30 kHz for spectral mask measurement.    The IEEE P802.11ax/D1.2 specifies an RBW of 100 kHz and a VBW of 7.5 kHz for spectral mask measurement.   To emulate this effect, if you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or    NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, the toolkit multiplies the number of averages for spectral measurements by three.
        ///    The IEEE P802.11ah/D1.3 specifies an RBW of 10 kHz and a VBW of 100 Hz for spectral mask    measurement. To emulate this effect, the toolkit multiplies the number of averages for spectral measurements by hundred, if you set the    NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM. 
        ///    The default value is 100 kHz if you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. 
        ///    The default value is 10 kHz if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM or    the NIWLANA_ETSI_IBE_ENABLED attribute to NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetRBW
        ///    Set Function: niWLANA_SetRBW
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRbw(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.Rbw, channel, out value);
        }


        /// <summary>
        ///Specifies the definition of the RBW type.
        ///    The default value is NIWLANA_VAL_RBW_DEFINITION_3DB.
        ///    Get Function: niWLANA_GetRBWDefinition
        ///    Set Function: niWLANA_SetRBWDefinition
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetRbwDefinition(string channel, int value)
        {
            return SetInt(niWLANAProperties.RbwDefinition, channel, value);
        }


        /// <summary>
        ///Specifies the definition of the RBW type.
        ///    The default value is NIWLANA_VAL_RBW_DEFINITION_3DB.
        ///    Get Function: niWLANA_GetRBWDefinition
        ///    Set Function: niWLANA_SetRBWDefinition
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRbwDefinition(string channel, out int value)
        {
            return GetInt(niWLANAProperties.RbwDefinition, channel, out value);
        }


        /// <summary>
        ///Returns the acquisition length measured by the niWLANA_RFSAAutoRange function. This value is expressed in seconds.    The niWLANA_RFSAAutoRange function measures the length of the burst returns the recommended acquisition    length to use while performing successful measurements. Use this value to set the NIWLANA_ACQUISITION_LENGTH attribute. 
        ///    Get Function: niWLANA_GetAutoRangeAcquisitionLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultAutorangeAcquisitionLength(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAutorangeAcquisitionLength, channel, out value);
        }

        /// <summary>
        /// Returns the peak power of the burst as calculated by the niWLANA_RFSAAutoRange function.     Use this value to set the NIWLANA_MAX_INPUT_POWER attribute.    
        /// 
        /// </summary>
        [Obsolete]
        public int GetResultAutorangeMaxInputPower(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAutorangeMaxInputPower, channel, out value);
        }

        /// <summary>
        /// Returns, as a percentage, the peak value of the chip error vector magnitude (EVM) for the first 1,000 chips in the    payload computed according to section 18.4.7.8 of IEEE Standard 802.11b-1999.
        ///     Note: For DSSS demodulation, if equalization is not enabled and the reference pulse-shaping filter     type and filter coefficients do not match the filter    configuration of the DUT/generator, you might notice EVM degradation.     Ensure the pulse-shaping type and pulse-shaping coefficient settings match    the input signal settings.
        ///     Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM might show degradation.
        ///     The toolkit broadly follows section 18.4.7.8 of IEEE Standard 802.11b-1999 to compute the    root mean square (RMS) value. The standard calls for EVM computation only on the differential quadrature phase shift keying (DQPSK) signal.    However, the toolkit computes EVM for all compulsory and optional data rates and modulation schemes defined    for IEEE Standard 802.11b-1999, as well as the extended rate physical layer-packet binary convolutional coding (ERP-PBCC) modes defined in IEEE Standard 802.11g.    Refer to the EVM Differentiation topic for an explanation of    the difference between RMS EVM, peak EVM, and 802.11b-1999 peak EVM, respectively.    Note: For DSSS demodulation, if equalization is not enabled and the reference pulse-shaping filter type and filter coefficients     do not match the filter configuration of the DUT/generator, you might notice EVM degradation. Ensure the pulse-shaping     type and pulse-shaping coefficient settings match the input signal settings.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemod80211bPeakEvm(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemod80211bPeakEvm, channel, out value);
        }


        /// <summary>
        /// Returns the average gated power, in dBm, defined by the measurement interval between the     NIWLANA_DSSS_GATED_POWER_START_TIME and the NIWLANA_DSSS_GATED_POWER_STOP_TIME attributes.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodAverageGatedPower(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodAverageGatedPower, channel, out value);
        }


        /// <summary>
        /// Returns the estimated carrier frequency offset, in hertz (Hz), of the transmitting DUT.    For example, if you set the NIWLANA_CARRIER_FREQUENCY attribute to 2.412 GHz and the toolkit    measures the carrier frequency of the DUT to be 2.413 GHz, the carrier frequency offset    is 1 MHz. This measurement follows section 17.3.9.4 of IEEE Standard 802.11a-1999 and section 20.3.21.4 of IEEE Standard 802.11n-2009.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodCarrierFrequencyOffset(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierFrequencyOffset, channel, out value);
        }


        /// <summary>
        /// Returns the ratio, in dB, of the DC offset to the mean amplitude of the burst.
        ///    The toolkit computes the ratio as the normalized DC offset and not according to section 18.4.7.7    of IEEE Standard 802.11b-1999, where the definition is valid only for unmodulated    continuous wave (CW) signals.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodCarrierSuppression(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodCarrierSuppression, channel, out value);
        }


        /// <summary>
        ///Returns the data rate used to transmit the SERVICE field and the physical layer    convergence procedure protocol data unit (PPDU). This value is expressed in Mbps. If you set the    NIWLANA_DSSS_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE, the data rate is extracted from the demodulated    SIGNAL field of the frame.    The SIGNAL field is defined in sections 15.2.3.3, 18.2.3.3, 18.2.3.10, and 19.3.2.1 of IEEE Standard 802.11-2007.
        ///    If you set the NIWLANA_DSSS_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE,    the value you specify in the NIWLANA_DSSS_DATA_RATE attribute specifies the data rate.
        ///    Get Function: niWLANA_GetDSSSDemodDataRate
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodDataRate(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultDsssDemodDataRate, channel, out value);
        }


        /// <summary>
        ///Indicates whether the header cyclic redundancy check (CRC),    as defined in section 18.2.3.6 of IEEE Standard 802.11b-1999, has successfully passed.
        ///    Get Function: niWLANA_GetDSSSDemodHeaderChecksumPassed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodHeaderChecksumPassed(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultDsssDemodHeaderChecksumPassed, channel, out value);
        }


        /// <summary>
        /// Specifies the ratio, in dB, of the mean amplitude of the in-phase (I) signal to the mean    amplitude of the quadrature-phase (Q) signal.
        ///     Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,     I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,     the estimates of these impairments might not be accurate.  
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodIqGainImbalance(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodIqGainImbalance, channel, out value);
        }


        /// <summary>
        ///Returns the length of the payload, including the medium access control (MAC) header. This value is expressed in bytes.    If you set the NIWLANA_DSSS_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE, the toolkit extracts the payload length    from the demodulated LENGTH field of the frame. The LENGTH field is defined in    sections 15.2.3.5, 18.2.3.5, 18.2.3.12, and 19.3.2.1.2 of IEEE Standard 802.11-2007.
        ///    If you set the NIWLANA_DSSS_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE,    the value you specify in the NIWLANA_DSSS_PAYLOAD_LENGTH attribute specifies the payload length.    The toolkit returns a value of -1 if it encounters various data lengths during the averaging process.
        ///    Get Function: niWLANA_GetDSSSDemodPayloadLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodPayloadLength(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultDsssDemodPayloadLength, channel, out value);
        }


        /// <summary>
        /// Returns, as a percentage, the peak value of the chip error vector magnitude (EVM) for the first 1,000 chips     in the payload computed according to section 18.4.7.8 of IEEE Standard 802.11b-1999.
        ///     Note: For DSSS demodulation, if equalization is not enabled and the reference pulse-shaping    filter type and filter coefficients do not match the filter    configuration of the DUT/generator, you might notice EVM degradation. Ensure the pulse-shaping    type and pulse-shaping coefficient settings match the input signal settings.
        ///     Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM might show degradation.
        ///    The toolkit broadly follows section 18.4.7.8 of IEEE Standard 802.11b-1999    to compute the root mean square (RMS) value. The standard calls for EVM computation    only on the differential quadrature phase shift keying (DQPSK) signal. However, the toolkit computes EVM for all compulsory and optional data rates    and modulation schemes defined for IEEE Standard 802.11b-1999, as well as the extended rate physical layer-packet binary convolutional coding (ERP-PBCC) modes    defined in IEEE Standard 802.11g-2003.  Refer to the EVM Differentiation topic for an explanation of    the difference between RMS EVM, peak EVM, and 802.11b peak EVM, respectively.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodPeakEvm(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodPeakEvm, channel, out value);
        }


        /// <summary>
        ///Indicates whether the detected preamble type is long or short.
        ///    Get Function: niWLANA_GetDSSSDemodPreambleType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodPreambleType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultDsssDemodPreambleType, channel, out value);
        }


        /// <summary>
        /// Returns the deviation in angles from 90 degrees between the in-phase (I)    and quadrature-phase (Q) signals.
        ///    Refer to the Quadrature Skew topic for more information.
        ///     Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,     I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,     the estimates of these impairments might not be accurate.  
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodQuadratureSkew(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodQuadratureSkew, channel, out value);
        }


        /// <summary>
        /// Returns the root mean square (RMS) value of the chip error vector magnitude (EVM) as a percentage of the mean amplitude of the signal envelope    for 802.11b direct sequence spread spectrum (DSSS) signals.
        ///     Note: For DSSS demodulation, if equalization is not enabled and the reference pulse-shaping    filter type and filter coefficients do not match the filter    configuration of the DUT/generator, you might notice EVM degradation. Ensure the pulse-shaping    type and pulse-shaping coefficient settings match the input signal settings.
        ///     Note: If the pulse-shaping filter coefficient is less than 0.2, DSSS EVM might show degradation.
        ///    The toolkit broadly follows section 18.4.7.8 of IEEE Standard 802.11b-1999    to compute the root mean square (RMS) value. The standard calls for EVM computation    only on the differential quadrature phase shift keying (DQPSK) signal. However, the toolkit computes EVM for all compulsory and optional data rates    and modulation schemes defined for IEEE Standard 802.11b-1999, as well as the extended rate physical layer-packet binary convolutional coding (ERP-PBCC) modes    defined in IEEE Standard 802.11g-2003.  Refer to the EVM Differentiation topic for an explanation of    the difference between RMS EVM, peak EVM, and 802.11b peak EVM, respectively.      
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodRmsEvm(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodRmsEvm, channel, out value);
        }


        /// <summary>
        /// Returns the estimated sample clock offset, in parts per million (ppm).    The estimated offset is the difference between the sample clocks    at the D/A converter of the transmitting DUT and the digitizer. If the clock offset is more than 25 ppm,    the estimated value may not be accurate. Use the estimated offset to verify if the DUT corresponds     to section 18.4.7.5 of IEEE Standard 802.11b-1999 and section 20.3.21.6 of IEEE Standard 802.11n-2009.
        ///     Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,     I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,     the estimates of these impairments might not be accurate.    
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodSampleClockOffset(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssDemodSampleClockOffset, channel, out value);
        }


        /// <summary>
        ///Indicates whether the toolkit successfully detected the start frame delimiter (SFD),    as defined in sections 18.2.3.2 and 18.2.3.9 of IEEE Standard 802.11b-1999.
        ///    Get Function: niWLANA_GetDSSSDemodSFDFound
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssDemodSfdFound(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultDsssDemodSfdFound, channel, out value);
        }


        /// <summary>
        ///Returns the measured power ramp-down time. This value is expressed in seconds.
        ///      If you set the NIWLANA_DSSS_POWER_RAMP_DOWN_LOW_THRESHOLD    and NIWLANA_DSSS_POWER_RAMP_DOWN_HIGH_THRESHOLD attributes    to 10% and 90%, respectively, the toolkit performs this measurement    according to section 18.4.7.6 of IEEE Standard 802.11b-1999. However, the toolkit    does not define the ramp time for unmodulated step input. To remove the variations    in the instantaneous power caused by modulation on the baseband signal, the toolkit    filters the power vector using the maximum value in a moving window.
        ///    Note: The direct sequence spread spectrum (DSSS) power ramp may not be found if the ramp-up or ramp-down time    of the incoming signal burst is greater than 5 &#181;s, in which case the toolkit returns an error.
        ///    Get Function: niWLANA_GetDSSSPowerRampDownTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssPowerRampDownTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssPowerRampDownTime, channel, out value);
        }


        /// <summary>
        ///Returns the measured power ramp-up time. This value is expressed in seconds.
        ///    If you set the NIWLANA_DSSS_POWER_RAMP_UP_LOW_THRESHOLD    and NIWLANA_DSSS_POWER_RAMP_UP_HIGH_THRESHOLD attributes    to 10% and 90%, respectively, the toolkit performs this measurement according to    section 18.4.7.6 of IEEE Standard 802.11b-1999. However, the toolkit does not define    the ramp time for unmodulated step input. To remove the variations in the instantaneous    power caused by modulation on the baseband signal, the toolkit filters the power vector       using the maximum value in a moving window.
        ///    Note: The direct sequence spread spectrum (DSSS) power ramp may not be found if the ramp-up or ramp-down time of the    incoming signal burst is greater than 5 &#181;s, in which case the toolkit returns an error.
        ///    Get Function: niWLANA_GetDSSSPowerRampUpTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultDsssPowerRampUpTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultDsssPowerRampUpTime, channel, out value);
        }


        /// <summary>
        ///Returns the maximum total power over any 1 MHz portion of the spectrum. This value is expressed in W/MHZ. 
        ///    You can use this attribute to verify that the device under test (DUT) conforms to section 17.3.9.1 of    IEEE Standard 802.11a-1999, section 18.4.7.1 of IEEE Standard 802.11b-1999, or IEEE Standard 802.11n-2009,    which specifies the maximum output power in certain cases.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Get Function: niWLANA_GetMaxSpectralDensity
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultMaxSpectralDensity(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultMaxSpectralDensity, channel, out value);
        }


        /// <summary>
        ///Returns the OBW of the measured signal. This value is expressed in Hz. The OBW    is the frequency range containing 99% of the power of the entire signal spectrum.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetOBW
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultObw(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultObw, channel, out value);
        }


        /// <summary>
        ///Returns the highest frequency component of the frequency range containing 99%    of the entire signal spectrum. This value is expressed in Hz.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetOBWHighFrequency
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultObwHighFrequency(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultObwHighFrequency, channel, out value);
        }


        /// <summary>
        ///Returns the lowest frequency component of the frequency range containing 99%    of the entire signal spectrum. This value is expressed in Hz.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetOBWLowFrequency
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultObwLowFrequency(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultObwLowFrequency, channel, out value);
        }


        /// <summary>
        ///Returns the 802.11n physical layer convergence procedure (PLCP) frame format. If you    set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the    value you specify in the NIWLANA_RESULT_OFDM_DEMOD_80211N_PLCP_FRAME_FORMAT attribute    specifies the PLCP format used.
        ///    Get Function: niWLANA_GetOFDMDemod80211nPLCPFrameFormat
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemod80211nPlcpFrameFormat(string channel, out string value)
        {
            int actualValue;
            int returnValue = GetInt(niWLANAProperties.ResultOfdmDemod80211nPlcpFrameFormat, channel, out actualValue);
            switch (actualValue)
            {
                case niWLANAConstants.Results80211nPlcpFrameFormatMixed:
                    value = "Mixed Mode";
                    break;
                case niWLANAConstants.Results80211nPlcpFrameFormatGreenfield:
                    value = "Greenfield";
                    break;
                case niWLANAConstants.Results80211nPlcpFrameFormatVarious:
                    value = "Various";
                    break;
                case niWLANAConstants.Results80211nPlcpFrameFormatUnknown:
                    value = "Unknown";
                    break;
                default:
                    value = "Unknown";
                    break;
            }
            return returnValue;
        }


        /// <summary>
        /// Returns the average gated power, in dBm. The gated power is the average power of the interval    defined by the interval between the    NIWLANA_OFDM_GATED_POWER_START_TIME and the NIWLANA_OFDM_GATED_POWER_STOP_TIME    attributes.
        ///     If you set the standard parameter of the niWLANA_SetStandard function to     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use the channelx active channel string to configure this attribute.     
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodAverageGatedPower(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodAverageGatedPower, channel, out value);
        }


        /// <summary>
        /// Returns the carrier frequency leakage, in dB, as a ratio the DC subcarrier energy to the sum    of the data and pilot subcarrier energies, measured as defined in section 17.3.9.6.1 of    IEEE Standard 802.11a-1999 and section 20.3.21.7.2 of IEEE Standard 802.11n-2009. You also can see the frequency leakage as the measure of normalized DC offset.
        ///     If you set the standard parameter of the niWLANA_SetStandard function to     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use the channelx active channel string to configure this attribute.  
        /// 
        /// </summary>        
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCarrierFrequencyLeakage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyLeakageAverage, channel, out value);
        }


        /// <summary>
        ///Returns the average of carrier frequency leakage. This value is expressed in dB. Carrier frequency leakage is the ratio of the energy    in the DC subcarrier to the total energy of all the subcarriers.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use    'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_TRUE, you must use '[segmentx/]' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use 'channelx' as the    active channel string format to query this format. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCarrierFrequencyLeakageAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyLeakageAverage, channel, out value);
        }


        /// <summary>
        /// Returns the estimated carrier frequency offset, in hertz (Hz), of the transmitting device under test (DUT).    For example, if you set the NIWLANA_CARRIER_FREQUENCY attribute to 2.412 GHz and the toolkit measures    the carrier frequency of the DUT to be 2.413 GHz, the carrier frequency offset is 1 MHz. This    measurement follows section 17.3.9.4 of IEEE Standard 802.11a-1999 and section 20.3.21.4 of IEEE Standard 802.11n-2009.        
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCarrierFrequencyOffset(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyOffset, channel, out value);
        }


        /// <summary>
        /// Returns the contribution of the power from other streams in channelx when the active channel     string used is channelx. To get the individual contributions of each stream, use the format channelx/streamy for the active channel.
        ///     Use the following active channel string formats to configure this attribute.
        ///     &#8226;channelx.
        ///     &#8226;channelx/streamy, where x is not equal to y.
        ///     Note: To use this attribute, you must have the NI WLAN Analysis Toolkit for IEEE 802.11a/b/g/n     license and set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM.
        ///     The default value is 0. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCrossPower(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCrossPower, channel, out value);
        }


        /// <summary>
        ///Returns the data rate used to transmit the SERVICE field and the    physical layer convergence procedure protocol data unit (PPDU). This value is expressed in Mbps.    If you set the NIWLANA_OFDM_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE, the data rate is extracted    from the demodulated SIGNAL field of the frame.    The SIGNAL field is defined in section 17.3.4 of IEEE Standard 802.11-2007.
        ///    If you set the    NIWLANA_OFDM_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the value you specify    in the NIWLANA_OFDM_DATA_RATE attribute specifies the data rate.
        ///    Get Function: niWLANA_GetOFDMDemodDataRate
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodDataRate(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodDataRate, channel, out value);
        }


        /// <summary>
        ///Returns the guard interval detected from the High-Throughput SIGNAL (HT-SIG) field for 802.11n signals, as defined in section    20.3.9.4.3 of the IEEE Standard 802.11n-2009. For 802.11ac signals, it is    detected from the VHT-SIG-A field. For 802.11ah signals, it is    detected from S1G-SIG/SIG-A field. For 80211af signals it is detected from TVHT-SIG-A field. For 802.11ax signals, the    toolkit detects the guard interval from the HE-SIG-A field. This value is expressed in seconds. 
        ///    Get Function: niWLANA_GetOFDMDemodGuardInterval
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodGuardInterval(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodGuardInterval, channel, out value);
        }


        /// <summary>
        /// Returns the ratio, in dB, of the mean amplitude of the in-phase (I) signal to the mean amplitude of    the quadrature-phase (Q) signal.
        ///     If you set the standard parameter of the niWLANA_SetStandard function to     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use the channelx active channel string to configure this attribute.
        ///     Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,     I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,     the estimates of these impairments might not be accurate.
        ///     Tip: If the cable connecting the DUT and the RF signal analyzer     has significant low-pass characteristics or in-band ripple, measuring OFDM I/Q gain imbalance and quadrature skew might be adversely affected. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodIqGainImbalance(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodIqGainImbalance, channel, out value);
        }


        /// <summary>
        ///Returns the detected modulation and coding scheme (MCS) index, which determines the modulation and coding scheme used.    For 802.11n signals, the toolkit detects the MCS index from the high-throughput SIGNAL (HT-SIG) field, which    is defined in sections 20.3.9.4.3 and 20.6 of the IEEE Standard 802.11n-2009. 
        ///    For 802.11ac signals, the toolkit detects the MCS index from the VHT-SIG-A field for a packet of SU PPDU format, and    from the VHT-SIG-B field for a packet of MU PPDU format. For 802.11ah signals, the toolkit detects the MCS index    from the S1G-SIG/SIG-A. For 80211af signals, the toolkit detects the MCS Index from the TVHT-SIG-A.
        ///     For 802.11ax signals, the toolkit detects the MCS index from the HE-SIG-A field for a packet    of SU PPDU format or Extended Range SU PPDU format, and from the HE-SIG-B field for a packet of MU PPDU format. 
        ///    If you set the    NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the value you    specify in the NIWLANA_RESULT_OFDM_DEMOD_MCS_INDEX attribute specifies the specifies the modulation and coding scheme.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use an    empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active channel string syntax to query this attribute. 
        ///      If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///    Get Function: niWLANA_GetOFDMDemodMCSIndex
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodMcsIndex(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodMcsIndex, channel, out value);
        }


        /// <summary>
        ///Returns the number of extension spatial streams detected from the high-throughput SIGNAL (HT-SIG) field as defined    in section 20.3.9.4.3 of the IEEE Standard 802.11n-2009. If you set the    NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the value you    specify in the NIWLANA_RESULT_OFDM_DEMOD_NUMBER_OF_EXTENSION_SPATIAL_STREAMS attribute specifies    the number of extension spatial streams.
        ///    Get Function: niWLANA_GetOFDMDemodNumberOfExtensionSpatialStreams
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodNumberOfExtensionSpatialStreams(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodNumberOfExtensionSpatialStreams, channel, out value);
        }


        /// <summary>
        ///Returns the length of the physical-layer payload. If you set the    NIWLANA_OFDM_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE, the toolkit extracts the payload length from the    demodulated SIGNAL field or HT SIGNAL field, VHT-SIG-B field or TVHT-SIG-B of the frame, if    the NIWLANA_STANDARD attribute is set    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM (section 17.3.4 of IEEE Standard 802.11a-1999),    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM (section 20.3.9.4.3 of IEEE Standard 802.11n-2009),    NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM (section 22.3.8.3.6 of IEEE Standard 802.11ac-2013), or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM (section    23.3.8.3.6 of IEEE Standard 80211af-2013) respectively. This value is expressed in bytes. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM and    the NIWLANA_OFDM_HEADER_DETECTION_ENABLED to NIWLANA_VAL_TRUE, the toolkit derives the payload length    from the S1G-SIG/SIG-A field of the frame. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_HEADER_DETECTION_ENABLED to NIWLANA_VAL_TRUE,    the toolkit derives the payload length from the decoded data bits. 
        ///    If you set the NIWLANA_OFDM_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE,    the value you specify in the NIWLANA_OFDM_PAYLOAD_LENGTH attribute specifies the payload length.    The toolkit returns a value of -1 if it encounters various data lengths during the averaging process.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM,    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU, you must use    an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active channel string syntax to query this attribute. 
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///    Get Function: niWLANA_GetOFDMDemodPayloadLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodPayloadLength(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodPayloadLength, channel, out value);
        }


        /// <summary>
        /// Returns the deviation in angle from 90 degrees between the in-phase (I) and quadrature-phase (Q)    signals.
        ///     Refer to the Quadrature Skew topic for more information.
        ///     If you set the standard parameter of the niWLANA_SetStandard function to     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use the channelx active channel string to configure this attribute.
        ///     Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,     I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than 15 degrees,     the estimates of these impairments might not be accurate.
        ///      Tip: If the cable connecting the DUT and the RF signal analyzer     has significant low-pass characteristics or in-band ripple, measuring OFDM I/Q gain imbalance and quadrature skew might be adversely affected.   
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodQuadratureSkew(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodQuadratureSkew, channel, out value);
        }


        /// <summary>
        /// Returns the root mean square (RMS) error vector magnitude (EVM) value,     in dB, as defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999.    The method of computation is discussed in section 17.3.9.7 of IEEE     Standard 802.11a-1999 and section 20.3.21.7.4 of IEEE Standard 802.11n-2009.
        ///     If you set the standard parameter of the niWLANA_SetStandard function to     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use an active channel string to configure this attribute.
        ///     &#8226;streamx for stream EVM.
        ///     &#8226;channelx for channel EVM.
        ///     Note: For DSSS demodulation, if equalization is not enabled and the reference pulse-shaping filter type    and filter coefficients do not match the filter configuration of the DUT/generator,     you might notice EVM degradation. Ensure the pulse-shaping type and pulse-shaping     coefficient settings match the input signal settings. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodRmsEvm(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodRmsEvm, channel, out value);
        }


        /// <summary>
        /// Returns the estimated sample clock offset, in parts per million (ppm). The estimated offset    is the difference between the sample clocks at the D/A converter of the transmitting device under test (DUT) and the digitizer.    If the clock offset is more than 25 ppm, the estimated value might be inaccurate. The clock offset      measurement follows section 17.3.9.5 of IEEE Standard 802.11a-1999, and section 20.3.21.6 of IEEE Standard 802.11n-2009.
        ///     Note: If the magnitude of the carrier or the Sample clock frequency offset is greater than 25 ppm,     I/Q gain imbalance magnitude is greater than 3 dB, and quadrature skew magnitude is greater than     15 degrees, the estimates of these impairments might not be accurate. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSampleClockOffset(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodSampleClockOffset, channel, out value);
        }


        /// <summary>
        /// Returns the minimum value, in dB, of the difference between the magnitude of the channel frequency response and the spectral flatness mask,    as defined in section 17.3.9.6.2 of IEEE Standard 802.11a-1999 and section 20.3.21.2 of IEEE Standard 802.11n-2009.
        ///     If you set the standard parameter of the niWLANA_SetStandard function to     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use the channelx active channel string to configure this attribute.
        ///     Refer to Spectral Flatness Margin for a graphical representation of the spectral flatness margin. 
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodSpectralFlatnessMargin(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodSpectralFlatnessMargin, channel, out value);
        }


        /// <summary>
        ///Returns the lowest margin which is the minimum difference between the spectral mask and the    acquired PSD, as defined in section 17.3.9.2 of    IEEE Standard 802.11a-1999, section 18.4.7.3 of IEEE Standard 802.11b-1999, and section 20.3.21.1 of IEEE Standard 802.11n-2009.    If the test fails, the spectral mask margin is    negative. The toolkit computes the spectral mask margin excluding the reference channel if you set    the NIWLANA_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE attribute to NIWLANA_VAL_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE_PEAK_SIGNAL_POWER. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use    'channelx' as the active channel string format when you set the NIWLANA_SPECTRAL_MASK_COMBINED_MASK_ENABLED    to NIWLANA_VAL_TRUE. 
        ///    If you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Get Function: niWLANA_GetSpectralMaskMargin
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultSpectralMaskMargin(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultSpectralMaskMargin, channel, out value);
        }


        /// <summary>
        ///Returns the lowest margin for each linear segment of the spectral emission mask, as defined in section    17.3.9.2 of IEEE Standard 802.11a-1999, section 18.4.7.3 of IEEE Standard 802.11b-1999, and section    20.3.21.1 of IEEE Standard 802.11n-2009. The resulting lowest margin indicates the minimum difference between the    acquired PSD spectrum and the spectral mask.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use    'channelx' as the active channel string format when you set the NIWLANA_SPECTRAL_MASK_COMBINED_MASK_ENABLED    to NIWLANA_VAL_TRUE. 
        ///    If you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetSpectralMaskMarginVector
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="data"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetResultSpectralMaskMarginVector(string channel, double[] data, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.ResultSpectralMaskMarginVector, data, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Returns the lowest margin for each linear segment of the spectral emission mask, as defined in section    17.3.9.2 of IEEE Standard 802.11a-1999, section 18.4.7.3 of IEEE Standard 802.11b-1999, and section    20.3.21.1 of IEEE Standard 802.11n-2009. The resulting lowest margin indicates the minimum difference between the    acquired PSD spectrum and the spectral mask.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use    'channelx' as the active channel string format when you set the NIWLANA_SPECTRAL_MASK_COMBINED_MASK_ENABLED    to NIWLANA_VAL_TRUE. 
        ///    If you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetSpectralMaskMarginVector
        /// 
        /// </summary>
        [Obsolete("Use Vector overload GetResultSpectralMaskMarginVector")]
        public int GetResultSpectralMaskMarginVector(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultSpectralMaskMarginVector, channel, out value);
        }


        /// <summary>
        ///Returns the reference level used for spectral mask margin measurements. This value is expressed in dBm/Hz. 
        ///    This value is the maximum of the PSD of the signal if NIWLANA_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE attribute    is set to NIWLANA_VAL_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE_PEAK_SIGNAL_POWER.
        ///    The 0 dB level of the spectral mask corresponds to this PSD value, and the toolkit    constructs the standard-specific spectral mask accordingly.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, you must use    'channelx' as the active channel string format when you set the NIWLANA_SPECTRAL_MASK_COMBINED_MASK_ENABLED    to NIWLANA_VAL_TRUE. 
        ///    If you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        ///    Get Function: niWLANA_GetResultSpectralMaskReferenceLevel
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultSpectralMaskReferenceLevel(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultSpectralMaskReferenceLevel, channel, out value);
        }


        /// <summary>
        /// Returns the average power of the acquired burst, in dBm.
        ///    You can use this measurement to verify that the device under test (DUT) conforms to section 17.3.9.1 of    IEEE Standard 802.11a-1999 or section 18.4.7.1 of IEEE Standard 802.11b-1999,    both of which specify maximum output power, in mW, in certain cases.
        ///     Use the following equation to convert from dBm to mW: mW = 10^(dBm/10)
        ///     If you set the standard parameter of the niWLANA_SetStandard function to     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use the channelx active channel string to configure this attribute.   
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpowerMeasurementsAveragePower(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpowerMeasurementsAveragePower, channel, out value);
        }


        /// <summary>
        /// Returns the peak power of the acquired burst, in dBm.
        ///     If you set the standard parameter of the niWLANA_SetStandard function to     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use an channelx active channel string to configure this attribute.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpowerMeasurementsPeakPower(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpowerMeasurementsPeakPower, channel, out value);
        }


        /// <summary>
        ///Returns the root-mean-square (RMS) error vector magnitude (EVM) value, in dB, of data subcarriers.
        ///     Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999 and section 20.3.21.7.4 of IEEE Standard 802.11n-2009.     The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999 and section 20.3.21.7.4 of IEEE Standard 802.11n-2009.
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use the following  active channel string formats to query this attribute:
        ///    streamx for stream EVM
        ///    channelx for channel EVM
        ///    Get Function: niWLANA_GetOFDMDemodDataRMSEVM
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodDataRmsEvm(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodDataRmsEvm, channel, out value);
        }


        /// <summary>
        ///Returns the root-mean-square (RMS) error vector magnitude (EVM) value, in dB, of pilot subcarriers.
        ///     Acceptable RMS EVM limits are defined in section 17.3.9.6.3 of IEEE Standard 802.11a-1999 and section 20.3.21.7.4 of IEEE Standard 802.11n-2009.     The method of computation is discussed in section 17.3.9.7 of IEEE Standard 802.11a-1999 and section 20.3.21.7.4 of IEEE Standard 802.11n-2009.
        ///     If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, you must use the following  active channel string formats to configure this attribute:
        ///    streamx for stream EVM
        ///    channelx for channel EVM
        ///    Get Function: niWLANA_GetOFDMDemodPilotRMSEVM
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodPilotRmsEvm(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodPilotRmsEvm, channel, out value);
        }


        /// <summary>
        ///Specifies the span for spectral acquisition. This value is expressed in Hz. if you set the NIWLANA_SPECTRAL_MASK_ENABLED attribute    or NIWLANA_SPECTRAL_MEASUREMENTS_ALL_ENABLED attribute to NIWLANA_VAL_TRUE.    The toolkit ignores this attribute if you set the NIWLANA_AUTO_SPAN_ENABLED attribute to NIWLANA_VAL_TRUE.
        ///    If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to NIWLANA_VAL_ADS_MODE_PACKET_FILTER the    span must be within the value set in the NIWLANA_DEVICE_INSTANTANEOUS_BANDWIDTH attribute.
        ///    The default value is 66 MHz. Valid values are 100 kHz to 5 GHz, inclusive.
        ///    Get Function: niWLANA_GetSpan
        ///    Set Function: niWLANA_SetSpan
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpan(string channel, double value)
        {
            return SetDouble(niWLANAProperties.Span, channel, value);
        }


        /// <summary>
        ///Specifies the span for spectral acquisition. This value is expressed in Hz. if you set the NIWLANA_SPECTRAL_MASK_ENABLED attribute    or NIWLANA_SPECTRAL_MEASUREMENTS_ALL_ENABLED attribute to NIWLANA_VAL_TRUE.    The toolkit ignores this attribute if you set the NIWLANA_AUTO_SPAN_ENABLED attribute to NIWLANA_VAL_TRUE.
        ///    If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to NIWLANA_VAL_ADS_MODE_PACKET_FILTER the    span must be within the value set in the NIWLANA_DEVICE_INSTANTANEOUS_BANDWIDTH attribute.
        ///    The default value is 66 MHz. Valid values are 100 kHz to 5 GHz, inclusive.
        ///    Get Function: niWLANA_GetSpan
        ///    Set Function: niWLANA_SetSpan
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpan(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.Span, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable spectral mask-related measurements.
        ///    Refer to section 17.9.3.2 of IEEE Standard 802.11a-1999,    section 18.4.7.3 of IEEE Standard 802.11b-1999, section 19.5.4 of IEEE Standard 802.11g-2003,    and section 20.3.21.1 of IEEE Standard 802.11n-2009, section 22.3.18.1 of IEEE Standard 802.11ac-2013,    section 24.3.16.1 of IEEE P802.11ah/D1.3, section 23.3.18.1 of IEEE 802.11af-2013, and section 28.3.18.1 of IEEE P802.11ax/D1.2 for more    information about spectral mask measurements.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSpectralMaskEnabled
        ///    Set Function: niWLANA_SetSpectralMaskEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMaskEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMaskEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the array of frequency offsets used to define the spectral mask.    The toolkit does not assume mask symmetry. Therefore, both positive and negative offsets from the center    frequency must be defined in ascending order. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you    must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you    must use 'segmenty' as the active    channel string format to set this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    The default is an array of mask specification corresponding to a nominal bandwidth of 20 MHz.
        ///    Get Function: niWLANA_GetSpectralMaskFrequencyOffsets
        ///    Set Function: niWLANA_SetSpectralMaskFrequencyOffsets
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="data"></param>
        /// <param name="dataSize"></param>
        /// <returns></returns>
        public int SetSpectralMaskFrequencyOffsets(string channel, double[] data, int dataSize)
        {
            return SetVectorDouble(channel, niWLANAProperties.SpectralMaskFrequencyOffsets, data, dataSize);
        }


        /// <summary>
        ///Specifies the array of frequency offsets used to define the spectral mask.    The toolkit does not assume mask symmetry. Therefore, both positive and negative offsets from the center    frequency must be defined in ascending order. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you    must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you    must use 'segmenty' as the active    channel string format to set this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    The default is an array of mask specification corresponding to a nominal bandwidth of 20 MHz.
        ///    Get Function: niWLANA_GetSpectralMaskFrequencyOffsets
        ///    Set Function: niWLANA_SetSpectralMaskFrequencyOffsets
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="data"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetSpectralMaskFrequencyOffsets(string channel, double[] data, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.SpectralMaskFrequencyOffsets, data, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        /// Specifies the number of iterations over which the toolkit averages spectral    mask measurements.
        ///     If you increase the number of averages, the toolkit provides smoother values but takes a longer time to compute the values.
        ///     The default value is 10. Valid values are 1 to 1,000 (inclusive).          
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMaskNumberOfAverages(string channel, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMaskNumberOfAverages, channel, out value);
        }


        /// <summary>
        ///Specifies the array of power offsets used to define the spectral mask.    You must specify the offsets from the mask reference power level for each of the frequency offset points. This value is expressed in dB.    The order of the power offsets in this array corresponds to the order of the frequency offsets that you specify in    the NIWLANA_SPECTRAL_MASK_FREQUENCY_OFFSETS attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you    must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you    must use 'segmenty' as the active    channel string format to set this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    The default is an array of mask specification corresponding to a nominal bandwidth of 20 MHz.
        ///    Get Function: niWLANA_GetSpectralMaskPowerOffsets
        ///    Set Function: niWLANA_SetSpectralMaskPowerOffsets
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="data"></param>
        /// <param name="dataSize"></param>
        /// <returns></returns>
        public int SetSpectralMaskPowerOffsets(string channel, double[] data, int dataSize)
        {
            return SetVectorDouble(channel, niWLANAProperties.SpectralMaskPowerOffsets, data, dataSize);
        }


        /// <summary>
        ///Specifies the array of power offsets used to define the spectral mask.    You must specify the offsets from the mask reference power level for each of the frequency offset points. This value is expressed in dB.    The order of the power offsets in this array corresponds to the order of the frequency offsets that you specify in    the NIWLANA_SPECTRAL_MASK_FREQUENCY_OFFSETS attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,    you must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you    must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, you    must use an empty string as the active channel string format to set this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you    must use 'segmenty' as the active    channel string format to set this attribute. 'segment0/' is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    The default is an array of mask specification corresponding to a nominal bandwidth of 20 MHz.
        ///    Get Function: niWLANA_GetSpectralMaskPowerOffsets
        ///    Set Function: niWLANA_SetSpectralMaskPowerOffsets
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="data"></param>
        /// <param name="dataSize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetSpectralMaskPowerOffsets(string channel, double[] data, int dataSize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channel, niWLANAProperties.SpectralMaskPowerOffsets, data, dataSize, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Specifies the user-defined reference level that the toolkit uses for spectral mask measurements. This value is expressed in dBm/Hz. 
        ///    Configure this attribute only if you set the NIWLANA_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE attribute    to NIWLANA_VAL_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE_USER_DEFINED.
        ///    This attribute is channel-specific for NI WLAN Analysis Toolkit version 3.0 and later.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetSpectralMaskReferenceLevel
        ///    Set Function: niWLANA_SetSpectralMaskReferenceLevel
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMaskReferenceLevel(string channel, double value)
        {
            return SetDouble(niWLANAProperties.SpectralMaskReferenceLevel, channel, value);
        }


        /// <summary>
        ///Specifies the user-defined reference level that the toolkit uses for spectral mask measurements. This value is expressed in dBm/Hz. 
        ///    Configure this attribute only if you set the NIWLANA_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE attribute    to NIWLANA_VAL_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE_USER_DEFINED.
        ///    This attribute is channel-specific for NI WLAN Analysis Toolkit version 3.0 and later.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetSpectralMaskReferenceLevel
        ///    Set Function: niWLANA_SetSpectralMaskReferenceLevel
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMaskReferenceLevel(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.SpectralMaskReferenceLevel, channel, out value);
        }


        /// <summary>
        ///Specifies the type of reference to use for spectral mask measurements.
        ///    The default value is NIWLANA_VAL_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE_PEAK_SIGNAL_POWER.
        ///    Get Function: niWLANA_GetSpectralMaskReferenceLevelType
        ///    Set Function: niWLANA_SetSpectralMaskReferenceLevelType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMaskReferenceLevelType(string channel, int value)
        {
            return SetInt(niWLANAProperties.SpectralMaskReferenceLevelType, channel, value);
        }


        /// <summary>
        ///Specifies the type of reference to use for spectral mask measurements.
        ///    The default value is NIWLANA_VAL_SPECTRAL_MASK_REFERENCE_LEVEL_TYPE_PEAK_SIGNAL_POWER.
        ///    Get Function: niWLANA_GetSpectralMaskReferenceLevelType
        ///    Set Function: niWLANA_SetSpectralMaskReferenceLevelType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMaskReferenceLevelType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMaskReferenceLevelType, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable the spectral mask trace.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSpectralMaskTraceEnabled
        ///    Set Function: niWLANA_SetSpectralMaskTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMaskTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.SpectralMaskTraceEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable the spectral mask trace.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSpectralMaskTraceEnabled
        ///    Set Function: niWLANA_SetSpectralMaskTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMaskTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMaskTraceEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether the spectral mask is user-defined or standard.
        ///    The default value is NIWLANA_VAL_SPECTRAL_MASK_TYPE_STANDARD.
        ///    Get Function: niWLANA_GetSpectralMaskType
        ///    Set Function: niWLANA_SetSpectralMaskType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMaskType(string channel, int value)
        {
            return SetInt(niWLANAProperties.SpectralMaskType, channel, value);
        }


        /// <summary>
        ///Specifies whether the spectral mask is user-defined or standard.
        ///    The default value is NIWLANA_VAL_SPECTRAL_MASK_TYPE_STANDARD.
        ///    Get Function: niWLANA_GetSpectralMaskType
        ///    Set Function: niWLANA_SetSpectralMaskType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMaskType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMaskType, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable all spectral measurement attributes.
        ///    When you set this attribute to NIWLANA_VAL_TRUE, the toolkit ignores the following attributes:
        ///    NIWLANA_SPECTRAL_MASK_ENABLED
        ///    NIWLANA_OBW_ENABLED
        ///    NIWLANA_MAX_SPECTRAL_DENSITY_ENABLED
        ///    NIWLANA_ACP_ENABLED
        ///    NIWLANA_SPECTRAL_MEASUREMENTS_CHANNEL_POWER_ENABLED
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSpectralMeasurementsAllEnabled
        ///    Set Function: niWLANA_SetSpectralMeasurementsAllEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpectralMeasurementsAllEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.SpectralMeasurementsAllEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable all spectral measurement attributes.
        ///    When you set this attribute to NIWLANA_VAL_TRUE, the toolkit ignores the following attributes:
        ///    NIWLANA_SPECTRAL_MASK_ENABLED
        ///    NIWLANA_OBW_ENABLED
        ///    NIWLANA_MAX_SPECTRAL_DENSITY_ENABLED
        ///    NIWLANA_ACP_ENABLED
        ///    NIWLANA_SPECTRAL_MEASUREMENTS_CHANNEL_POWER_ENABLED
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetSpectralMeasurementsAllEnabled
        ///    Set Function: niWLANA_SetSpectralMeasurementsAllEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpectralMeasurementsAllEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.SpectralMeasurementsAllEnabled, channel, out value);
        }



        /// <summary>
        /// Specifies the standard for measurements.
        ///     Note: If you do not select a standard, the toolkit returns an error.
        ///     The default value is NIWLANA_VAL_STANDARD_80211AG_OFDM.  
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetStandard(string channel, out int value)
        {
            return GetInt(niWLANAProperties.Standard, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable measurement of peak power and average power in the acquired burst. This value is expressed in dBm. 
        ///    The toolkit automatically detects the start and end of a valid burst corresponding to a WLAN    packet.
        ///    The toolkit detects the start of the burst by determining the position at which the total power    of a nonoverlapping moving window increases by at least 12 dB between two consecutive windows,    as well as between two windows separated by one window. The toolkit detects the end of the burst by determining    the position at which the total power of a moving window decreases by at least 12 dB between    two consecutive windows, as well as between two windows that are separated by one window and two window lengths.
        ///    If the toolkit cannot automatically determine the start of the signal burst, the toolkit returns an error.    If the toolkit cannot determine the end of the burst, the toolkit uses the whole acquired waveform.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetTxPowerMeasurementEnabled
        ///    Set Function: niWLANA_SetTxPowerMeasurementEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetTxpowerMeasurementsEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.TxpowerMeasurementsEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages burst power measurements.
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values.
        ///    The default value is 1. Valid values are 1 to 1,000, inclusive.
        ///    Get Function: niWLANA_GetTxPowerMeasurementNumberOfAverages
        ///    Set Function: niWLANA_SetTxPowerMeasurementNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetTxpowerMeasurementsNumberOfAverages(string channel, out int value)
        {
            return GetInt(niWLANAProperties.TxpowerMeasurementsNumberOfAverages, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable the power versus time (PvT) trace.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetTxPowerMeasurementsPvtTraceEnabled
        ///    Set Function: niWLANA_SetTxPowerMeasurementsPvtTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetTxpowerMeasurementsPvtTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.TxpowerMeasurementsPvtTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies the trigger delay. This value is expressed in seconds. The toolkit computes    the NIWLANA_RECOMMENDED_IQ_PRE_TRIGGER_DELAY and NIWLANA_RECOMMENDED_IQ_POST_TRIGGER_DELAY attributes    based on the value of the NIWLANA_TRIGGER_DELAY attribute.
        ///    If the signal to be measured does not generate immediately when the trigger occurs,    set this attribute to the value of the delay. 
        ///    The trigger delay value must be positive in this case. Set this attribute to a negative    value if your application requires a pretrigger delay in addition    to the default recommended pre-trigger delay which is 5 &#181;s.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetTriggerDelay
        ///    Set Function: niWLANA_SetTriggerDelay
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetTriggerDelay(string channel, double value)
        {
            return SetDouble(niWLANAProperties.TriggerDelay, channel, value);
        }


        /// <summary>
        ///Specifies the trigger delay. This value is expressed in seconds. The toolkit computes    the NIWLANA_RECOMMENDED_IQ_PRE_TRIGGER_DELAY and NIWLANA_RECOMMENDED_IQ_POST_TRIGGER_DELAY attributes    based on the value of the NIWLANA_TRIGGER_DELAY attribute.
        ///    If the signal to be measured does not generate immediately when the trigger occurs,    set this attribute to the value of the delay. 
        ///    The trigger delay value must be positive in this case. Set this attribute to a negative    value if your application requires a pretrigger delay in addition    to the default recommended pre-trigger delay which is 5 &#181;s.
        ///    The default value is 0.
        ///    Get Function: niWLANA_GetTriggerDelay
        ///    Set Function: niWLANA_SetTriggerDelay
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetTriggerDelay(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.TriggerDelay, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended acquisition type for the current measurement configuration. 
        ///    If you enable any of the spectral measurements attributes, the toolkit sets this attribute    to NIWLANA_VAL_ACQUISITION_TYPE_SPECTRUM. Otherwise, the toolkit sets this    attribute to NIWLANA_VAL_ACQUISITION_TYPE_IQ. For more information about simultaneous I/Q and spectrum measurements    refer to the Simultaneous Measurements topic.
        ///    The default value is NIWLANA_VAL_ACQUISITION_TYPE_IQ. 
        ///    Get Function: niWLANA_GetRecommendedAcquisitionType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedAcquisitionType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.RecommendedAcquisitionType, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended acquisition length. This value is expressed in seconds. This attribute is used    to configure NI vector signal analyzers for signal acquisition inside the niWLANA_RFSAConfigureHardware function    or the niWLANA_RFSAConfigureMIMOHardware function.    The toolkit determines this attribute using the following equation:
        ///    Recommended Acquisition Length = Acquisition Length + Recommended Pre-Trigger Delay
        ///    where Maximum Measurement Length is the maximum of the values of the following attributes, if the    corresponding measurement is enabled and NIWLANA_ACQUISITION_LENGTH attribute is not set. 
        ///    NIWLANA_TXPOWER_MEASUREMENT_LENGTH 
        ///    NIWLANA_CCDF_MEASUREMENT_LENGTH 
        ///    NIWLANA_GATED_SPECTRUM_MEASUREMENT_LENGTH 
        ///    NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_LENGTH 
        ///    NIWLANA_OFDM_DEMOD_MEASUREMENT_LENGTH attribute or automatically computed measurement length    if you set the NIWLANA_OFDM_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    NIWLANA_DSSS_DEMOD_MEASUREMENT_LENGTH attribute or automatically computed measurement    length if you set the NIWLANA_DSSS_DEMOD_AUTO_COMPUTE_MEASUREMENT_LENGTH_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    All of the above measurements cannot be enabled simultaneously. Refer to the Simultaneous Measurements topic for more details. 
        ///    If you did not set any of the above attributes and the NIWLANA_ACQUISITION_LENGTH attribute is set, the maximum    measurement length equals the value of the NIWLANA_ACQUISITION_LENGTH attribute. 
        ///    If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE to NIWLANA_ADS_MODE_PACKET_FILTER, the    toolkit determines this attribute using the following equation: 
        ///    Recommended Acquisition Length = Acquisition Length + Recommended Pre-Trigger Delay
        ///    If you do not use the niWLANA_RFSAConfigureHardware function, multiply this attribute by    the NIWLANA_RECOMMENDED_IQ_SAMPLING_RATE attribute and pass the result to the NIRFSA_ATTR_NUMBER_OF_SAMPLES attribute. 
        ///    Get Function: niWLANA_GetRecommendedAcquisitionLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedAcquisitionLength(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.RecommendedAcquisitionLength, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended minimum quiet time during which the signal    level must be below the trigger value for triggering to occur. This value is expressed in seconds. 
        ///    If you do not use the niWLANA_RFSAConfigureHardware function or the niWLANA_RFSAConfigureMIMOHardware function, pass this attribute    to the NIRFSA_ATTR_REF_TRIGGER_MINIMUM_QUIET_TIME attribute.
        ///    This attribute returns a value of 5 µs.
        ///    Get Function: niWLANA_GetRecommendedMinimumQuietTime
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedMinimumQuietTime(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.RecommendedMinimumQuietTime, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended number of records to acquire from the NI-RFSA.    If you do not use the niWLANA_RFSAConfigureHardware function or the niWLANA_RFSAConfigureMIMOHardware function, pass this    attribute to the NIRFSA_ATTR_NUMBER_OF_RECORDS attribute.
        ///    For spectral measurements and I/Q measurements on direct sequence spread spectrum (DSSS) and    OFDM signals, the    NIWLANA_RECOMMENDED_NUMBER_OF_RECORDS attribute returns the maximum of the following attributes if the corresponding measurements are enabled.
        ///    Eight times the NIWLANA_SPECTRAL_MASK_NUMBER_OF_AVERAGES if you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_80211AX_MIMO_OFDM, or hundred times the NIWLANA_SPECTRAL_MASK_NUMBER_OF_AVERAGES if    you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_80211AH_MIMO_OFDM, or    three times the NIWLANA_SPECTRAL_MASK_NUMBER_OF_AVERAGES otherwise.
        ///    NIWLANA_OBW_NUMBER_OF_AVERAGES
        ///    NIWLANA_MAX_SPECTRAL_DENSITY_NUMBER_OF_AVERAGES
        ///    NIWLANA_TXPOWER_MEASUREMENTS_NUMBER_OF_AVERAGES
        ///    NIWLANA_CCDF_NUMBER_OF_RECORDS
        ///    NIWLANA_DSSS_POWER_RAMP_MEASUREMENT_NUMBER_OF_AVERAGES 
        ///    NIWLANA_OFDM_DEMOD_NUMBER_OF_AVERAGES 
        ///    NIWLANA_DSSS_DEMOD_NUMBER_OF_AVERAGES 
        ///    NIWLANA_ACP_NUMBER_OF_AVERAGES 
        ///    NIWLANA_ETSI_IBE_NUMBER_OF_AVERAGES 
        ///    If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute    to NIWLANA_VAL_ADS_MODE_PACKET_FILTER, the NIWLANA_RECOMMENDED_NUMBER_OF_RECORDS returns a value of 1.
        ///    Get Function: niWLANA_GetRecommendedNumberOfRecords
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedNumberOfRecords(string channel, out int value)
        {
            return GetInt(niWLANAProperties.RecommendedNumberOfRecords, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended minimum sample rate for the NI-RFSA. This    value is expressed in samples per second. If you do not use the    niWLANA_RFSAConfigureHardware function or the niWLANA_RFSAConfigureMIMOHardware function, pass this attribute to the niRFSA_ConfigureIQRate function.
        ///    The toolkit derives this attribute from the current signal configuration as shown in the table found    in the Recommended IQ Sampling Rate help topic. 
        ///    To view the table, refer to the NI LabWindows/CVI WLAN Analysis Toolkit Reference Help, and    navigate to the Recommended I/Q Sampling Rate help topic.
        ///    Get Function: niWLANA_GetRecommendedIQSamplingRate
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedIqSamplingRate(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.RecommendedIqSamplingRate, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended pretrigger delay. This value is expressed in seconds. If you do not    use the niWLANA_RFSAConfigureHardware function, or the niWLANA_RFSAConfigureMIMOHardware function,    multiply this attribute by the NIRFSA_ATTR_IQ_RATE attribute, then pass the result    to the NIRFSA_ATTR_REF_TRIGGER_PRETRIGGER_SAMPLES attribute.
        ///    The toolkit uses this attribute to acquire data prior to the trigger to account for the    delays in the measurement process. Configure the NIWLANA_TRIGGER_DELAY attribute if your application    requires an additional pretrigger delay. 
        ///    To view the recommended pre trigger delay duration values, refer to the Recommended Pre-Trigger Delay topic.
        ///    Get Function: niWLANA_GetRecommendedIQPreTriggerDelay
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedIqPreTriggerDelay(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.RecommendedIqPreTriggerDelay, channel, out value);
        }


        /// <summary>
        ///Returns the toolkit-recommended post-trigger delay. This value is expressed in seconds.
        ///    If you do not use instances niWLANA_RFSAMeasure or niWLANA_RFSAMIMOMeasure functions    and you configure a positive value to the NIWLANA_TRIGGER_DELAY attribute, then pass    this attribute to the t0 parameter of the niWLANA_AnalyzeIQComplexF64    or niWLANA_AnalyzeMIMOIQComplexF64 functions.
        ///    If you do not use the niWLANA_RFSAMeasure or niWLANA_RFSAMIMOMeasure functions for acquisition    and analysis and use the niWLANA_AnalyzeIQComplexF64    or niWLANA_AnalyzeMIMOIQComplexF64 functions;    and use niRFSA_FetchIQSingleRecordComplexF64 to acquire the waveform from NI RF vector    signal analyzer, pass this attribute to the t0    cluster element of the dataOutput parameter in the niRFSA_FetchIQSingleRecordComplexF64 function.     The toolkit derives the value for the NIWLANA_RECOMMENDED_IQ_POST_TRIGGER_DELAY attribute    from the NIWLANA_TRIGGER_DELAY attribute. Configure the NIWLANA_TRIGGER_DELAY attribute if the signal to be measured is generated    after a delay when the trigger occurs.
        ///    Get Function: niWLANA_GetRecommendedIQPostTriggerDelay
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedIqPostTriggerDelay(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.RecommendedIqPostTriggerDelay, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended span for spectral acquisition. This value is expressed in Hz.
        ///    Get Function: niWLANA_GetRecommendedSpectrumSpan
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedSpectrumSpan(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.RecommendedSpectrumSpan, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended RBW type for spectral acquisition.    The value of this attribute is the same as the value of the NIWLANA_RBW_DEFINITION attribute. If you    do not use the niWLANA_RFSAConfigureHardware function or the niWLANA_RFSAConfigureMIMOHardware function,    derive the NIRFSA_ATTR_RESOLUTION_BANDWIDTH_TYPE attribute from the NIWLANA_RECOMMENDED_SPECTRUM_RBW_DEFINITION attribute.
        ///    Get Function: niWLANA_GetRecommendedSpectrumRBWDefinition
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedSpectrumRbwDefinition(string channel, out int value)
        {
            return GetInt(niWLANAProperties.RecommendedSpectrumRbwDefinition, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended RBW for spectral    acquisition. This value is expressed in Hz. The value of this attribute is the same as the value of the    NIWLANA_RBW attribute. If you do not use the niWLANA_RFSAConfigureHardware function or    the niWLANA_RFSAConfigureMIMOHardware function, pass the NIWLANA_RECOMMENDED_SPECTRUM_RBW attribute    to the NIRFSA_ATTR_RESOLUTION_BANDWIDTH attribute.
        ///    Get Function: niWLANA_GetRecommendedSpectrumRBW
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedSpectrumRbw(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.RecommendedSpectrumRbw, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended VBW for spectral acquisition. This value is expressed in Hz.
        ///    Get Function: niWLANA_GetRecommendedSpectrumVBW
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedSpectrumVbw(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.RecommendedSpectrumVbw, channel, out value);
        }

        /// <summary>
        ///Returns the toolkit-recommended time-domain FFT window type. The value of this    attribute is the same as the value of the NIWLANA_FFT_WINDOW_TYPE attribute. 
        ///    If you do not use the niWLANA_RFSAConfigureHardware function, pass this attribute to the NIRFSA_ATTR_FFT_WINDOW_TYPE attribute.
        ///    Get Function: niWLANA_GetRecommendedSpectrumFFTWindowType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetRecommendedSpectrumFftWindowType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.RecommendedSpectrumFftWindowType, channel, out value);
        }

        /// <summary>
        ///Returns the channel bandwidth detected by the toolkit.
        ///    If you query the NIWLANA_DETECTED_CHANNEL_BANDWIDTH attribute after the niWLANA_RFSAAutoDetectionOfStandard    function and prior to performing signal analysis, the NIWLANA_DETECTED_CHANNEL_BANDWIDTH attribute returns the channel    bandwidth detected by the function.
        ///    If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE attribute to Packet Filter and query    the NIWLANA_DETECTED_CHANNEL_BANDWIDTH attribute after performing signal    analysis, the NIWLANA_DETECTED_CHANNEL_BANDWIDTH attribute returns the detected channel bandwidth of the current packet.
        ///    Get Function: niWLANA_GetDetectedChannelBandwidth
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDetectedChannelBandwidth(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DetectedChannelBandwidth, channel, out value);
        }

        /// <summary>
        ///Returns the average peak power of the acquired bursts. This value is expressed in dBm. Peak power is measured for one burst.    Average Peak power is the average of peak power values across iterations.
        ///     If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpPeakPowerAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpPeakPowerAverage, channel, out value);
        }


        /// <summary>
        ///Returns the minimum peak power of the acquired bursts. This value is expressed in dBm. Peak power is measured for one burst.    Minimum Peak power is the minimum of peak power values across iterations.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpPeakPowerMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpPeakPowerMinimum, channel, out value);
        }

        /// <summary>
        ///Returns the standard deviation of peak power of the acquired bursts. This value is expressed in dBm. Peak power is measured for one burst.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///   If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpPeakPowerStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpPeakPowerStandardDeviation, channel, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int ResultTxpAveragePowerMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpAveragePowerMinimum, channel, out value);
        }

        /// <summary>
        ///Returns the maximum across iterations of average power of the acquired burst. This value is expressed in dBm. 
        ///    You can use this measurement to verify that the device under test (DUT) conforms to section 17.3.9.1 of IEEE Standard 802.11a-1999,    section 18.4.7.1 of IEEE Standard 802.11b-1999, or section 20.3.21.3 of IEEE Standard 802.11n-2009, all of which specify maximum    output power in certain cases. This value is expressed in mW. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM,    NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpAveragePowerMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpAveragePowerMaximum, channel, out value);
        }

        /// <summary>
        ///Returns the standard deviation of average power of the acquired burst. This value is expressed in dBm. 
        ///    You can use this measurement to verify that the device under test (DUT) conforms to section 17.3.9.1 of IEEE Standard 802.11a-1999,    section 18.4.7.1 of IEEE Standard 802.11b-1999, or section 20.3.21.3 of IEEE Standard 802.11n-2009, all of which specify maximum    output power in certain cases. This value is expressed in mW. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpAveragePowerStandardDeviation(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpAveragePowerStandardDeviation, channel, out value);
        }

        /// <summary>
        ///Returns the average across iterations of average power with idle time of the acquired burst. This value is expressed in dBm.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpAveragePowerWithIdleTimeAverage(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpAveragePowerWithIdleTimeAverage, channel, out value);
        }

        /// <summary>
        ///Returns the minimum across iterations of average power with idle time of the acquired burst. This value is expressed in dBm.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM,    NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpAveragePowerWithIdleTimeMinimum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpAveragePowerWithIdleTimeMinimum, channel, out value);
        }

        /// <summary>
        ///Returns the maximum across iterations of average power with idle time of the acquired burst. This value is expressed in dBm.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM,    NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must    use 'channelx' as the active channel string format to query this attribute.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use '[segmentx/]channely' as the active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1.
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use 'channelx' for the total power of all segments, if the channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    Refer to the Configuring Active Channels (LabWindows/CVI) topic for more information about configuring active channels.
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultTxpAveragePowerWithIdleTimeMaximum(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultTxpAveragePowerWithIdleTimeMaximum, channel, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodCommonPilotErrorRms(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCommonPilotErrorRms, channel, out value);
        }

        /// <summary>
        ///Returns the standard, which includes the type of physical layer, detected by the toolkit.
        ///    If you query the NIWLANA_DETECTED_STANDARD attribute after the niWLANA_RFSAAutoDetectionOfStandard function and prior    to performing signal analysis, the NIWLANA_DETECTED_STANDARD attribute returns the standard detected by the function.
        ///    If you set the NIWLANA_AUTO_DETECTION_STANDARD_MODE to NIWLANA_VAL_ADS_MODE_PACKET_FILTER and query the NIWLANA_DETECTED_STANDARD attribute    after performing the signal analysis, the NIWLANA_DETECTED_STANDARD attribute returns the detected standard of the current packet.
        ///    Get Function: niWLANA_GetDetectedStandard
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDetectedStandard(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DetectedStandard, channel, out value);
        }

        /// <summary>
        ///Specifies whether the toolkit automatically calculates the span required for the current configuration of Spectral Mask measurement.    If you want to specify the NIWLANA_SPAN attribute, set the NIWLANA_AUTO_SPAN_ENABLED attribute to NIWLANA_VAL_FALSE.
        ///    Note: The default value is NIWLANA_VAL_FALSE if you set the compatibilityVersion parameter of    the niWLANA_OpenSession function to values other    than NIWLANA_VAL_COMPATIBILITY_VERSION_040000 or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    The toolkit sets the following recommended span values if you set the NIWLANA_AUTO_SPAN_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    If the Channel Bandwidth is set to 1 MHz, the recommended span is 3.3 MHz. 
        ///    If the Channel Bandwidth is set to 2 MHz, the recommended span is 6.6 MHz. 
        ///    If the Channel Bandwidth is set to 4 MHz, the recommended span is 13.2 MHz. 
        ///    If the Channel Bandwidth is set to 5 MHz, the recommended span is 20 MHz. 
        ///    If the Channel Bandwidth is set to 6 MHz, the recommended span is 19.8 MHz. 
        ///    If the Channel Bandwidth is set to 7 MHz, the recommended span is 23.1 MHz. 
        ///    If the Channel Bandwidth is set to 8 MHz, the recommended span is 26.4 MHz. 
        ///    If the Channel Bandwidth is set to 10 MHz, the recommended span is 33 MHz. 
        ///    If the Channel Bandwidth is set to 16 MHz, the recommended span is 52.8 MHz. 
        ///    If the Channel Bandwidth is set to 20 MHz, the recommended span is 66 MHz. 
        ///    If the Channel Bandwidth is set to 40 MHz, the recommended span is 120 MHz. 
        ///    If the Channel Bandwidth is set to 80 MHz, the recommended span is 240 MHz. 
        ///    If the Channel Bandwidth is set to 160 MHz, the recommended span is 480 MHz. 
        ///    Get Function: niWLANA_GetAutoSpanEnabled
        ///    Set Function: niWLANA_SetAutoSpanEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetAutoSpanEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.AutoSpanEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether the toolkit automatically calculates the span required for the current configuration of Spectral Mask measurement.    If you want to specify the NIWLANA_SPAN attribute, set the NIWLANA_AUTO_SPAN_ENABLED attribute to NIWLANA_VAL_FALSE.
        ///    Note: The default value is NIWLANA_VAL_FALSE if you set the compatibilityVersion parameter of    the niWLANA_OpenSession function to values other    than NIWLANA_VAL_COMPATIBILITY_VERSION_040000 or NIWLANA_VAL_COMPATIBILITY_VERSION_050000.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    The toolkit sets the following recommended span values if you set the NIWLANA_AUTO_SPAN_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    If the Channel Bandwidth is set to 1 MHz, the recommended span is 3.3 MHz. 
        ///    If the Channel Bandwidth is set to 2 MHz, the recommended span is 6.6 MHz. 
        ///    If the Channel Bandwidth is set to 4 MHz, the recommended span is 13.2 MHz. 
        ///    If the Channel Bandwidth is set to 5 MHz, the recommended span is 20 MHz. 
        ///    If the Channel Bandwidth is set to 6 MHz, the recommended span is 19.8 MHz. 
        ///    If the Channel Bandwidth is set to 7 MHz, the recommended span is 23.1 MHz. 
        ///    If the Channel Bandwidth is set to 8 MHz, the recommended span is 26.4 MHz. 
        ///    If the Channel Bandwidth is set to 10 MHz, the recommended span is 33 MHz. 
        ///    If the Channel Bandwidth is set to 16 MHz, the recommended span is 52.8 MHz. 
        ///    If the Channel Bandwidth is set to 20 MHz, the recommended span is 66 MHz. 
        ///    If the Channel Bandwidth is set to 40 MHz, the recommended span is 120 MHz. 
        ///    If the Channel Bandwidth is set to 80 MHz, the recommended span is 240 MHz. 
        ///    If the Channel Bandwidth is set to 160 MHz, the recommended span is 480 MHz. 
        ///    Get Function: niWLANA_GetAutoSpanEnabled
        ///    Set Function: niWLANA_SetAutoSpanEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAutoSpanEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.AutoSpanEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable the pilot EVM per symbol trace for    signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodPilotEVMPerSymbolTraceEnabled
        ///    Set Function: niWLANA_GetOFDMDemodPilotEVMPerSymbolTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodPilotEvmPerSymbolTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodPilotEvmPerSymbolTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable the pilot EVM per symbol trace for    signals containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodPilotEVMPerSymbolTraceEnabled
        ///    Set Function: niWLANA_GetOFDMDemodPilotEVMPerSymbolTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodPilotEvmPerSymbolTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodPilotEvmPerSymbolTraceEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable the data EVM per symbol trace for signals    containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodDataEVMPerSymbolTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodDataEVMPerSymbolTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodDataEvmPerSymbolTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodDataEvmPerSymbolTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable the data EVM per symbol trace for signals    containing an OFDM payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodDataEVMPerSymbolTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodDataEVMPerSymbolTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodDataEvmPerSymbolTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodDataEvmPerSymbolTraceEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to check for the validity of the signal frame check sequence (FCS). The toolkit calculates FCS over the decoded bits    excluding the last 32 bits. The toolkit then compares this value with the FCS value in the received payload, which is    represented by the last 32 bits of the payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodMACFrameCheckSequenceCheckEnabled
        ///    Set Function: niWLANA_SetOFDMDemodMACFrameCheckSequenceCheckEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodMacFrameCheckSequenceCheckEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodMacFrameCheckSequenceCheckEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to check for the validity of the signal frame check sequence (FCS). The toolkit calculates FCS over the decoded bits    excluding the last 32 bits. The toolkit then compares this value with the FCS value in the received payload, which is    represented by the last 32 bits of the payload.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodMACFrameCheckSequenceCheckEnabled
        ///    Set Function: niWLANA_SetOFDMDemodMACFrameCheckSequenceCheckEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodMacFrameCheckSequenceCheckEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodMacFrameCheckSequenceCheckEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable all traces of direct sequence spread spectrum (DSSS) demodulation.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodAllTracesEnabled
        ///    Set Function: niWLANA_SetDSSSDemodAllTracesEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodAllTracesEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodAllTracesEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable all traces of direct sequence spread spectrum (DSSS) demodulation.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodAllTracesEnabled
        ///    Set Function: niWLANA_SetDSSSDemodAllTracesEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodAllTracesEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodAllTracesEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to enable the EVM per chip trace    for 802.11b and 802.11g direct sequence spread spectrum (DSSS) signals.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodEVMPerChipTraceEnabled
        ///    Set Function: niWLANA_SetDSSSDemodEVMPerChipTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodEvmPerChipTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodEvmPerChipTraceEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable the EVM per chip trace    for 802.11b and 802.11g direct sequence spread spectrum (DSSS) signals.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodEVMPerChipTraceEnabled
        ///    Set Function: niWLANA_SetDSSSDemodEVMPerChipTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodEvmPerChipTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodEvmPerChipTraceEnabled, channel, out value);
        }

        /// <summary>
        ///Specifies whether to check for the validity of the signal frame check sequence (FCS). The toolkit calculates the checksum    over the decoded bits, excluding the last 32 bits. The toolkit then compares this value with the checksum value in the received payload,    which is represented by the last 32 bits of the payload.
        ///    Note: Decoding of received bits is not supported for direct sequence spread spectrum (DSSS) signals    that have a data rate of 33 Mbps. Therefore, the toolkit cannot compute MAC FCS.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodMACFrameCheckSequenceCheckEnabled
        ///    Set Function: niWLANA_SetDSSSDemodMACFrameCheckSequenceCheckEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDsssDemodMacFrameCheckSequenceCheckEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.DsssDemodMacFrameCheckSequenceCheckEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to check for the validity of the signal frame check sequence (FCS). The toolkit calculates the checksum    over the decoded bits, excluding the last 32 bits. The toolkit then compares this value with the checksum value in the received payload,    which is represented by the last 32 bits of the payload.
        ///    Note: Decoding of received bits is not supported for direct sequence spread spectrum (DSSS) signals    that have a data rate of 33 Mbps. Therefore, the toolkit cannot compute MAC FCS.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetDSSSDemodMACFrameCheckSequenceCheckEnabled
        ///    Set Function: niWLANA_SetDSSSDemodMACFrameCheckSequenceCheckEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDsssDemodMacFrameCheckSequenceCheckEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.DsssDemodMacFrameCheckSequenceCheckEnabled, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable the power versus time (PvT) trace.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetTxPowerMeasurementsPvtTraceEnabled
        ///    Set Function: niWLANA_SetTxPowerMeasurementsPvtTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetTxpowerMeasurementsPvtTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.TxpowerMeasurementsPvtTraceEnabled, channel, out value);
        }

        //added on 26-12-2011
        /// <summary>
        ///Specifies whether to enable measurement of peak power and average power in the acquired burst. This value is expressed in dBm. 
        ///    The toolkit automatically detects the start and end of a valid burst corresponding to a WLAN    packet.
        ///    The toolkit detects the start of the burst by determining the position at which the total power    of a nonoverlapping moving window increases by at least 12 dB between two consecutive windows,    as well as between two windows separated by one window. The toolkit detects the end of the burst by determining    the position at which the total power of a moving window decreases by at least 12 dB between    two consecutive windows, as well as between two windows that are separated by one window and two window lengths.
        ///    If the toolkit cannot automatically determine the start of the signal burst, the toolkit returns an error.    If the toolkit cannot determine the end of the burst, the toolkit uses the whole acquired waveform.
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetTxPowerMeasurementEnabled
        ///    Set Function: niWLANA_SetTxPowerMeasurementEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetTxpowerMeasurementsEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.TxpowerMeasurementsEnabled, channel, value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages burst power measurements.
        ///    If you increase the number of averages, the toolkit provides more accurate values but takes longer to compute the values.
        ///    The default value is 1. Valid values are 1 to 1,000, inclusive.
        ///    Get Function: niWLANA_GetTxPowerMeasurementNumberOfAverages
        ///    Set Function: niWLANA_SetTxPowerMeasurementNumberOfAverages
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetTxpowerMeasurementsNumberOfAverages(string channel, int value)
        {
            return SetInt(niWLANAProperties.TxpowerMeasurementsNumberOfAverages, channel, value);
        }


        /// <summary>
        ///Specifies the instantaneous bandwidth of the NI-RFSA. This value is expressed Hz. This attribute    is set according to the device model in the niWLANA_RFSAConfigureHardware function or the niWLANA_RFSAConfigureMIMOHardware function.
        ///    The default value is 5 GHz. 
        ///    Get Function: niWLANA_GetDeviceInstantaneousBandwidth
        ///    Set Function: niWLANA_SetDeviceInstantaneousBandwidth
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDeviceInstantaneousBandwidth(string channel, double value)
        {
            return SetDouble(niWLANAProperties.DeviceInstantaneousBandwidth, channel, value);
        }

        /// <summary>
        ///Specifies the instantaneous bandwidth of the NI-RFSA. This value is expressed Hz. This attribute    is set according to the device model in the niWLANA_RFSAConfigureHardware function or the niWLANA_RFSAConfigureMIMOHardware function.
        ///    The default value is 5 GHz. 
        ///    Get Function: niWLANA_GetDeviceInstantaneousBandwidth
        ///    Set Function: niWLANA_SetDeviceInstantaneousBandwidth
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDeviceInstantaneousBandwidth(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.DeviceInstantaneousBandwidth, channel, out value);
        }

        /// <summary>
        ///Indicates whether the cyclic redundancy check (CRC) has passed for the high-throughput SIGNAL (HT-SIG) field as defined in section 20.3.9.4.3    of the IEEE Standard 802.11n-2009.
        ///    Get Function: niWLANA_GetOFDMDemodHTSIGCRCPassed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetResultOfdmDemodHtSigCrcPassed(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodHtSigCrcPassed, channel, out value);
        }

        #region 14.5
        /// <summary>
        ///Specifies the packet preamble type when you set the NIWLANA_OFDM_DEMOD_80211AH_PREAMBLE_DETECTION_ENABLED attribute    to NIWLANA_VAL_FALSE. This attribute is valid only if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM and    the NIWLANA_CHANNEL_BANDWIDTH attribute to 2 MHz, 4 MHz, 8 MHz or 16 MHz. 
        ///    The default value is NIWLANA_VAL_80211AH_PREAMBLE_TYPE_SHORT. 
        ///    Get Function: niWLANA_Get80211ahPreambleType
        ///    Set Function: niWLANA_Set80211ahPreambleType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int Set_80211ahPreambleType(string channel, int value)
        {
            return SetInt(niWLANAProperties._80211ahPreambleType, channel, value);
        }

        /// <summary>
        ///Specifies the packet preamble type when you set the NIWLANA_OFDM_DEMOD_80211AH_PREAMBLE_DETECTION_ENABLED attribute    to NIWLANA_VAL_FALSE. This attribute is valid only if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM and    the NIWLANA_CHANNEL_BANDWIDTH attribute to 2 MHz, 4 MHz, 8 MHz or 16 MHz. 
        ///    The default value is NIWLANA_VAL_80211AH_PREAMBLE_TYPE_SHORT. 
        ///    Get Function: niWLANA_Get80211ahPreambleType
        ///    Set Function: niWLANA_Set80211ahPreambleType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int Get_80211ahPreambleType(string channel, out int value)
        {
            return GetInt(niWLANAProperties._80211ahPreambleType, channel, out value);
        }


        /// <summary>
        /// Specifies whether to enable the ACP measurement.
        /// The default value is NIWLANA_VAL_FALSE.
        /// 
        /// </summary>
        ///<param name = "channel">
        ///</param>
        ///<param name = "value">
        /// Specifies whether to enable demodulation-based measurements for 802.11a-1999, 802.11g-2003 OFDM, 802.11g-2003 DSSS-OFDM, 802.11j-2004, 802.11n-2009, or 802.11p-2010 signals. The default value is NIWLANA_VAL_FALSE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetACPEnabled
        /// int32 __stdcall niWLANA_SetACPEnabled (niWLANAnalysisSession session, 
        ///     char channelString[], 
        ///     int32 value);
        /// Purpose
        /// Specifies whether to enable the ACP measurement.
        /// The default value is NIWLANA_VAL_FALSE.
        /// 
        ///</returns>
        public int SetAcpEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.AcpEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable the ACP measurement.
        ///       The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetACPEnabled
        ///    Set Function: niWLANA_SetACPEnabled
        /// 
        /// </summary>
        ///<param name = "channel">
        ///</param>
        ///<param name = "value">
        /// Specifies whether to enable demodulation-based measurements for 802.11a-1999, 802.11g-2003 OFDM, 802.11g-2003 DSSS-OFDM, 802.11j-2004, 802.11n-2009, or 802.11p-2010 signals. The default value is NIWLANA_VAL_FALSE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetACPEnabled
        /// int32 __stdcall niWLANA_SetACPEnabled (niWLANAnalysisSession session, 
        ///     char channelString[], 
        ///     int32 value);
        /// Purpose
        /// Specifies whether to enable the ACP measurement.
        /// The default value is NIWLANA_VAL_FALSE.
        /// 
        ///</returns>
        public int GetAcpEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.AcpEnabled, channel, out value);
        }


        /// <summary>
        /// Specifies the number of iterations over which the toolkit averages the power spectrum.
        /// The default value is 1. Valid values are 1 to 1,000, inclusive.
        /// 
        /// </summary>
        ///<param name = "channel">
        ///</param>
        ///<param name = "value">
        /// Specifies the number of iterations over which the toolkit averages DSSS demodulation-based measurements. The default value is 1. Valid values are 1 to 1,000, inclusive.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetACPNumberOfAverages
        /// int32 __stdcall niWLANA_SetACPNumberOfAverages (niWLANAnalysisSession session, 
        ///     char channelString[], 
        ///     int32 value);
        /// Purpose
        /// Specifies the number of iterations over which the toolkit averages the power spectrum.
        /// The default value is 1. Valid values are 1 to 1,000, inclusive.
        /// 
        ///</returns>

        public int SetAcpNumberOfAverages(string channel, int value)
        {
            return SetInt(niWLANAProperties.AcpNumberOfAverages, channel, value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages the power spectrum.
        ///       The default value is 1. Valid values are 1 to 1,000, inclusive.
        ///    Get Function: niWLANA_GetACPNumberOfAverages
        ///    Set Function: niWLANA_SetACPNumberOfAverages
        /// 
        /// </summary>
        ///<param name = "channel">
        ///</param>
        ///<param name = "value">
        /// Specifies the number of iterations over which the toolkit averages DSSS demodulation-based measurements. The default value is 1. Valid values are 1 to 1,000, inclusive.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetACPNumberOfAverages
        /// int32 __stdcall niWLANA_SetACPNumberOfAverages (niWLANAnalysisSession session, 
        ///     char channelString[], 
        ///     int32 value);
        /// Purpose
        /// Specifies the number of iterations over which the toolkit averages the power spectrum.
        /// The default value is 1. Valid values are 1 to 1,000, inclusive.
        /// 
        ///</returns>
        public int GetAcpNumberOfAverages(string channel, out int value)
        {
            return GetInt(niWLANAProperties.AcpNumberOfAverages, channel, out value);
        }


        /// <summary>
        ///Specifies whether to enable the ACP trace.
        ///       The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetACPTraceEnabled
        ///    Set Function: niWLANA_SetACPTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetAcpTraceEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.AcpTraceEnabled, channel, value);
        }


        /// <summary>
        ///Specifies whether to enable the ACP trace.
        ///       The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetACPTraceEnabled
        ///    Set Function: niWLANA_SetACPTraceEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAcpTraceEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.AcpTraceEnabled, channel, out value);
        }



        /// <summary>
        /// Specifies the number of offset channels to be measured on either side of the reference channel.
        /// The NIWLANA_CHANNEL_BANDWIDTH attribute specifies the integration bandwidth of the all the adjacent channels.
        /// The default value is 1.
        /// 
        /// </summary>
        ///<param name = "channel">
        ///</param>
        ///<param name = "value">
        /// Specifies the number of iterations over which the toolkit averages DSSS demodulation-based measurements. The default value is 1. Valid values are 1 to 1,000, inclusive.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetACPNumberOfOffsets
        /// int32 __stdcall niWLANA_SetACPNumberOfOffsets (niWLANAnalysisSession session, 
        ///     char channelString[], 
        ///     int32 value);
        /// Purpose
        /// Specifies the number of offset channels to be measured on either side of the reference channel.
        /// The NIWLANA_CHANNEL_BANDWIDTH attribute specifies the integration bandwidth of the all the adjacent channels.
        /// The default value is 1.
        /// 
        ///</returns>
        public int SetAcpNumberOfOffsets(string channel, int value)
        {
            return SetInt(niWLANAProperties.AcpNumberOfOffsets, channel, value);
        }


        /// <summary>
        ///Specifies the number of offset channels to be measured on either side of the reference channel.
        ///    The NIWLANA_CHANNEL_BANDWIDTH attribute specifies the integration bandwidth of the all the adjacent channels. 
        ///      The default value is 1.
        ///    Get Function: niWLANA_GetACPNumberOfOffsets
        ///    Set Function: niWLANA_SetACPNumberOfOffsets
        /// 
        /// </summary>
        ///<param name = "channel">
        ///</param>
        ///<param name = "value">
        /// Specifies the number of iterations over which the toolkit averages DSSS demodulation-based measurements. The default value is 1. Valid values are 1 to 1,000, inclusive.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_SetACPNumberOfOffsets
        /// int32 __stdcall niWLANA_SetACPNumberOfOffsets (niWLANAnalysisSession session, 
        ///     char channelString[], 
        ///     int32 value);
        /// Purpose
        /// Specifies the number of offset channels to be measured on either side of the reference channel.
        /// The NIWLANA_CHANNEL_BANDWIDTH attribute specifies the integration bandwidth of the all the adjacent channels.
        /// The default value is 1.
        /// 
        ///</returns>
        public int GetAcpNumberOfOffsets(string channel, out int value)
        {
            return GetInt(niWLANAProperties.AcpNumberOfOffsets, channel, out value);
        }




        /// <summary>
        /// Returns the reference channel power in the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute. This value is expressed in dBm.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM,
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM 
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS is set to 1)
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAcpReferenceChannelPower(string channel, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAcpReferenceChannelPower, channel, out value);
        }




        /// <summary>
        /// Returns the power in the lower offset channels relative to the power in the reference channel measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute. The number of offset channels is specified by the NIWLANA_ACP_NUMBER_OF_OFFSETS attribute. The elements in the array are in the order of increasing frequency separation with respect to the reference channel. This value is expressed in dBc.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM 
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS is set to 1)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "dataArray">
        /// Returns the power in the lower offset channels, in dBc, measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the data array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the dataArray parameter. If dataArray is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetACPLowerRelativePower
        /// int32 __stdcall niWLANA_GetACPLowerRelativePower (niWLANAnalysisSession session, 
        ///     char channelString[], 
        ///     float64 dataArray[], 
        ///     int32 dataArraySize, 
        ///     int32 *actualNumDataArrayElements);
        /// Purpose
        /// Returns the power in the lower offset channels, in dBc, relative to the power in the reference channel measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute. The number of offset channels is specified by the NIWLANA_ACP_NUMBER_OF_OFFSETS attribute. The elements in the array are in the order of increasing frequency separation with respect to the reference channel.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AGJP_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM,
        ///                     ""
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM 
        ///                     "segmentx/channely"
        /// 
        ///</returns>
        public int GetAcpLowerRelativePower(string channelString, double[] dataArray, int dataArraySize, out int actualArraySize)
        {
            return GetVectorDouble(channelString, niWLANAProperties.AcpLowerRelativePower, dataArray, dataArraySize, out actualArraySize);

        }



        /// <summary>
        /// Returns the power in the lower offset channels measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute. The number of offset channels is specified by the NIWLANA_ACP_NUMBER_OF_OFFSETS attribute. The elements in the array are in the order of increasing frequency separation with respect to the reference channel. This value is expressed in dBm.
        /// You must use the following active channel string formats to query this function.
        ///                                                       NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM 
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS is set to 1)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "dataArray">
        /// Returns the power in the lower offset channels, in dBm, measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the data array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the dataArray parameter. If dataArray is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetACPLowerAbsolutePower
        /// int32 __stdcall niWLANA_GetACPLowerAbsolutePower (niWLANAnalysisSession session, 
        ///     char channelString[], 
        ///     float64 dataArray[], 
        ///     int32 dataArraySize, 
        ///     int32 *actualNumDataArrayElements);
        /// Purpose
        /// Returns the power in the lower offset channels, in dBm, measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute. The number of offset channels is specified by the NIWLANA_ACP_NUMBER_OF_OFFSETS attribute. The elements in the array are in the order of increasing frequency separation with respect to the reference channel.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AGJP_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM,
        ///                     ""
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM 
        ///                     "segmentx/channely"
        /// 
        ///</returns>
        public int GetAcpLowerAbsolutePower(string channelString, double[] dataArray, int dataArraySize, out int actualArraySize)
        {
            return GetVectorDouble(channelString, niWLANAProperties.AcpLowerAbsolutePower, dataArray, dataArraySize, out actualArraySize);
        }



        /// <summary>
        /// Returns the power in the upper offset channels measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute. The number of offset channels is specified by the NIWLANA_ACP_NUMBER_OF_OFFSETS attribute. The elements in the array are in the order of increasing frequency separation with respect to the reference channel. This value is expressed in dBc.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM 
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS is set to 1)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "dataArray">
        /// Returns the power in the upper offset channels, in dBc, measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute. 
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the data array. If the array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the output array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the dataArray parameter. If dataArray is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetACPUpperRelativePower
        /// int32 __stdcall niWLANA_GetACPUpperRelativePower (niWLANAnalysisSession session, 
        ///     char channelString[], 
        ///     float64 dataArray[], 
        ///     int32 dataArraySize, 
        ///     int32 *actualNumDataArrayElements);
        /// Purpose
        /// Returns the power in the upper offset channels, in dBc, measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute. The number of offset channels is specified by the NIWLANA_ACP_NUMBER_OF_OFFSETS attribute. The elements in the array are in the order of increasing frequency separation with respect to the reference channel.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AGJP_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM,
        ///                     ""
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM 
        ///                     "segmentx/channely"
        /// 
        ///</returns>
        public int GetAcpUpperRelativePower(string channelString, double[] dataArray, int dataArraySize, out int actualArraySize)
        {
            return GetVectorDouble(channelString, niWLANAProperties.AcpUpperRelativePower, dataArray, dataArraySize, out actualArraySize);
        }


        /// <summary>
        /// Returns the power in the upper offset channels measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute. The number of offset channels is specified by the NIWLANA_ACP_NUMBER_OF_OFFSETS attribute. This value is expressed in dBm. The elements in the array are in the order of increasing frequency separation with respect to the reference channel.
        /// You must use the following active channel string formats to query this function.
        ///                                                       NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM 
        ///                     "[segmentx/]channely" ("segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS is set to 1)
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "dataArray">
        /// Returns the power in the upper offset channels, in dBm, measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the data array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the dataArray parameter. If dataArray is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetACPUpperAbsolutePower
        /// int32 __stdcall niWLANA_GetACPUpperAbsolutePower (niWLANAnalysisSession session, 
        ///     char channelString[], 
        ///     float64 dataArray[], 
        ///     int32 dataArraySize, 
        ///     int32 *actualNumDataArrayElements);
        /// Purpose
        /// Returns the power in the upper offset channels, in dBm, measured over the bandwidth specified by the NIWLANA_CHANNEL_BANDWIDTH attribute. The number of offset channels is specified by the NIWLANA_ACP_NUMBER_OF_OFFSETS attribute. The elements in the array are in the order of increasing frequency separation with respect to the reference channel.
        /// You must use the following active channel string formats to query this function.
        ///                                                      NIWLANA_STANDARD attribute
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AGJP_OFDM, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, NIWLANG_VAL_STANDARD_80211G_DSSS_OFDM,
        ///                     ""
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANG_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM 
        ///                     "segmentx/channely"
        /// 
        ///</returns>
        public int GetAcpUpperAbsolutePower(string channelString, double[] dataArray, int dataArraySize, out int actualArraySize)
        {
            return GetVectorDouble(channelString, niWLANAProperties.AcpUpperAbsolutePower, dataArray, dataArraySize, out actualArraySize);
        }


        /// <summary>
        ///Specifies the type of the guard interval (Cyclic Prefix) in an OFDM symbol. If you set    the NIWLANA_DSSS_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the NIWLANA_GUARD_INTERVAL_TYPE attribute    for performing OFDM demodulation measurements.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_FOUR is 0.8 &#181;s,     and the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_EIGHT is 0.4 &#181;s. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_FOUR is 0.8 &#181;s    and the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_EIGHT is 0.4 &#181;s. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and the NIWLANA_CHANNEL_BANDWIDTH to 6 MHz or 7 MHz,    the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_FOUR is 6 &#181;s, and    the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_EIGHT is 3 &#181;s. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and the NIWLANA_CHANNEL_BANDWIDTH to 8 MHz,    the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_FOUR is 4.5 &#181;s,    and the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_EIGHT is 2.25 &#181;s. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM,    the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_FOUR is 3.2 &#181;s,    the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_EIGHT is 1.6 &#181;s and the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_SIXTEEN is 0.8 &#181;s. 
        ///    Get Function: niWLANA_GetGuardIntervalType
        ///    Set Function: niWLANA_SetGuardIntervalType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetGuardIntervalType(string channel, int value)
        {
            return SetInt(niWLANAProperties.GuardIntervalType, channel, value);
        }



        /// <summary>
        ///Specifies the type of the guard interval (Cyclic Prefix) in an OFDM symbol. If you set    the NIWLANA_DSSS_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the NIWLANA_GUARD_INTERVAL_TYPE attribute    for performing OFDM demodulation measurements.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_FOUR is 0.8 &#181;s,     and the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_EIGHT is 0.4 &#181;s. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_FOUR is 0.8 &#181;s    and the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_EIGHT is 0.4 &#181;s. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and the NIWLANA_CHANNEL_BANDWIDTH to 6 MHz or 7 MHz,    the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_FOUR is 6 &#181;s, and    the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_EIGHT is 3 &#181;s. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, and the NIWLANA_CHANNEL_BANDWIDTH to 8 MHz,    the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_FOUR is 4.5 &#181;s,    and the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_EIGHT is 2.25 &#181;s. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM,    the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_FOUR is 3.2 &#181;s,    the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_EIGHT is 1.6 &#181;s and the NIWLANA_VAL_GUARD_INTERVAL_TYPE_ONE_BY_SIXTEEN is 0.8 &#181;s. 
        ///    Get Function: niWLANA_GetGuardIntervalType
        ///    Set Function: niWLANA_SetGuardIntervalType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetGuardIntervalType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.GuardIntervalType, channel, out value);
        }





        /// <summary>
        ///Indicates whether the cyclic redundancy check (CRC) has passed for the S1G-SIG/SIG-A field.
        ///    Get Function: niWLANA_GetOFDMDemodS1GSIGCRCPassed
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodS1gSigCrcPassed(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodS1gSigCrcPassed, channel, out value);
        }


        /// <summary>
        ///Specifies the preamble type of packet when you set the NIWLANA_OFDM_DEMOD_80211AH_PREAMBLE_DETECTION_ENABLED attribute    to NIWLANA_VAL_FALSE. This attribute is valid only when you set the NIWLANA_DETECTED_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM  and NIWLANA_CHANNEL_BANDWIDTH attribute to either 2 MHz, 4 MHz, 8 MHz or 16 MHz. 
        ///    The default value is NIWLANA_VAL_80211AH_PREAMBLE_TYPE_SHORT.   Get Function: niWLANA_GetOFDMDemod80211ahPreambleType
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemod80211ahPreambleType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemod80211ahPreambleType, channel, out value);
        }


        /// <summary>
        ///Returns the value of the Length field as decoded from SIG/SIG-A field in 802.11ah signals. 
        ///    Get Function: niWLANA_GetOFDMDemodS1GSIGLength
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodS1gSigLength(string channel, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodS1gSigLength, channel, out value);
        }

        /// <summary>
        ///Specifies the type of the guard interval (Cyclic Prefix) in an OFDM Symbol. If you set    the NIWLANA_DSSS_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_FALSE, the toolkit uses the NIWLANA_GUARD_INTERVAL_TYPE attribute    for performing OFDM demodulation measurements.
        ///    Get Function: niWLANA_GetOfdmGuardIntervalType
        ///    </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodGuardIntervalType(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmGuardIntervalType, channel, out value);
        }

        /// <summary>
        /// Calculates the carrier frequency of 802.11a/b/g/p/n channels according to sections  16.4.6, 17.4.6, 18.3.8.4 and 20.3.15 of IEEE Std 802.11-2012.
        /// 
        /// </summary>
        ///<param name = "channelStartingFrequency">
        /// Specifies the starting frequency of the frequency band.
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelBandwidth">
        /// Specifies the channel bandwidth used for analyzing the signal. You can choose a 5 MHz, 10 MHz, 20 MHz, or 40 MHz channel.
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelNumber">
        /// Specifies the offset of the center frequency, in increments of 5 MHz, above the starting frequency of the channel. 
        /// 
        ///</param>
        ///<param name = "secondaryFactor">
        /// Specifies whether the secondary channel is above or below the primary channel when you set the
        /// channelBandwidth parameter to 40 MHz.
        /// The toolkit creates a 40 MHz channel by combining the primary channel and the secondary channel, each with a 20 MHz bandwidth.
        /// The value of -1 indicates that the secondary channel is below the primary channel whereas the value of +1 indicates that the secondary channel is above the primary channel.
        /// Valid values are -1 and +1.
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Returns the carrier frequency. The function calculates the carrier frequency using the following equation: Carrier frequency (Hz) = channel starting frequency (Hz) + (channelNumber * 5 MHz). 
        /// When you set the channelBandwidth parameter to 40 MHz, the channelNumber parameter is the primary channel number. The function calculates the carrier frequency using the following equation:
        /// Carrier frequency (Hz) = channel starting frequency (Hz) + (channel number * 5 MHz) + (Secondary factor  * 20 MHz)
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_ChannelNumberToCarrierFrequency80211abgjpn
        /// int32 __stdcall niWLANA_ChannelNumberToCarrierFrequency80211abgjpn (float64 channelStartingFrequency, 
        ///     float64 channelBandwidth, 
        ///     int32 channelNumber, 
        ///     int32 secondaryFactor, 
        ///     float64 *carrierFrequency);
        /// Purpose
        /// Calculates the carrier frequency of 802.11a/b/g/p/n channels according to sections  16.4.6, 17.4.6, 18.3.8.4 and 20.3.15 of IEEE Std 802.11-2012.
        /// 
        ///</returns>
        public int ChannelNumberToCarrierFrequency80211abgjpn(double channelStartingFrequency, double channelBandwidth, int channelNumber, int secondaryFactor, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANA_ChannelNumberToCarrierFrequency80211abgjpn(channelStartingFrequency, channelBandwidth, channelNumber, secondaryFactor,
                  out carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Calculates the carrier frequency of 802.11ac channels according to section 22.3.14 of IEEE Std 802.11ac-2013.
        /// 
        /// </summary>
        ///<param name = "channelStartingFrequencyHz">
        /// Specifies the start frequency of the frequency band. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelNumber">
        /// Specifies the offset of the center frequency, in increments of 5 MHz, above the starting frequency of the channel. 
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Returns the carrier frequency. The function calculates the carrier frequency using the following formula:
        /// Carrier frequency (Hz) = channel starting frequency (Hz) + (channel number * 5 MHz)
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_ChannelNumberToCarrierFrequency80211ac
        /// int32 __stdcall niWLANA_ChannelNumberToCarrierFrequency80211ac (int32 frequencyBand,
        ///     float64 channelBandwidth,
        ///     int32 channelNumber,
        ///     int32 secondaryFactor, 
        ///     float64 channelStartingFactor,
        ///     float64 *carrierFrequency);
        /// Purpose
        /// Calculates the carrier frequency of 802.11ac channels according to section 22.3.14 of IEEE Std 802.11ac-2013.
        /// 
        ///</returns>
        public int ChannelNumberToCarrierFrequency80211ac(double channelStartingFrequencyHz, int channelNumber, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANA_ChannelNumberToCarrierFrequency80211ac(channelStartingFrequencyHz, channelNumber,
                  out carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Calculates the carrier frequency of 802.11ah channels using input parameters according to section 22.3.13 of IEEE P802.11ah/D1.3.
        /// 
        /// </summary>
        ///<param name = "channelStartingFrequencyHz">
        /// Specifies the start frequency of the frequency band.
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelNumber">
        /// Specifies the offset of the center frequency, in increments of 0.5 MHz, above the starting frequency of the channel. 
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Returns the carrier frequency. The function calculates the carrier frequency using the following formula:
        /// Carrier frequency (Hz) = channel starting frequency (Hz) + (channel number * 0.5 MHz)
        ///  This value is expressed in Hz.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_ChannelNumberToCarrierFrequency80211ah
        /// int32 __stdcall niWLANA_ChannelNumberToCarrierFrequency80211ah (float64 channelStartingFrequency, 
        ///     int32 channelNumber, 
        ///     float64 *carrierFrequency);
        /// Purpose
        /// Calculates the carrier frequency of 802.11ah channels using input parameters according to section 22.3.13 of IEEE P802.11ah/D1.3.
        /// 
        ///</returns>
        public int ChannelNumberToCarrierFrequency80211ah(double channelStartingFrequencyHz, int channelNumber, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANA_ChannelNumberToCarrierFrequency80211ah(channelStartingFrequencyHz, channelNumber,
                  out carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }



        /// <summary>
        /// Returns the power spectrum, absolute channel power trace and relative channel power trace. 
        /// To use this function, you must set the NIWLANA_ACP_TRACE_ENABLED attribute and either the NIWLANA_SPECTRAL_MEASUREMENTS_ALL_ENABLED or NIWLANA_ACP_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                     NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"[segmentx]/channely"
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "f0">
        /// Indicates the start frequency of the spectrum. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "df">
        /// Indicates the frequency intervals between data points in the spectrum.This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "y">
        /// Indicates power spectrum values in dBm.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the size of the Y array.
        /// 
        ///</param>
        ///<param name = "actualArraySize">
        /// Returns the number of elements in the data array. If the Y array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the Y array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetACPTrace
        /// int32 __stdcall niWLANA_GetACPTrace (niWLANA session,
        ///     float64 *f0, 
        ///     float64 *df,
        ///     float64 Y[],
        ///     int32 dataArraySize,
        ///     int32 *actualDataArraySize);
        /// Purpose
        /// Returns the power spectrum, absolute channel power trace and relative channel power trace. 
        /// To use this function, you must set the NIWLANA_ACP_TRACE_ENABLED attribute and either the NIWLANA_SPECTRAL_MEASUREMENTS_ALL_ENABLED or NIWLANA_ACP_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// You must use the following active channel string formats to query this function.
        ///                                     NIWLANA_STANDARD attribute setting
        ///                     Active channel string syntax
        ///                      NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS, NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM
        ///                     "" (empty string)
        ///                                     NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM
        ///                     "channelx"
        ///                                     NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM , NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"[segmentx]/channely"
        /// 
        ///</returns>
        public int GetACPTrace(string channelString, out double f0, out double df, double[] y, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetACPTrace(Handle, channelString,
                  out f0,
                  out df, y, dataArraySize,
                  out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///Specifies whether to enable automatic detection of preamble type of 80211ah burst. If this attribute is disabled, you must    set the NIWLANA_80211AH_PREAMBLE_TYPE attribute when the NIWLANA_CHANNEL_BANDWIDTH attribute is set to 2MHz, 4MHz, 8MHz or 16MHz.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemod80211ahPreambleDetectionEnabled
        ///    Set Function: niWLANA_SetOFDMDemod80211ahPreambleDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemod80211ahPreambleDetectionEnabled(string channel, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemod80211ahPreambleDetectionEnabled, channel, value);
        }

        /// <summary>
        ///Specifies whether to enable automatic detection of preamble type of 80211ah burst. If this attribute is disabled, you must    set the NIWLANA_80211AH_PREAMBLE_TYPE attribute when the NIWLANA_CHANNEL_BANDWIDTH attribute is set to 2MHz, 4MHz, 8MHz or 16MHz.
        ///    The default value is NIWLANA_VAL_TRUE.
        ///    Get Function: niWLANA_GetOFDMDemod80211ahPreambleDetectionEnabled
        ///    Set Function: niWLANA_SetOFDMDemod80211ahPreambleDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channel"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemod80211ahPreambleDetectionEnabled(string channel, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemod80211ahPreambleDetectionEnabled, channel, out value);
        }

        #endregion

        private int SetInt(niWLANAProperties propertyId, string repeatedCapabilityOrChannel, int value)
        {
            return TestForError(PInvoke.niWLANA_SetScalarAttributeI32(Handle, repeatedCapabilityOrChannel, propertyId, value));
        }

        private int SetInt(niWLANAProperties propertyId, int value)
        {
            return this.SetInt(propertyId, "", value);
        }

        private int GetInt(niWLANAProperties propertyId, string repeatedCapabilityOrChannel, out int value)
        {
            return TestForError(PInvoke.niWLANA_GetScalarAttributeI32(Handle, repeatedCapabilityOrChannel, propertyId, out value));
        }

        private int GetInt(niWLANAProperties propertyId, out int value)
        {
            return this.GetInt(propertyId, "", out value);
        }

        private int SetDouble(niWLANAProperties propertyId, string repeatedCapabilityOrChannel, double value)
        {
            return TestForError(PInvoke.niWLANA_SetScalarAttributeF64(Handle, repeatedCapabilityOrChannel, propertyId, value));
        }

        private int SetDouble(niWLANAProperties propertyId, double value)
        {
            return this.SetDouble(propertyId, "", value);
        }

        private int GetDouble(niWLANAProperties propertyId, string repeatedCapabilityOrChannel, out double value)
        {
            return TestForError(PInvoke.niWLANA_GetScalarAttributeF64(Handle, repeatedCapabilityOrChannel, propertyId, out value));

        }

        private int GetDouble(niWLANAProperties propertyId, out double value)
        {
            return this.GetDouble(propertyId, "", out value);
        }

        private int SetVectorDouble(string channelString, niWLANAProperties propertyId, double[] data, int dataSize)
        {
            return TestForError(PInvoke.niWLANA_SetVectorAttributeF64(Handle, channelString, propertyId, data, dataSize));
        }

        private int GetVectorDouble(string channelString, niWLANAProperties propertyId, double[] data, int dataSize, out int actualNumDataArrayElements)
        {
            return TestForError(PInvoke.niWLANA_GetVectorAttributeF64(Handle, channelString, propertyId, data, dataSize, out actualNumDataArrayElements));
        }

        #region 15.0

        /// <summary>
        /// Specifies whether the format of the incoming OFDM signal is non-high throughput (HT). This attribute is valid only if the NIWLANA_STANDARD attribute is set to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AF_MIMOOFDM. A non-HT format signal has only L-LTF, L-STF, and L-SIG symbols in the preamble, which are similar to 802.11n, 802.11ac, or 802.11af signals with the same bandwidth. The payload is modulated in the same manner as an 802.11a signal with a 20 MHz bandwidth. The payload is repeated with appropriate tone rotation to fill the channel bandwidth. The default value is NIWLANA_VAL_OFDM_NON_HT_MODULATION_MODE_OFF. 
        /// 
        /// Get Function: niWLANA_GetNonHTModulationMode
        /// Set Function: niWLANA_SetNonHTModulationMode
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNonHTModulationMode(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmNonHTModulationMode, channelString, value);
        }


        /// <summary>
        /// Specifies whether the format of the incoming OFDM signal is non-high throughput (HT). This attribute is valid only if the NIWLANA_STANDARD attribute is set to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AF_MIMOOFDM. A non-HT format signal has only L-LTF, L-STF, and L-SIG symbols in the preamble, which are similar to 802.11n, 802.11ac, or 802.11af signals with the same bandwidth. The payload is modulated in the same manner as an 802.11a signal with a 20 MHz bandwidth. The payload is repeated with appropriate tone rotation to fill the channel bandwidth. The default value is NIWLANA_VAL_OFDM_NON_HT_MODULATION_MODE_OFF. 
        /// 
        /// Get Function: niWLANA_GetNonHTModulationMode
        /// Set Function: niWLANA_SetNonHTModulationMode
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNonHTModulationMode(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmNonHTModulationMode, channelString, out value);
        }


        /// <summary>
        ///Specifies whether to enable the European Telecommunications Standards Institute (ETSI) in-band    emission (IBE) measurement. This measurement computes the PSD of the 802.11af signal, and applies limits to check for unwanted emissions, as    specified in ETSI EN 301 598 V1.1.1 (2014-04) by ETSI. 
        ///     The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetETSIIBEEnabled
        ///    Set Function: niWLANA_SetETSIIBEEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetETSIIBEEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.ETSIIBEEnabled, channelString, value);
        }



        /// <summary>
        ///Specifies whether to enable the European Telecommunications Standards Institute (ETSI) in-band    emission (IBE) measurement. This measurement computes the PSD of the 802.11af signal, and applies limits to check for unwanted emissions, as    specified in ETSI EN 301 598 V1.1.1 (2014-04) by ETSI. 
        ///     The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetETSIIBEEnabled
        ///    Set Function: niWLANA_SetETSIIBEEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetETSIIBEEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ETSIIBEEnabled, channelString, out value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages the PSD for European Telecommunications Standards    Institute (ETSI) in-band emission measurements. 
        ///    The default value is 1. Valid values are 1 to 1,000, inclusive. 
        ///    Get Function: niWLANA_GetETSIIBENumberOfAverages
        ///    Set Function: niWLANA_SetETSIIBENumberOfAverages
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetETSIIBENumberOfAverages(string channelString, int value)
        {
            return SetInt(niWLANAProperties.ETSIIBENumberOfAverages, channelString, value);
        }


        /// <summary>
        ///Specifies the number of iterations over which the toolkit averages the PSD for European Telecommunications Standards    Institute (ETSI) in-band emission measurements. 
        ///    The default value is 1. Valid values are 1 to 1,000, inclusive. 
        ///    Get Function: niWLANA_GetETSIIBENumberOfAverages
        ///    Set Function: niWLANA_SetETSIIBENumberOfAverages
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetETSIIBENumberOfAverages(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ETSIIBENumberOfAverages, channelString, out value);
        }


        /// <summary>
        ///Specifies whether to enable the ETSI PSD and in-band emission limits traces. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetETSIIBETraceEnabled
        ///    Set Function: niWLANA_SetETSIIBETraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetETSIIBETraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.ETSIIBETraceEnabled, channelString, value);
        }



        /// <summary>
        ///Specifies whether to enable the ETSI PSD and in-band emission limits traces. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetETSIIBETraceEnabled
        ///    Set Function: niWLANA_SetETSIIBETraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetETSIIBETraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ETSIIBETraceEnabled, channelString, out value);
        }


        /// <summary>
        ///Specifies the number of adjacent channels to be considered for the European Telecommunications    Standards Institute (ETSI) in-band emission measurements on either    side of the transmission channel. 
        ///    Get Function: niWLANA_GetETSIIBENumberOfOffsets
        ///    Set Function: niWLANA_SetETSIIBENumberOfOffsets
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetETSIIBENumberOfOffsets(string channelString, int value)
        {
            return SetInt(niWLANAProperties.ETSIIBENumberOfOffset, channelString, value);
        }



        /// <summary>
        ///Specifies the number of adjacent channels to be considered for the European Telecommunications    Standards Institute (ETSI) in-band emission measurements on either    side of the transmission channel. 
        ///    Get Function: niWLANA_GetETSIIBENumberOfOffsets
        ///    Set Function: niWLANA_SetETSIIBENumberOfOffsets
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetETSIIBENumberOfOffsets(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ETSIIBENumberOfOffset, channelString, out value);
        }


        /// <summary>
        ///Specifies the RF power averaged over the time period of a transmission burst from the device    under test (DUT). This value is expressed in dBm. This value is used to normalize the acquired spectrum data before    the PSD computation, as specified in section 5.3.3 of ETSI EN 301 598 V1.1.1 (2014-04). 
        ///    Get Function: niWLANA_GetETSIIBEDUTAverageOutputPower
        ///    Set Function: niWLANA_SetETSIIBEDUTAverageOutputPower
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetETSIIBEDUTAverageOutputPower(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.ETSIIBEDUTAverageOutputPower, channelString, value);
        }


        /// <summary>
        ///Specifies the RF power averaged over the time period of a transmission burst from the device    under test (DUT). This value is expressed in dBm. This value is used to normalize the acquired spectrum data before    the PSD computation, as specified in section 5.3.3 of ETSI EN 301 598 V1.1.1 (2014-04). 
        ///    Get Function: niWLANA_GetETSIIBEDUTAverageOutputPower
        ///    Set Function: niWLANA_SetETSIIBEDUTAverageOutputPower
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetETSIIBEDUTAverageOutputPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ETSIIBEDUTAverageOutputPower, channelString, out value);
        }


        /// <summary>
        ///Specifies the value that the toolkit uses as the limit on the PSD over    any 100 kHz band in the transmit channel for European Telecommunications Standards Institute (ETSI) in-band emission measurement, as    specified in section 4.2.3 of ETSI EN 301 598 V1.1.1 (2014-04).  This value is expressed in dBm. 
        ///    Get Function: niWLANA_GetETSIIBETransmitChannelPSDLimit
        ///    Set Function: niWLANA_SetETSIIBETransmitChannelPSDLimit
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetETSIIBETransmitChannelPSDLimit(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.ETSIIBETransmitChannelPSDLimit, channelString, value);
        }



        /// <summary>
        ///Specifies the value that the toolkit uses as the limit on the PSD over    any 100 kHz band in the transmit channel for European Telecommunications Standards Institute (ETSI) in-band emission measurement, as    specified in section 4.2.3 of ETSI EN 301 598 V1.1.1 (2014-04).  This value is expressed in dBm. 
        ///    Get Function: niWLANA_GetETSIIBETransmitChannelPSDLimit
        ///    Set Function: niWLANA_SetETSIIBETransmitChannelPSDLimit
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetETSIIBETransmitChannelPSDLimit(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ETSIIBETransmitChannelPSDLimit, channelString, out value);
        }


        /// <summary>
        ///Specifies the emission class with which the DUT complies. This value defines    the adjacent channel leakage ratio (ACLR) limits in the adjacent channels for European Telecommunications    Standards Institute (ETSI) in-band emission measurements, as specified in section 4.2.4.2 of    ETSI EN 301 598 V1.1.1 (2014-04). 
        ///    The default value is NIWLANA_VAL_ETSI_DEVICE_EMISSION_CLASS_1.
        ///    Get Function: niWLANA_GetETSIIBEDeviceEmissionClass
        ///    Set Function: niWLANA_SetETSIIBEDeviceEmissionClass
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetETSIIBEDeviceEmissionClass(string channelString, int value)
        {
            return SetInt(niWLANAProperties.ETSIIBEDeviceEmissionClass, channelString, value);
        }


        /// <summary>
        ///Specifies the emission class with which the DUT complies. This value defines    the adjacent channel leakage ratio (ACLR) limits in the adjacent channels for European Telecommunications    Standards Institute (ETSI) in-band emission measurements, as specified in section 4.2.4.2 of    ETSI EN 301 598 V1.1.1 (2014-04). 
        ///    The default value is NIWLANA_VAL_ETSI_DEVICE_EMISSION_CLASS_1.
        ///    Get Function: niWLANA_GetETSIIBEDeviceEmissionClass
        ///    Set Function: niWLANA_SetETSIIBEDeviceEmissionClass
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetETSIIBEDeviceEmissionClass(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ETSIIBEDeviceEmissionClass, channelString, out value);
        }

        /// <summary>
        ///Specifies the array of lower limits on the difference between the adjacent channel leakage ratio (ACLR) limit value and the    actual ACLR value for the corresponding transmit channel and the adjacent channel being considered. You must set the values for all    the adjacent channels with the starting index for the lowest-frequency channel. The size of this array    must be twice the value you specify in the NIWLANA_ETSI_IBE_NUMBER_OF_OFFSETS attribute. 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <returns></returns>
        public int SetETSIIBEDeltaACLR(string channelString, double[] dataArray, int dataArraySize)
        {
            return SetVectorDouble(channelString, niWLANAProperties.ETSIIBEDeltaACLR, dataArray, dataArraySize);
        }

        /// <summary>
        ///Specifies the array of lower limits on the difference between the adjacent channel leakage ratio (ACLR) limit value and the    actual ACLR value for the corresponding transmit channel and the adjacent channel being considered. You must set the values for all    the adjacent channels with the starting index for the lowest-frequency channel. The size of this array    must be twice the value you specify in the NIWLANA_ETSI_IBE_NUMBER_OF_OFFSETS attribute. 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetETSIIBEDeltaACLR(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ETSIIBEDeltaACLR, dataArray, dataArraySize, out actualNumDataArrayElements);
        }

        /// <summary>
        /// Returns the lowest margin, which is the minimum difference between the in-band emission limits and the measured power spectral density. If the test fails, the NIWLANA_RESULT_ETSI_IBE_MARGIN attribute returns a negative value. 
        /// 
        /// Get Function: niWLANA_GetETSIIBEMargin
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetETSIIBEMargin(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultETSIIBEMargin, channelString, out value);
        }

        /// <summary>
        /// Returns the array of the lowest margin, in dB, which is the minimum difference between the in-band emission limits and the measured power spectral density, per channel. If the test fails for a channel, the ETSI IBE margin value for the corresponding channel is negative. The elements in the array are in the order of increasing frequency with the starting index corresponding to the channel lowest in frequency. The size of this array is 2 * N + 1, where N is the value you specify in the NIWLANA_ETSI_IBE_NUMBER_OF_OFFSETS attribute. 
        /// 
        /// Get Function: niWLANA_GetETSIIBEMarginVector
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetETSIIBEMarginVector(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultETSIIBEMarginVector, dataArray, dataArraySize, out actualNumDataArrayElements);
        }

        /// <summary>
        /// Returns the array of frequencies, in hertz (Hz), at which the lowest margin for each channel is observed. The elements in the array correspond one-to-one to the elements in the NIWLANA_RESULT_ETSI_IBE_MARGIN_VECTOR attribute. The size of this array is 2 * N + 1, where N is the value you specify in the NIWLANA_ETSI_IBE_NUMBER_OF_OFFSETS attribute. 
        /// 
        /// Get Function: niWLANA_GetETSIIBEMarginFrequencyVector
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetETSIIBEMarginFrequencyVector(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultETSIIBEMarginFrequencyVector, dataArray, dataArraySize, out actualNumDataArrayElements);
        }

        /// <summary>
        /// Returns the ratio, as a percentage, of the number of points of the power spectral density measurement that are above the applied spectral emission limits to the total number of points in the power spectral density measurement. 
        /// 
        /// Get Function: niWLANA_GetETSIIBEViolation
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetETSIIBEViolation(string channelString, out double value)
        {

            return GetDouble(niWLANAProperties.ResultETSIIBEViolation, channelString, out value);
        }

        /// <summary>
        /// Returns the array of the lowest margins, in dB, which is the minimum difference between the delta ACLR limit value and the actual delta ACLR value, per channel. You must specify the delta ACLR limit by configuring the NIWLANA_ETSI_IBE_DELTA_ACLR attribute. Actual delta ACLR value is same as the corresponding value of the NIWLANA_RESULT_ETSI_IBE_MARGIN_VECTOR attribute. If the test fails for a channel, the value of the NIWLANA_RESULT_ETSI_IBE_DELTA_ACLR_MARGIN_VECTOR attribute for the corresponding channel is negative. The elements in the array are in the order of increasing frequency with the starting index corresponding to the channel lowest in frequency. The size of this array is 2 * N + 1, where N is the value you specify in the NIWLANA_ETSI_IBE_NUMBER_OF_OFFSETS attribute. 
        /// 
        /// Get Function: niWLANA_GetETSIIBEDeltaACLRMarginVector
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetETSIIBEDeltaACLRMarginVector(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultETSIIBEDeltaACLRMarginVector, dataArray, dataArraySize, out actualNumDataArrayElements);
        }

        /// <summary>
        /// Returns the array of frequencies, in hertz (Hz), at which the lowest delta ACLR margin for each channel is observed. The elements in the array correspond one-to-one to the elements in the NIWLANA_RESULT_ETSI_IBE_DELTA_ACLR_MARGIN_VECTOR attribute. The size of this array is 2 * N + 1, where N is the value you specify in the NIWLANA_ETSI_IBE_NUMBER_OF_OFFSETS attribute. 
        /// 
        /// Get Function: niWLANA_GetETSIIBEDeltaACLRMarginFrequencyVector
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetETSIIBEDeltaACLRMarginFrequencyVector(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultETSIIBEDeltaACLRFrequencyVector, dataArray, dataArraySize, out actualNumDataArrayElements);
        }

        /// <summary>
        ///Specifies whether to automatically detect the non-high throughput (HT) modulated frame. If this attribute is disabled, you must specify the    frame format using the NIWLANA_RESULT_OFDM_DEMOD_NON_HT_MODULATION_MODE attribute. This attribute is valid only if you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodNonHTModulationDetectionEnabled
        ///    Set Function: niWLANA_SetOFDMDemodNonHTModulationDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodNonHTModulationDetectionEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmNonHTModulationDetectionEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether to automatically detect the non-high throughput (HT) modulated frame. If this attribute is disabled, you must specify the    frame format using the NIWLANA_RESULT_OFDM_DEMOD_NON_HT_MODULATION_MODE attribute. This attribute is valid only if you set    the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM,    or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodNonHTModulationDetectionEnabled
        ///    Set Function: niWLANA_SetOFDMDemodNonHTModulationDetectionEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodNonHTModulationDetectionEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmNonHTModulationDetectionEnabled, channelString, out value);
        }

        /// <summary>
        /// Returns the value of the LDPC Extra OFDM Symbol field as decoded from the VHT-SIG-A field of the 802.11ac signal or the TVHT-SIG-A field of the 802.11af signal. 
        /// 
        /// Get Function: niWLANA_GetOFDMDemodLDPCExtraSymbol 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodLDPCExtraSymbol(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmLDPCExtraOfdmSymbol, channelString, out value);
        }

        /// <summary>
        /// Returns the non-high throughput (HT) modulation mode of the frame. This attribute is valid only if you set the NIWLANA_VAL_STANDARD attribute to NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM. 
        /// 
        /// Get Function: niWLANA_GetOFDMDemodNonHTModulationMode
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodNonHTModulationMode(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmNonHTModulationMode, channelString, out value);
        }

        /// <summary>
        /// Calculates the carrier frequency of 802.11af channels, as defined in section 23.3.14 of IEEE Standard 802.11af-2013.
        /// 
        /// </summary>
        /// <param name="channelStartingFrequency">
        /// Specifies the start frequency, in hertz (Hz), of the frequency band. The default value is 45 MHz. 
        /// </param>
        /// <param name="channelBandwidth">
        /// Specifies the channel bandwidth, in Hz, used for transmitting the signal. The default value is 6 MHz. 
        /// </param>
        /// <param name="channelNumber">
        /// Specifies the offset of the center frequency, in increments of the channel bandwidth, in Hz, used for transmitting the signal. The default value is 1 MHz. 
        /// </param>
        /// <param name="TVHTMode">
        /// Specifies the mode of the 802.11af signal transmission. 
        /// 
        /// The function calculates the carrier frequency using the following equation: 
        /// carrier frequency (Hz) = channel starting frequency (Hz) + (TVHT_W * channel number + channel center frequency correction (Hz) 
        /// where channel center frequency correction (Hz) is used to adjust the carrier frequency in the different TVHT modes.
        /// 
        /// It is 0 for NIWLANA_VAL_TVHT_MODE_1 and NIWLANA_VAL_TVHT_MODE_2N, 0.5 * TVHT_W for NIWLANA_VAL_TVHT_MODE_2C and NIWLANA_VAL_TVHT_MODE_4N, and 1.5 * TVHT_W for NIWLANA_VAL_TVHT_MODE_4C. 
        /// 
        /// The default value is NIWLANA_VAL_TVHT_MODE_1. 
        /// 
        /// NIWLANA_VAL_TVHT_MODE_1(0) Specifies the TVHT mode representing a single basic channel unit (BCU).  
        /// NIWLANA_VAL_TVHT_MODE_2C(1) Specifies the TVHT mode representing two contiguous BCUs. 
        /// NIWLANA_VAL_TVHT_MODE_2N(2) Specifies the TVHT mode representing two noncontiguous BCUs. 
        /// NIWLANA_VAL_TVHT_MODE_4C(3) Specifies the TVHT mode representing four contiguous BCUs. 
        /// NIWLANA_VAL_TVHT_MODE_4N(4) Specifies the TVHT mode representing two noncontiguous frequency segments, each of which are composed of two BCUs. 
        /// 
        /// </param>
        /// <param name="carrierFrequency">
        /// Returns the carrier frequency, in Hz. 
        /// 
        /// </param>
        ///<returns>
        ///
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        ///
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// 
        ///</returns>
        public int ChannelNumberToCarrierFrequency80211af(double channelStartingFrequency, double channelBandwidth, int channelNumber, int TVHTMode, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANA_ChannelNumberToCarrierFrequency80211af(channelStartingFrequency, channelBandwidth, channelNumber, TVHTMode, out carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the in band emission limits and PSD, as defined in section 4.2.3, 4.2.4.2 and 5.3.3 of the European Telecommunications Standards Institute (ETSI) specification document ETSI EN 301 598 V1.1.1 (2014-04). The PSD is computed as power over 100 kHz band. 
        /// To use this function, you must set the NIWLANA_ETSI_IBE_TRACE_ENABLED attribute and the NIWLANA_ETSI_IBE_ENABLED attribute to NIWLANA_VAL_TRUE.
        /// The first element of the spectral mask array contains the in-band emission limits computed relative to the in-band power over the channel bandwidth, the second element of the array contains the absolute in-band emission limits, as defined in the ETSI specifications, and the third element of the array contains the PSD trace. 
        /// 
        /// </summary>
        /// <param name="f0">
        /// Indicates the start frequency, in hertz (Hz), of the trace.
        /// </param>
        /// <param name="df">
        /// Indicates the frequency intervals, in Hz, between the points in the trace.
        /// </param>
        /// <param name="relativeLimits">
        /// Indicates the in-band emission limits relative to the in-band transmit power computed for the PSD.
        /// </param>
        /// <param name="absoluteLimits">
        /// Indicates the in-band emission absolute limits defined for the PSD.
        /// </param>
        /// <param name="PSD">
        /// Indicates ETSI PSD values in dBm/100 kHz.
        /// </param>
        /// <param name="dataArraySize">
        /// Specifies the number of elements in the data array.
        /// </param>
        /// <param name="actualDataArraySize">
        /// Returns the number of elements in the data array. If the PSD array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the PSD array.
        /// </param>
        /// <returns>
        /// Returns the status code of this operation. The status code  either indicates success or describes an error or warning condition.
        /// Examine the status code from each call to an niWLAN function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the niWLANA_GetErrorString function.
        ///
        /// The general meaning of the status code is as follows:
        /// Value           Meaning
        /// 0               Success
        /// Positive Values Warnings
        /// Negative Values Errors
        /// </returns>
        public int GetETSIIBETrace(out double f0, out double df, double[] relativeLimits, double[] absoluteLimits, double[] PSD, int dataArraySize, out int actualDataArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetETSIIBETrace(Handle, out f0, out df, relativeLimits, absoluteLimits, PSD, dataArraySize, out actualDataArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Indicates whether the cyclic redundancy check (CRC) has passed for TVHT-SIG-A field of the 802.11af signal. 
        /// Get Function:niWLANA_GetOFDMDemodTVHTSIGACRCPassed
        /// 
        /// NIWLANA_VAL_FALSE (0) Indicates that the result has failed.  
        /// NIWLANA_VAL_TRUE (1) Indicates that the result has passed.  
        /// NIWLANA_VAL_VARIOUS (-1) Indicates that the result varies across iterations.  
        /// NIWLANA_VAL_NOT_APPLICABLE (-3) Indicates that the result is invalid for the current signal.  
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodTVHTSIGACRCPassed(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmTVHTSIGACRCPassed, channelString, out value);
        }        

        /// <summary>
        /// Returns the format of the received signal. This attribute is valid only if you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM. 
        /// Get Function:niWLANA_GetOFDMDemodTVHTMode 
        /// 
        /// NIWLANA_VAL_TVHT_MODE_1 (0) Indicates that the received signal is in the NIWLANA_VAL_TVHT_MODE_1 format, representing a single basic channel unit (BCU).  
        /// NIWLANA_VAL_TVHT_MODE_2C (1) Indicates that the received signal is in the TVHT_MODE_2C format, representing two contiguous BCUs.  
        /// NIWLANA_VAL_TVHT_MODE_2N (2) Indicates that the received signal is in the TVHT_MODE_2N format, representing two noncontiguous BCUs.  
        /// NIWLANA_VAL_TVHT_MODE_4C (3) Indicates that the received signal is in the TVHT_MODE_4C format, representing four contiguous BCUs.  
        /// NIWLANA_VAL_TVHT_MODE_4N (4) 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodTVHTMode(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmTVHTMode, channelString, out value);
        }        

        #endregion

        #region 15.5
        /// <summary>
        ///Specifies whether to use a single analyzer or two analyzers for each channel of a    multi-segment (80+80) MHz 802.11ac signal for spectral measurements. This    attribute is applicable when the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2 and channel bandwidth    is 80 MHz. When you set this attribute to NIWLANA_VAL_SINGLE_ANALYZER, you must specify the value of    the NIWLANA_CARRIER_FREQUENCY attribute for both the segments. 
        ///    The default value is NIWLANA_VAL_MULTIPLE_ANALYZERS. 
        ///    Set Function: niWLANA_SetMultiSegmentMeasurementMode
        ///     Get Function: niWLANA_GetMultiSegmentMeasurementMode
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetMultiSegmentMeasurementMode(string channelString, int value)
        {
            return SetInt(niWLANAProperties.MultiSegmentMeasurementMode, channelString, value);
        }

        /// <summary>
        /// Sets the value of an niWLAN analysis string attribute.
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="attributeID"></param>
        /// <param name="attributeValue"></param>
        /// <returns></returns>
        public int SetAttributeString(string channelString, niWLANAProperties attributeID, string attributeValue)
        {
            int pInvokeResult = PInvoke.niWLANA_SetAttributeString(Handle, channelString, attributeID, attributeValue);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Queries the value of an niWLAN analysis string  attribute. 
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="attributeID"></param>
        /// <param name="attributeValue"></param>
        /// <param name="bufferSize"></param>
        /// <param name="actualStringSize"></param>
        /// <returns></returns>
        public int GetAttributeString(string channelString, niWLANAProperties attributeID, string attributeValue, int bufferSize, out int actualStringSize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetAttributeString(Handle, channelString, attributeID, attributeValue, bufferSize, out actualStringSize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Sets the NIWLANA_AMPLITUDE_CORRECTION_ENABLED attribute.
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetAmplitudeCorrectionEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.AmplitudeCorrectionEnabled, channelString, value);
        }

        /// <summary>
        /// Sets the amplitude correction table specified by  the values of the frequencyCorrection and the amplitudeCorrection parameters. A positive value for the amplitudeCorrection parameter indicates that the input signal to the analyzer is attenuated at the corresponding frequency.
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="tableIndex"></param>
        /// <param name="amplitudeCorrection"></param>
        /// <param name="frequency"></param>
        /// <param name="arraySize"></param>
        /// <returns></returns>
        public int SetAmplitudeCorrectionTable(string channelString, int tableIndex, double[] amplitudeCorrection, double[] frequency, int arraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_SetAmplitudeCorrectionTable(Handle, channelString, tableIndex, amplitudeCorrection, frequency, arraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Selects the amplitude correction table for the specified analyzer. For multiple analyzers, you must call this function for each analyzer.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="analyzerIndex"></param>
        /// <param name="tableIndex"></param>
        /// <returns></returns>
        public int SelectAmplitudeCorrectionTable(string channelString, int analyzerIndex, int tableIndex)
        {
            int pInvokeResult = PInvoke.niWLANA_SelectAmplitudeCorrectionTable(Handle, channelString, analyzerIndex, tableIndex);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the frequency values and the amplitude correction values corresponding to the specified index.
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="index"></param>
        /// <param name="isTableIndex"></param>
        /// <param name="amplitudeCorrection"></param>
        /// <param name="frequency"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualArraySize"></param>
        /// <returns></returns>
        public int GetAmplitudeCorrectionTable(string channelString, int index, int isTableIndex, double[] amplitudeCorrection, double[] frequency, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetAmplitudeCorrectionTable(Handle, channelString, index, isTableIndex, amplitudeCorrection, frequency, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///Specifies whether to use a single analyzer or two analyzers for each channel of a    multi-segment (80+80) MHz 802.11ac signal for spectral measurements. This    attribute is applicable when the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2 and channel bandwidth    is 80 MHz. When you set this attribute to NIWLANA_VAL_SINGLE_ANALYZER, you must specify the value of    the NIWLANA_CARRIER_FREQUENCY attribute for both the segments. 
        ///    The default value is NIWLANA_VAL_MULTIPLE_ANALYZERS. 
        ///    Set Function: niWLANA_SetMultiSegmentMeasurementMode
        ///     Get Function: niWLANA_GetMultiSegmentMeasurementMode
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetMultiSegmentMeasurementMode(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.MultiSegmentMeasurementMode, channelString, out value);
        }

        /// <summary>
        ///Specifies whether to enable amplitude correction based on the amplitude correction table. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetAmplitudeCorrectionEnabled
        ///    Set Function: niWLANA_SetAmplitudeCorrectionEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAmplitudeCorrectionEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.AmplitudeCorrectionEnabled, channelString, out value);
        }

        /// <summary>
        ///Returns the peak power or the peak-to-peak voltage of the signal burst as calculated by the niWLANA_RFSAAutoRange function. 
        ///    Use this value to set the NIRFSA_ATTR_REFERENCE_LEVEL attribute or the NIRFSA_ATTR_IQ_IN_PORT_VERTICAL_RANGE attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AG_OFDM, NIWLANA_VAL_STANDARD_80211J_OFDM, NIWLANA_VAL_STANDARD_80211P_OFDM, NIWLANA_VAL_STANDARD_80211BG_DSSS    or NIWLANA_VAL_STANDARD_80211G_DSSS_OFDM, you must use an    empty string to query this attribute. 
        ///     If you set the NIWLANA_STANDARD attribute to    NIWLANA_VAL_STANDARD_80211N_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AH_MIMO_OFDM, you must use a    'channelx' as the active channel string format to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute    to NIWLANA_VAL_STANDARD_80211AC_MIMO_OFDM, NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM, or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM you must    use 'segmentx/channely' as the active channel    string syntax to query this attribute. 
        ///    Get Function: niWLANA_GetAutoRangeMaxInputRange
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAutoRangeMaxInputRange(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAutorangeMaxInputRange, channelString, out value);
        }

        /// <summary>
        ///Returns the acquisition length measured by the niWLANA_RFSAAutoRange function. This value is expressed in seconds.    The niWLANA_RFSAAutoRange function measures the length of the burst returns the recommended acquisition    length to use while performing successful measurements. Use this value to set the NIWLANA_ACQUISITION_LENGTH attribute. 
        ///    Get Function: niWLANA_GetAutoRangeAcquisitionLength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAutoRangeAcquisitionLength(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAutorangeAcquisitionLength, channelString, out value);
        }

        /// <summary>
        ///Identifies the reference files used for combined signal demodulation    of the 802.11n and 802.11ac signals. This attribute is specific to the    device under test and    should be similar to the one specified for reference generation using the WLAN Analysis Soft    Front Panel. Refer to the Combined Signal Demodulation topic for    more information about combined signal demodulation. 
        ///    Get Function: niWLANA_GetOFDMDemodRefDataConstellationIdentifier
        ///    Set Function: niWLANA_SetOFDMDemodRefDataConstellationIdentifier
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="attrVal"></param>
        /// <returns></returns>
        public int SetOFDMDemodRefDataConstellationIdentifier(string channelString, string attrVal)
        {
            int pInvokeResult = PInvoke.niWLANA_SetOFDMDemodRefDataConstellationIdentifier(Handle, channelString, attrVal);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///Identifies the reference files used for combined signal demodulation    of the 802.11n and 802.11ac signals. This attribute is specific to the    device under test and    should be similar to the one specified for reference generation using the WLAN Analysis Soft    Front Panel. Refer to the Combined Signal Demodulation topic for    more information about combined signal demodulation. 
        ///    Get Function: niWLANA_GetOFDMDemodRefDataConstellationIdentifier
        ///    Set Function: niWLANA_SetOFDMDemodRefDataConstellationIdentifier
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="arraySize"></param>
        /// <param name="attrVal"></param>
        /// <returns></returns>
        public int GetOFDMDemodRefDataConstellationIdentifier(string channelString, int arraySize, string attrVal)
        {
            int pInvokeResult = PInvoke.niWLANA_GetOFDMDemodRefDataConstellationIdentifier(Handle, channelString, arraySize, attrVal);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///Specifies the scrambler seed for combined signal demodulation performed    on 802.11n and 802.11ac signals. To reduce the test time, you must fix scrambler seed while generating a signal from the device under test (DUT). 
        ///    If the DUT scrambler seed value is a fixed value during the creation of reference files and during the OFDM Demod    measurement, the valid value for the NIWLANA_SCRAMBLER_SEED attribute is the fixed seed value or -1. 
        ///    If the DUT scrambler seed value is a varying value during the creation of reference files and during the OFDM Demod    measurement, the valid value for the NIWLANA_SCRAMBLER_SEED attribute is -1. 
        ///    If the DUT scrambler seed value is a varying value during the creation of reference files and a fixed value during the OFDM Demod    measurement, the valid value for the NIWLANA_SCRAMBLER_SEED attribute is the fixed seed value. 
        ///    Note: The measurement time is the lowest when the scrambler seed value is a fixed value during OFDM Demod measurement. 
        ///    Get Function: niWLANA_GetScramblerSeed
        ///    Set Function: niWLANA_SetScramblerSeed
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetScramblerSeed(string channelString, int value)
        {
            return SetInt(niWLANAProperties.ScramblerSeed, channelString, value);
        }

        /// <summary>
        ///Specifies the scrambler seed for combined signal demodulation performed    on 802.11n and 802.11ac signals. To reduce the test time, you must fix scrambler seed while generating a signal from the device under test (DUT). 
        ///    If the DUT scrambler seed value is a fixed value during the creation of reference files and during the OFDM Demod    measurement, the valid value for the NIWLANA_SCRAMBLER_SEED attribute is the fixed seed value or -1. 
        ///    If the DUT scrambler seed value is a varying value during the creation of reference files and during the OFDM Demod    measurement, the valid value for the NIWLANA_SCRAMBLER_SEED attribute is -1. 
        ///    If the DUT scrambler seed value is a varying value during the creation of reference files and a fixed value during the OFDM Demod    measurement, the valid value for the NIWLANA_SCRAMBLER_SEED attribute is the fixed seed value. 
        ///    Note: The measurement time is the lowest when the scrambler seed value is a fixed value during OFDM Demod measurement. 
        ///    Get Function: niWLANA_GetScramblerSeed
        ///    Set Function: niWLANA_SetScramblerSeed
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetScramblerSeed(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ScramblerSeed, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetAutoRangeMaxInputPower(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultAutorangeMaxInputRange, channelString, out value);
        }

        /// <summary>
        ///Returns the lowest margin, which is the minimum difference between the unused tone error mask    and the measured unused tone error per 26-tone RU. Refer to the OFDM Unused Tone Error Measurement topic for more    information about unused tone error margins.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you    must use 'channelx' to query this attribute for margin across segments, if the    channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. you must use '[segmentx/]channely' as the active    channel string syntax to query this attribute for margin per segment. ['segment0/]' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Get Function: niWLANA_GetOFDMDemodUnusedToneErrorMargin
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodUnusedToneErrorMargin(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodUnusedToneErrorMargin, channelString, out value);
        }

        /// <summary>
        ///Returns the 26-tone RU index for which the lowest unused tone error margin    was observed. The lowest unused tone error margin is the minimum difference between unused tone error mask    and measured unused tone error per 26-tone RU. Refer to the OFDM Unused Tone Error Measurement topic for more    information about unused tone error RU index.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you    must use 'channelx' to query this attribute for margin RU index across segments, if the    channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. you must use '[segmentx/]channely' as the active    channel string syntax to query this attribute for margin RU index per segment. ['segment0/]' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Get Function: niWLANA_GetOFDMDemodUnusedToneErrorMargin
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodUnusedToneErrorMarginRUIndex(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodUnusedToneErrorMarginRuIndex, channelString, out value);
        }

        /// <summary>
        ///Returns the difference between the unused tone error mask and the measured unused tone error per 26-tone    RU, averaged across iterations. This value is expressed in dB. The elements in the array correspond to 26-tone RUs assuming    the entire bandwidth is composed of 26-tone RUs. For 26-tone RUs corresponding to occupied subcarrier locations, this attribute    returns infinity as the value. Refer to the OFDM Unused Tone Error Measurement topic for more    information about unused tone error margin vector.
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you    must use 'channelx' to query this attribute for margin vector across segments, if the    channel bandwidth is 80 MHz and the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 2. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. you must use '[segmentx/]channely' as the active    channel string syntax to query this attribute for margin vector per segment. ['segment0/]' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Get Function: niWLANA_GetOFDMDemodUnusedToneErrorMarginVector
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="dataArraySize"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetOFDMDemodUnusedToneErrorMarginVector(string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.ResultOfdmDemodUnusedToneErrorMarginVector, dataArray, dataArraySize, out actualNumDataArrayElements);
        }

        /// <summary>
        ///Specifies the index of the segment to be analyzed in a 80+80 MHz 802.11ax signal. You must set this attribute when    you want to analyze a single segment out of the two segments. 
        ///    You must set the NIWLANA_NUMBER_OF_SEGMENTS attribute to 1 and    the NIWLANA_CHANNEL_BANDWIDTH attribute to 80 MHz to configure this attribute. 
        ///    The default value is 0. The valid values are 0 and 1. 
        ///    Get Function: niWLANA_GetOFDMDemod80Plus80SegmentIndex
        ///    Set Function: niWLANA_SetOFDMDemod80Plus80SegmentIndex
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemod80Plus80SegmentIndex(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemod80Plus80SegmentIndex, channelString, value);
        }


        /// <summary>
        ///Specifies the index of the segment to be analyzed in a 80+80 MHz 802.11ax signal. You must set this attribute when    you want to analyze a single segment out of the two segments. 
        ///    You must set the NIWLANA_NUMBER_OF_SEGMENTS attribute to 1 and    the NIWLANA_CHANNEL_BANDWIDTH attribute to 80 MHz to configure this attribute. 
        ///    The default value is 0. The valid values are 0 and 1. 
        ///    Get Function: niWLANA_GetOFDMDemod80Plus80SegmentIndex
        ///    Set Function: niWLANA_SetOFDMDemod80Plus80SegmentIndex
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemod80Plus80SegmentIndex(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemod80Plus80SegmentIndex, channelString, out value);
        }


        /// <summary>
        ///Specifies whether to compensate the EVM results measured during the OFDM Demod measurement for inherent    instrument noise of the NI vector signal analyzers. You must measure the noise floor before applying    the noise compensation. Refer to the Noise Compensation topic for more information on applying noise compensation. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetNoiseCompensationEnabled
        ///    Set Function: niWLANA_SetNoiseCompensationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNoiseCompensationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.NoiseCompensationEnabled, channelString, value);
        }


        /// <summary>
        ///Specifies whether to compensate the EVM results measured during the OFDM Demod measurement for inherent    instrument noise of the NI vector signal analyzers. You must measure the noise floor before applying    the noise compensation. Refer to the Noise Compensation topic for more information on applying noise compensation. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetNoiseCompensationEnabled
        ///    Set Function: niWLANA_SetNoiseCompensationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNoiseCompensationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.NoiseCompensationEnabled, channelString, out value);
        }


        /// <summary>
        ///Specifies an array of carrier frequencies at which the instrument noise floor is measured. The measured instrument    noise floor is used to apply noise compensation during the OFDM Demod measurement. 
        ///    Get Function: niWLANA_GetNoiseCompensationCarrierFrequencies
        ///    Set Function: niWLANA_SetNoiseCompensationCarrierFrequencies
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <returns></returns>
        public int SetNoiseCompensationCarrierFrequencies(string channelString, double[] dataArray)
        {
            return SetVectorDouble(channelString, niWLANAProperties.NoiseCompensationCarrierFrequencies, dataArray, dataArray.Length);
        }


        /// <summary>
        ///Specifies an array of carrier frequencies at which the instrument noise floor is measured. The measured instrument    noise floor is used to apply noise compensation during the OFDM Demod measurement. 
        ///    Get Function: niWLANA_GetNoiseCompensationCarrierFrequencies
        ///    Set Function: niWLANA_SetNoiseCompensationCarrierFrequencies
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetNoiseCompensationCarrierFrequencies(string channelString, double[] dataArray, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.NoiseCompensationCarrierFrequencies, dataArray, dataArray.Length, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Specifies the array of channel bandwidths for which the instrument noise floor is measured to apply noise    compensation during the OFDM Demod measurement. 
        ///    The instrument noise floor is measured for the specified channel bandwidth at the carrier frequency    specified in the corresponding element of the NIWLANA_NOISE_COMPENSATION_CARRIER_FREQUENCIES attribute. The array size    of the channel bandwidth must be same as the array size of the carrier frequencies. You can only specify the maximum    channel bandwidth at a particular carrier frequency for which you want to measure the instrument noise floor. 
        ///    Get Function: niWLANA_GetNoiseCompensationMaxChannelBandwidths
        ///    Set Function: niWLANA_SetNoiseCompensationMaxChannelBandwidths
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <returns></returns>
        public int SetNoiseCompensationMaxChannelBandwidths(string channelString, double[] dataArray)
        {
            return SetVectorDouble(channelString, niWLANAProperties.NoiseCompensationMaximumChannelBandwidths, dataArray, dataArray.Length);
        }



        /// <summary>
        ///Specifies the array of channel bandwidths for which the instrument noise floor is measured to apply noise    compensation during the OFDM Demod measurement. 
        ///    The instrument noise floor is measured for the specified channel bandwidth at the carrier frequency    specified in the corresponding element of the NIWLANA_NOISE_COMPENSATION_CARRIER_FREQUENCIES attribute. The array size    of the channel bandwidth must be same as the array size of the carrier frequencies. You can only specify the maximum    channel bandwidth at a particular carrier frequency for which you want to measure the instrument noise floor. 
        ///    Get Function: niWLANA_GetNoiseCompensationMaxChannelBandwidths
        ///    Set Function: niWLANA_SetNoiseCompensationMaxChannelBandwidths
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="dataArray"></param>
        /// <param name="actualNumDataArrayElements"></param>
        /// <returns></returns>
        public int GetNoiseCompensationMaxChannelBandwidths(string channelString, double[] dataArray, out int actualNumDataArrayElements)
        {
            return GetVectorDouble(channelString, niWLANAProperties.NoiseCompensationMaximumChannelBandwidths, dataArray, dataArray.Length, out actualNumDataArrayElements);
        }


        /// <summary>
        ///Specifies the minimum reference level used to measure the instrument noise floor. The measured instrument noise floor is used to apply noise compensation during the OFDM Demod measurement. 
        ///    The default value is -30 dBm. 
        ///    Get Function: niWLANA_GetNoiseCompensationMinimumReferenceLevel
        ///    Set Function: niWLANA_SetNoiseCompensationMinimumReferenceLevel
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNoiseCompensationMinimumReferenceLevel(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.NoiseCompensationMinimumReferenceLevel, channelString, value);
        }

        /// <summary>
        ///Specifies the minimum reference level used to measure the instrument noise floor. The measured instrument noise floor    is used to apply noise compensation during the OFDM Demod measurement. 
        ///    The default value is -30 dBm. 
        ///    Get Function: niWLANA_GetNoiseCompensationMinimumReferenceLevel
        ///    Set Function: niWLANA_SetNoiseCompensationMinimumReferenceLevel
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNoiseCompensationMinimumReferenceLevel(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.NoiseCompensationMinimumReferenceLevel, channelString, out value);
        }

        /// <summary>
        ///Specifies the maximum reference level used to measure the instrument noise floor. The measured instrument noise floor    is used to apply noise compensation during the OFDM Demod measurement. 
        ///    The default value is 10 dBm. 
        ///    Get Function: niWLANA_GetNoiseCompensationMaximumReferenceLevel
        ///    Set Function: niWLANA_SetNoiseCompensationMaximumReferenceLevel
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNoiseCompensationMaximumReferenceLevel(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.NoiseCompensationMaximumReferenceLevel, channelString, value);
        }

        /// <summary>
        ///Specifies the maximum reference level used to measure the instrument noise floor. The measured instrument noise floor    is used to apply noise compensation during the OFDM Demod measurement. 
        ///    The default value is 10 dBm. 
        ///    Get Function: niWLANA_GetNoiseCompensationMaximumReferenceLevel
        ///    Set Function: niWLANA_SetNoiseCompensationMaximumReferenceLevel
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNoiseCompensationMaximumReferenceLevel(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.NoiseCompensationMaximumReferenceLevel, channelString, out value);
        }

        /// <summary>
        ///Specifies the step size used to compute the reference levels between the minimum and maximum reference levels. The    niWLANA_RFSAMeasureNoiseFloor measures the instrument noise floor at these reference levels. The measured instrument    noise floor is used to apply noise compensation during the OFDM Demod measurement.
        ///    The only valid value is 0.5 dB. 
        ///    Get Function: niWLANA_GetNoiseCompensationReferenceLevelStepSize
        ///    Set Function: niWLANA_SetNoiseCompensationReferenceLevelStepSize
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNoiseCompensationReferenceLevelStepSize(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.ReferenceLevelStepSize, channelString, value);
        }

        /// <summary>
        ///Specifies the step size used to compute the reference levels between the minimum and maximum reference levels. The    niWLANA_RFSAMeasureNoiseFloor measures the instrument noise floor at these reference levels. The measured instrument    noise floor is used to apply noise compensation during the OFDM Demod measurement.
        ///    The only valid value is 0.5 dB. 
        ///    Get Function: niWLANA_GetNoiseCompensationReferenceLevelStepSize
        ///    Set Function: niWLANA_SetNoiseCompensationReferenceLevelStepSize
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNoiseCompensationReferenceLevelStepSize(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ReferenceLevelStepSize, channelString, out value);
        }

        /// <summary>
        ///Specifies whether to optimize reference level for the EVM measurement. You must use    the niWLANA_RFSAConfigureOptimalEVMReferenceLevel function to configure the optimal reference level. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOptimizeReferenceLevelForEVMEnabled
        ///    Set Function: niWLANA_SetOptimizeReferenceLevelForEVMEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOptimizeReferenceLevelForEVMEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OptimizeReferenceLevelForEvmEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether to optimize reference level for the EVM measurement. You must use    the niWLANA_RFSAConfigureOptimalEVMReferenceLevel function to configure the optimal reference level. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOptimizeReferenceLevelForEVMEnabled
        ///    Set Function: niWLANA_SetOptimizeReferenceLevelForEVMEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOptimizeReferenceLevelForEVMEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OptimizeReferenceLevelForEvmEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies the value used for adjusting the factor used for computation of the optimal    reference level. You must use the niWLANA_RFSAConfigureOptimalEVMReferenceLevel function to configure    the optimal reference level and margin. If you expect the peak power of the input signal to vary from    packet to packet, then set this attribute to the value by which the maximum peak power exceeds the    value configured as peak power value by the niWLANA_RFSAConfigureOptimalEVMReferenceLevel function. 
        ///    Get Function: niWLANA_GetOptimizeReferenceLevelForEVMMargin
        ///    Set Function: niWLANA_SetOptimizeReferenceLevelForEVMMargin
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOptimizeReferenceLevelForEVMMargin(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.OptimizeReferenceLevelForEvmMargin, channelString, value);
        }

        /// <summary>
        ///Specifies the value used for adjusting the factor used for computation of the optimal    reference level. You must use the niWLANA_RFSAConfigureOptimalEVMReferenceLevel function to configure    the optimal reference level and margin. If you expect the peak power of the input signal to vary from    packet to packet, then set this attribute to the value by which the maximum peak power exceeds the    value configured as peak power value by the niWLANA_RFSAConfigureOptimalEVMReferenceLevel function. 
        ///    Get Function: niWLANA_GetOptimizeReferenceLevelForEVMMargin
        ///    Set Function: niWLANA_SetOptimizeReferenceLevelForEVMMargin
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOptimizeReferenceLevelForEVMMargin(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.OptimizeReferenceLevelForEvmMargin, channelString, out value);
        }

        /// <summary>
        ///Specifies the size of resource unit (RU) in terms of the number of subcarriers for the    802.11ax signal. The RU size is specified for each user when you set the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    When you set the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, only    NIWLANA_VAL_OFDM_DEMOD_RU_SIZE_242 and NIWLANA_VAL_OFDM_DEMOD_RU_SIZE_106 RU sizes are valid. 
        ///    The toolkit ignores this attirbute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    the PPDU type values other than NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use the following active channel string formats to query this attribute: 
        ///    'userx' as the active channel string format, if you set the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU.
        ///    An empty string as the active channel, if you set the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU.
        ///    The default value is NIWLANA_VAL_OFDM_DEMOD_RU_SIZE_26. 
        ///     Get Function: niWLANA_GetOFDMRUSize
        ///    Set Function: niWLANA_SetOFDMRUSize
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMRUSize(string channelString, int value)
        {
            return SetInt(niWLANAProperties.RuSize, channelString, value);
        }

        /// <summary>
        ///Specifies the size of resource unit (RU) in terms of the number of subcarriers for the    802.11ax signal. The RU size is specified for each user when you set the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    When you set the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, only    NIWLANA_VAL_OFDM_DEMOD_RU_SIZE_242 and NIWLANA_VAL_OFDM_DEMOD_RU_SIZE_106 RU sizes are valid. 
        ///    The toolkit ignores this attirbute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    the PPDU type values other than NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use the following active channel string formats to query this attribute: 
        ///    'userx' as the active channel string format, if you set the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU.
        ///    An empty string as the active channel, if you set the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU.
        ///    The default value is NIWLANA_VAL_OFDM_DEMOD_RU_SIZE_26. 
        ///     Get Function: niWLANA_GetOFDMRUSize
        ///    Set Function: niWLANA_SetOFDMRUSize
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMRUSize(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.RuSize, channelString, out value);
        }

        /// <summary>
        ///Specifies the location of the resource unit (RU), in terms of the index of 26-tone RU, assuming the entire bandwidth is    composed of 26-tone RUs in the 802.11ax signal. 
        ///    Refer to the Configuring RU Offset topic in NI LabWindows/CVI WLAN Analysis Toolkit Reference Help for more information. 
        ///    The toolkit ignores this attirbute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    the PPDU type values other than NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    This attirbute is valid only if you set the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU and NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use the following active channel string formats to query this attribute: 
        ///    'userx' as the active channel string format, if you set the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU.
        ///    The valid values are as follows: 
        ///    If you set the NIWLANA_CHANNEL_BANDWIDTH to 20, and the NIWLANA_NUMBER_OF_SEGMENTS is 1, the valid value is between 0 and 8, all inclusive. 
        ///    If you set the NIWLANA_CHANNEL_BANDWIDTH to 40, and the NIWLANA_NUMBER_OF_SEGMENTS is 1, the valid value is between 0 and 17, all inclusive. 
        ///    If you set the NIWLANA_CHANNEL_BANDWIDTH to 80, and the NIWLANA_NUMBER_OF_SEGMENTS is 1, the valid value is between 0 and 36, all inclusive. 
        ///    If you set the NIWLANA_CHANNEL_BANDWIDTH to 160, and the NIWLANA_NUMBER_OF_SEGMENTS is 1, the valid value is between 0 and 73, all inclusive. 
        ///    If you set the NIWLANA_CHANNEL_BANDWIDTH to 80, and the NIWLANA_NUMBER_OF_SEGMENTS is 2, the valid value is between 0 and 73, all inclusive. 
        ///    The default value is 0. 
        ///    Get Function: niWLANA_GetOFDMRUOffset
        ///    Set Function: niWLANA_SetOFDMRUOffset
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMRUOffset(string channelString, int value)
        {
            return SetInt(niWLANAProperties.RuOffset, channelString, value);
        }

        /// <summary>
        ///Specifies the location of the resource unit (RU), in terms of the index of 26-tone RU, assuming the entire bandwidth is    composed of 26-tone RUs in the 802.11ax signal. 
        ///    Refer to the Configuring RU Offset topic in NI LabWindows/CVI WLAN Analysis Toolkit Reference Help for more information. 
        ///    The toolkit ignores this attirbute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    the PPDU type values other than NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    This attirbute is valid only if you set the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU and NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must    use the following active channel string formats to query this attribute: 
        ///    'userx' as the active channel string format, if you set the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU.
        ///    The valid values are as follows: 
        ///    If you set the NIWLANA_CHANNEL_BANDWIDTH to 20, and the NIWLANA_NUMBER_OF_SEGMENTS is 1, the valid value is between 0 and 8, all inclusive. 
        ///    If you set the NIWLANA_CHANNEL_BANDWIDTH to 40, and the NIWLANA_NUMBER_OF_SEGMENTS is 1, the valid value is between 0 and 17, all inclusive. 
        ///    If you set the NIWLANA_CHANNEL_BANDWIDTH to 80, and the NIWLANA_NUMBER_OF_SEGMENTS is 1, the valid value is between 0 and 36, all inclusive. 
        ///    If you set the NIWLANA_CHANNEL_BANDWIDTH to 160, and the NIWLANA_NUMBER_OF_SEGMENTS is 1, the valid value is between 0 and 73, all inclusive. 
        ///    If you set the NIWLANA_CHANNEL_BANDWIDTH to 80, and the NIWLANA_NUMBER_OF_SEGMENTS is 2, the valid value is between 0 and 73, all inclusive. 
        ///    The default value is 0. 
        ///    Get Function: niWLANA_GetOFDMRUOffset
        ///    Set Function: niWLANA_SetOFDMRUOffset
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMRUOffset(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.RuOffset, channelString, out value);
        }

        /// <summary>
        ///Specifies whether the dual carrier modulation (DCM) is applied to the data part of the 802.11ax signals or    not. The attribute can be set to NIWLANA_VAL_TRUE only when the MCS index is 0, 1, 3, and 4, and the number of spatial    streams spatial streams 1 or 2. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for the PPDU types    other than Trigger-Based PPDU. 
        ///    If you set the set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU you    must use an empty string as the active channel string formats to query this attribute. 
        ///    If you set the set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU you    must use userx as the active channel string format to query this attribute. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetDualCarrierModulationEnabled
        ///    Set Function: niWLANA_SetDualCarrierModulationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetDualCarrierModulationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDualCarrierModulationEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether the dual carrier modulation (DCM) is applied to the data part of the 802.11ax signals or    not. The attribute can be set to NIWLANA_VAL_TRUE only when the MCS index is 0, 1, 3, and 4, and the number of spatial    streams spatial streams 1 or 2. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for the PPDU types    other than Trigger-Based PPDU. 
        ///    If you set the set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU you    must use an empty string as the active channel string formats to query this attribute. 
        ///    If you set the set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU you    must use userx as the active channel string format to query this attribute. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetDualCarrierModulationEnabled
        ///    Set Function: niWLANA_SetDualCarrierModulationEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetDualCarrierModulationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDualCarrierModulationEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies the value of the modulation and coding scheme (MCS) index of the HE-SIG-B field of 802.11ax signal    when you set the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    the PPDU types other than Trigger-Based PPDU. 
        ///    The default value is 0. The valid values are 0 to 5, inclusive. 
        ///    Get Function: niWLANA_GetHESIGBMCSIndex
        ///    Set Function: niWLANA_SetHESIGBMCSIndex
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
         
        [Obsolete]
        public int SetHESIGBMCSIndex(string channelString, int value)
        {
            return SetInt(niWLANAProperties.HeSigBMcsIndex, channelString, value);
        }

        /// <summary>
        ///Specifies the value of the modulation and coding scheme (MCS) index of the HE-SIG-B field of 802.11ax signal    when you set the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    the PPDU types other than Trigger-Based PPDU. 
        ///    The default value is 0. The valid values are 0 to 5, inclusive. 
        ///    Get Function: niWLANA_GetHESIGBMCSIndex
        ///    Set Function: niWLANA_SetHESIGBMCSIndex
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
            [Obsolete]
        public int GetHESIGBMCSIndex(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.HeSigBMcsIndex, channelString, out value);
        }

        /// <summary>
        ///Specifies the number of HE-SIG-B symbols present in the 802.11ax signal when you set    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for the PPDU types    other than Trigger-Based PPDU. 
        ///    The default value is 1. 
        ///    Get Function: niWLANA_GetNumberOfHESIGBSymbols
        ///    Set Function: niWLANA_SetNumberOfHESIGBSymbols
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNumberOfHESIGBSymbols(string channelString, int value)
        {
            return SetInt(niWLANAProperties.NumberOfHeSigBSymbols, channelString, value);
        }

        /// <summary>
        ///Specifies the number of HE-SIG-B symbols present in the 802.11ax signal when you set    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for the PPDU types    other than Trigger-Based PPDU. 
        ///    The default value is 1. 
        ///    Get Function: niWLANA_GetNumberOfHESIGBSymbols
        ///    Set Function: niWLANA_SetNumberOfHESIGBSymbols
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNumberOfHESIGBSymbols(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.NumberOfHeSigBSymbols, channelString, out value);
        }

        /// <summary>
        ///Specifies the presence of an extra OFDM symbol segment for LDPC in the 802.11ax Trigger-based PPDU. The toolkit uses    this value for decoding the PSDU bits. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for the PPDU types    other than Trigger-Based PPDU. 
        ///    The default value is 0. The valid values are 0 and 1. 
        ///    Get Function: niWLANA_GetLDPCExtraSymbolUsed
        ///    Set Function: niWLANA_SetLDPCExtraSymbolUsed
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetLDPCExtraSymbolUsed(string channelString, int value)
        {
            return SetInt(niWLANAProperties.LdpcExtraSymbolUsed, channelString, value);
        }

        /// <summary>
        ///Specifies the presence of an extra OFDM symbol segment for LDPC in the 802.11ax Trigger-based PPDU. The toolkit uses    this value for decoding the PSDU bits. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for the PPDU types    other than Trigger-Based PPDU. 
        ///    The default value is 0. The valid values are 0 and 1. 
        ///    Get Function: niWLANA_GetLDPCExtraSymbolUsed
        ///    Set Function: niWLANA_SetLDPCExtraSymbolUsed
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetLDPCExtraSymbolUsed(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.LdpcExtraSymbolUsed, channelString, out value);
        }

        /// <summary>
        ///Specifies whether the dual carrier modulation (DCM) is applied on the HE-SIG-B field of 802.11ax signals or not. The DCM is applied    to the HE-SIG-B MCS index values 0, 1, 3, and 4. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    the PPDU types other than Trigger-Based PPDU. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetHESIGBDCMEnabled
        ///    Set Function: niWLANA_SetHESIGBDCMEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetHESIGBDCMEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.HeSigBDualCarrierModulationEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether the dual carrier modulation (DCM) is applied on the HE-SIG-B field of 802.11ax signals or not. The DCM is applied    to the HE-SIG-B MCS index values 0, 1, 3, and 4. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    the PPDU types other than Trigger-Based PPDU. 
        ///    The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetHESIGBDCMEnabled
        ///    Set Function: niWLANA_SetHESIGBDCMEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetHESIGBDCMEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.HeSigBDualCarrierModulationEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies the disambiguation in number of symbols used in 802.11ax signal. This disambiguation is caused due to the packet extension. The toolkit    ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute    to NIWLANA_VAL_TRUE for PPDUs other than the NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    The default value is 0. The valid values are 0 and 1. 
        ///    Get Function: niWLANA_GetOFDMPacketExtensionDisambiguity
        ///    Set Function: niWLANA_SetOFDMPacketExtensionDisambiguity
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMPacketExtensionDisambiguity(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmPacketExtensionDisambiguity, channelString, value);
        }

        /// <summary>
        ///Specifies the disambiguation in number of symbols used in 802.11ax signal. This disambiguation is caused due to the packet extension. The toolkit    ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute    to NIWLANA_VAL_TRUE for PPDUs other than the NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    The default value is 0. The valid values are 0 and 1. 
        ///    Get Function: niWLANA_GetOFDMPacketExtensionDisambiguity
        ///    Set Function: niWLANA_SetOFDMPacketExtensionDisambiguity
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMPacketExtensionDisambiguity(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmPacketExtensionDisambiguity, channelString, out value);
        }

        /// <summary>
        ///Specifies the HE-LTF symbol size in the 802.11ax signals. The IEEE P802.11ax/D1.2 specifies the following    combinations of the HE-LTF symbol size and the NIWLANA_GUARD_INTERVAL attribute. 
        ///    If you set the NIWLANA_PPDU_TYPE attribute to NIWLANA_VAL_PPDU_TYPE_SU_PPDU, NIWLANA_VAL_PPDU_TYPE_MU_PPDU or    NIWLANA_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANA_HE_LTF_SIZE attribute    is NIWLANA_VAL_HE_LTF_SIZE_4X, and the NIWLANA_GUARD_INTERVAL attribute value is 1/4. 
        ///    If you set the NIWLANA_PPDU_TYPE attribute to NIWLANA_VAL_PPDU_TYPE_SU_PPDU, NIWLANA_VAL_PPDU_TYPE_MU_PPDU or    NIWLANA_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANA_HE_LTF_SIZE attribute value    is NIWLANA_VAL_HE_LTF_SIZE_2X, and the NIWLANA_GUARD_INTERVAL attribute    value is 1/8. 
        ///    If you set the NIWLANA_PPDU_TYPE attribute to NIWLANA_VAL_PPDU_TYPE_SU_PPDU, NIWLANA_VAL_PPDU_TYPE_MU_PPDU or    NIWLANA_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANA_HE_LTF_SIZE attribute value    is NIWLANA_VAL_HE_LTF_SIZE_2X and NIWLANA_VAL_HE_LTF_SIZE_4X, and the NIWLANA_GUARD_INTERVAL attribute value    is 1/16. 
        ///    If you set the NIWLANA_PPDU_TYPE attribute to NIWLANA_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the NIWLANA_HE_LTF_SIZE attribute    value is NIWLANA_VAL_HE_LTF_SIZE_4X and the NIWLANA_GUARD_INTERVAL attribute value    is 1/4. 
        ///    If you set the NIWLANA_PPDU_TYPE attribute to NIWLANA_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the NIWLANA_HE_LTF_SIZE attribute    value is NIWLANA_VAL_HE_LTF_SIZE_2X and the NIWLANA_GUARD_INTERVAL attribute value is 1/8. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    the PPDU types other than NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    The default value is NIWLANA_VAL_HE_LTF_SIZE_AUTO. 
        ///    Get Function: niWLANA_GetHELTFSize
        ///    Set Function: niWLANA_SetHELTFSize
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetHELTFSize(string channelString, int value)
        {
            return SetInt(niWLANAProperties.HeLtfSize, channelString, value);
        }

        /// <summary>
        ///Specifies the HE-LTF symbol size in the 802.11ax signals. The IEEE P802.11ax/D1.2 specifies the following    combinations of the HE-LTF symbol size and the NIWLANA_GUARD_INTERVAL attribute. 
        ///    If you set the NIWLANA_PPDU_TYPE attribute to NIWLANA_VAL_PPDU_TYPE_SU_PPDU, NIWLANA_VAL_PPDU_TYPE_MU_PPDU or    NIWLANA_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANA_HE_LTF_SIZE attribute    is NIWLANA_VAL_HE_LTF_SIZE_4X, and the NIWLANA_GUARD_INTERVAL attribute value is 1/4. 
        ///    If you set the NIWLANA_PPDU_TYPE attribute to NIWLANA_VAL_PPDU_TYPE_SU_PPDU, NIWLANA_VAL_PPDU_TYPE_MU_PPDU or    NIWLANA_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANA_HE_LTF_SIZE attribute value    is NIWLANA_VAL_HE_LTF_SIZE_2X, and the NIWLANA_GUARD_INTERVAL attribute    value is 1/8. 
        ///    If you set the NIWLANA_PPDU_TYPE attribute to NIWLANA_VAL_PPDU_TYPE_SU_PPDU, NIWLANA_VAL_PPDU_TYPE_MU_PPDU or    NIWLANA_VAL_PPDU_TYPE_EXTENDED_RANGE_SU_PPDU, the NIWLANA_HE_LTF_SIZE attribute value    is NIWLANA_VAL_HE_LTF_SIZE_2X and NIWLANA_VAL_HE_LTF_SIZE_4X, and the NIWLANA_GUARD_INTERVAL attribute value    is 1/16. 
        ///    If you set the NIWLANA_PPDU_TYPE attribute to NIWLANA_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the NIWLANA_HE_LTF_SIZE attribute    value is NIWLANA_VAL_HE_LTF_SIZE_4X and the NIWLANA_GUARD_INTERVAL attribute value    is 1/4. 
        ///    If you set the NIWLANA_PPDU_TYPE attribute to NIWLANA_VAL_PPDU_TYPE_TRIGGER_BASED_PPDU, the NIWLANA_HE_LTF_SIZE attribute    value is NIWLANA_VAL_HE_LTF_SIZE_2X and the NIWLANA_GUARD_INTERVAL attribute value is 1/8. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    the PPDU types other than NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    The default value is NIWLANA_VAL_HE_LTF_SIZE_AUTO. 
        ///    Get Function: niWLANA_GetHELTFSize
        ///    Set Function: niWLANA_SetHELTFSize
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetHELTFSize(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.HeLtfSize, channelString, out value);
        }

        /// <summary>
        ///Specifies the number of HE-LTF symbols in the 802.11ax signal when    the NIWLANA_OFDM_PPDU_TYPE attribute is set to NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    The default value is -1, which indicates that the value is derived from the maximum index of space time    streams across users. The valid values are -1, 1, 2, 4, 6, and 8. 
        ///    Get Function: niWLANA_GetNumberOfHELTFSymbols
        ///    Set Function: niWLANA_SetNumberOfHELTFSymbols
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetNumberOfHELTFSymbols(string channelString, int value)
        {
            return SetInt(niWLANAProperties.NumberOfHeLtfSymbols, channelString, value);
        }


        /// <summary>
        ///Specifies the number of HE-LTF symbols in the 802.11ax signal when    the NIWLANA_OFDM_PPDU_TYPE attribute is set to NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    The default value is -1, which indicates that the value is derived from the maximum index of space time    streams across users. The valid values are -1, 1, 2, 4, 6, and 8. 
        ///    Get Function: niWLANA_GetNumberOfHELTFSymbols
        ///    Set Function: niWLANA_SetNumberOfHELTFSymbols
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetNumberOfHELTFSymbols(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.NumberOfHeLtfSymbols, channelString, out value);
        }


        /// <summary>
        ///Specifies whether to enable the unused tone error trace for 802.11ax signals. This attribute is valid only for the Trigger-based PPDUs.   The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodUnusedToneErrorTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodUnusedToneErrorTraceEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodUnusedToneErrorTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodUnusedToneErrorTraceEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether to enable the unused tone error trace for 802.11ax signals. This attribute is valid only for the Trigger-based PPDUs.   The default value is NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodUnusedToneErrorTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodUnusedToneErrorTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodUnusedToneErrorTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodUnusedToneErrorTraceEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies whether to enable the decoded header bits for 802.11a/g, 802.11j, 802.11p, 802.11n, 802.11ac or 802.11ax signals. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodDecodedHeaderTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodDecodedHeaderTraceEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodDecodedHeaderTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodDecodedHeaderBitsTraceEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether to enable the decoded header bits for 802.11a/g, 802.11j, 802.11p, 802.11n, 802.11ac or 802.11ax signals. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodDecodedHeaderTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodDecodedHeaderTraceEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodDecodedHeaderTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodDecodedHeaderBitsTraceEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies whether to enable the unused tone error measurement for the 802.11ax trigger-based PPDU signals. 
        ///    The default value is  NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodUnusedToneErrorEnabled
        ///    Set Function: niWLANA_SetOFDMDemodUnusedToneErrorEnabled
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodUnusedToneErrorEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodUnusedToneErrorEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether to enable the unused tone error measurement for the 802.11ax trigger-based PPDU signals. 
        ///    The default value is  NIWLANA_VAL_FALSE. 
        ///    Get Function: niWLANA_GetOFDMDemodUnusedToneErrorEnabled
        ///    Set Function: niWLANA_SetOFDMDemodUnusedToneErrorEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodUnusedToneErrorEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodUnusedToneErrorEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies the reference used to create the unused tone error mask for the 802.11ax Trigger-based PPDU signals. 
        ///    The default value is NIWLANA_VAL_OFDM_UNUSED_TONE_ERROR_MASK_REFERENCE_LOW_POWER.
        ///    Get Function: niWLANA_GetOFDMDemodUnusedToneErrorMaskReference
        ///    Set Function: niWLANA_SetOFDMDemodUnusedToneErrorMaskReference
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodUnusedToneErrorMaskReference(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodUnusedToneErrorMaskReference, channelString, value);
        }

        /// <summary>
        ///Specifies the reference used to create the unused tone error mask for the 802.11ax Trigger-based PPDU signals. 
        ///    The default value is NIWLANA_VAL_OFDM_UNUSED_TONE_ERROR_MASK_REFERENCE_LOW_POWER.
        ///    Get Function: niWLANA_GetOFDMDemodUnusedToneErrorMaskReference
        ///    Set Function: niWLANA_SetOFDMDemodUnusedToneErrorMaskReference
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodUnusedToneErrorMaskReference(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodUnusedToneErrorMaskReference, channelString, out value);
        }

        /// <summary>
        ///Returns the average, across iterations, of absolute carrier frequency leakage. This value is    expressed in dBm. The absolute carrier frequency leakage is the power measured in the DC subcarrier. This attribute    is valid only when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Get Function: niWLANA_GetOFDMDemodAbsoluteCarrierFrequencyLeakageAverage
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodAbsoluteCarrierFrequencyLeakageAverage(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodNoiseAbsoluteCarrierFrequencyLeakageAverage, channelString, out value);
        }

        /// <summary>
        ///Returns the minimum, across iterations, of absolute carrier frequency leakage. This value is    expressed in dBm. The absolute carrier frequency leakage is the power measured in the DC subcarrier. This attribute    is valid only when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Get Function: niWLANA_GetOFDMDemodAbsoluteCarrierFrequencyLeakageMinimum
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodAbsoluteCarrierFrequencyLeakageMinimum(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodNoiseAbsoluteCarrierFrequencyLeakageMinimum, channelString, out value);
        }

        /// <summary>
        ///Returns the maximum, across iterations, of absolute carrier frequency leakage. This value is    expressed in dBm. The absolute carrier frequency leakage is the power measured in the DC subcarrier. This attribute    is valid only when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Get Function: niWLANA_GetOFDMDemodAbsoluteCarrierFrequencyLeakageMaximum
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodAbsoluteCarrierFrequencyLeakageMaximum(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodNoiseAbsoluteCarrierFrequencyLeakageMaximum, channelString, out value);
        }

        /// <summary>
        ///Returns the standard deviation, across iterations, of absolute carrier frequency leakage. This value is    expressed in dBm. The absolute carrier frequency leakage is the power measured in the DC subcarrier. This attribute    is valid only when you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AF_MIMO_OFDM or NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and    the NIWLANA_OFDM_DEMOD_COMBINED_SIGNAL_DEMODULATION_ENABLED attribute to NIWLANA_VAL_FALSE, you must use '[segmentx/]channely' as the    active channel string format to query this attribute. 'segment0/' is optional if    the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1. 
        ///    Get Function: niWLANA_GetOFDMDemodAbsoluteCarrierFrequencyLeakageStandardDeviation
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodAbsoluteCarrierFrequencyLeakageStandardDeviation(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodNoiseAbsoluteCarrierFrequencyLeakageStandardDeviation, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMNoiseCompensationApplied(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodNoiseCompensationApplied, channelString, out value);
        }

        /// <summary>
        ///Returns the HE-LTF size in the 802.11ax signals. This value is decoded from the HE-SIG-A field. 
        ///    Get Function: niWLANA_GetOFDMDemodHELTFSize
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodHELTFSize(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodHeLtfSize, channelString, out value);
        }

        /// <summary>
        ///Indicates whether the transmission mode of 802.11ax or 802.11ah signal is uplink or downlink. This value    is decoded from DL/UL field of HE-SIG-A in the case of 802.11ax, and from the uplink indication    field of S1G SIG in the case of 802.11ah signal. 
        ///    Get Function: niWLANA_GetOFDMDemodTransmissionMode
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodTransmissionMode(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodTransmissionMode, channelString, out value);
        }

        /// <summary>
        ///Indicates whether the cyclic redundancy check (CRC) has passed for the HE-SIG-A field. 
        ///    Get Function: niWLANA_GetOFDMDemodHESIGACRCPassed
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodHESIGACRCPassed(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodHeSigACrcPassed, channelString, out value);
        }

        /// <summary>
        ///Indicates whether the cyclic redundancy check (CRC) has passed for the HE-SIG-B field. This    value is the result of a logical AND operation on all CRC pass checks in HE-SIG-B field. 
        ///    Get Function: niWLANA_GetOFDMDemodHESIGBCRCPassed
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodHESIGBCRCPassed(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodHeSigBCrcPassed, channelString, out value);
        }

        /// <summary>
        ///Specifies whether the transmission mode of the 802.11ax signal is uplink or downlink. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    The default value is NIWLANA_VAL_TRANSMISSION_MODE_DL. 
        ///    Get Function: niWLANA_GetTransmissionMode
        ///    Set Function: niWLANA_SetTransmissionMode
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int SetTransmissionMode(string channelString, int value)
        {
            return SetInt(niWLANAProperties.TransmissionMode, channelString, value);
        }

        /// <summary>
        ///Specifies whether the transmission mode of the 802.11ax signal is uplink or downlink. 
        ///    The toolkit ignores this attribute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE. 
        ///    The default value is NIWLANA_VAL_TRANSMISSION_MODE_DL. 
        ///    Get Function: niWLANA_GetTransmissionMode
        ///    Set Function: niWLANA_SetTransmissionMode
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        [Obsolete]
        public int GetTransmissionMode(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.TransmissionMode, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetPackeExtensionDuration(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodPacketExtentionDuration, channelString, out value);
        }

        /// <summary>
        ///Returns the length of the Physical Layer Convergence Procedure (PLCP) Service Data Unit (PSDU) of the    802.11ax signal. This value is expressed in bytes. You must set the NIWLANA_OFDM_DEMOD_MAC_FRAME_CHECK_SEQUENCE_CHECK_ENABLED attribute or    the NIWLANA_OFDM_DEMOD_DECODED_BITS_TRACE_ENABLED attribute to NIWLANA_VAL_TRUE to enable the PSDU bit decoding. If the PSDU bit decoding    is enabled, the toolkit returns the exact PSDU length excluding the post FEC padding bits. If    PSDU bit decoding is not enabled, the toolkit returns an approximate value of the PSDU length derived from the    HE-SIG-A and/or HE-SIG-B fields of the packet. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///    Get Function: niWLANA_GetOFDMDemodPSDULength
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodPSDULength(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodDetectedPsduLength, channelString, out value);
        }

        /// <summary>
        ///Returns the pre-FEC padding factor value decoded from the HE-SIG-A field of the 802.11ax signal. 
        ///    Get Function: niWLANA_GetOFDMDemodPreFECPaddingFactor
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodPreFECPaddingFactor(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodPreFecPaddingFactor, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodPacketExtensionDisambiguity(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodPacketExtentionDisambiguity, channelString, out value);
        }

        /// <summary>
        ///Returns the STA-ID of the user, detected by decoding the HE-SIG-B field of 802.11ax signal. The STA-ID is 11 LSBs of the association ID (AID). 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///    Get Function: niWLANA_GetOFDMDemodSTAID
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodSTAID(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodStaId, channelString, out value);
        }

        /// <summary>
        ///Returns the detected value of the DCM field by decoding the HE-SIG-A or HE-SIG-B fields of the 802.11ax signal. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_SU_PPDU or NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you    must use an empty string to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///    Get Function: niWLANA_GetOFDMDemodDCMEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodDCMEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodDcmEnabled, channelString, out value);
        }

        /// <summary>
        ///Returns the detected HE-SIG-B MCS index value by decoding the HE-SIG-A value of the 802.11ax signal. 
        ///    Get Function: niWLANA_GetOFDMDemodHESIGBMCSIndex
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodHESIGBMCSIndex(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodHeSigBMcsIndex, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodHESIGBDualCarrierModulationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodHeSigBDualCarrierModulationEnabled, channelString, out value);
        }

        /// <summary>
        ///Returns the detected value of the HE-SIG-B number of symbols by decoding the HE-SIG-A value of the 802.11ax signal. 
        ///    Get Function: niWLANA_GetOFDMDemodNumberOfHESIGBSymbols
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodNumberOfHESIGBSymbols(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodNumberofHeSigBSymbols, channelString, out value);
        }

        /// <summary>
        ///Returns the size of the resource unit (RU) for each user in the 802.11ax signal. For NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, this value    is derived from the RU allocation field of HE-SIG-B. For NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, this value is    automatically detected if the autodetection of RU is enabled. You must set the NIWLANA_OFDM_RU_SIZE attribute    to NIWLANA_VAL_OFDM_DEMOD_RU_SIZE_AUTO or the NIWLANA_OFDM_RU_OFFSET attribute to -1 to enable the autodetection of RU. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM, and    the NIWLANA_OFDM_PPDU_TYPE attribute to NIWLANA_VAL_OFDM_DEMOD_EXTENDED_RANGE_SU_PPDU, you    must use an empty string to query this attribute. 
        ///    Get Function: niWLANA_GetOFDMDemodRUSize
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodRUSize(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodRuSize, channelString, out value);
        }

        /// <summary>
        ///Returns the location of the resource unit (RU), in terms of the index of a 26-tone RU, assuming the entire bandwidth is    composed of 26-tone RUs in the 802.11ax signal. For NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, this attribute value is derived from the RU    allocation field of HE-SIG-B. For NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, this attribute value is automatically detected    if the autodetection of RU is enabled. You must set the NIWLANA_OFDM_RU_SIZE attribute    to NIWLANA_VAL_OFDM_DEMOD_RU_SIZE_AUTO or the NIWLANA_OFDM_RU_OFFSET attribute to -1 to enable the autodetection of RU. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU or NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///    Get Function: niWLANA_GetOFDMDemodRUOffset
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodRUOffset(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodRuOffset, channelString, out value);
        }


        /// <summary>
        ///Specifies the Pre-FEC padding factor used in 802.11ax Trigger-Based PPDU. The toolkit uses this    value for decoding the PSDU bits. 
        ///    The toolkit ignores this attirbute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    PPDU type values other than NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    The default value is 1. The valid values are 1 to 4, inclusive. 
        ///    Get Function: niWLANA_GetOFDMPreFECPaddingFactor
        ///    Set Function: niWLANA_SetOFDMPreFECPaddingFactor
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMPreFECPaddingFactor(string channelString, int value)
        {
            return SetInt(niWLANAProperties.PreFecPaddingFactor, channelString, value);
        }

        /// <summary>
        ///Specifies the Pre-FEC padding factor used in 802.11ax Trigger-Based PPDU. The toolkit uses this    value for decoding the PSDU bits. 
        ///    The toolkit ignores this attirbute if you set the NIWLANA_OFDM_DEMOD_HEADER_DETECTION_ENABLED attribute to NIWLANA_VAL_TRUE for    PPDU type values other than NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. 
        ///    The default value is 1. The valid values are 1 to 4, inclusive. 
        ///    Get Function: niWLANA_GetOFDMPreFECPaddingFactor
        ///    Set Function: niWLANA_SetOFDMPreFECPaddingFactor
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMPreFECPaddingFactor(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.PreFecPaddingFactor, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetLOOffsetMode(string channelString, int value)
        {
            return SetInt(niWLANAProperties.LOFrequencyOffsetMode, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetLOOffsetMode(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.LOFrequencyOffsetMode, channelString, out value);
        }

        /// <summary>
        ///Specifies the LO frequecy offset to be used when you set the NIWLANA_LO_FREQUENCY_OFFSET_MODE attribute    to NIWLANA_VAL_LO_FREQUENCY_OFFSET_MODE_USER_DEFINED. This value is expressed in Hz. 
        ///    The default value is 0. 
        ///    Get Function: niWLANA_GetLOFrequencyOffset
        ///    Set Function: niWLANA_SetLOFrequencyOffset
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetLOFrequencyOffset(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.LOFrequencyOffset, channelString, value);
        }

        /// <summary>
        ///Specifies whether to enable configuration for sharing of local oscillator (LO) signal for multiple NI RF vector signal    analyzers or vector signal transceivers. 
        ///    The niWLANA_RFSAConfigureMultipleDeviceSynchronization function reads this attribute. 
        ///    The default value is NIWLANA_VAL_LO_SHARING_ENABLED_TRUE if the compatibilityVersion parameter    of the niWLANA_OpenSession function is set to a value other    than NIWLANA_VAL_COMPATIBILITY_VERSION_050000, and NIWLANA_VAL_LO_SHARING_ENABLED_FALSE otherwise.
        ///    Get Function: niWLANA_GetLOSharingEnabled
        ///    Set Function: niWLANA_SetLOSharingEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetLOFrequencyOffset(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.LOFrequencyOffset, channelString, out value);
        }

        /// <summary>
        /// Configures the frequency on NI RF vector signal generators and NI RF synthesizers. NI RF synthesizers are used as external local oscillator (LO) devices. This VI also configures LO frequency offset based on the NIWLANA_LO_FREQUENCY_OFFSET_MODE  and NIWLANA_LO_FREQUENCY_OFFSET attributes. It also configures the NIWLANA_CARRIER_FREQUENCY attribute.
        /// 
        /// </summary>
        ///<param name = "rfsaHandles">
        /// Specifies a reference to an NI-RFSA instrument session. This parameter is obtained from the niRFSA_init or niRFSA_InitWithOptions functions and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "LOSource">
        /// Specifies whether to use the internal or the external LO source. This value is applicable only for the first RFSA device within a set if you set the rfsaLODaisyChainEnabled parameter to TRUE. The default value is NIWLANA_VAL_LO_SOURCE_ONBOARD.
        /// NIWLANA_VAL_LO_SOURCE_EXTERNAL (0)
        /// Uses an external LO as the LO source.
        /// NIWLANA_VAL_LO_SOURCE_ONBOARD (2)
        /// Uses an internal LO as the LO source.
        /// 
        ///</param>
        ///<param name = "externalLOHandle">
        /// Identifies the instrument session of the external LO device. The toolkit obtains this parameter from niRFSG_init or niRFSG_InitWithOptions functions. 
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Specifies the carrier frequency used to analyze signals. This value is expressed in Hz. 
        /// 
        ///</param>
        ///<param name = "rfsaLODaisyChainEnabled">
        /// Specifies whether to export the LO signal from one RFSA device to the next. The default value is FALSE. 
        /// 
        ///</param>
        ///<param name = "LOExportToExternalDevicesEnabled">
        /// Specifies whether to export the LO signal from each RFSA device on its LO OUT terminal, which you can use to share the LO signal with an external device. An example of an external device would be an RFSG device. The default value is FALSE. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAConfigureFrequencySingleLO
        /// int32 __stdcall niWLANA_RFSAConfigureFrequencySingleLO (niWLANA session,
        ///     ViSession rfsaSessions[],
        ///     int32 numberOfRFSASessions,
        ///     int32 LOSource,
        ///     ViSession externalLOHandle,
        ///     float64 carrierFrequency,
        ///     int32 rfsaLODaisyChainEnabled,
        ///     int32 LOExportToExternalDevicesEnabled);
        /// Purpose
        /// Configures the frequency on NI RF vector signal generators and NI RF synthesizers. NI RF synthesizers are used as external local oscillator (LO) devices. This VI also configures LO frequency offset based on the NIWLANA_LO_FREQUENCY_OFFSET_MODE  and NIWLANA_LO_FREQUENCY_OFFSET attributes. It also configures the NIWLANA_CARRIER_FREQUENCY attribute.
        /// 
        ///</returns>
        public int RFSAConfigureFrequencySingleLO(HandleRef[] rfsaHandles, int LOSource, HandleRef externalLOHandle, double carrierFrequency, int rfsaLODaisyChainEnabled, int LOExportToExternalDevicesEnabled)
        {
            Int32[] rfsaPtrs = new Int32[rfsaHandles.Length];
            rfsaPtrs = Array.ConvertAll<HandleRef, Int32>(rfsaHandles, x => x.Handle.ToInt32());
            Int32 exteralLOSessions = GetInt32Sessions(externalLOHandle);

            int pInvokeResult = PInvoke.niWLANA_RFSAConfigureFrequencySingleLO(Handle, rfsaPtrs, rfsaHandles.Length, LOSource, exteralLOSessions, carrierFrequency, rfsaLODaisyChainEnabled, LOExportToExternalDevicesEnabled);
            TestForError(pInvokeResult, rfsaHandles);
            return pInvokeResult;
        }

        /// <summary>
        /// Configures frequency on NI RF vector signal analyzers, and NI RF synthesizers. NI RF synthesizers are used as external local oscillator (LO) devices. This function also configures LO frequency offset based on the NIWLANA_LO_FREQUENCY_OFFSET_MODE  and NIWLANA_LO_FREQUENCY_OFFSET attributes. This function equally divides the NI RF vector signal analyzers and NI RF synthesizers into sets such that each set corresponds to one carrier frequency. The number of sets is equal to the size of the carrierFrequencies array. In each set, the first NI RF vector signal analyzer is used as the master device for LO daisy chaining. It also configures the NIWLANA_CARRIER_FREQUENCY attribute.
        /// 
        /// </summary>
        ///<param name = "rfsaHandles">
        /// Specifies a reference to an NI-RFSA instrument session. This parameter is obtained from the niRFSA_init or niRFSA_InitWithOptions functions and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "LOSource">
        /// Specifies whether to use the internal or the external LO source. This value is applicable only for the first RFSA device within a set if you set the rfsaLODaisyChainEnabled parameter to TRUE. The default value is NIWLANA_VAL_LO_SOURCE_ONBOARD.
        /// NIWLANA_VAL_LO_SOURCE_EXTERNAL (0)
        /// Uses an external LO as the LO source.
        /// NIWLANA_VAL_LO_SOURCE_ONBOARD (2)
        /// Uses an internal LO as the LO source.
        /// 
        ///</param>
        ///<param name = "externalLOHandles">
        /// Identifies the instrument sessions of external LO devices. The toolkit obtains this parameter from the niRFSG_init or niRFSG_InitWithOptions functions
        /// 
        ///</param>
        ///<param name = "carrierFrequencies">
        /// Specifies the carrier frequencies used to analyze signals. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "dataArraySize">
        /// Specifies the number of elements in the carrierFrequency array. This value should be the same as the value you set for the NIWLANA_NUMBER_OF_SEGMENTS attribute.
        /// 
        ///</param>
        ///<param name = "rfsaLODaisyChainEnabled">
        /// Specifies whether to export the LO signal from one RFSA device to the next. The default value is FALSE.
        /// 
        ///</param>
        ///<param name = "LOExportToExternalDevicesEnabled">
        /// Specifies whether to export the LO signal from each RFSA device on its LO OUT terminal, which you can use to share the LO signal with an external device. An example of an external device would be an RFSG device. The default value is FALSE.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAConfigureFrequencyMultipleLO
        /// int32 __stdcall niWLANA_RFSAConfigureFrequencyMultipleLO (niWLANA session,
        ///     ViSession rfsaSessions[],
        ///     int32 numberOfRFSASessions,
        ///     int32 LOSource,
        ///     ViSession externalLOHandles[],
        ///     int32 numberOfLOHandles,
        ///     float64 carrierFrequencies[],
        ///     int32 dataArraySize,
        ///     int32 rfsaLODaisyChainEnabled,
        ///     int32 LOExportToExternalDevicesEnabled);
        /// Purpose
        /// Configures frequency on NI RF vector signal analyzers, and NI RF synthesizers. NI RF synthesizers are used as external local oscillator (LO) devices. This function also configures LO frequency offset based on the NIWLANA_LO_FREQUENCY_OFFSET_MODE  and NIWLANA_LO_FREQUENCY_OFFSET attributes. This function equally divides the NI RF vector signal analyzers and NI RF synthesizers into sets such that each set corresponds to one carrier frequency. The number of sets is equal to the size of the carrierFrequencies array. In each set, the first NI RF vector signal analyzer is used as the master device for LO daisy chaining. It also configures the NIWLANA_CARRIER_FREQUENCY attribute.
        /// 
        ///</returns>
        public int RFSAConfigureFrequencyMultipleLO(HandleRef[] rfsaHandles, int LOSource, HandleRef[] externalLOHandles, double[] carrierFrequencies, int dataArraySize, int rfsaLODaisyChainEnabled, int LOExportToExternalDevicesEnabled)
        {
            Int32[] rfsaPtrs = new Int32[rfsaHandles.Length];
            rfsaPtrs = Array.ConvertAll<HandleRef, Int32>(rfsaHandles, x => x.Handle.ToInt32());
            Int32[] exteralLOSessions = GetInt32Sessions(externalLOHandles);
            int pInvokeResult = PInvoke.niWLANA_RFSAConfigureFrequencyMultipleLO(Handle, rfsaPtrs, rfsaHandles.Length, LOSource, exteralLOSessions, externalLOHandles.Length, carrierFrequencies, dataArraySize, rfsaLODaisyChainEnabled, LOExportToExternalDevicesEnabled);
            TestForError(pInvokeResult, rfsaHandles);
            return pInvokeResult;
        }

        /// <summary>
        ///Returns the index of the first space-time stream of the user in the 802.11ax signal. This value is derived from the    Spatial Configuration field of the HE-SIG-B field. 
        ///    If you set the NIWLANA_STANDARD attribute to NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM and the NIWLANA_OFDM_PPDU_TYPE attribute    to NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, you must use 'userx' as the active    channel string syntax to query this attribute. 
        ///     Get Function: niWLANA_GetOFDMDemodSpaceTimeStreamOffset
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodSpaceTimeStreamOffset(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodSpaceTimeStreamOffset, channelString, out value);
        }

        /// <summary>
        /// Performs an acquisition, and configures the best reference level or vertical range for the NI vector signal analyzer based on the peak power or the voltage of the measured signal. This function configures the optimal reference level for EVM, if you set the NIWLANA_OPTIMIZE_REFERENCE_LEVEL_FOR_EVM_ENABLED attribute to NIWLANA_VAL_TRUE. You must configure the NIWLANA_STANDARD, NIWLANA_CHANNEL_BANDWIDTH and NIWLANA_OPTIMIZE_REFERENCE_LEVEL_FOR_EVM_ENABLED attributes before calling this function.
        /// If you set the NIRFSA_ATTR_INPUT_PORT attribute to NIRFSA_VAL_RF_IN or NIRFSA_VAL_IQ_IN, this function calculates the reference level or the vertical range respectively, and configures the value on NI-RFSA.
        /// 
        /// </summary>
        ///<param name = "rFSASession">
        /// Specifies a reference to an NI-RFSA instrument session. This parameter is obtained from the niRFSA_init or niRFSA_InitWithOptions functions and identifies a particular instrument session. 
        /// 
        ///</param>
        ///<param name = "channelString">
        /// Specifies the RFSA device channel. Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "measurementInterval">
        /// Specifies the acquisition length. This value is expressed in seconds. The toolkit uses this value to compute the number of samples to acquire from NI RF vector signal analyzer. The default value is 0.01.
        /// 
        ///</param>
        ///<param name = "maximumNumberOfIterations">
        /// Specifies the maximum number of iterations used to calculate the NI RF vector signal analyzer reference level. The default value is 5.
        ///</param>
        ///<param name = "resultantReferenceLevel">
        /// Returns the NI RF vector signal analyzer reference level or the vertical range to measure the input signal. The reference level value is exressed in dBm. The vertical range value is expressed in volts (V). Use this value to configure the NIRFSA_ATTR_REFERENCE_LEVEL or NIRFSA_ATTR_DIGITIZER_VERTICAL_RANGE attribute.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAAutoLevelv2
        /// int32 __stdcall niWLANA_RFSAAutoLevelv2 (niWLANA session, 
        ///     ViSession rfsaHandle,
        ///     char hwChannelString[], 
        ///     float64 measurementIntervalSec,
        ///     int maximumNumberOfIterations,
        ///     float64* resultantReferenceLevel);
        /// Purpose
        /// Performs an acquisition, and configures the best reference level or vertical range for the NI vector signal analyzer based on the peak power or the voltage of the measured signal. This function configures the optimal reference level for EVM, if you set the NIWLANA_OPTIMIZE_REFERENCE_LEVEL_FOR_EVM_ENABLED attribute to NIWLANA_VAL_TRUE. You must configure the NIWLANA_STANDARD, NIWLANA_CHANNEL_BANDWIDTH and NIWLANA_OPTIMIZE_REFERENCE_LEVEL_FOR_EVM_ENABLED attributes before calling this function.
        /// If you set the NIRFSA_ATTR_INPUT_PORT attribute to NIRFSA_VAL_RF_IN or NIRFSA_VAL_IQ_IN, this function calculates the reference level or the vertical range respectively, and configures the value on NI-RFSA.
        /// 
        ///</returns>
        public int RFSAAutoLevelv2(HandleRef rFSASession, string channelString, double measurementInterval, int maximumNumberOfIterations, out double resultantReferenceLevel)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAAutoLevelv2(Handle, rFSASession.Handle.ToInt32(), channelString, measurementInterval, maximumNumberOfIterations, out resultantReferenceLevel);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Configures the reference level on the NI vector signal analyzer after applying optimization for EVM that uses inherent room in the dynamic range of the device. The optimization lowers the reference level from user-specified peak power by a factor that depends upon the user-specified peak power and carrier frequency. You can adjust the factor further by configuring the NIWLANA_OPTIMIZE_REFERENCE_LEVEL_FOR_EVM_MARGIN attribute. You must set the NIWLANA_OPTIMIZE_REFERENCE_LEVEL_FOR_EVM_ENABLED attribute to NIWLANA_VAL_TRUE to enable the optimization.
        /// 
        /// </summary>
        ///<param name = "rFSASession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSA_init or niRFSA_InitWithOptions functions. 
        /// 
        ///</param>
        ///<param name = "channelString">
        /// Specifies the RFSA device channel. Set this parameter to "" (empty string) or NULL.
        /// 
        ///</param>
        ///<param name = "peakPower">
        /// Specifies the expected peak power at the input of NI vector signal analyzer. This value is expressed in dBm. The default value is 0.
        /// 
        ///</param>
        ///<param name = "referenceLevel">
        /// Returns the reference level optimized for EVM. This value is expressed in dBm.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAConfigureOptimalEVMReferenceLevel
        /// int32 __stdcall niWLANA_RFSAConfigureOptimalEVMReferenceLevel
        /// (niWLANA session, 
        ///     ViSession rfsaHandle,
        ///     char hwChannelString[], 
        ///     float64 peakPower,
        ///     float64* optimalReferenceLevel);
        /// Purpose
        /// Configures the reference level on the NI vector signal analyzer after applying optimization for EVM that uses inherent room in the dynamic range of the device. The optimization lowers the reference level from user-specified peak power by a factor that depends upon the user-specified peak power and carrier frequency. You can adjust the factor further by configuring the NIWLANA_OPTIMIZE_REFERENCE_LEVEL_FOR_EVM_MARGIN attribute. You must set the NIWLANA_OPTIMIZE_REFERENCE_LEVEL_FOR_EVM_ENABLED attribute to NIWLANA_VAL_TRUE to enable the optimization.
        /// 
        ///</returns>
        public int RFSAConfigureOptimalEVMReferenceLevel(HandleRef rFSASession, string channelString, double peakPower, out double referenceLevel)
        {
            int pInvokeResult = PInvoke.niWLANA_RFSAConfigureOptimalEVMReferenceLevel(Handle, rFSASession.Handle.ToInt32(), channelString, peakPower, out referenceLevel);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Measures the noise floor of the NI vector signal analyzers. The measured noise floor values are used to compensate EVM results during OFDM demod measurement when you set the NIWLANA_NOISE_COMPENSATION_ENABLED attribute to NIWLANA_VAL_TRUE. Measure the noise floor only if you want to perform measurement with noise compensation.
        /// You must ensure that there is no high power signal present at the RF In port of the analyzer while it is measuring the noise floor. If you have a device-under-test (DUT) connected to the analyzer, you must ensure that the device is not transmitting any signal.
        /// You must specify LO daisy chain settings that match physical connections on hardware. You must use the same LO daisy chain settings and connections when performing measurement with noise compensation.
        /// If you perform self-calibration on the NI vector signal analyzer, you must perform noise floor measurement again.
        /// Refer to the Calibration of NI Vector Signal Transceiver Devices for WLAN Measurements topic for more information.
        /// 
        /// </summary>
        ///<param name = "instrHandle">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSA_init or niRFSA_InitWithOptions functions. 
        /// 
        ///</param>
        ///<param name = "externalLOHandle">
        /// Specifies the instrument session for an external local oscillator (LO) device.
        /// 
        ///</param>
        ///<param name = "LOSource">
        /// Specifies the source of the LO signal for the device. The default value is NIWLANA_VAL_LO_SOURCE_EXTERNAL.
        /// NIWLANA_VAL_LO_SOURCE_EXTERNAL (0)
        /// Uses the LO signal from an external LO device.
        /// NIWLANA_VAL_LO_SOURCE_PREVIOUS_DEVICE (1)
        /// Uses the LO signal from a previous device in the LO daisy chain settings array, forming a daisy chain.
        /// NIWLANA_VAL_LO_SOURCE_ONBOARD (2)
        /// Uses the onboard LO as the source of local oscillator signal.
        /// 
        ///</param>
        ///<param name = "PortType">
        /// Specifies whether the port on the device is NIWLANA_VAL_PORT_TYPE_RF_IN or NIWLANA_VAL_PORT_TYPE_RF_OUT. If the device is an NI vector signal analyzer, then you must choose port type as NIWLANA_VAL_PORT_TYPE_RF_IN. The default value is NIWLANA_VAL_PORT_TYPE_RF_IN. If the device is an NI vector signal generator, then you must choose port type as NIWLANA_VAL_PORT_TYPE_RF_OUT.
        /// NIWLANA_VAL_PORT_TYPE_RF_IN (0)
        /// Indicates that the device is an NI vector signal analyzer.
        /// NIWLANA_VAL_PORT_TYPE_RF_OUT (1)
        /// Indicates that the device is an NI vector signal generator.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSAMeasureNoiseFloor
        /// int32 __stdcall niWLANA_RFSAMeasureNoiseFloor (niWLANA session,
        ///     ViSession instrSessions[],
        ///     ViSession externalLOHandle,
        ///     int32 LOSource[],
        ///     int32 portType[],
        ///     int32 dataArraySize);
        /// Purpose
        /// Measures the noise floor of the NI vector signal analyzers. The measured noise floor values are used to compensate EVM results during OFDM demod measurement when you set the NIWLANA_NOISE_COMPENSATION_ENABLED attribute to NIWLANA_VAL_TRUE. Measure the noise floor only if you want to perform measurement with noise compensation.
        /// You must ensure that there is no high power signal present at the RF In port of the analyzer while it is measuring the noise floor. If you have a device-under-test (DUT) connected to the analyzer, you must ensure that the device is not transmitting any signal.
        /// You must specify LO daisy chain settings that match physical connections on hardware. You must use the same LO daisy chain settings and connections when performing measurement with noise compensation.
        /// If you perform self-calibration on the NI vector signal analyzer, you must perform noise floor measurement again.
        /// Refer to the Calibration of NI Vector Signal Transceiver Devices for WLAN Measurements topic for more information.
        /// 
        ///</returns>
        public int RFSAMeasureNoiseFloor(HandleRef[] instrHandle, HandleRef externalLOHandle, Int32[] LOSource, Int32[] PortType)
        {
            Int32 exteralLOSessions = GetInt32Sessions(externalLOHandle);
            Int32[] rfsaPtrs = new Int32[instrHandle.Length];
            rfsaPtrs = Array.ConvertAll<HandleRef, Int32>(instrHandle, x => x.Handle.ToInt32());

            int pInvokeResult = PInvoke.niWLANA_RFSAMeasureNoiseFloor(Handle, rfsaPtrs, exteralLOSessions, LOSource, PortType, instrHandle.Length);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }


        /// <summary>
        /// Returns the unused tone error trace and the unused tone error mask for the analyzed 802.11ax Trigger-Based PPDU signal.
        /// Refer to the Unused Tone Error Measurement topic for more information.
        ///  You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute value
        ///                     Active channel string syntax
        ///                                     NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"[segmentx/]channely" if the value of the value of the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute is NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. "segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "RUIndex">
        /// Returns an array of indexes of 26-tone RUs, assuming the entire bandwidth is composed of 26-tone resource units (RUs).
        /// 
        ///</param>
        ///<param name = "UnusedToneErrorMask">
        /// Returns the unused tone error mask computed based on the MCS index of the occupied RU.
        /// 
        ///</param>
        ///<param name = "UnusedToneError">
        /// Returns the unused tone error for each RU index. This value is expressed in dB.
        /// 
        ///</param>
        ///<param name = "actualDataArraySize">
        /// Returns the number of elements in the RUIndex, unusedToneErrorMask and unusedToneError arrays. If the arrays are not large enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output arrays. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetOFDMDemodUnusedToneErrorTrace
        /// int32 __stdcall niWLANA_GetOFDMDemodUnusedToneErrorTrace (niWLANA session,
        ///     char channelString[], 
        ///     int32 RUIndex[],
        ///     float64 unusedToneErrorMask[],
        ///     float64 unusedToneError[],
        ///     int32 dataArraySize,
        ///     int32 *actualArraySize);
        /// Purpose
        /// Returns the unused tone error trace and the unused tone error mask for the analyzed 802.11ax Trigger-Based PPDU signal.
        /// Refer to the Unused Tone Error Measurement topic for more information.
        ///  You must use the following active channel string formats to query this function.
        ///                                                     NIWLANA_STANDARD attribute value
        ///                     Active channel string syntax
        ///                                     NIWLANA_VAL_STANDARD_80211AX_MIMO_OFDM
        /// 					"[segmentx/]channely" if the value of the value of the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE attribute is NIWLANA_VAL_OFDM_DEMOD_TRIGGER_BASED_PPDU. "segment0/" is optional if the NIWLANA_NUMBER_OF_SEGMENTS attribute is set to 1
        /// 
        ///</returns>
        public int GetOFDMDemodUnusedToneErrorTrace(string channelString, int[] RUIndex, double[] UnusedToneErrorMask, double[] UnusedToneError,
                                                     out int actualDataArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetOFDMDemodUnusedToneErrorTrace(Handle, channelString, RUIndex, UnusedToneErrorMask, UnusedToneError, UnusedToneError.Length, out actualDataArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the sequence of bits obtained from the signal after decoding the header field for the 802.11ax signals.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "decodedHESIGABitsTrace">
        /// Returns an array of bits in the HE-SIG-A field.
        /// 
        ///</param>
        ///<param name = "actualDecodedHESIGABitsTraceSize">
        /// Returns the number of elements in the decodedHESIGABitsTrace array. If the decodedHESIGABitsTrace array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<param name = "decodedHESIGBBitsTrace">
        /// Returns an array of bits in the HE-SIG-B field. If the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE is a value other than NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, the HE-SIG-B field returns an empty array. 
        /// 
        ///</param>
        ///<param name = "actualdecodedHESIGBBitsTraceSize">
        /// Returns the number of elements in the decodedHESIGBBitsTrace array. If the decodedHESIGBBitsTrace array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<param name = "decodedLSIGBitsTrace">
        /// Returns an array of bits in the L-SIG field.
        /// 
        ///</param>
        ///<param name = "actualDecodedLSIGBitsTraceSize">
        /// Returns the number of elements in the decodedLSIGBitsTrace array. If the decodedLSIGBitsTrace array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211ax
        /// int32 __stdcall niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211ax (niWLANA session,
        ///     char channelString[], 
        ///     int32 decodedHESIGABitsTrace[],
        ///     int32 *actualDecodedHESIGABitsTraceSize,
        ///     int32 decodedHESIGBBitsTrace[],
        ///     int32 *actualdecodedHESIGBBitsTraceSize,
        ///     int32 decodedLSIGBitsTrace[],
        ///     int32 *actualDecodedLSIGBitsTraceSize);
        /// Purpose
        /// Returns the sequence of bits obtained from the signal after decoding the header field for the 802.11ax signals.
        /// 
        ///</returns>
        public int GetCurrentIterationDecodedHeaderBitsTrace80211ax(string channelString, int[] decodedHESIGABitsTrace, out int actualDecodedHESIGABitsTraceSize,
                                                                    int[] decodedHESIGBBitsTrace, out int actualdecodedHESIGBBitsTraceSize,
                                                                    int[] decodedLSIGBitsTrace, out int actualDecodedLSIGBitsTraceSize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211ax(Handle, channelString, decodedHESIGABitsTrace, decodedHESIGABitsTrace.Length,
                                                                                                  out actualDecodedHESIGABitsTraceSize, decodedHESIGBBitsTrace, decodedHESIGBBitsTrace.Length,
                                                                                                  out actualdecodedHESIGBBitsTraceSize, decodedLSIGBitsTrace, decodedLSIGBitsTrace.Length,
                                                                                                  out actualDecodedLSIGBitsTraceSize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the sequence of bits obtained from the signal after decoding the header field for the 802.11n signals.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// 
        ///</param>
        ///<param name = "decodedHTSIGBitsTrace">
        /// Returns an array of bits in the HT-SIG field. 
        /// 
        ///</param>
        ///<param name = "actualDecodedHTSIGBitsTraceSize">
        /// Returns the number of elements in the decodedHTSIGBitsTrace array. If the decodedHTSIGBitsTrace array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<param name = "decodedLSIGBitsTrace">
        /// Returns an array of bits in the L-SIG field. If the NIWLANA_RESULT_OFDM_DEMOD_80211N_PLCP_FRAME_FORMAT is NIWLANA_VAL_80211N_PLCP_FRAME_FORMAT_GREENFIELD, this parameter returns an empty array.
        /// 
        ///</param>
        ///<param name = "actualdecodedLSIGBitsTrace">
        /// Returns the number of elements in the decodedLSIGBitsTrace array. If the decodedLSIGBitsTrace array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211n
        /// int32 __stdcall niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211n (niWLANA session,
        ///     char channelString[], 
        ///     int32 decodedHTSIGBitsTrace[],
        ///     int32 decodedHTSIGBitsTraceSize,
        ///     int32 *actualDecodedHTSIGBitsTraceSize,
        ///     int32 decodedLSIGBitsTrace[],
        ///     int32 decodedLSIGBitsTracetSize,
        ///     int32 *actualdecodedLSIGBitsTrace);
        /// Purpose
        /// Returns the sequence of bits obtained from the signal after decoding the header field for the 802.11n signals.
        /// 
        ///</returns>
        public int GetCurrentIterationDecodedHeaderBitsTrace80211n(string channelString, int[] decodedHTSIGBitsTrace, out int actualDecodedHTSIGBitsTraceSize,
                                                                   int[] decodedLSIGBitsTrace, out int actualdecodedLSIGBitsTrace)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211n(Handle, channelString, decodedHTSIGBitsTrace, decodedHTSIGBitsTrace.Length, out actualDecodedHTSIGBitsTraceSize,
                                                                                                decodedLSIGBitsTrace, decodedLSIGBitsTrace.Length, out actualdecodedLSIGBitsTrace);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the sequence of bits obtained from the signal after decoding the header field for the 802.11ac signals.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "decodedLSIGBitsTrace">
        /// Returns an array of bits in the L-SIG field.
        /// 
        ///</param>
        ///<param name = "actualDecodedLSIGBitsTraceSize">
        /// Returns the number of elements in the decodedLSIGBitsTrace array. If the decodedLSIGBitsTrace array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<param name = "decodedVHTSIGABitsTrace">
        /// Returns an array of bits in the VHT-SIG-A field.
        /// 
        ///</param>
        ///<param name = "actualDecodedVHTSIGABitsTraceSize">
        /// Returns the number of elements in the decodedVHTSIGABitsTrace array. If the decodedVHTSIGABitsTrace array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<param name = "decodedVHTSIGBBitsTrace">
        /// Returns an array of bits in the VHT-SIG-B field. This trace is an array of the decoded bits. When the NIWLANA_RESULT_OFDM_DEMOD_PPDU_TYPE is NIWLANA_VAL_OFDM_DEMOD_PPDU_TYPE_MU_PPDU, the array has VHT-SIG-B bits of all users appended in the order of users.
        /// 
        ///</param>
        ///<param name = "actualDecodedVHTSIGBBitsTraceSize">
        /// Returns the number of elements in the decodedVHTSIGBBitsTrace array. If the decodedVHTSIGBBitsTrace array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211ac
        /// int32 __stdcall niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211ac (niWLANA session,
        ///     char channelString[], 
        ///     int32 decodedLSIGBitsTrace[],
        ///     int32 decodedLSIGBitsTraceSize,
        ///     int32 *actualdecodedLSIGBitsTraceSize,
        ///     int32 decodedVHTSIGABitsTrace[],
        ///     int32 decodedVHTSIGABitsTraceSize,
        ///     int32 actualdecodedVHTSIGABitsTraceSize,
        ///     int32 decodedVHTSIGBBitsTrace[],
        ///     int32 decodedVHTSIGBBitsTraceSize,
        ///     int32 actualdecodedVHTSIGBBitsTraceSize);
        /// Purpose
        /// Returns the sequence of bits obtained from the signal after decoding the header field for the 802.11ac signals.
        /// 
        ///</returns>
        public int GetCurrentIterationDecodedHeaderBitsTrace80211ac(string channelString, Int32[] decodedLSIGBitsTrace, out int actualDecodedLSIGBitsTraceSize, Int32[] decodedVHTSIGABitsTrace,
                                                                    out int actualDecodedVHTSIGABitsTraceSize, Int32[] decodedVHTSIGBBitsTrace, out int actualDecodedVHTSIGBBitsTraceSize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211ac(Handle, channelString, decodedLSIGBitsTrace, decodedLSIGBitsTrace.Length, out actualDecodedLSIGBitsTraceSize,
                                decodedVHTSIGABitsTrace, decodedVHTSIGABitsTrace.Length, out actualDecodedVHTSIGABitsTraceSize, decodedVHTSIGBBitsTrace, decodedVHTSIGBBitsTrace.Length, out actualDecodedVHTSIGBBitsTraceSize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the Complementary Cumulative Distribution Function (CCDF) trace of the absolute carrier frequency offsets measured on the 802.11ax Trigger-Based PPDUs over the number of averages. You can query this trace when you set the NIWLANA_OFDM_DEMOD_TRACE_SETTINGS_CARRIER_FREQUENCY_OFFSET_CCDF_TRACE_ENABLED and NIWLANA_OFDM_DEMOD_CARRIER_FREQUENCY_OFFSET_ESTIMATION_ENABLED attributes to NIWLANA_VAL_TRUE.
        /// 
        /// </summary>
        ///<param name = "channelString">
        ///</param>
        ///<param name = "minBin">
        /// Indicates the bin centered at the minimum absolute carrier frequency offset value.
        /// 
        ///</param>
        ///<param name = "binSize">
        /// Indicates the size of each bin. 
        /// 
        ///</param>
        ///<param name = "CCDF">
        /// Indicates an array of CCDF values of the absolute carrier frequency offsets.
        /// 
        ///</param>
        ///<param name = "actualCCDFArraySize">
        /// Returns the number of elements in the CCDF array. If the CCDF array is not large enough to hold all the samples, the function returns an error and this parameter returns the minimum expected size of the CCDF array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetOFDMDemodCarrierFrequencyOffsetCCDFTrace
        /// int32 __stdcall niWLANA_GetOFDMDemodCarrierFrequencyOffsetCCDFTrace(
        ///     niWLANA session, 
        ///     char channelString[], 
        ///     double *minBin,
        ///     double *binSize,
        ///     double CCDF[],
        ///     int CCDFArraySize,
        ///     int *actualCCDFArraySize);
        /// Purpose
        /// Returns the Complementary Cumulative Distribution Function (CCDF) trace of the absolute carrier frequency offsets measured on the 802.11ax Trigger-Based PPDUs over the number of averages. You can query this trace when you set the NIWLANA_OFDM_DEMOD_TRACE_SETTINGS_CARRIER_FREQUENCY_OFFSET_CCDF_TRACE_ENABLED and NIWLANA_OFDM_DEMOD_CARRIER_FREQUENCY_OFFSET_ESTIMATION_ENABLED attributes to NIWLANA_VAL_TRUE.
        /// 
        ///</returns>
        public int GetOFDMDemodCarrierFrequencyOffsetCCDFTrace(string channelString, out double minBin, out double binSize, double[] CCDF,
                                                                       out int actualCCDFArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetOFDMDemodCarrierFrequencyOffsetCCDFTrace(Handle, channelString, out minBin, out binSize, CCDF,
                                                                                            CCDF.Length, out actualCCDFArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Loads the noise compensation data in the toolkit session if you set the NIWLANA_NOISE_COMPENSATION_ENABLED attribute to NIWLANA_VAL_TRUE. The noise compensation data includes the noise floor measurement data of the NI vector signal analyzer and reference level settings used during noise floor measurement. The toolkit uses noise floor measurement data to compensate EVM results during OFDM demod measurement. The function loads the data only if it is not loaded already. You must set the forceLoad parameter to TRUE to load the new data if you run the noise floor measurement on the NI vector signal analyzers while the process in which OFDM demod measurement is performed is running.
        /// 
        /// </summary>
        ///<param name = "rFSASession">
        /// Identifies the instrument session. The toolkit obtains this parameter from the niRFSA_init or niRFSA_InitWithOptions functions. 
        /// 
        ///</param>
        ///<param name = "forceLoad">
        /// Loads the latest noise compensation data in the toolkit session even if it is loaded already. 
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_RFSALoadNoiseCompensationData
        /// int32 __stdcall niWLANA_RFSALoadNoiseCompensationData (niWLANA session, 
        ///     ViSession rfsaSession,
        ///     int32 forceLoad);
        /// Purpose
        /// Loads the noise compensation data in the toolkit session if you set the NIWLANA_NOISE_COMPENSATION_ENABLED attribute to NIWLANA_VAL_TRUE. The noise compensation data includes the noise floor measurement data of the NI vector signal analyzer and reference level settings used during noise floor measurement. The toolkit uses noise floor measurement data to compensate EVM results during OFDM demod measurement. The function loads the data only if it is not loaded already. You must set the forceLoad parameter to TRUE to load the new data if you run the noise floor measurement on the NI vector signal analyzers while the process in which OFDM demod measurement is performed is running.
        /// 
        ///</returns>
        public int RFSALoadNoiseCompensationData(HandleRef rFSASession, int forceLoad)
        {

            int pInvokeResult = PInvoke.niWLANA_RFSALoadNoiseCompensationData(Handle, rFSASession, forceLoad);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        /// Returns the sequence of bits obtained from the signal after decoding the header field for the 802.11a/g, 802.11j and 802.11p signals.
        /// 
        /// </summary>
        ///<param name = "channelString">
        /// 
        ///</param>
        ///<param name = "decodedSignalBitsTrace">
        /// Returns an array of bits in the SIGNAL field.
        /// 
        ///</param>
        ///<param name = "actualdecodedSignalBitsTrace">
        /// Returns the number of elements in the decodedSignalBitsTrace array. If the decodedSignalBitsTrace array is not large
        /// enough to hold all the samples, the function returns an error and this parameter returns the minimum
        /// expected size of the output array.
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211agjp
        /// int32 __stdcall niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211agjp (niWLANA session,
        ///     char channelString[], 
        ///     int32 decodedSignalBitsTrace[],
        ///     int32 decodedSignalBitsTraceSize,
        ///     int32 *actualdecodedSignalBitsTrace);
        /// Purpose
        /// Returns the sequence of bits obtained from the signal after decoding the header field for the 802.11a/g, 802.11j and 802.11p signals.
        /// 
        ///</returns>
        public int GetCurrentIterationDecodedHeaderBitsTrace80211agjp(string channelString, int[] decodedSignalBitsTrace,
                                                                      out int actualdecodedSignalBitsTrace)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211agjp(Handle, channelString, decodedSignalBitsTrace, decodedSignalBitsTrace.Length,
                                                                                                   out actualdecodedSignalBitsTrace);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        /// <summary>
        ///Specifies whether to enable the carrier frequency offset CCDF trace for 802.11ax Trigger-Based PPDU signals. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodCarrierFrequencyOffsetCCDFTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCarrierFrequencyOffsetCCDFTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodCarrierFrequencyOffsetCCDFTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodTraceSettingCarrierFrequencyOffsetCcdfTraceEnabled, channelString, value);
        }

        /// <summary>
        ///Specifies whether to enable the carrier frequency offset CCDF trace for 802.11ax Trigger-Based PPDU signals. 
        ///    The default value is NIWLANA_VAL_FALSE.
        ///    Get Function: niWLANA_GetOFDMDemodCarrierFrequencyOffsetCCDFTraceEnabled
        ///    Set Function: niWLANA_SetOFDMDemodCarrierFrequencyOffsetCCDFTraceEnabled
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodCarrierFrequencyOffsetCCDFTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodTraceSettingCarrierFrequencyOffsetCcdfTraceEnabled, channelString, out value);
        }

        /// <summary>
        ///Specifies the method the toolkit uses to estimate the channel frequency response.
        ///    The default value is NIWLANA_VAL_CHANNEL_ESTIMATION_METHOD_PREAMBLE.
        ///    Get Function: niWLANA_GetOFDMDemodChannelEstimationMethod
        ///    Set Function: niWLANA_SetOFDMDemodChannelEstimationMethod
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodChannelEstimationMethod(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodChannelEstimationMethod, channelString, value);
        }

        /// <summary>
        ///Specifies the method the toolkit uses to estimate the channel frequency response.
        ///    The default value is NIWLANA_VAL_CHANNEL_ESTIMATION_METHOD_PREAMBLE.
        ///    Get Function: niWLANA_GetOFDMDemodChannelEstimationMethod
        ///    Set Function: niWLANA_SetOFDMDemodChannelEstimationMethod
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodChannelEstimationMethod(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodChannelEstimationMethod, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodCarrierFrequencyOffsetCCDFTenPercent(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.ResultOfdmDemodCarrierFrequencyOffsetCcdfTenPercent, channelString, out value);
        }

        /// <summary>
        /// Calculates the carrier frequency of 802.11ax channels.
        /// 
        /// </summary>
        ///<param name = "channelStartingFrequency">
        /// Specifies the start frequency of the frequency band. This value is expressed in Hz.
        /// 
        ///</param>
        ///<param name = "channelBandwidth">
        /// Specifies offset of the center frequency, in increments of 5 MHz, above the starting frequency of the channel. 
        /// The default value is 1.
        /// 
        ///</param>
        ///<param name = "carrierFrequency">
        /// Returns the carrier frequency. This value is expressed in Hz.The function calculates the carrier frequency using the following equation:
        /// Carrier frequency (Hz) = channel starting frequency (Hz) + (channel number * 5 MHz).
        /// 
        ///</param>
        ///<returns>
        /// 
        ///niWLANA_ChannelNumberToCarrierFrequency80211ax
        /// int32 __stdcall niWLANG_ChannelNumberToCarrierFrequency80211ax (float64 channelStartingFrequency, 
        ///     int32 channelNumber, 
        ///     float64 *carrierFrequency)
        /// Purpose
        /// Calculates the carrier frequency of 802.11ax channels.
        /// 
        ///</returns>
        public int ChannelNumberToCarrierFrequency80211ax(double channelStartingFrequency, double channelBandwidth, out double carrierFrequency)
        {
            int pInvokeResult = PInvoke.niWLANA_ChannelNumberToCarrierFrequency80211ax(channelStartingFrequency, channelBandwidth, out  carrierFrequency);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        #endregion

        #region 17.1
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetSpaceTimeStreamOffset(string channelString, int value)
        {
            return SetInt(niWLANAProperties.SpaceTimeStreamOffset, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetSpaceTimeStreamOffset(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.SpaceTimeStreamOffset, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetMUMimoLtfModeEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.MuMimoLtfModeEnabled, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetMUMimoLtfModeEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.MuMimoLtfModeEnabled, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodIQImpairmentsCompensationEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodUserDefinedIQImpairmentsCompensationEnabled, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodIQImpairmentsCompensationEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodUserDefinedIQImpairmentsCompensationEnabled, channelString, out value);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodIQGainImbalance(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.OfdmDemodUserDefinedIQGainImbalance, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodIQGainImbalance(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemodUserDefinedIQGainImbalance, channelString, out value);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodQuadratureSkew(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.OfdmDemodUserDefinedQuadratureSkew, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodQuadratureSkew(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemodUserDefinedQuadratureSkew, channelString, out value);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodTimingSkew(string channelString, double value)
        {
            return SetDouble(niWLANAProperties.OfdmDemodUserDefinedTimingSkew, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodTimingSkew(string channelString, out double value)
        {
            return GetDouble(niWLANAProperties.OfdmDemodUserDefinedTimingSkew, channelString, out value);
        }



        #endregion

        #region 18.0

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetMidamblePeriodicity(string channelString, int value)
        {
            return SetInt(niWLANAProperties.MidamblePeriodicity, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetMidamblePeriodicity(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.MidamblePeriodicity, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMDemodIQGainImbalancePerSubcarrierTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodIQGainImbalancePerSubcarrierTraceEnabled, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMDemodIQGainImbalancePerSubcarrierTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodIQGainImbalancePerSubcarrierTraceEnabled, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodQuadratureSkewPerSubcarrierTraceEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodQuadratureSkewPerSubcarrierTraceEnabled, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodQuadratureSkewPerSubcarrierTraceEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodQuadratureSkewPerSubcarrierTraceEnabled, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOfdmDemodIQImpairmentsPerSubcarrierEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OfdmDemodIQImpairmentsPerSubcarrierEnabled, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmDemodIQImpairmentsPerSubcarrierEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OfdmDemodIQImpairmentsPerSubcarrierEnabled, channelString, out value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOfdmMidamblePeriodicity(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.ResultOfdmDemodMidamblePeriodicity, channelString, out value);
        }


        public int GetCurrentIterationOfdmDemodIQGainImbalancePerSubcarrierTrace(string channelString, double[] IQGainImbalance, Int32[] subcarrierIndices, int dataArraySize ,out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOfdmDemodIQGainImbalancePerSubcarrierTrace(Handle, channelString, IQGainImbalance, subcarrierIndices, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        public int GetCurrentIterationOfdmDemodQuadratureSkewPerSubcarrierTrace(string channelString, double[] quadratureSkew, Int32[] subcarrierIndices, int dataArraySize, out int actualArraySize)
        {
            int pInvokeResult = PInvoke.niWLANA_GetCurrentIterationOfdmDemodQuadratureSkewPerSubcarrierTrace(Handle, channelString, quadratureSkew, subcarrierIndices, dataArraySize, out actualArraySize);
            TestForError(pInvokeResult);
            return pInvokeResult;
        }

        #endregion 
	
	#region 19.1
	
	public int RFSAForceTClkSynchronization(HandleRef[] rfsaHandles, int forceSync)
        {
            Int32[] rfsaPtrs = new Int32[rfsaHandles.Length];
            rfsaPtrs = Array.ConvertAll<HandleRef, Int32>(rfsaHandles, x => x.Handle.ToInt32());
            int pInvokeResult = PInvoke.niWLANA_RFSAForceTClkSynchronization(Handle, rfsaPtrs, rfsaHandles.Length, forceSync);
            TestForError(pInvokeResult, rfsaHandles);
            return pInvokeResult;
        }
	
	/// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int SetOFDMChannelEstimationOnLLTFEnabled(string channelString, int value)
        {
            return SetInt(niWLANAProperties.OFDMChannelEstimationOnLLTFEnabled, channelString, value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channelString"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public int GetOFDMChannelEstimationOnLLTFEnabled(string channelString, out int value)
        {
            return GetInt(niWLANAProperties.OFDMChannelEstimationOnLLTFEnabled, channelString, out value);
        }
	
	#endregion
	
        /// <summary>
        /// 
        /// Closes the niWLANA generation session and releases resources associated with that session. Call this function once for each unique named session that you have created.
        /// 
        /// </summary>
        /// <returns>
        /// Returns the status code of this operation. The status code either indicates success or describes an error or warning condition. Examine the status code from each call to an niGSM generation function to determine if an error has occurred.
        /// To obtain a text description of the status code and additional information about the error condition, call the GetErrorString function.
        /// The general meaning of the status code is as follows:
        /// 
        /// Value           Meaning
        /// ----------------------------------------
        /// 0               Success 
        /// Positive Values Warnings 
        /// Negative Values Exception will be thrown
        /// </returns>
        public void Close()
        {
            if (!_isNamedSession)
                Dispose();
            else
            {
                if (!Handle.Handle.Equals(IntPtr.Zero))
                    PInvoke.niWLANA_CloseSession(Handle);
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public int DeallocateMemory()
        {
            return TestForError(PInvoke.niWLANA_DeallocateMemory());
        }


        private static Int32 GetInt32Sessions(HandleRef session)
        {
            Int32 int32sessions = 0;
            if (session.Handle.ToInt32() > 0)
            {
                int32sessions = session.Handle.ToInt32();
            }
            return int32sessions;
        }

        private static Int32[] GetInt32Sessions(HandleRef[] sessions)
        {
            Int32[] int32sessions = null;
            if (sessions != null)
            {
                int32sessions = new Int32[sessions.Length];
                for (int i = 0; i < sessions.Length; i++)
                {
                    int32sessions[i] = sessions[i].Handle.ToInt32();
                }
            }
            return int32sessions;
        }



        #region IDisposable Members


        ///<summary>
        /// Closes the niWLAN Analysis unnamed session and releases resources associated with that unnamed session.
        ///
        ///</summary>
        public void Dispose()
        {
            if (!_isNamedSession)
            {
                this.Dispose(true);
                System.GC.SuppressFinalize(this);
            }
        }

        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Dispose managed resources.
            }
            // Dispose() does not close a named session. Users must call Close() to close a named session.
            if (!_isNamedSession)
            {
                // Dispose unmanaged resources
                // Handle.Handle is IntPtr.Zero when the session is inactive/closed.
                if (!Handle.Handle.Equals(IntPtr.Zero))
                {
                    PInvoke.niWLANA_CloseSession(Handle);
                }
            }
        }

        #endregion

        private class PInvoke
        {
            const string nativeDllName = "niWLANAnalysis_net.dll";

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SetReferenceDataConstellation", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SetReferenceDataConstellation(System.Runtime.InteropServices.HandleRef session, string channelString, double[] I, double[] Q, int dataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_AnalyzeIQComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_AnalyzeIQComplexF64(System.Runtime.InteropServices.HandleRef session, double t0, double dt, niComplexNumber[] data, int numberofSamples, int reset, out int averagingDone);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SetAMPMReferenceWaveform", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SetAMPMReferenceWaveform(System.Runtime.InteropServices.HandleRef session, double t0, double dt, niComplexNumber[] data, int lenOfY);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_AnalyzeMIMOIQComplexF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_AnalyzeMIMOIQComplexF64(System.Runtime.InteropServices.HandleRef session, double[] t0, double[] dt, niComplexNumber[] waveforms, int numberofChannels, int numberofSamplesInEachWfm, int reset, out int averagingDone);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_AnalyzeMIMOPowerSpectrum", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_AnalyzeMIMOPowerSpectrum(System.Runtime.InteropServices.HandleRef session, double[] f0, double[] df, double[] powerSpectra, int numberofChannels, int numofSamplesInEachSpectrum);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_AnalyzePowerSpectrum", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_AnalyzePowerSpectrum(System.Runtime.InteropServices.HandleRef session, double f0, double df, double[] powerSpectrumData, int dataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_CloseSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_CloseSession(System.Runtime.InteropServices.HandleRef session);

            [Obsolete]
            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationConstellation", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationConstellation(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] double[] iData, [In, Out] double[] qData, int dataArraySize, out int actualNumDataArrayElements);

            [Obsolete]
            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationEVMPerSymbol", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationEVMPerSymbol(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] double[] eVMperSymbol, int eVMperSymbolArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationReferenceConstellationTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationReferenceConstellationTrace(System.Runtime.InteropServices.HandleRef session, string channelString, double[] I, double[] Q, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodNumberOfSpatialStreams", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodNumberOfSpatialStreams(System.Runtime.InteropServices.HandleRef session, string channelString, out int numStreams);

            [Obsolete]
            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMEVMPerSubcarrier", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMEVMPerSubcarrier(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] double[] eVMperSubcarrier, int eVMperSubcarrierArraySize, out int actualArraySize);

            [Obsolete]
            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMEVMPerSymbolPerSubcarrier", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMEVMPerSymbolPerSubcarrier(System.Runtime.InteropServices.HandleRef session, string channelString, out double eVMTrace, int numRows, int numColumns, out int actualNumRows, out int actualNumColumns);

            [Obsolete]
            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationPvT", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationPvT(System.Runtime.InteropServices.HandleRef session, string channelString, out double t0, out double dt, [In, Out] double[] data, int dataArraySize, out int actualNumDataArrayElements);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetErrorString", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetErrorString(System.Runtime.InteropServices.HandleRef session, int errorCode, StringBuilder errorMessage, int errorMessageLength);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetScalarAttributeF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetScalarAttributeF64(System.Runtime.InteropServices.HandleRef session, string channelString, niWLANAProperties attributeID, out double attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetScalarAttributeI32", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetScalarAttributeI32(System.Runtime.InteropServices.HandleRef session, string channelString, niWLANAProperties attributeID, out int attributeValue);

            [Obsolete]
            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetSpectralMask", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetSpectralMask(System.Runtime.InteropServices.HandleRef session, string channelString, out double f0, out double df, [In, Out] double[] spectralMask, [In, Out] double[] spectrum, int dataArraySize, out int actualNumDataArrayElements);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetVectorAttributeF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetVectorAttributeF64(System.Runtime.InteropServices.HandleRef session, string channelString, niWLANAProperties attributeID, [In, Out] double[] data, int dataArraySize, out int actualNumDataArrayElements);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_OpenSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_OpenSession(string sessionName, int compatibilityVersion, out IntPtr session, out int isNewSession);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_ResetSession", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_ResetSession(System.Runtime.InteropServices.HandleRef session);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAAutoLevel", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAAutoLevel(System.Runtime.InteropServices.HandleRef rFSASession, string hardwareChannelString, double carrierFrequency, double bandwidth, double measurementInterval, int maxNumberofIterations, out double resultantReferenceLevel);

            [DllImport(nativeDllName, EntryPoint = "niWLANSA_RFSAAutoLevel", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANSA_RFSAAutoLevel(System.Runtime.InteropServices.HandleRef rFSASession, string hardwareChannelString, double bandwidth, double measurementInterval, int maxNumberofIterations, out double resultantReferenceLevel);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAAutoRange", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAAutoRange(System.Runtime.InteropServices.HandleRef session, string wLANChannelString, System.Runtime.InteropServices.HandleRef rFSASession, string hardwareChannelString);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAConfigure", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAConfigure(System.Runtime.InteropServices.HandleRef session, string wLANChannelString, System.Runtime.InteropServices.HandleRef rFSASession, string hardwareChannelString, int resetHardware, out long samplesPerRecord);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAConfigureHardware", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAConfigureHardware(HandleRef WLANSession, System.Runtime.InteropServices.HandleRef rFSASession, string hardwareChannelString, out long samplesPerRecord);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAMeasure", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAMeasure(System.Runtime.InteropServices.HandleRef session, System.Runtime.InteropServices.HandleRef rFSASession, string hardwareChannelString, double timeout);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAMIMOMeasure", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAMIMOMeasure(System.Runtime.InteropServices.HandleRef session, Int32[] rFSASessions, string[] hardwareChannelStrings, int numberofChannels, double timeout);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAReadGatedPowerSpectrum", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAReadGatedPowerSpectrum(System.Runtime.InteropServices.HandleRef session, string wLANChannelString, System.Runtime.InteropServices.HandleRef rFSASession, string hardwareChannelString, double timeout, out double f0, out double df, [In, Out] double[] powerSpectrum, int powerSpectrumArraySize, out int actualNumPowerSpectrumElement);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAReadMIMOGatedPowerSpectrum", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAReadMIMOGatedPowerSpectrum(System.Runtime.InteropServices.HandleRef session, string wLANChannelStrings, Int32[] rFSASessions, string hwChannelStrings, double timeout, [In, Out] double[] f0, [In, Out] double[] df, [In, Out] double[] powerSpectra, int numberofChannels, int individualSpectrumSize, out int actualNumSamplesInEachSpec);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SelectMeasurements", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SelectMeasurements(System.Runtime.InteropServices.HandleRef session, uint measurement);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAAutoDetectionOfStandard", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAAutoDetectionOfStandard(System.Runtime.InteropServices.HandleRef Handle, IntPtr rfsaSession, string hwChannelString);

            [Obsolete]
            [DllImport(nativeDllName, EntryPoint = "niWLANA_SetPowerLevel", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SetPowerLevel(System.Runtime.InteropServices.HandleRef session, string channelString, double maxInputPower);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SetScalarAttributeF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SetScalarAttributeF64(System.Runtime.InteropServices.HandleRef session, string channelString, niWLANAProperties attributeID, double attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SetScalarAttributeI32", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SetScalarAttributeI32(System.Runtime.InteropServices.HandleRef session, string channelString, niWLANAProperties attributeID, int attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SetVectorAttributeF64", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SetVectorAttributeF64(System.Runtime.InteropServices.HandleRef session, string channelString, niWLANAProperties attributeID, double[] data, int dataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SelectMeasurementsWithTraces", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SelectMeasurementsWithTraces(System.Runtime.InteropServices.HandleRef session, int measurement, int enableTraces);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodNumberOfSpaceTimeStreams", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodNumberOfSpaceTimeStreams(System.Runtime.InteropServices.HandleRef session, string channelString, out int numStreams);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationConstellationTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationConstellationTrace(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] double[] iData, [In, Out] double[] qData, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationPvTTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationPvTTrace(System.Runtime.InteropServices.HandleRef session, string channelString, out double t0, out double dt, [In, Out] double[] pvT, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationEVMPerSymbolTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationEVMPerSymbolTrace(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] int[] index, [In, Out] double[] eVMperSymbol, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationDecodedBitsTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationDecodedBitsTrace(System.Runtime.InteropServices.HandleRef session, [In, Out] int[] decodedbits, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetSpectralMaskTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetSpectralMaskTrace(System.Runtime.InteropServices.HandleRef session, string channelString, out double f0, out double df, [In, Out] double[] spectralMask, [In, Out] double[] spectrum, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodEVMPerSymbolPerSubcarrierTrace(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] int[] index, out double eVMTrace, int numRows, int numColumns, out int actualNumRows, out int actualNumColumns);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodEVMPerSubcarrierTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodEVMPerSubcarrierTrace(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] int[] index, [In, Out] double[] eVMperSubcarrier, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodDataEVMPerSymbolTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodDataEVMPerSymbolTrace(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] int[] index, [In, Out] double[] dataEVMperSymbol, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodPilotEVMPerSymbolTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodPilotEVMPerSymbolTrace(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] int[] index, [In, Out] double[] pilotEVMperSymbol, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodChannelFrequencyResponseTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodChannelFrequencyResponseTrace(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] int[] index, [In, Out] double[] magnitude, [In, Out] double[] phase, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodSpectralFlatnessTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodSpectralFlatnessTrace(System.Runtime.InteropServices.HandleRef session, string channelString, [In, Out] int[] index, [In, Out] double[] upperMask, [In, Out] double[] spectralFlatness, [In, Out] double[] lowerMask, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SaveConfigurationToFile", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SaveConfigurationToFile(System.Runtime.InteropServices.HandleRef session, string filePath, int operation);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_LoadConfigurationFromFile", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_LoadConfigurationFromFile(System.Runtime.InteropServices.HandleRef session, string filePath, int reset);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_ReadWaveformFromFile", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_ReadWaveformFromFile(string filePath, string waveformName, int offset, int count, out double t0, out double dt, out niComplexNumber waveform, int waveformSize, out int actualSize, out int eOF);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_ChannelNumberToCarrierFrequency", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_ChannelNumberToCarrierFrequency(int frequencyBand, double channelBandwidth, int channelNumber, int secondaryFactor, double channelStartingFactor, out double carrierFrequency);

            #region Version 4.0

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodPreambleFrequencyErrorTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodPreambleFrequencyErrorTrace(HandleRef session, string channelString, [In, Out] double[] time, [In, Out]double[] preambleFrequencyError, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodCommonPilotErrorTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodCommonPilotErrorTrace(HandleRef session, string channelString, [In, Out]int[] index, [In, Out]double[] CPEMagnitude, [In, Out]double[] CPEPhase, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodPhaseNoisePSDTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOFDMDemodPhaseNoisePSDTrace(HandleRef session, string channelString, out double f0, out double df, [In, Out] double[] phaseNoisePSD, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_DeallocateMemory", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_DeallocateMemory();
            #endregion

            #region Version 4.1

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetAMPMPolynomialCoefficients", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetAMPMPolynomialCoefficients(System.Runtime.InteropServices.HandleRef session, string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetAMAMPolynomialCoefficients", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetAMAMPolynomialCoefficients(System.Runtime.InteropServices.HandleRef session, string channelString, double[] dataArray, int dataArraySize, out int actualNumDataArrayElements);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_ConfigureFastEVM", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_ConfigureFastEVM(System.Runtime.InteropServices.HandleRef session, int standard, double channelBandwidth);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCCDFTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCCDFTrace(System.Runtime.InteropServices.HandleRef session, string activeChannel, out double signalCcdfMinBin, out double signalCcdfBinSize, double[] signalCcdf, int signalCcdfDataArraySize, out int signalCcdfActualArraySize, out double guassianCcdfBinSize, out double guassianCcdfMinSize, double[] gaussianCcdf, int gaussianCcdfDataArraySize, out int gaussianCcdfActualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAConfigureMultipleDeviceSynchronization", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAConfigureMultipleDeviceSynchronization(System.Runtime.InteropServices.HandleRef session, System.Int32[] rFSASessions, int noOfChannels, string MasterReferenceClockSource, int[] TriggerLines, int noOfTriggerLines);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAMultipleDeviceInitiate", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAMultipleDeviceInitiate(System.Runtime.InteropServices.HandleRef session, System.Runtime.InteropServices.HandleRef[] rFSASessions, int noOfChannels);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAAutoTriggerRoute", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAAutoTriggerRoute(System.Runtime.InteropServices.HandleRef rFSASession, int noOfChannels, string triggerLine0, int lenOfTrig0, string triggerLine1, int lenOfTrig1, string reference, int lenOfReference, out int isInSameBus, int[] busNumber, int sizeOfBusNo, out int isDefaultLineSelected);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSATriggerUnroute", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSATriggerUnroute(string triggerLine0, string triggerLine1, string reference, int isInSameBus, int[] busNumber, int sizeOfBusNo, int isDefaultLineSelected);

            #endregion

           
          
            #region 14.5

            [DllImport(nativeDllName, EntryPoint = "niWLANA_ChannelNumberToCarrierFrequency80211abgjpn", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_ChannelNumberToCarrierFrequency80211abgjpn(double channelStartingFrequency, double channelBandwidth, int channelNumber, int secondaryFactor, out double carrierFrequency);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_ChannelNumberToCarrierFrequency80211ac", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_ChannelNumberToCarrierFrequency80211ac(double channelStartingFrequencyHz, int channelNumber, out double carrierFrequency);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_ChannelNumberToCarrierFrequency80211ah", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_ChannelNumberToCarrierFrequency80211ah(double channelStartingFrequencyHz, int channelNumber, out double carrierFrequency);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetACPTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetACPTrace(HandleRef session, string channelString, out double f0, out double df, [In, Out] double[] y, int dataArraySize, out int actualArraySize);

            #endregion

            [DllImport(nativeDllName, EntryPoint = "niWLANA_ChannelNumberToCarrierFrequency80211af", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_ChannelNumberToCarrierFrequency80211af(double channelStartingFrequency, double channelBandwidth, int channelNumber, int TVHTMode, out double carrierFrequency);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetETSIIBETrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetETSIIBETrace(System.Runtime.InteropServices.HandleRef session, out double f0, out double df, double[] relativeLimits, double[] absoluteLimits, double[] PSD, int dataArraySize, out int actualDataArraySize);

          

            #region 15.5

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SetAttributeString", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SetAttributeString(System.Runtime.InteropServices.HandleRef session, string channelString, niWLANAProperties attributeID, string attributeValue);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetAttributeString", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetAttributeString(System.Runtime.InteropServices.HandleRef session, string channelString, niWLANAProperties attributeID, string attributeValue, int bufferSize, out int actualStringSize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetAmplitudeCorrectionTable", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetAmplitudeCorrectionTable(System.Runtime.InteropServices.HandleRef session, string channelString, int index, int isTableIndex, [In, Out] double[] amplitudeCorrection, [In, Out] double[] frequency, int dataArraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SelectAmplitudeCorrectionTable", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SelectAmplitudeCorrectionTable(System.Runtime.InteropServices.HandleRef session, string channelString, int analyzerIndex, int tableIndex);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SetAmplitudeCorrectionTable", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SetAmplitudeCorrectionTable(System.Runtime.InteropServices.HandleRef session, string channelString, int tableIndex, [In, Out] double[] amplitudeCorrection, [In, Out] double[] frequency, int arraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_SetOFDMDemodRefDataConstellationIdentifier", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_SetOFDMDemodRefDataConstellationIdentifier(System.Runtime.InteropServices.HandleRef session, string channelString, string attrVal);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetOFDMDemodRefDataConstellationIdentifier", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetOFDMDemodRefDataConstellationIdentifier(System.Runtime.InteropServices.HandleRef session, string channelString, int arraySize, string attrVal);

            #endregion

            #region 17.0
            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAAutoLevelv2", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAAutoLevelv2(System.Runtime.InteropServices.HandleRef session, Int32 rFSASession, string channelString, double measurementIntervalSec, int maximumNumberOfIterations, out double resultantReferenceLevel);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAConfigureOptimalEVMReferenceLevel", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAConfigureOptimalEVMReferenceLevel(System.Runtime.InteropServices.HandleRef session, Int32 rFSASession, string hwchannelstring, double peakPower, out double optimalReferenceLevel);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAMeasureNoiseFloor", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAMeasureNoiseFloor(System.Runtime.InteropServices.HandleRef session, Int32[] rFSASessions, Int32 ExternalLOHandle, Int32[] LOSource, Int32[] PortType, int dataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetOFDMDemodUnusedToneErrorTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetOFDMDemodUnusedToneErrorTrace(System.Runtime.InteropServices.HandleRef session, string channelString, int[] RUIndex, double[] UnusedToneErrorMask, double[] UnusedToneError,
                                                                              int dataArraySize, out int actualdataArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAConfigureFrequencySingleLO", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAConfigureFrequencySingleLO(HandleRef session, Int32[] rfsaSessions, int numberOfRfsaHandles, int LOSource, Int32 exteralLOHandle, double carrierFrequency, int rfsgLODaisyChainEnabled, int LOExportToExternalDevicesEnabled);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAConfigureFrequencyMultipleLO", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAConfigureFrequencyMultipleLO(HandleRef session, Int32[] rfsaSessions, int numberOfRfsaHandles, int LOSource, Int32[] exteralLOHandles, int numberOfexteralLOHandles, double[] carrierFrequency, int dataArraySize, int rfsgLODaisyChainEnabled, int LOExportToExternalDevicesEnabled);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211ax", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211ax(HandleRef session, string channelString, Int32[] decodedHESIGABitsTrace, int decodedHESIGABitsTraceSize,
                                     out int actualDecodedHESIGABitsTraceSize, Int32[] decodedHESIGBBitsTrace, int decodedHESIGBBitsTraceSize, out int actualdecodedHESIGBBitsTraceSize,
                                     Int32[] decodedLSIGBitsTrace, int decodedLSIGBitsTraceSize, out int actualDecodedLSIGBitsTraceSize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211n", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211n(HandleRef session, string channelString, Int32[] decodedHTSIGBitsTrace, int decodedHTSIGBitsTraceSize,
                                     out int actualDecodedHTSIGBitsTraceSize, Int32[] decodedLSIGBitsTrace, int decodedLSIGBitsTracetSize, out int actualdecodedLSIGBitsTrace);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211agjp", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211agjp(HandleRef session, string channelString, Int32[] decodedSignalBitsTrace,
                                                                                                int decodedSignalBitsTraceSize, out int actualdecodedSignalBitsTrace);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_ChannelNumberToCarrierFrequency80211ax", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_ChannelNumberToCarrierFrequency80211ax(double channelStartingFrequency, double channelBandwidth, out double carrierFrequency);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211ac", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationDecodedHeaderBitsTrace80211ac(HandleRef session, string channelString, Int32[] decodedHESIGABitsTrace, int decodedHESIGABitsTraceSize, out int actualDecodedHESIGABitsTraceSize,
                                     Int32[] decodedHESIGBBitsTrace, int decodedHESIGBBitsTraceSize, out int actualdecodedHESIGBBitsTraceSize, Int32[] decodedLSIGBitsTrace, int decodedLSIGBitsTraceSize, out int actualDecodedLSIGBitsTraceSize);
            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetOFDMDemodCarrierFrequencyOffsetCCDFTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetOFDMDemodCarrierFrequencyOffsetCCDFTrace(HandleRef session, string channelString, out double minBin, out double binSize,
                                                                                         double[] CCDF, int CCDFArraySize, out int actualCCDFArraySize);

            [DllImport(nativeDllName, EntryPoint = "RFSALoadNoiseCompensationData", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSALoadNoiseCompensationData(HandleRef session, System.Runtime.InteropServices.HandleRef Rfsasession, int forceLoad);
            #endregion

            #region 18.0

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodIQGainImbalancePerSubcarrierTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOfdmDemodIQGainImbalancePerSubcarrierTrace(HandleRef session, string channelString, double[] IQGainImbalance, Int32[] subcarrierIndices, int arraySize, out int actualArraySize);

            [DllImport(nativeDllName, EntryPoint = "niWLANA_GetCurrentIterationOFDMDemodQuadratureSkewPerSubcarrierTrace", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_GetCurrentIterationOfdmDemodQuadratureSkewPerSubcarrierTrace(HandleRef session, string channelString, double[] quadratureSkew, Int32[] subcarrierIndices, int arraySize, out int actualArraySize);

            #endregion
	    
	    #region 19.1
	    
	    [DllImport(nativeDllName, EntryPoint = "niWLANA_RFSAForceTClkSynchronization", CallingConvention = CallingConvention.StdCall)]
            public static extern int niWLANA_RFSAForceTClkSynchronization(System.Runtime.InteropServices.HandleRef session, Int32[] rfsaSessions, int numberOfRfsaHandles, int forceSync);
	    
	    #endregion

        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="status"></param>
        /// <returns></returns>
        public int TestForError(int status)
        {
            if ((status < 0))
            {
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                status = GetErrorString(status, msg);
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), status);
            }
            return status;
        }

        private int TestForError(int status, HandleRef rfsaHandle)
        {
            if ((status < 0))
            {
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                GetErrorString(status, msg);
                //get rfsa detailed error message
                if (String.IsNullOrEmpty(msg.ToString()))
                    niRFSA.GetError(rfsaHandle, status, msg);
                //get rfsa general error message
                if (String.IsNullOrEmpty(msg.ToString()))
                    niRFSA.ErrorMessage(rfsaHandle, status, msg);
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), status);
            }
            return status;
        }

        private static int StaticTestForError(int status, HandleRef rfsaHandle)
        {
            if ((status < 0))
            {
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                //GetErrorString(status, msg);
                //get rfsa detailed error message
                if (String.IsNullOrEmpty(msg.ToString()))
                    niRFSA.GetError(rfsaHandle, status, msg);
                //get rfsa general error message
                if (String.IsNullOrEmpty(msg.ToString()))
                    niRFSA.ErrorMessage(rfsaHandle, status, msg);
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), status);
            }
            return status;
        }
        private static int StaticGetErrorString(int status, StringBuilder msg)
        {
            System.Runtime.InteropServices.HandleRef nullHandle = new HandleRef();
            int size = PInvoke.niWLANA_GetErrorString(nullHandle, status, null, 0);
            if ((size >= 0))
            {
                msg.Capacity = size;
                PInvoke.niWLANA_GetErrorString(nullHandle, status, msg, size);
            }
            return status;
        }
        private static int StaticTestForError(int status, HandleRef[] rfsaHandles)
        {
            if ((status < 0))
            {
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                for (int i = 0; String.IsNullOrEmpty(msg.ToString()) && i < rfsaHandles.Length; i++)
                {
                    if (rfsaHandles[i].Handle != IntPtr.Zero)
                    {
                        //get rfsa detailed error message
                        niRFSA.GetError(rfsaHandles[i], status, msg);
                        //get rfsa general error message
                        if (String.IsNullOrEmpty(msg.ToString()))
                            niRFSA.ErrorMessage(rfsaHandles[i], status, msg);
                    }
                }
                //if (String.IsNullOrEmpty(msg.ToString()))
                niWLANA.StaticGetErrorString(status, msg);
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), status);
            }
            return status;
        }

        private int TestForError(int status, HandleRef[] rfsaHandles)
        {
            if ((status < 0))
            {
                System.Text.StringBuilder msg = new System.Text.StringBuilder();
                GetErrorString(status, msg);
                for (int i = 0; String.IsNullOrEmpty(msg.ToString()) && i < rfsaHandles.Length; i++)
                {
                    if (rfsaHandles[i].Handle != IntPtr.Zero)
                    {
                        //get rfsa detailed error message
                            niRFSA.GetError(rfsaHandles[i], status, msg);
                        //get rfsa general error message
                        if (String.IsNullOrEmpty(msg.ToString()))
                            niRFSA.ErrorMessage(rfsaHandles[i], status, msg);
                    }
                }
                if (String.IsNullOrEmpty(msg.ToString()))
                    StaticGetErrorString(status, msg);
                throw new System.Runtime.InteropServices.ExternalException(msg.ToString(), status);
            }
            return status;
        }
    }
    /// <summary>
    /// 
    /// </summary>
    public class niWLANAConstants
    {
        /// <summary>
        /// 
        /// </summary>
        public const int CompatibilityVersion010000 = 10000;
        /// <summary>
        /// 
        /// </summary>
        public const int CompatibilityVersion020000 = 20000;
        /// <summary>
        /// 
        /// </summary>
        public const int CompatibilityVersion030000 = 30000;
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211agOfdm = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211bgDsss = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211gDsssOfdm = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211nMimoOfdm = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int AcquisitionTypeIq = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int AcquisitionTypeSpectrum = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int True = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int False = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate6 = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate9 = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate12 = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate18 = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate24 = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate36 = 5;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate48 = 6;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDataRate54 = 7;
        /// <summary>
        /// 
        /// </summary>
        public const int FecCodingTypeBcc = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int FecCodingTypeLdpc = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int ResultsFecCodingTypeVarious = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate1 = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate2 = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate5p5Cck = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate5p5Pbcc = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate11Cck = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate11Pbcc = 5;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate22 = 6;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDataRate33 = 7;
        /// <summary>
        /// 
        /// </summary>
        public const int RbwDefinition3db = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int RbwDefinition6db = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int RbwDefinitionEnbw = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int RbwDefinitionBinWidth = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int WindowUniform = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int WindowHanning = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int WindowHamming = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int WindowBlackmanHarris = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int WindowExactBlackman = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int WindowBlackman = 5;
        /// <summary>
        /// 
        /// </summary>
        public const int WindowFlatTop = 6;
        /// <summary>
        /// 
        /// </summary>
        public const int Window4TermBlackmanHarris = 7;
        /// <summary>
        /// 
        /// </summary>
        public const int Window7TermBlackmanHarris = 8;
        /// <summary>
        /// 
        /// </summary>
        public const int WindowLowSideLobe = 9;
        /// <summary>
        /// 
        /// </summary>
        public const int StandardUnknown = -2;
        /// <summary>
        /// 
        /// </summary>
        public const int GatedSpectrumModeRbw = 0;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int GatedSpectrumModeAcquisitionLength = 1;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int GatedSpectrumModeRbwAndAcquisitionLength = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int SpectralMaskTypeStandard = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int SpectralMaskTypeUserDefined = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int SpectralMaskReferenceLevelTypePeakSignalPower = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int SpectralMaskReferenceLevelTypeUserDefined = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmPhaseTrackingStandard = 0;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int OfdmPhaseTrackingInstantaneous = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Results80211nPlcpFrameFormatMixed = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int Results80211nPlcpFrameFormatGreenfield = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Results80211nPlcpFrameFormatVarious = -1;
        /// <summary>
        /// 
        /// </summary>
        public const int Results80211nPlcpFrameFormatUnknown = -2;
        /// <summary>
        /// 
        /// </summary>
        public const int ResultsOfdmDataRateVarious = 8;
        /// <summary>
        /// 
        /// </summary>
        public const int FilterRectangular = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int FilterRaisedCosine = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int FilterRootRaisedCosine = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int FilterGaussian = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssPhaseTrackingStandard = 0;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int DsssPhaseTrackingInstantaneous = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int ResultsDsssDataRateVarious = 8;
        /// <summary>
        /// 
        /// </summary>
        public const int PreambleTypeLongPreamble = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int PreambleTypeShortPreamble = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int PreambleTypeVarious = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDemodSfdFoundFalse = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDemodSfdFoundTrue = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDemodSfdFoundVarious = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDemodHeaderChecksumPassedFalse = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDemodHeaderChecksumPassedTrue = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDemodHeaderChecksumPassedVarious = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodMeasurement = 0x1;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodWithGatedPowerMeasurement = 0x2;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDemodMeasurement = 0x4;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssDemodWithGatedPowerMeasurement = 0x8;
        /// <summary>
        /// 
        /// </summary>
        public const int DsssPowerRampMeasurement = 0x10;
        /// <summary>
        /// 
        /// </summary>
        public const int TxpPowerMeasurement = 0x20;
        /// <summary>
        /// 
        /// </summary>
        public const int SpectralMaskMeasurement = 0x40;
        /// <summary>
        /// 
        /// </summary>
        public const int ObwMeasurement = 0x80;
        /// <summary>
        /// 
        /// </summary>
        public const int MaxSpectralDensityMeasurement = 0x100;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int CfoEstimationMethodPreambleOnly = 0;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int CfoEstimationMethodPreambleAndData = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Various = -1;
        /// <summary>
        /// 
        /// </summary>
        public const int NotApplicable = -3;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int Standard80211agjpOfdm = 0;

        #region version 4.0

        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211acMimoOfdm = 4;

        /*- Values for Gated Spectrum Averaging Type -*/
        /// <summary>
        /// 
        /// </summary>
        public const int GatedSpectrumAveragingTypeRms = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int GatedSpectrumAveragingTypeLog = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int SpectralMaskTypeStandardAt5Ghz = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmPhaseTrackingNone = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmPhaseTrackingStandardWithCubicSplineFit = 3;

        /*- Values for OFDM IQ Mismatch Correction Signal Model  */
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmIqMismatchCorrectionSignalModelTx = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmIqMismatchCorrectionSignalModelRx = 1;

        /* Values for TxPower Measurement Mode  */
        /// <summary>
        /// 
        /// </summary>
        public const int TxPowerMeasurementsModeFirstPacket = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int TxPowerMeasurementsModeEntireAcquisition = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int FileOperationModeOpen = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int FileOperationModeOpenOrCreate = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int FileOperationModeCreateOrReplace = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int FileOperationModeCreate = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int FrequencyBand2p4Ghz = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int FrequencyBand5Ghz = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodCfrTraceModeWithLinearPhase = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodCfrTraceModeDeviationFromLinearPhase = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodGroupDelayTraceModeWithAverageGroupDelay = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodGroupDelayTraceModeDeviationFromAverageGroupDelay = 1;

        #endregion

        #region Version 4.1
        /// <summary>
        /// 
        /// </summary>
        public const int GatedSpectrumModeMeasurementLength = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int GatedSpectrumModeRbwAndMeasurementLength = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int SpectralMaskTransmitPowerClassA = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int SpectralMaskTransmitPowerClassB = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int SpectralMaskTransmitPowerClassC = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int SpectralMaskTransmitPowerClassD = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodPpduTypeSuPpdu = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodPpduTypeMuPpdu = 1;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int AmpmMeasurementsAveragingModeExponential = 0;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int AmpmMeasurementsAveragingModeRepeat = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int TclkSynchronisationEnabledFalse = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int TclkSynchronisationEnabledTrue = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int LoSharingEnabledFalse = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int LoSharingEnabledTrue = 1;

        #endregion

        #region version 14.0
        /// <summary>
        /// 
        /// </summary>
        public const int AutoDetectionStandardModeOff = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int AutoDetectionStandardModePacketFilter = 2;

        #endregion
        #region version 14.5
        /// <summary>
        /// 
        /// </summary>
        public const int CompatibilityVersion040000 = 40000;
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211ahMimoOfdm = 5;
        /// <summary>
        /// 
        /// </summary>
        public const int ChannelPowerMeasurement = 0x200;
        /// <summary>
        /// 
        /// </summary>
        public const int CcdfMeasurement = 0x400;
        /// <summary>
        /// 
        /// </summary>
        public const int AcpMeasurement = 0x1000;


        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int ResultGuardIntervalTypeUnknown = -2;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int ResultGuardIntervalTypeVarious = -1;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int GuardIntervalTypeLong = 0;
        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int GuardIntervalTypeShort = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int _80211ahPreambleTypeShort = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int _80211ahPreambleTypeLong = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int Results80211ahPreambleTypeVarious = -1;
        /// <summary>
        /// 
        /// </summary>
        public const int Results80211ahPreambleTypeUnknown = -2;
        /// <summary>
        /// 
        /// </summary>
        public const int Results80211ahPreambleTypeNotApplicable = -3;



        #endregion

        #region version 15.0

        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211afMimoOfdm = 6;
        /// <summary>
        /// 
        /// </summary>
        public const int EtsiIbeMeasurement = 0x2000;
        /// <summary>
        /// 
        /// </summary>
        public const int EtsiDeviceEmissionClass1 = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int EtsiDeviceEmissionClass2 = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int EtsiDeviceEmissionClass3 = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int EtsiDeviceEmissionClass4 = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int EtsiDeviceEmissionClass5 = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int GatedSpectrumAveragingTypePeakHold = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int TvhtMode1 = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int TvhtMode2C = 1;
        /// <summary>
        /// 
        /// </summary>
        public const int TvhtMode2N = 2;
        /// <summary>
        /// 
        /// </summary>
        public const int TvhtMode4C = 3;
        /// <summary>
        /// 
        /// </summary>
        public const int TvhtMode4N = 4;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmNonHtModulationModeOff = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int OfdmNonHtModulationModeOn = 1;

        #endregion

        #region version 15.5

        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211jOfdm = 7;

        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211pOfdm = 8;

        /// <summary>
        /// 
        /// </summary>
        public const int SingleAnalyzer = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int MultipleAnalyzers = 1;

        #endregion

        #region version 17.0
        /// <summary>
        /// 
        /// </summary>
        public const int Standard80211axMimoOfdm = 9;

        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int TransmissionModeDownlink = 0;

        /// <summary>
        /// 
        /// </summary>
        [Obsolete]
        public const int TransmissionModeUplink = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodExtendedRangeSuPpdu = 2;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodTriggerBasedPpdu = 3;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodRuSizeAuto = -1;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodRuSize26 = 26;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodRuSize52 = 52;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodRuSize106 = 106;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodRuSize242 = 242;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodRuSize484 = 484;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmDemodRuSize996 = 996;

        /// <summary>
        /// 
        /// </summary>

        public const int OfdmDemodRuSize2x996 = 1992;

        /// <summary>
        /// 
        /// </summary>
        public const int GuardIntervalTypeOneByFour = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int GuardIntervalTypeOneByEight = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int GuardIntervalTypeOneBySixteen = 2;

        /// <summary>
        /// 
        /// </summary>
        public const int HeLtfSizeAuto = -1;

        /// <summary>
        /// 
        /// </summary>
        public const int HeLtfSize4X = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int HeLtfSize2X = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int NoiseCompensationAppliedNone = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int NoiseCompensationAppliedPartial = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int NoiseCompensationAppliedFull = 2;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmUnusedToneErrorMaskReferenceLowPower = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int OfdmUnusedToneErrorMaskReferenceHighPower = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int CompatibilityVersion050000 = 50000;

        /// <summary>
        /// 
        /// </summary>
        public const int LOFrequencyOffsetModeAuto = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int LOFrequencyOffsetModeUserDefined = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int LOFrequencyOffsetModeDisabled = 2;

        /// <summary>
        /// 
        /// </summary>
        public const int CfoEstimationMethodPreambleAndPilots = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int CfoEstimationMethodPreambleAndPilotsAndData = 2;
        /// <summary>
        /// 
        /// </summary>
        
	    public const int LOSourcePreviousDevice = 1;
       
        /// <summary>
        /// 
        /// </summary>
        public const int LOSourceExternal = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int LOSourceOnboard = 2;

        /// <summary>
        /// 
        /// </summary>
        public const int LOSourceSgSaShared = 3;
        
        /// <summary>
        /// 
        /// </summary>
        public const int ChannelEstimationMethodPreamble = 0;
        /// <summary>
        /// 
        /// </summary>
        public const int ChannelEstimationMethodPreambleAndData = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int PortTypeRFIn = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int PortTypeRFOut = 1;


        #endregion

        #region 17.1
        
        /// <summary>
        /// 
        /// </summary>
        public const int CfoEstimationMethodInitialPreamble = 0;
        
        /// <summary>
        /// 
        /// </summary>
        public const int CfoEstimationMethodFullPreamble = 3;

        /// <summary>
        /// 
        /// </summary>
        public const int HeLtfSize1X = 2;

        #endregion 

        #region 18.0

        /// <summary>
        /// 
        /// </summary>
        public const int MidamblePeriodicityNone = 0;

        /// <summary>
        /// 
        /// </summary>
        public const int MidamblePeriodicity10Symbols = 1;

        /// <summary>
        /// 
        /// </summary>
        public const int MidamblePeriodicity20Symbols = 2;

        #endregion
	
	#region 19.1

        /// <summary>
        /// 
        /// </summary>
        public const int ForceSyncDisabled = 0;
	
	/// <summary>
        /// 
        /// </summary>
        public const int ForceSyncEnabled = 1;

        #endregion

    }
    /// <summary>
    /// 
    /// </summary>
    public enum niWLANAProperties
    {
        /// <summary>
        /// double
        /// </summary>
        CarrierFrequency = 0,

        /// <summary>
        /// double
        /// </summary>
        AcquisitionLength = 2,

        /// <summary>
        /// int
        /// </summary>
        IqPowerEdgeReferenceTriggerEnabled = 3,

        /// <summary>
        /// double
        /// </summary>
        Span = 5,

        /// <summary>
        /// double
        /// </summary>
        Rbw = 6,

        /// <summary>
        /// int
        /// </summary>
        Standard = 7,

        /// <summary>
        /// int
        /// </summary>
        SpectralMeasurementsAllEnabled = 8,

        /// <summary>
        /// int
        /// </summary>
        FftWindowType = 9,

        /// <summary>
        /// int
        /// </summary>
        SpectralMaskEnabled = 10,

        /// <summary>
        /// int
        /// </summary>
        SpectralMaskNumberOfAverages = 11,

        /// <summary>
        /// int
        /// </summary>
        ObwEnabled = 16,

        /// <summary>
        /// int
        /// </summary>
        ObwNumberOfAverages = 18,

        /// <summary>
        /// int
        /// </summary>
        MaxSpectralDensityEnabled = 19,

        /// <summary>
        /// int
        /// </summary>
        MaxSpectralDensityNumberOfAverages = 20,

        /// <summary>
        /// double
        /// </summary>
        ResultMaxSpectralDensity = 21,

        /// <summary>
        /// double
        /// </summary>
        ResultSpectralMaskMargin = 22,

        /// <summary>
        /// double
        /// </summary>
        ResultObw = 25,

        /// <summary>
        /// int
        /// </summary>
        DsssPowerRampMeasurementEnabled = 31,

        /// <summary>
        /// int
        /// </summary>
        DsssPowerRampMeasurementNumberOfAverages = 32,

        /// <summary>
        /// int
        /// </summary>
        TxpowerMeasurementsEnabled = 33,

        /// <summary>
        /// int
        /// </summary>
        TxpowerMeasurementsNumberOfAverages = 34,

        /// <summary>
        /// double
        /// </summary>
        ResultTxpowerMeasurementsPeakPower = 35,

        /// <summary>
        /// double
        /// </summary>
        ResultTxpowerMeasurementsAveragePower = 36,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssPowerRampUpTime = 41,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssPowerRampDownTime = 42,
        /// <summary>
        /// int
        /// </summary>
        OfdmDemodEnabled = 43,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodNumberOfAverages = 44,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodHeaderDetectionEnabled = 45,

        /// <summary>
        /// double
        /// </summary>
        OfdmDemodGatedPowerStartTime = 46,

        /// <summary>
        /// double
        /// </summary>
        OfdmDemodGatedPowerStopTime = 47,

        /// <summary>
        /// int
        /// </summary>
        OfdmPayloadLength = 48,

        /// <summary>
        /// int
        /// </summary>
        OfdmDataRate = 49,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodMeasurementStartLocation = 50,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodAmplitudeTrackingEnabled = 52,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodPhaseTracking = 53,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodTimeTrackingEnabled = 54,


        /// <summary>
        /// int
        /// </summary>
        [Obsolete("Use OfdmDemodChannelEstimationMethod")]
        OfdmDemodChannelTrackingEnabled = 55,


        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodRmsEvm = 56,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCarrierFrequencyOffset = 57,

        /// <summary>
        /// double
        /// </summary>
        [Obsolete("Use ResultOfdmDemodCarrierFrequencyLeakageAverage instead")]
        ResultOfdmDemodCarrierFrequencyLeakage = 58,
        /// <summary>
        /// 
        /// </summary>
        ResultOfdmDemodCarrierFrequencyLeakageAverage = 58,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodSpectralFlatnessMargin = 59,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodSampleClockOffset = 60,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodIqGainImbalance = 61,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodQuadratureSkew = 62,
        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodPayloadLength = 64,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodDataRate = 66,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodEnabled = 67,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodNumberOfAverages = 68,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodEqualizationEnabled = 69,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodReferencePulseShapingFilterType = 70,

        /// <summary>
        /// double
        /// </summary>
        DsssDemodReferencePulseShapingFilterCoefficient = 71,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodHeaderDetectionEnabled = 72,

        /// <summary>
        /// int
        /// </summary>
        DsssPayloadLength = 73,

        /// <summary>
        /// int
        /// </summary>
        DsssDataRate = 74,

        /// <summary>
        /// double
        /// </summary>
        DsssDemodGatedPowerStartTime = 75,

        /// <summary>
        /// double
        /// </summary>
        DsssDemodGatedPowerStopTime = 76,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodMeasurementStartLocation = 77,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodRmsEvm = 79,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodPeakEvm = 80,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodCarrierFrequencyOffset = 81,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodIqGainImbalance = 82,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodQuadratureSkew = 83,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodCarrierSuppression = 84,

        /// <summary>
        /// int
        /// </summary>
        ResultDsssDemodPayloadLength = 85,

        /// <summary>
        /// int
        /// </summary>
        ResultDsssDemodDataRate = 87,

        /// <summary>
        /// int
        /// </summary>
        ResultDsssDemodPreambleType = 88,

        /// <summary>
        /// int
        /// </summary>
        ResultDsssDemodSfdFound = 89,

        /// <summary>
        /// int
        /// </summary>
        ResultDsssDemodHeaderChecksumPassed = 90,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodGatedPowerEnabled = 112,


        /// <summary>
        /// int
        /// </summary>
        DsssDemodGatedPowerEnabled = 113,

        /// <summary>
        /// int
        /// </summary>
        FftWindowSize = 117,

        /// <summary>
        /// int
        /// </summary>
        FftSize = 118,

        /// <summary>
        /// double
        /// </summary>
        DsssPowerRampUpLowThreshold = 135,

        /// <summary>
        /// double
        /// </summary>
        DsssPowerRampUpHighThreshold = 136,

        /// <summary>
        /// double
        /// </summary>
        DsssPowerRampDownLowThreshold = 137,

        /// <summary>
        /// double
        /// </summary>
        DsssPowerRampDownHighThreshold = 138,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemod80211bPeakEvm = 140,


        /// <summary>
        /// int
        /// </summary>
        StbcIndex = 141,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodMaximumSymbolsUsed = 142,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodMaximumChipsUsed = 143,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodPhaseTracking = 145,

        /// <summary>
        /// int
        /// </summary>
        [Obsolete]
        NumberOfIterations = 154,

        /// <summary>
        /// int
        /// </summary>
        RecommendedNumberOfRecords = 154,

        /// <summary>
        /// int
        /// </summary>
        SpectralMaskReferenceLevelType = 155,

        /// <summary>
        /// double
        /// </summary>
        SpectralMaskReferenceLevel = 156,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodSampleClockOffset = 158,

        /// <summary>
        /// double
        /// </summary>
        ResultObwHighFrequency = 159,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodStbcIndex = 160,

        /// <summary>
        /// int
        /// </summary>
        FecCodingType = 162,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodFecCodingType = 163,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodDecodedBitsTraceEnabled = 164,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodEffectiveDataRate = 168,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodNotSoundingBit = 169,

        /// <summary>
        /// double
        /// </summary>
        DeviceInstantaneousBandwidth = 170,

        /// <summary>
        /// double
        /// </summary>
        TriggerDelay = 171,

        /// <summary>
        /// int
        /// </summary>
        RecommendedAcquisitionType = 172,

        /// <summary>
        /// double
        /// </summary>
        RecommendedAcquisitionLength = 173,

        /// <summary>
        /// double
        /// </summary>
        RecommendedMinimumQuietTime = 174,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodMacFrameCheckSequenceCheckEnabled = 175,

        /// <summary>
        /// double
        /// </summary>
        RecommendedIqSamplingRate = 176,

        /// <summary>
        /// double
        /// </summary>
        RecommendedIqPreTriggerDelay = 177,

        /// <summary>
        /// double
        /// </summary>
        RecommendedIqPostTriggerDelay = 178,

        /// <summary>
        /// double
        /// </summary>
        RecommendedSpectrumSpan = 179,

        /// <summary>
        /// int
        /// </summary>
        RecommendedSpectrumRbwDefinition = 180,

        /// <summary>
        /// double
        /// </summary>
        RecommendedSpectrumRbw = 181,

        /// <summary>
        /// double
        /// </summary>
        RecommendedSpectrumVbw = 182,

        /// <summary>
        /// int
        /// </summary>
        RecommendedSpectrumFftWindowType = 183,

        /// <summary>
        /// int
        /// </summary>
        AutoSpanEnabled = 184,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodDecodedBitsTraceEnabled = 185,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodAllTracesEnabled = 187,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodAllTracesEnabled = 188,

        /// <summary>
        /// int
        /// </summary>
        ResultDsssDemodMacFrameCheckSequencePassed = 189,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemod80211bPeakEvm2007 = 205,

        /// <summary>
        /// double
        /// </summary>
        ResultObwLowFrequency = 256,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodAverageGatedPower = 257,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodAverageGatedPower = 258,

        /// <summary>
        /// double
        /// </summary>
        ResultSpectralMaskReferenceLevel = 262,

        /// <summary>
        /// int
        /// </summary>
        SpectralMaskTraceEnabled = 264,

        /// <summary>
        /// int
        /// </summary>
        TxpowerMeasurementsPvtTraceEnabled = 265,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodConstellationTraceEnabled = 266,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodConstellationTraceEnabled = 267,

        /// <summary>
        /// double
        /// </summary>
        AutorangeMaxAcquisitionLength = 270,

        /// <summary>
        /// double
        /// </summary>
        AutorangeMaxIdleTime = 274,

        /// <summary>
        /// double
        /// </summary>
        ChannelBandwidth = 276,

        /// <summary>
        /// int
        /// </summary>
        NumberOfReceiveChannels = 275,


        /// <summary>
        /// int
        /// </summary>
        OfdmDemod80211nPlcpFrameDetectionEnabled = 279,

        /// <summary>
        /// int
        /// </summary>
        _80211nPlcpFrameFormat = 280,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodChannelFrequencyResponseTraceEnabled = 281,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCrossPower = 288,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodMcsIndex = 291,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodGuardInterval = 293,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodNumberOfExtensionSpatialStreams = 294,
        /// <summary>
        /// int
        /// </summary>
        GatedSpectrumMode = 295,

        /// <summary>
        /// int
        /// </summary>
        RbwDefinition = 296,

        /// <summary>
        /// int
        /// </summary>
        SpectralMaskType = 297,

        /// <summary>
        /// int
        /// </summary>
        McsIndex = 298,

        /// <summary>
        /// double
        /// </summary>
        GuardInterval = 299,

        /// <summary>
        /// int
        /// </summary>
        NumberOfExtensionSpatialStreams = 300,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodSpectralFlatnessTraceEnabled = 301,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemod80211nPlcpFrameFormat = 303,

        /// <summary>
        /// int
        /// </summary>
        GatedSpectrumEnabled = 304,

        /// <summary>
        /// float64
        /// </summary>
        SpectralMaskFrequencyOffsets = 305,

        /// <summary>
        /// float64
        /// </summary>
        SpectralMaskPowerOffsets = 306,

        /// <summary>
        /// float64
        /// </summary>
        ResultSpectralMaskMarginVector = 307,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodEvmPerSymbolTraceEnabled = 308,

        /// <summary>
        /// int
        /// </summary>
        CompatibilityVersion = 309,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodEvmPerSubcarrierTraceEnabled = 310,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodEvmPerChipTraceEnabled = 311,

        /// <summary>
        /// int
        /// </summary>
        [Obsolete]
        DsssDemodEvmPerSymbolTraceEnabled = 311,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodLowpassFilteringEnabled = 312,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodLowpassFilteringEnabled = 313,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodEvmPerSymbolPerSubcarrierTraceEnabled = 314,

        /// <summary>
        /// double
        /// </summary>
        [Obsolete]
        MaxInputPower = 316,

        /// <summary>
        /// double
        /// </summary>
        [Obsolete]
        ResultAutorangeMaxInputPower = 317,

        /// <summary>
        /// double
        /// </summary>
        ResultAutorangeAcquisitionLength = 318,

        /// <summary>
        /// double
        /// </summary>
        OfdmDemodSymbolTimingAdjustment = 321,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodCfoEstimationMethod = 323,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodMacFrameCheckSequenceCheckEnabled = 324,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodHeaderParityPassed = 325,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodHtSigCrcPassed = 326,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodMacFrameCheckSequencePassed = 327,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodPilotRmsEvm = 328,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodDataRmsEvm = 329,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodPilotEvmPerSymbolTraceEnabled = 330,


        /// <summary>
        /// int
        /// </summary>
        OfdmDemodDataEvmPerSymbolTraceEnabled = 331,


        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodDsssofdmHeaderCrcPassed = 334,

        /// <summary>
        /// int
        /// </summary>
        DetectedStandard = 335,


        /// <summary>
        /// double
        /// </summary>
        DetectedChannelBandwidth = 336,


        #region Version 4.0
        ///<summary>
        /// int 
        ///</summary>
        NumberOfSegments = 209, //0xD1	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmLSigPayloadLength = 215, // 0xD7	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        StbcAllStreamsEnabled = 211, //0xD3	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        NumberOfSpaceTimeStreams = 210, //					0xD2	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        ShortGuardIntervalB1Bit = 228, //			0xE4	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        AggregationBit = 235,	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        GatedSpectrumAveragingType = 384, //0x180	/*int32*/
        /// <summary>
        /// 
        /// </summary>
        ResultSpectralMaskFrequencyOffsetsUsed = 192, //			0xC0	/*float64, readonly*/
        /// <summary>
        /// 
        /// </summary>
        ResultSpectralMaskPowerOffsetsUsed = 193, //						0xC1	/*float64, readonly*/
        /// <summary>
        /// 
        /// </summary>
        ResultSpectralMaskMarginFrequencyVector = 519, //				0x207	/*float64, readonly*/
        /// <summary>
        /// 
        /// </summary>
        ResultSpectralMaskMarginPowerSpectralDensityVector = 520, //		0x208	/*float64, readonly*/
        /// <summary>
        /// 
        /// </summary>
        ResultSpectralMaskViolation = 521, //									0x209	/*float64, readonly*


        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodPreambleFrequencyErrorTraceEnabled = 213, //			0xD5	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodCommonPilotErrorTraceEnabled = 388, //					0x184	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodPhaseNoisePsdTraceEnabled = 391, //					0x187	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodIqMismatchSignalModel = 233, //						0xE9	/*int32*/

        /*- OFDM Demod:Impairments Estimation Enabled ------------------------------------------------------------*/
        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodCarrierFrequencyOffsetEstimationEnabled = 392, //			0x188	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodSampleClockOffsetEstimationEnabled = 393, //		0x189	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodIqGainImbalanceEstimationEnabled = 394, //				0x18A	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodQuadratureSkewEstimationEnabled = 395, //				0x18B	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodTimingSkewEstimationEnabled = 396, //						0x18C	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodCarrierFrequencyLeakageEstimationEnabled = 397, //		0x18D	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodCommonPilotErrorEstimationEnabled = 398, //				0x18E	/*int32*/

        /*- OFDM Demod:Impairments Compensation Enabled ------------------------------------------------------------*/
        ///<summary>
        /// int 
        ///</summary>

        OfdmDemodIqGainImbalanceCompensationEnabled = 403, //			0x193	/*int32*/
        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodQuadratureSkewCompensationEnabled = 404, //				0x194	/*int32*/

        ///<summary>
        /// int 
        ///</summary>
        OfdmDemodTimingSkewCompensationEnabled = 400, //				0x190	/*int32*/

        /// <summary>
        /// int
        /// </summary>
        Property80211acAmpduEnabled = 399, //0x18F,   /*int32*/

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodCombinedSignalDemodulationEnabled = 408,	//	0x198   /*int32*/

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodBurstStartDetectionEnabled = 389, //				0x185   /*int32*/

        /// <summary>
        /// float ReadOnly
        /// </summary>
        OfdmDemodRmsPhaseError = 224,//						0xE0	/*float64,readonly*/

        /// <summary>
        /// int ReadOnly
        /// </summary>
        OfdmDemodNumberOfSpaceTimeStreams = 217,//				0xD9	/*int32,readonly*/

        /// <summary>
        /// int ReadOnly
        /// </summary>
        OfdmDemodSpectralFlatnessMarginSubcarrierIndex = 381, //	0x17D	/*int32,readonly*/

        /// <summary>
        /// int ReadOnly
        /// </summary>
        OfdmDemodNumberOfOfdmSymbols = 230,     //		0xE6	/*int32,readonly*/

        /// <summary>
        /// int ReadOnly
        /// </summary>
        OfdmDemodAggregation = 234,         //	0xEA	/*int32,readonly*/


        /// <summary>
        /// float ReadOnly
        /// </summary>
        ResultOfdmDemodTimingSkew = 221, //								0xDD	/*float64,readonly*/


        /// <summary>
        /// float ReadOnly
        /// </summary>
        ResultOfdmDemodRmsPhaseError = 224, //								0xE0	/*float64,readonly*/


        /// <summary>
        /// float ReadOnly
        /// </summary>
        ResultOfdmDemodCommonPilotErrorRms = 382, //				0x17E	/*float64,readonly*/

        /// <summary>
        /// int ReadOnly
        /// </summary>
        ResultOfdmDemodLSigPayloadLength = 216, //					0xD8	/*int32,readonly*/

        /// <summary>
        /// int ReadOnly
        /// </summary>
        ResultOfdmDemodStbcAllStreamsEnabled = 218, //				0xDA	/*int32,readonly*/

        /// <summary>
        /// int ReadOnly
        /// </summary>
        ResultOfdmDemodNumberOfSpaceTimeStreams = 217, //			0xD9	/*int32,readonly*/	

        /// <summary>
        /// int ReadOnly
        /// </summary>
        ResultOfdmDemodVhtSigACrcPassed = 219, //        0xDB	/*int32,readonly*/	

        /// <summary>
        /// int ReadOnly
        /// </summary>
        ResultOfdmDemodVhtSigBCrcPassed = 220, //        0xDC	/*int32,readonly*/	

        /// <summary>
        /// int ReadOnly
        /// </summary>
        ResultOfdmDemodShortGuardIntervalB1Bit = 229, // 		0xE5	/*int32,readonly*/

        /*- Advanced -----------------------------------------------------*/
        /// <summary>
        /// int
        /// </summary>
        SwapIAndQEnabled = 214, 	/*int32*/

        /// <summary>
        /// int
        /// </summary>
        SampleClockRateFactor = 383, //								0x17F	/*int32*/

        /// <summary>
        /// double ReadOnly
        /// </summary>
        ResultTxpPeakPowerAverage = 541,//									0x21D	/*float64,readonly*/

        /// <summary>
        /// double ReadOnly
        /// </summary>
        ResultTxpPeakPowerMinimum = 380,//									0x17C	/*float64,readonly*/

        /// <summary>
        /// double ReadOnly
        /// </summary>
        ResultTxpPeakPowerStandardDeviation = 542,//					0x21E	/*float64,readonly*/

        /// <summary>
        /// double ReadOnly
        /// </summary>
        ResultTxpAveragePowerMinimum = 377,//								0x179	/*float64, readonly*/	

        /// <summary>
        /// double ReadOnly
        /// </summary>
        ResultTxpAveragePowerMaximum = 378,//							0x17A	/*float64, readonly*/	

        /// <summary>
        /// double ReadOnly
        /// </summary>
        ResultTxpAveragePowerStandardDeviation = 379,//						0x17B	/*float64, readonly*/		

        /// <summary>
        /// double ReadOnly
        /// </summary>
        ResultTxpAveragePowerWithIdleTimeAverage = 204,//					0xCC	/*float64, readonly*/		

        /// <summary>
        /// double ReadOnly
        /// </summary>
        ResultTxpAveragePowerWithIdleTimeMinimum = 534,//					0x216	/*float64, readonly*/

        /// <summary>
        /// double ReadOnly
        /// </summary>
        ResultTxpAveragePowerWithIdleTimeMaximum = 535,//					0x217	/*float64, readonly*/

        #endregion

        #region Missing Properties Added

        /// <summary>
        /// double
        /// </summary>
        SpectralMaskCenterFrequency = 527,

        /// <summary>
        /// int
        /// </summary>
        SpectralMaskCombinedMaskEnabled = 537,

        /// <summary>
        /// int
        /// </summary>
        TxpowerMeasurementsMode = 529,

        /// <summary>
        /// double
        /// </summary>
        ResultTxpPeakPowerMaximum = 35,

        /// <summary>
        /// double
        /// </summary>
        ResultTxpAveragePowerAverage = 36,

        /// <summary>
        /// double
        /// </summary>
        ResultAmpmMeasurementsAmamResidual = 633,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodReferenceConstellationTraceEnabled = 411,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodGroupDelayTraceEnabled = 413,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodChannelFrequencyResponseTraceMode = 414,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodGroupDelayTraceMode = 415,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodEvmPerSubcarrierPerSymbolTraceEnabled = 522,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodUserDefinedGatePowerEnabled = 112,

        /// <summary>
        /// double
        /// </summary>
        OfdmDemodUserDefinedGateStartTime = 46,

        /// <summary>
        /// double
        /// </summary>
        OfdmDemodUserDefinedGateStopTime = 47,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodGatedPowerTotalPacketPowerEnabled = 549,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodGatedPowerPreambleAndHeaderPowerEnabled = 550,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodGatedPowerDataPowerEnabled = 551,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodVhtSigBCrcCheckEnabled = 572,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodCommonClockSourceEnabled = 540,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemod80Plus80FilterBeforeSyncEnabled = 538,

        /// <summary>
        /// double
        /// </summary>
        OfdmDemod80Plus80OversamplingFactor = 539,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodRmsEvmAverage = 56,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodRmsEvmMinimum = 254,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodRmsEvmMaximum = 255,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodRmsEvmStandardDeviation = 337,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodDataRmsEvmAverage = 329,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodDataRmsEvmMinimum = 341,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodDataRmsEvmMaximum = 342,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodDataRmsEvmStandardDeviation = 343,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodPilotRmsEvmAverage = 328,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodPilotRmsEvmMinimum = 338,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodPilotRmsEvmMaximum = 339,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodPilotRmsEvmStandardDeviation = 340,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodAverageGatedPowerAverage = 257,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodAverageGatedPowerMinimum = 350,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodAverageGatedPowerMaximum = 351,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodAverageGatedPowerStandardDeviation = 352,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCrossPowerAverage = 288,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodChannelMatrixCrossPowerMinimum = 344,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodChannelMatrixCrossPowerMaximum = 345,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodChannelMatrixCrossPowerStdDev = 346,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodSpectralFlatnessMarginAverage = 59,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodSpectralFlatnessMarginMinimum = 347,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodSpectralFlatnessMarginMaximum = 348,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodSpectralFlatnessMarginStandardDeviation = 349,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodSpectralFlatnessMarginSubcarrierIndex = 381,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodNumberOfOfdmSymbols = 230,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodAggregation = 234,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodNumberOfSymbolsUsed = 194,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodBurstStartTime = 513,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodChannelMatrixAbsolutePowerAverage = 530,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodChannelMatrixAbsolutePowerMinimum = 531,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodChannelMatrixAbsolutePowerMaximum = 532,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodChannelMatrixAbsolutePowerStdDev = 533,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodGatedPowerMeanPowerAverage = 556,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodGatedPowerMeanPowerMinimum = 557,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodGatedPowerMeanPowerMaximum = 558,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodGatedPowerMeanPowerStandardDeviation = 559,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodGatedPowerPeakPowerAverage = 560,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodGatedPowerPeakPowerMinimum = 561,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodGatedPowerPeakPowerMaximum = 562,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodGatedPowerPeakPowerStandardDeviation = 563,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCarrierFrequencyOffsetAverage = 57,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCarrierFrequencyOffsetMinimum = 236,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCarrierFrequencyOffsetMaximum = 237,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCarrierFrequencyOffsetStandardDeviation = 238,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCarrierFrequencyLeakageMinimum = 239,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCarrierFrequencyLeakageMaximum = 240,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCarrierFrequencyLeakageStandardDeviation = 241,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodSampleClockOffsetAverage = 60,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodSampleClockOffsetMinimum = 242,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodSampleClockOffsetMaximum = 243,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodSampleClockOffsetStandardDeviation = 244,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodIqGainImbalanceAverage = 61,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodIqGainImbalanceMinimum = 245,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodIqGainImbalanceMaximum = 246,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodIqGainImbalanceStandardDeviation = 247,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodQuadratureSkewAverage = 62,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodQuadratureSkewMinimum = 251,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodQuadratureSkewMaximum = 252,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodQuadratureSkewStandardDeviation = 253,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodTimingSkewAverage = 221,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodTimingSkewMinimum = 248,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodTimingSkewMaximum = 249,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodTimingSkewStandardDeviation = 250,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCommonPilotErrorRmsAverage = 382,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCommonPilotErrorRmsMinimum = 405,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCommonPilotErrorRmsMaximum = 406,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCommonPilotErrorRmsStandardDeviation = 407,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCommonPhaseErrorAverage = 774,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCommonPhaseErrorMinimum = 775,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCommonPhaseErrorMaximum = 776,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCommonPhaseErrorStandardDeviation = 777,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodUserDefinedGatePowerEnabled = 113,

        /// <summary>
        /// double
        /// </summary>
        DsssDemodUserDefinedGateStartTime = 75,

        /// <summary>
        /// double
        /// </summary>
        DsssDemodUserDefinedGateStopTime = 76,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodGatedPowerTotalPacketPowerEnabled = 552,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodGatedPowerPreambleAndHeaderPowerEnabled = 553,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodGatedPowerDataPowerEnabled = 555,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodBurstStartDetectionEnabled = 517,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodCarrierFrequencyOffsetEstimationEnabled = 543,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodSampleClockOffsetEstimationEnabled = 544,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodIqGainImbalanceEstimationEnabled = 545,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodQuadratureSkewEstimationEnabled = 546,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodCarrierSuppressionEstimationEnabled = 547,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodRmsEvmAverage = 79,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodRmsEvmMinimum = 368,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodRmsEvmMaximum = 369,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodRmsEvmStandardDeviation = 370,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodPeakEvmMaximum = 80,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodPeakEvmMinimum = 371,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemod80211bPeakEvmMaximum = 140,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemod80211bPeakEvmMinimum = 372,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemod80211bPeakEvm2007Maximum = 205,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemod80211bPeakEvm2007Minimum = 373,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodAverageGatedPowerAverage = 258,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodAverageGatedPowerMinimum = 374,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodAverageGatedPowerMaximum = 375,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodAverageGatedPowerStandardDeviation = 376,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodBurstStartTime = 516,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodGatedPowerMeanPowerAverage = 564,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodGatedPowerMeanPowerMinimum = 565,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodGatedPowerMeanPowerMaximum = 566,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodGatedPowerMeanPowerStandardDeviation = 567,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodGatedPowerPeakPowerAverage = 568,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodGatedPowerPeakPowerMinimum = 569,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodGatedPowerPeakPowerMaximum = 570,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodGatedPowerPeakPowerStandardDeviation = 571,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodCarrierFrequencyOffsetAverage = 81,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodCarrierFrequencyOffsetMinimum = 353,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodCarrierFrequencyOffsetMaximum = 354,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodCarrierFrequencyOffsetStandardDeviation = 355,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodIqGainImbalanceAverage = 82,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodIqGainImbalanceMinimum = 356,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodIqGainImbalanceMaximum = 357,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodIqGainImbalanceStandardDeviation = 358,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodQuadratureSkewAverage = 83,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodQuadratureSkewMinimum = 359,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodQuadratureSkewMaximum = 360,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodQuadratureSkewStandardDeviation = 361,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodCarrierSuppressionAverage = 84,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodCarrierSuppressionMinimum = 362,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodCarrierSuppressionMaximum = 363,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodCarrierSuppressionStandardDeviation = 364,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodSampleClockOffsetAverage = 158,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodSampleClockOffsetMinimum = 365,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodSampleClockOffsetMaximum = 366,

        /// <summary>
        /// double
        /// </summary>
        ResultDsssDemodSampleClockOffsetStandardDeviation = 367,

        #endregion

        #region Version 4.1

        /// <summary>
        /// int
        /// </summary>
        TclkSynchronisationEnabled = 420,

        /// <summary>
        /// int
        /// </summary>
        LoSharingEnabled = 421,

        /// <summary>
        /// int
        /// </summary>
        OfdmPpduType = 643,

        /// <summary>
        /// int
        /// </summary>
        OfdmNumberOfUsers = 644,

        /// <summary>
        /// int
        /// </summary>
        GatedSpectrumMeasurementLength = 212,

        /// <summary>
        /// int
        /// </summary>
        SpectralMaskTransmitPowerClass = 419,

        /// <summary>
        /// int
        /// </summary>
        SpectralMeasurementsChannelPowerEnabled = 610,

        /// <summary>
        /// int
        /// </summary>
        SpectralMeasurementsChannelPowerNumberOfAverages = 779,

        /// <summary>
        /// int
        /// </summary>
        SpectralMeasurementsChannelPowerAutoMeasureBWEnabled = 780,

        /// <summary>
        /// double
        /// </summary>
        SpectralMeasurementsChannelPowerMeasurementBandwidth = 781,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultSpectralMeasurementsChannelPower = 782,

        /// <summary>
        /// double
        /// </summary>
        TxPowerMeasurementLength = 387,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultTxpAveragePowerWithIdleTimeStandardDeviation = 536,

        /// <summary>
        /// int
        /// </summary>
        CcdfEnabled = 579,

        /// <summary>
        /// int
        /// </summary>
        CcdfTraceEnabled = 580,

        /// <summary>
        /// int
        /// </summary>
        CcdfRemoveDeadTime = 595,

        /// <summary>
        /// double
        /// </summary>
        CcdfMeasurementLength = 412,

        /// <summary>
        /// int
        /// </summary>
        CcdfNumberOfRecords = 596,

        /// <summary>
        /// double
        /// </summary>
        ResultCcdfAveragePower = 582,

        /// <summary>
        /// double
        /// </summary>
        ResultCcdfAveragePowerPercentile = 583,

        /// <summary>
        /// double
        /// </summary>
        ResultCcdf10PercentPower = 584,

        /// <summary>
        /// double
        /// </summary>
        ResultCcdf1PercentPower = 585,

        /// <summary>
        /// double
        /// </summary>
        ResultCcdf1By10PercentPower = 586,

        /// <summary>
        /// double
        /// </summary>
        ResultCcdf1By100PercentPower = 587,

        /// <summary>
        /// double
        /// </summary>
        ResultCcdf1By1000PercentPower = 588,

        /// <summary>
        /// double
        /// </summary>
        ResultCcdf1By10000PercentPower = 589,

        /// <summary>
        /// double
        /// </summary>
        ResultCcdfPeakToAveragePowerRatio = 590,

        /// <summary>
        /// double
        /// </summary>
        ResultCcdfResultantCount = 591,

        /// <summary>
        /// double
        /// </summary>
        DsssPowerRampMeasurementLength = 416,

        /// <summary>
        /// int
        /// </summary>
        AmpmMeasurementsEnabled = 620,

        /// <summary>
        /// int
        /// </summary>
        AmpmMeasurementsAveragingMode = 621,

        /// <summary>
        /// int
        /// </summary>
        AmpmMeasurementsNumberOfAverages = 622,

        /// <summary>
        /// double
        /// </summary>
        AmpmMeasurementsDutInputPowerLevel = 623,

        /// <summary>
        /// double
        /// </summary>
        AmpmMeasurementsMeasurementLength = 624,


        /// <summary>
        /// int
        /// </summary>
        AmpmMeasurementsAllTracesEnabled = 785,

        /// <summary>
        /// int
        /// </summary>
        AmpmMeasurementsAmamTraceEnabled = 659,

        /// <summary>
        /// int
        /// </summary>
        AmpmMeasurementsAmpmTraceEnabled = 660,

        /// <summary>
        /// int
        /// </summary>
        AmpmMeasurementsAmamCurveFitTraceEnabled = 661,

        /// <summary>
        /// int
        /// </summary>
        AmpmMeasurementsAmpmCurveFitTraceEnabled = 662,

        /// <summary>
        /// int
        /// </summary>
        AmpmMeasurementsMeanAcquiredWaveformTraceEnabled = 783,

        /// <summary>
        /// int
        /// </summary>
        AmpmMeasurementsProcessedReferenceWaveformTraceEnabled = 784,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultAmpmMeasurementsAmpmPolynomialCoefficients = 627,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultAmpmMeasurementsAmamPolynomialCoefficients = 628,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultAmpmMeasurements1DbCompressionPoint = 629,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultAmpmMeasurementsPhaseErrorRange = 630,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultAmpmMeasurementsGainErrorRange = 631,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultAmpmMeasurementsAmpmResidual = 632,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultAmpmMeasurementsAveragePhaseError = 635,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultAmpmMeasurementsAverageGain = 636,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultAmpmMeasurementsMinimumInputPower = 650,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultAmpmMeasurementsMaximumInputPower = 651,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodServiceBitsTraceEnabled = 771,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodMeasurementLength = 417,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodAutoComputeMeasurementLengthEnabled = 515,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodChannelEvmEnabled = 602,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodChannelMatrixPowerEnabled = 603,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodStreamPowerEnabled = 668,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodSpectralFlatnessMarginEnabled = 604,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodReferenceDataConstellationEnabled = 605,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodCommonPhaseErrorEstimationEnabled = 778,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultOfdmDemodStreamPowerAverage = 669,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultOfdmDemodStreamPowerMinimum = 670,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultOfdmDemodStreamPowerMaximum = 671,


        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultOfdmDemodStreamPowerStandardDeviation = 768,


        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultOfdmDemodCommmonPhaseErrorAverage = 774,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultOfdmDemodCommmonPhaseErrorMinimum = 775,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultOfdmDemodCommmonPhaseErrorMaximum = 776,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultOfdmDemodCommmonPhaseErrorStandardDeviation = 777,

        /// <summary>
        /// int, ReadOnly
        /// </summary>
        ResultOfdmDemodPpduType = 646,

        /// <summary>
        /// int, ReadOnly
        /// </summary>
        ResultOfdmDemodNumberOfUsers = 647,

        /// <summary>
        /// int, ReadOnly
        /// </summary>
        ResultOfdmDemodScramblerSeed = 649,

        /// <summary>
        /// double
        /// </summary>
        DsssDemodMeasurementLength = 418,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodAutoComputeMeasurementLengthEnabled = 518,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultDsssDemodPhaseErrorRmsAverage = 611,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultDsssDemodPhaseErrorRmsMinimum = 612,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultDsssDemodPhaseErrorRmsMaximum = 613,

        /// <summary>
        /// double, ReadOnly
        /// </summary>
        ResultDsssDemodPhaseErrorRmsStandardDeviation = 614,

        /// <summary>
        /// int
        /// </summary>
        DsssDemodAutoComputeAcquisitionLengthEnabled = 518,

        /// <summary>
        /// double
        /// </summary>
        AmpmMeasurementsMeasurementInterval = 624,

        #endregion
        #region version 14.0
        /// <summary>
        /// int
        /// </summary>
        AutoDetectionStandardMode = 789,
        /// <summary>
        /// int
        /// </summary>
        TxPowerBurstDetectionEnabled = 792,
        #endregion

        #region version 14.5
        /// <summary>
        /// int
        /// </summary>
        _80211ahPreambleType = 797,

        /// <summary>
        /// int
        /// </summary>
        AcpEnabled = 798,

        /// <summary>
        /// int
        /// </summary>
        AcpNumberOfAverages = 799,

        /// <summary>
        /// int
        /// </summary>
        AcpTraceEnabled = 800,

        /// <summary>
        /// int
        /// </summary>
        AcpNumberOfOffsets = 801,

        /// <summary>
        /// double
        /// </summary>
        ResultAcpReferenceChannelPower = 802,

        /// <summary>
        /// double[]
        /// </summary>
        AcpLowerRelativePower = 803,

        /// <summary>
        /// double[]
        /// </summary>
        AcpLowerAbsolutePower = 804,

        /// <summary>
        /// double[]
        /// </summary>
        AcpUpperRelativePower = 805,

        /// <summary>
        /// double[]
        /// </summary>
        AcpUpperAbsolutePower = 806,

        /// <summary>
        /// int
        /// </summary>
        GuardIntervalType = 814,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodS1gSigCrcPassed = 816,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemod80211ahPreambleType = 818,


        /// <summary>
        /// int
        /// </summary>
        OfdmGuardIntervalType = 821,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodS1gSigLength = 820,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemod80211ahPreambleDetectionEnabled = 817,

        #endregion

        #region version 15.0

        /// <summary>
        /// int
        /// </summary>
        OfdmNonHTModulationMode = 827,

        /// <summary>
        /// int
        /// </summary>		
        ETSIIBEEnabled = 829,

        /// <summary>
        /// int
        /// </summary>
        ETSIIBENumberOfAverages = 830,

        /// <summary>
        /// int
        /// </summary>
        ETSIIBETraceEnabled = 831,

        /// <summary>
        /// int
        /// </summary>
        ETSIIBENumberOfOffset = 832,

        /// <summary>
        /// double
        /// </summary>
        ETSIIBEDUTAverageOutputPower = 833,

        /// <summary>
        /// double
        /// </summary>
        ETSIIBETransmitChannelPSDLimit = 835,

        /// <summary>
        /// int
        /// </summary>
        ETSIIBEDeviceEmissionClass = 836,

        /// <summary>
        /// double[]
        /// </summary>
        ETSIIBEDeltaACLR = 837,

        /// <summary>
        /// double
        /// </summary>
        ResultETSIIBEMargin = 838,

        /// <summary>
        /// double[]
        /// </summary>
        ResultETSIIBEMarginVector = 839,

        /// <summary>
        /// 
        /// </summary>
        ResultETSIIBEMarginFrequencyVector = 840,

        /// <summary>
        /// double
        /// </summary>
        ResultETSIIBEViolation = 841,

        /// <summary>
        /// double[]
        /// </summary>
        ResultETSIIBEDeltaACLRMarginVector = 842,

        /// <summary>
        /// double[]
        /// </summary>
        ResultETSIIBEDeltaACLRFrequencyVector = 843,

        /// <summary>
        /// int
        /// </summary>
        OfdmNonHTModulationDetectionEnabled = 846,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmLDPCExtraOfdmSymbol = 825,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmTVHTSIGACRCPassed = 823,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmTVHTMode = 848,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmNonHTModulationMode = 847,

        #endregion

        #region version 15.5

        /// <summary>
        /// int
        /// </summary>
        MultiSegmentMeasurementMode = 858,

        /// <summary>
        /// int
        /// </summary>
        AmplitudeCorrectionEnabled = 869,

        /// <summary>
        /// double
        /// </summary>
        ResultAutorangeMaxInputRange = 317,

        /// <summary>
        /// int
        /// </summary>
        ScramblerSeed = 854,

        /// <summary>
        /// string
        /// </summary>
        OfdmDemodReferenceDataConstellationIdentifier = 853,

        #endregion

        #region version 17.0

        /// <summary>
        /// int
        /// </summary>
        OptimizeReferenceLevelForEvmEnabled = 915,

        /// <summary>
        /// double
        /// </summary>
        OptimizeReferenceLevelForEvmMargin = 914,

        /// <summary>
        /// int
        /// </summary>
        NoiseCompensationEnabled = 907,

        /// <summary>
        /// double[]
        /// </summary>
        NoiseCompensationCarrierFrequencies = 916,

        /// <summary>
        /// double[]
        /// </summary>
        NoiseCompensationMaximumChannelBandwidths = 917,

        /// <summary>
        /// double[] 
        /// </summary>
        NoiseCompensationMinimumReferenceLevel = 910,

        /// <summary>
        /// double[] 
        /// </summary>
        NoiseCompensationMaximumReferenceLevel = 911,

        /// <summary>
        /// double[] 
        /// </summary>
        ReferenceLevelStepSize = 912,

        /// <summary>
        /// int
        /// </summary>
        RuSize = 851,

        /// <summary>
        /// int
        /// </summary>
        RuOffset = 852,

        /// <summary>
        /// int
        /// </summary>
        PreFecPaddingFactor = 875,

        /// <summary>
        ///int 
        /// </summary>
        OfdmPacketExtensionDisambiguity = 876,

        /// <summary>
        /// int 
        /// </summary>
        OfdmDualCarrierModulationEnabled = 873,

        /// <summary>
        /// int
        /// </summary>
        [Obsolete]
        HeSigBMcsIndex = 918,

        /// <summary>
        /// int
        /// </summary>
        [Obsolete]
        HeSigBDualCarrierModulationEnabled = 919,

        /// <summary>
        /// int
        /// </summary>
        NumberOfHeSigBSymbols = 920,

        /// <summary>
        /// int
        /// </summary>
        LdpcExtraSymbolUsed = 898,

        /// <summary>
        /// int
        /// </summary>
        HeLtfSize = 874,

        /// <summary>
        /// int
        /// </summary>
        [Obsolete]
        TransmissionMode = 850,

        /// <summary>
        ///int 
        /// </summary>
        NumberOfHeLtfSymbols = 896,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodUnusedToneErrorTraceEnabled = 859,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodDecodedHeaderBitsTraceEnabled = 1031,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodUnusedToneErrorEnabled = 922,

        /// <summary>
        /// int32
        /// </summary>
        OfdmDemodUnusedToneErrorMaskReference = 923,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemod80Plus80SegmentIndex = 1030,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodHeLtfSize = 1028,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodNoiseCompensationApplied = 913,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodNoiseAbsoluteCarrierFrequencyLeakageAverage = 1024,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodNoiseAbsoluteCarrierFrequencyLeakageMinimum = 1025,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodNoiseAbsoluteCarrierFrequencyLeakageMaximum = 1026,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodNoiseAbsoluteCarrierFrequencyLeakageStandardDeviation = 1027,

        /// <summary>
        /// int 
        /// </summary>
        ResultOfdmDemodDetectedS1gSigLength = 820,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodDetectedPsduLength = 897,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodPreFecPaddingFactor = 880,

        /// <summary>
        ///int 
        /// </summary>
        ResultOfdmDemodPacketExtentionDisambiguity = 881,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodStaId = 890,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodDcmEnabled = 883,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodHeSigBMcsIndex = 888,
        /// <summary>
        /// int 
        /// </summary>
        ResultOfdmDemodHeSigBDualCarrierModulationEnabled = 889,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodNumberofHeSigBSymbols = 927,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodRuSize = 891,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodRuOffset = 894,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodSpaceTimeStreamOffset = 909,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodTransmissionMode = 882,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodHeSigACrcPassed = 872,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodHeSigBCrcPassed = 892,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodPacketExtentionDuration = 885,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodUnusedToneErrorMargin = 924,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodUnusedToneErrorMarginRuIndex = 925,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodUnusedToneErrorMarginVector = 926,

        /// <summary>
        /// int
        /// </summary>
        LOFrequencyOffsetMode = 1034,

        /// <summary>
        /// double
        /// </summary>
        LOFrequencyOffset = 1035,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodTraceSettingCarrierFrequencyOffsetCcdfTraceEnabled = 1038,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodChannelEstimationMethod = 55,

        /// <summary>
        /// double
        /// </summary>
        ResultOfdmDemodCarrierFrequencyOffsetCcdfTenPercent = 1039,
        #endregion
        
        
        #region 17.1
        /// <summary>
        /// int
        /// </summary>
        SpaceTimeStreamOffset = 1043,
        /// <summary>
        /// int 
        /// </summary>
        MuMimoLtfModeEnabled = 1044,

        /// <summary>
        /// int 
        /// </summary>
        OfdmDemodUserDefinedIQImpairmentsCompensationEnabled = 1045,

        /// <summary>
        /// double
        /// </summary>
        OfdmDemodUserDefinedIQGainImbalance = 1046,

        /// <summary>
        /// double
        /// </summary>
        OfdmDemodUserDefinedQuadratureSkew = 1047,

        /// <summary>
        /// double
        /// </summary>
        OfdmDemodUserDefinedTimingSkew = 1048,
        #endregion

        #region 18.0

        /// <summary>
        /// int
        /// </summary>
        MidamblePeriodicity = 1059,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodIQGainImbalancePerSubcarrierTraceEnabled = 1053,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodQuadratureSkewPerSubcarrierTraceEnabled = 1054,

        /// <summary>
        /// int
        /// </summary>
        OfdmDemodIQImpairmentsPerSubcarrierEnabled = 1052,

        /// <summary>
        /// int
        /// </summary>
        ResultOfdmDemodMidamblePeriodicity = 1060,
       
        #endregion
	
	#region 19.1

        /// <summary>
        /// int
        /// </summary>
        OFDMChannelEstimationOnLLTFEnabled = 1061,
      
        #endregion
    }
}